// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"iOKch":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "254537832ab86267";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets, assetsToDispose, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets); // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                } // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle, id) {
    // Execute the module.
    bundle(id); // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            }); // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"3xP9X":[function(require,module,exports) {
var _router = require("./router");
var _state = require("./state");
var _navbar = require("./components/navbar");
(function() {
    const root = document.querySelector(".root");
    (0, _router.initRouter)(root);
    if (localStorage.token) (0, _state.state).init();
})();

},{"./components/navbar":"fqQWF","./router":"iz1VF","./state":"gYwa1"}],"fqQWF":[function(require,module,exports) {
var _router = require("../../router");
var _state = require("../../state");
var _0Ubication = require("../../pages/0-ubication");
var _2CMisDatos = require("../../pages/2c-mis-datos");
var _3APublicar = require("../../pages/3a-publicar");
var _3BMisMascotas = require("../../pages/3b-mis-mascotas");
var _2BLogin = require("../../pages/2b-login");
const currentState = (0, _state.state).getState();
customElements.define("nav-comp", class extends HTMLElement {
    constructor(){
        super();
        this.render();
    }
    render() {
        this.innerHTML = `
    <nav class="navbar fixed-top">
      <div class="container-fluid">

        <a class="navbar-brand" style="cursor:pointer">Lost Pets</a>

        <button class="navbar-toggler" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasNavbar" aria-controls="offcanvasNavbar">
          <span class="navbar-toggler-icon"></span>
        </button>


        <div
          class="offcanvas offcanvas-end"
          tabindex="-1"
          id="offcanvasNavbar"
          aria-labelledby="offcanvasNavbarLabel"
        >
          <div class="offcanvas-header">
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="offcanvas"
              aria-label="Close"
            ></button>
          </div>
          <div class="offcanvas-body">
            <ul class="navbar-nav justify-content-end flex-grow-1 pe-3">



              <li class="nav-item"
              data-bs-dismiss="offcanvas"
              aria-label="Close"
              >
                <div class="nav-link" style="cursor: pointer" id="mis-datos">
                  Mis datos
                </div>
              </li>

              <li class="nav-item"
              data-bs-dismiss="offcanvas"
              aria-label="Close"
              >
                <div class="nav-link" style="cursor: pointer" id="mis-mascotas">
                  Mis mascotas reportadas
                </div>
              </li>

              <li class="nav-item"
              data-bs-dismiss="offcanvas"
              aria-label="Close"
              >
                <div class="nav-link" style="cursor: pointer" id="publicar-mascota">
                  Publicar mascota perdida
                </div>
              </li>
              <li class="nav-item"
              data-bs-dismiss="offcanvas"
              aria-label="Close">
                <div class="nav-link" style="cursor: pointer" id="cerrar-sesion">
                  Cerrar sesión
                </div>
              </li>
            </ul>
          </div>
        </div>

      </div>
    </nav>`;
        const root = document.querySelector(".root");
        (0, _router.initRouter)(root);
        const datos = this.querySelector("#mis-datos");
        datos.addEventListener("click", (e)=>{
            if (currentState.userId) {
                history.pushState({}, "", "/mis-datos");
                if (root.firstChild) root.firstChild.remove();
                root.appendChild((0, _2CMisDatos.initPageMisDatos)(root));
            } else if (!currentState.userId) {
                history.pushState({}, "", "/login");
                if (root.firstChild) root.firstChild.remove();
                root.appendChild((0, _2BLogin.initPageLogIn)(root, "/mis-datos"));
            }
        });
        const mascotas = this.querySelector("#mis-mascotas");
        mascotas.addEventListener("click", (e)=>{
            if (currentState.userId) {
                console.log("A mis mascotas perdidas");
                history.pushState({}, "", "/mis-mascotas");
                if (root.firstChild) root.firstChild.remove();
                root.appendChild((0, _3BMisMascotas.initPageMisMascotas)(root));
            } else if (!currentState.userId) {
                history.pushState({}, "", "/login");
                if (root.firstChild) root.firstChild.remove();
                root.appendChild((0, _2BLogin.initPageLogIn)(root, "/mis-mascotas"));
            }
        });
        const reportar = this.querySelector("#publicar-mascota");
        reportar.addEventListener("click", (e)=>{
            if (currentState.userId) {
                history.pushState({}, "", "/publicar-mascota");
                if (root.firstChild) root.firstChild.remove();
                root.appendChild((0, _3APublicar.initPagePublicar)(root));
            } else if (!currentState.userId) {
                history.pushState({}, "", "/login");
                if (root.firstChild) root.firstChild.remove();
                root.appendChild((0, _2BLogin.initPageLogIn)(root, "/publicar-mascota"));
            }
        });
        const cerrarSesion = this.querySelector("#cerrar-sesion");
        cerrarSesion.addEventListener("click", (e)=>{
            (0, _state.state).logOut();
            history.pushState({}, "", "/");
            if (root.firstChild) root.firstChild.remove();
            root.appendChild((0, _0Ubication.initPageUbication)(root));
            location.reload();
        });
    }
});

},{"../../state":"gYwa1","../../router":"iz1VF","../../pages/2c-mis-datos":"5afcR","../../pages/3b-mis-mascotas":"123UY","../../pages/0-ubication":"798W8","../../pages/3a-publicar":"3fMd3","../../pages/2b-login":"kxzJg"}],"gYwa1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "state", ()=>state);
var _2CMisDatos = require("./pages/2c-mis-datos");
var _3BMisMascotas = require("./pages/3b-mis-mascotas");
var _3APublicar = require("./pages/3a-publicar");
var _3CEditarMascota = require("./pages/3c-editar-mascota");
const url = "http://localhost:3000";
const state = {
    data: {
        email: "",
        fullname: "",
        token: "",
        userId: "",
        ubication: {}
    },
    listeners: [],
    getState () {
        return this.data;
    },
    setState (newState) {
        this.data = newState;
        console.log(this.data);
        for (const call of this.listeners)call(newState);
    },
    init () {
        const currentState = this.getState();
        const userToken = localStorage.getItem("token");
        fetch(url + "/init/" + userToken, {}).then((res)=>{
            return res.json();
        }).then((data)=>{
            const { id , email , fullname  } = data;
            currentState.userId = id;
            currentState.email = email;
            currentState.fullname = fullname;
            currentState.token = userToken;
            state.setState(currentState);
        });
        currentState.token = userToken;
        this.setState(currentState);
    },
    subscribe (callback) {
        this.listeners.push(callback);
    },
    logIn (values, root, alerta, route) {
        const currentState = state.getState();
        const { email , password , check  } = values;
        fetch(url + "/login", {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify({
                email,
                password
            })
        }).then((res)=>{
            return res.json();
        }).then((data)=>{
            if (data.message) {
                console.log("ERROR", data);
                alerta.innerHTML = "ERROR";
            // this.setState(currentState);
            } else if (data) {
                console.log("Se hizo sign-in:", data);
                alerta.innerHTML = "";
                currentState.userId = data.user.id;
                currentState.fullname = data.user.fullname;
                currentState.email = email;
                currentState.token = data.token;
                this.setState(currentState);
                if (check) localStorage.setItem("token", data.token.toString());
                console.log(route);
                // ROUTEO
                history.pushState({}, "", route);
                if (root.firstChild) root.firstChild.remove();
                if (route == "/mis-datos") root.appendChild((0, _2CMisDatos.initPageMisDatos)(root));
                if (route == "/mis-mascotas") root.appendChild((0, _3BMisMascotas.initPageMisMascotas)(root));
                if (route == "/publicar-mascota") root.appendChild((0, _3APublicar.initPagePublicar)(root));
            }
        });
    },
    getToken (loginValues, root, alerta) {
        const currentState = state.getState();
        const { email , password , check  } = loginValues;
        fetch(url + "/auth/token", {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify({
                email,
                password
            })
        }).then((res)=>{
            return res.json();
        }).then((data)=>{
            if (data.message) {
                console.log("ERROR", data);
                alerta.innerHTML = "ERROR";
                this.setState(currentState);
            } else if (data.token) {
                console.log("Se hizo sign-in:", data);
                alerta.innerHTML = "OK LOG";
                currentState.email = email;
                currentState.token = data.token;
                this.setState(currentState);
                if (check) localStorage.setItem("token", data.token.toString());
            }
        });
    },
    getAuth (values, root, confirmacion) {
        const currentState = state.getState();
        const { email , fullname , password  } = values;
        console.log("A autenticar user!");
        fetch(url + "/auth", {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify({
                email,
                fullname,
                password
            })
        }).then((res)=>{
            return res.json();
        }).then((data)=>{
            console.log("Se autentic\xf3 user:", data);
            confirmacion.innerHTML = `El usuario fue creado exitosamente`;
        // root.goTo(route);
        });
    },
    updateUser (values) {
        const currentState = state.getState();
        fetch(url + "/update-user/" + this.data.userId, {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify(values)
        }).then((res)=>{
            return res.json();
        }).then(()=>{
            currentState.email = values.email;
            currentState.fullname = values.fullname;
            state.setState(currentState);
            console.log("DATOS ACTUALIZADOS");
        });
    },
    logOut () {
        if (localStorage.getItem("token")) localStorage.removeItem("token");
        this.data = "";
        console.log(this.data);
    },
    setMyUbication (ubication) {
        const currentState = state.getState();
        currentState.ubication = ubication;
        state.setState(currentState);
    },
    mostrarMascotasCercaTuyo (root, contenedor, template) {
        const currentState = state.getState();
        const { lat , lng  } = currentState.ubication;
        fetch(url + "/pets-near-me" + "?lat=" + lat + "&lng=" + lng).then((res)=>{
            return res.json();
        }).then((results)=>{
            contenedor.replaceChildren();
            for (let r of results){
                const pet_id = template.content.querySelector(".selected_pet");
                pet_id.setAttribute("data-bs-pet_id", r.objectID);
                const pet_name = template.content.querySelector(".selected_pet");
                pet_name.setAttribute("data-bs-pet_name", r.name);
                const foto = template.content.querySelector(".card-img-top");
                foto.src = r.picture_url;
                // foto.src = r.thumbnail;
                const nombre = template.content.querySelector(".card-title");
                nombre.textContent = r.name;
                const ubicacion = template.content.querySelector(".card-text");
                ubicacion.textContent = r.ubication;
                const clone = document.importNode(template.content, true);
                contenedor.appendChild(clone);
            }
        });
    },
    setReporte (reporte) {
        fetch(url + "/new-report", {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify(reporte)
        }).then((res)=>{
            return res.json();
        }).then((data)=>{
            console.log(data);
        });
    },
    mostrarMisMascotas (root, contenedor, template) {
        const currentState = state.getState();
        fetch(url + "/my-pets/" + currentState.userId).then((res)=>{
            return res.json();
        }).then((results)=>{
            if (results.length == 0) contenedor.innerHTML = `<h5 class="card-title">No tenés mascotas reportadas</h5>`;
            else {
                contenedor.replaceChildren();
                for (let r of results){
                    const pet_id = template.content.querySelector("#edit_pet");
                    pet_id.setAttribute("pet_id", r.id);
                    const pet_id_delete = template.content.querySelector("#delete_pet");
                    pet_id_delete.setAttribute("pet_id", r.id);
                    const foto = template.content.querySelector(".card-img-top");
                    foto.src = r.picture_url;
                    // foto.src = r.thumbnail;
                    const nombre = template.content.querySelector(".card-title");
                    nombre.textContent = r.name;
                    const ubicacion = template.content.querySelector(".card-text");
                    ubicacion.textContent = r.ubication;
                    const clone = document.importNode(template.content, true);
                    contenedor.appendChild(clone);
                }
            }
        });
    },
    publicarMascota (datosNewPet) {
        const currentState = state.getState();
        datosNewPet.userId = currentState.userId;
        fetch(url + "/new-pet", {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify(datosNewPet)
        }).then((res)=>{
            return res.json();
        }).then((data)=>{
            console.log(data);
        });
    },
    irAEditarMascota (root, pet_id) {
        // ROUTEO
        history.pushState({}, "", "/editar-mascota");
        if (root.firstChild) root.firstChild.remove();
        root.appendChild((0, _3CEditarMascota.initPageEditarMascota)(root));
        // DB
        fetch(url + "/pet/" + pet_id).then((res)=>{
            return res.json();
        }).then((pet)=>{
            console.log("La mascota a editar es:", pet);
            const nameInput = root.querySelector("#Name");
            nameInput.setAttribute("pet_id", pet_id);
            nameInput.value = pet.name;
            const ubicationInput = root.querySelector("#Ubicacion");
            ubicationInput.value = pet.ubication;
            const petPicture = root.querySelector(".pet-picture");
            petPicture.setAttribute("src", pet.picture_url);
        });
    },
    editarMascota (datos) {
        // Preparo body para update
        const sendBody = {};
        if (datos.imagen_data) sendBody.imagen_data = datos.imagen_data;
        if (datos.name) sendBody.name = datos.name;
        if (datos.ubication) sendBody.ubication = datos.ubication;
        if (datos.last_location_lat) sendBody.last_location_lat = datos.last_location_lat;
        if (datos.last_location_lng) sendBody.last_location_lng = datos.last_location_lng;
        fetch(url + "/edit-pet/" + datos.id, {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify(sendBody)
        }).then((res)=>{
            return res.json();
        }).then((data)=>{
            console.log(data);
        });
    },
    eliminarMascota (root, pet_id) {
        fetch(url + "/delete-pet/" + pet_id, {
            method: "post",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify({
                status: "deleted"
            })
        }).then((res)=>{
            return res.json();
        }).then((data)=>{
            console.log(data);
        });
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","./pages/2c-mis-datos":"5afcR","./pages/3b-mis-mascotas":"123UY","./pages/3a-publicar":"3fMd3","./pages/3c-editar-mascota":"6qduQ"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"5afcR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initPageMisDatos", ()=>initPageMisDatos);
var _state = require("../../state");
function initPageMisDatos(root) {
    const div = document.createElement("div");
    const currentState = (0, _state.state).getState();
    if (currentState.userId) console.log("hay user");
    else if (!currentState.userId) console.log("NO hay user");
    div.innerHTML = `
  <h1 class="fs-1">Mis Datos</h1>

  <div class="modal-login"></div>

  <label class="mb-3">Completa sólo los campos que desees actualizar</label>

  <form class="form-mis-datos">

  <div class="mb-3">
    <label for="Name" class="form-label">Nombre</label>
    <input class="form-control" id="Name" aria-describedby="nameHelp">
  </div>

  <div class="mb-3">
    <label for="Email" class="form-label">Email</label>
    <input type="email" class="form-control" id="Email" aria-describedby="emailHelp">
  </div>

  <div class="mb-3">
    <label for="Contraseña" class="form-label">Contraseña</label>
    <input type="password" class="form-control" id="Contraseña">
  </div>

  <div class="mb-3">
    <label for="Repetir-Contraseña" class="form-label">Repetir contraseña</label>
    <input type="password" class="form-control" id="Repetir-Contraseña">
  </div>

  <div class="alerta-password"></div>

  <button type="submit" class="btn btn-primary">Actualizar mis datos</button>
  
  </form>
  `;
    const modalLogin = div.querySelector(".modal-login");
    const alertaPassword = div.querySelector(".alerta-password");
    // const currentState = state.getState();
    const fullname = currentState.fullname;
    const nameInput = div.querySelector("#Name");
    const emailInput = div.querySelector("#Email");
    const passwordInput = div.querySelector("#Contrase\xf1a");
    const repeatPasswordInput = div.querySelector("#Repetir-Contrase\xf1a");
    nameInput.value = currentState.fullname;
    emailInput.value = currentState.email;
    const form = div.querySelector(".form-mis-datos");
    form.addEventListener("submit", (e)=>{
        e.preventDefault();
        if (passwordInput.value == repeatPasswordInput.value) {
            alertaPassword.innerHTML = "";
            const dataValues = {};
            dataValues.fullname = nameInput.value || currentState.fullname;
            dataValues.email = emailInput.value || currentState.email;
            dataValues.password = passwordInput.value;
            (0, _state.state).updateUser(dataValues);
        } else if (passwordInput.value != repeatPasswordInput.value) alertaPassword.innerHTML = `Las constraseñas no coinciden`;
    });
    return div;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../../state":"gYwa1"}],"123UY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initPageMisMascotas", ()=>initPageMisMascotas);
var _state = require("../../state");
function initPageMisMascotas(root) {
    const div = document.createElement("div");
    div.innerHTML = `
  <h1 class="fs-1">Mis Mascotas</h1>

  
  <div class="results" id="results"></div>

  <template id="template">

    <div class="card mb-3" style="width: 18rem;">
      <img src="" class="card-img-top" alt="...">
      <div class="card-body">
        <h5 class="card-title"></h5>
        <p class="card-text"></p>
        <button class="btn btn-warning mb-3" id="edit_pet" pet_id="" >
          Editar
        </button>

        <button class="btn btn-danger mb-3" id="delete_pet" pet_id="" >
          Eliminar
        </button>
      </div>
    </div>

    </template>


  `;
    const contenedor = div.querySelector(".results");
    const template = div.querySelector("#template");
    (0, _state.state).mostrarMisMascotas(root, contenedor, template);
    // Agrego listenners Botón Editar y Eliminar
    let counter = 1;
    const intervalIdB = setInterval(()=>{
        counter--;
        if (counter < 0) {
            clearInterval(intervalIdB);
            const items = contenedor.children;
            for (const i of items){
                const editButton = i.querySelector("#edit_pet");
                editButton.addEventListener("click", (e)=>{
                    const pet_id = e.target.getAttribute("pet_id");
                    (0, _state.state).irAEditarMascota(root, pet_id);
                });
                const deleteButton = i.querySelector("#delete_pet");
                deleteButton.addEventListener("click", (e)=>{
                    const pet_id = e.target.getAttribute("pet_id");
                    (0, _state.state).eliminarMascota(root, pet_id);
                });
            }
        }
    }, 1000);
    return div;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../../state":"gYwa1"}],"3fMd3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initPagePublicar", ()=>initPagePublicar);
var _state = require("../../state");
var _dropzone = require("dropzone");
var _mapboxGl = require("mapbox-gl");
var _mapbox = require("../../lib/mapbox");
const MAPBOX_TOKEN = "pk.eyJ1IjoiZGFuaWVsYS1ha2VybWFuIiwiYSI6ImNsZGs3aXo0MzE1MG4zdXMyNXF3ZDRnYzUifQ.kr3GsybRoqh2YOfz4faKgw";
function initPagePublicar(root) {
    const div = document.createElement("div");
    div.innerHTML = `
  <link
  href="//api.mapbox.com/mapbox-gl-js/v2.3.1/mapbox-gl.css"
  rel="stylesheet"
/>
  <h1 class="fs-1">Publicar Mascota</h1>

  <form class="form-publicar">

  <div class="mb-3">
    <label for="Name" class="form-label">Nombre de tu mascota</label>
    <input class="form-control" id="Name" aria-describedby="nameHelp">
  </div>

  <div class="mb-3 dropzone"></div>

  <div class="mb-3 mapa-container"></div>

  <div class="mb-3">
    <label for="Ubicacion" class="form-label">Ciudad o barrio</label>
    <input class="form-control" id="Ubicacion">
  </div>

  <button type="submit" class="btn btn-primary">Publicar</button>
  
  </form>

  `;
    // Dropzone
    const divDrop = div.querySelector(".dropzone");
    let imageDataURL;
    const myDropzone = new (0, _dropzone.Dropzone)(divDrop, {
        url: "/falsa",
        clickable: true,
        autoProcessQueue: false,
        addRemoveLinks: true
    });
    myDropzone.on("thumbnail", function(file) {
        // usando este evento pueden acceder al dataURL directamente
        imageDataURL = file.dataURL;
    });
    // Mapbox
    // INICIA EL MAPA EN EL CONTENEDOR
    function initMap() {
        const mapContainer = div.querySelector(".mapa-container");
        _mapboxGl.accessToken = MAPBOX_TOKEN;
        return new _mapboxGl.Map({
            container: mapContainer,
            style: "mapbox://styles/mapbox/streets-v11",
            center: [
                -74.5,
                40
            ],
            zoom: 9
        });
    }
    const map = initMap();
    const petName = div.querySelector("#Name");
    const form = div.querySelector(".form-publicar");
    form.addEventListener("submit", (e)=>{
        e.preventDefault();
        const inputLocalizacion = div.querySelector("#Ubicacion");
        const localValue = inputLocalizacion.value;
        console.log(localValue);
        // SE REALIZA LA GEOBUSQUEDA
        (0, _mapbox.mapboxClient).geocodeForward(localValue, {
            country: "ar",
            autocomplete: true,
            language: "es"
        }, // SE GUARDA LOS DATOS DE LA BUSQUIEDA EN UN ATRIBUTO SEARCHDATA
        (err, data, res)=>{
            const firstResult = data.features[0];
            const lng = firstResult.geometry.coordinates[0];
            const lat = firstResult.geometry.coordinates[1];
            const searchData = {
                lng,
                lat
            };
            console.log(searchData);
            // CREA EL MARKER EN EL MAPA
            new _mapboxGl.Marker().setLngLat(firstResult.geometry.coordinates).addTo(map);
            map.setCenter(firstResult.geometry.coordinates);
            map.setZoom(14);
            // Objeto para request
            const datosNewPet = {};
            datosNewPet.name = petName.value;
            datosNewPet.ubication = localValue;
            datosNewPet.status = "lost";
            datosNewPet.imagen_data = imageDataURL;
            datosNewPet.last_location_lat = lat;
            datosNewPet.last_location_lng = lng;
            console.log({
                datosNewPet
            });
            (0, _state.state).publicarMascota(datosNewPet);
        });
    });
    return div;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","dropzone":"bsyxN","mapbox-gl":"562rs","../../lib/mapbox":"cxbpN","../../state":"gYwa1"}],"bsyxN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>$3ed269f2f0fb224b$export$2e2bcd8739ae039);
parcelHelpers.export(exports, "Dropzone", ()=>$3ed269f2f0fb224b$export$2e2bcd8739ae039);
var _justExtend = require("just-extend");
var _justExtendDefault = parcelHelpers.interopDefault(_justExtend);
function $parcel$interopDefault(a) {
    return a && a.__esModule ? a.default : a;
}
class $4040acfd8584338d$export$2e2bcd8739ae039 {
    // Add an event listener for given event
    on(event, fn) {
        this._callbacks = this._callbacks || {};
        // Create namespace for this event
        if (!this._callbacks[event]) this._callbacks[event] = [];
        this._callbacks[event].push(fn);
        return this;
    }
    emit(event, ...args) {
        this._callbacks = this._callbacks || {};
        let callbacks = this._callbacks[event];
        if (callbacks) for (let callback of callbacks)callback.apply(this, args);
        // trigger a corresponding DOM event
        if (this.element) this.element.dispatchEvent(this.makeEvent("dropzone:" + event, {
            args: args
        }));
        return this;
    }
    makeEvent(eventName, detail) {
        let params = {
            bubbles: true,
            cancelable: true,
            detail: detail
        };
        if (typeof window.CustomEvent === "function") return new CustomEvent(eventName, params);
        else {
            // IE 11 support
            // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
            var evt = document.createEvent("CustomEvent");
            evt.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);
            return evt;
        }
    }
    // Remove event listener for given event. If fn is not provided, all event
    // listeners for that event will be removed. If neither is provided, all
    // event listeners will be removed.
    off(event, fn) {
        if (!this._callbacks || arguments.length === 0) {
            this._callbacks = {};
            return this;
        }
        // specific event
        let callbacks = this._callbacks[event];
        if (!callbacks) return this;
        // remove all handlers
        if (arguments.length === 1) {
            delete this._callbacks[event];
            return this;
        }
        // remove specific handler
        for(let i = 0; i < callbacks.length; i++){
            let callback = callbacks[i];
            if (callback === fn) {
                callbacks.splice(i, 1);
                break;
            }
        }
        return this;
    }
}
var $fd6031f88dce2e32$exports = {};
$fd6031f88dce2e32$exports = '<div class="dz-preview dz-file-preview">\n  <div class="dz-image"><img data-dz-thumbnail=""></div>\n  <div class="dz-details">\n    <div class="dz-size"><span data-dz-size=""></span></div>\n    <div class="dz-filename"><span data-dz-name=""></span></div>\n  </div>\n  <div class="dz-progress">\n    <span class="dz-upload" data-dz-uploadprogress=""></span>\n  </div>\n  <div class="dz-error-message"><span data-dz-errormessage=""></span></div>\n  <div class="dz-success-mark">\n    <svg width="54" height="54" viewBox="0 0 54 54" fill="white" xmlns="http://www.w3.org/2000/svg">\n      <path d="M10.2071 29.7929L14.2929 25.7071C14.6834 25.3166 15.3166 25.3166 15.7071 25.7071L21.2929 31.2929C21.6834 31.6834 22.3166 31.6834 22.7071 31.2929L38.2929 15.7071C38.6834 15.3166 39.3166 15.3166 39.7071 15.7071L43.7929 19.7929C44.1834 20.1834 44.1834 20.8166 43.7929 21.2071L22.7071 42.2929C22.3166 42.6834 21.6834 42.6834 21.2929 42.2929L10.2071 31.2071C9.81658 30.8166 9.81658 30.1834 10.2071 29.7929Z"></path>\n    </svg>\n  </div>\n  <div class="dz-error-mark">\n    <svg width="54" height="54" viewBox="0 0 54 54" fill="white" xmlns="http://www.w3.org/2000/svg">\n      <path d="M26.2929 20.2929L19.2071 13.2071C18.8166 12.8166 18.1834 12.8166 17.7929 13.2071L13.2071 17.7929C12.8166 18.1834 12.8166 18.8166 13.2071 19.2071L20.2929 26.2929C20.6834 26.6834 20.6834 27.3166 20.2929 27.7071L13.2071 34.7929C12.8166 35.1834 12.8166 35.8166 13.2071 36.2071L17.7929 40.7929C18.1834 41.1834 18.8166 41.1834 19.2071 40.7929L26.2929 33.7071C26.6834 33.3166 27.3166 33.3166 27.7071 33.7071L34.7929 40.7929C35.1834 41.1834 35.8166 41.1834 36.2071 40.7929L40.7929 36.2071C41.1834 35.8166 41.1834 35.1834 40.7929 34.7929L33.7071 27.7071C33.3166 27.3166 33.3166 26.6834 33.7071 26.2929L40.7929 19.2071C41.1834 18.8166 41.1834 18.1834 40.7929 17.7929L36.2071 13.2071C35.8166 12.8166 35.1834 12.8166 34.7929 13.2071L27.7071 20.2929C27.3166 20.6834 26.6834 20.6834 26.2929 20.2929Z"></path>\n    </svg>\n  </div>\n</div>\n';
let $4ca367182776f80b$var$defaultOptions = {
    /**
   * Has to be specified on elements other than form (or when the form doesn't
   * have an `action` attribute).
   *
   * You can also provide a function that will be called with `files` and
   * `dataBlocks`  and must return the url as string.
   */ url: null,
    /**
   * Can be changed to `"put"` if necessary. You can also provide a function
   * that will be called with `files` and must return the method (since `v3.12.0`).
   */ method: "post",
    /**
   * Will be set on the XHRequest.
   */ withCredentials: false,
    /**
   * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
   * If set to null or 0, no timeout is going to be set.
   */ timeout: null,
    /**
   * How many file uploads to process in parallel (See the
   * Enqueuing file uploads documentation section for more info)
   */ parallelUploads: 2,
    /**
   * Whether to send multiple files in one request. If
   * this it set to true, then the fallback file input element will
   * have the `multiple` attribute as well. This option will
   * also trigger additional events (like `processingmultiple`). See the events
   * documentation section for more information.
   */ uploadMultiple: false,
    /**
   * Whether you want files to be uploaded in chunks to your server. This can't be
   * used in combination with `uploadMultiple`.
   *
   * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
   */ chunking: false,
    /**
   * If `chunking` is enabled, this defines whether **every** file should be chunked,
   * even if the file size is below chunkSize. This means, that the additional chunk
   * form data will be submitted and the `chunksUploaded` callback will be invoked.
   */ forceChunking: false,
    /**
   * If `chunking` is `true`, then this defines the chunk size in bytes.
   */ chunkSize: 2097152,
    /**
   * If `true`, the individual chunks of a file are being uploaded simultaneously.
   */ parallelChunkUploads: false,
    /**
   * Whether a chunk should be retried if it fails.
   */ retryChunks: false,
    /**
   * If `retryChunks` is true, how many times should it be retried.
   */ retryChunksLimit: 3,
    /**
   * The maximum filesize (in MiB) that is allowed to be uploaded.
   */ maxFilesize: 256,
    /**
   * The name of the file param that gets transferred.
   * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
   * Dropzone will append `[]` to the name.
   */ paramName: "file",
    /**
   * Whether thumbnails for images should be generated
   */ createImageThumbnails: true,
    /**
   * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
   */ maxThumbnailFilesize: 10,
    /**
   * If `null`, the ratio of the image will be used to calculate it.
   */ thumbnailWidth: 120,
    /**
   * The same as `thumbnailWidth`. If both are null, images will not be resized.
   */ thumbnailHeight: 120,
    /**
   * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
   * Can be either `contain` or `crop`.
   */ thumbnailMethod: "crop",
    /**
   * If set, images will be resized to these dimensions before being **uploaded**.
   * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
   * ratio of the file will be preserved.
   *
   * The `options.transformFile` function uses these options, so if the `transformFile` function
   * is overridden, these options don't do anything.
   */ resizeWidth: null,
    /**
   * See `resizeWidth`.
   */ resizeHeight: null,
    /**
   * The mime type of the resized image (before it gets uploaded to the server).
   * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
   * See `resizeWidth` for more information.
   */ resizeMimeType: null,
    /**
   * The quality of the resized images. See `resizeWidth`.
   */ resizeQuality: 0.8,
    /**
   * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
   * Can be either `contain` or `crop`.
   */ resizeMethod: "contain",
    /**
   * The base that is used to calculate the **displayed** filesize. You can
   * change this to 1024 if you would rather display kibibytes, mebibytes,
   * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
   * not `1 kilobyte`. You can change this to `1024` if you don't care about
   * validity.
   */ filesizeBase: 1000,
    /**
   * If not `null` defines how many files this Dropzone handles. If it exceeds,
   * the event `maxfilesexceeded` will be called. The dropzone element gets the
   * class `dz-max-files-reached` accordingly so you can provide visual
   * feedback.
   */ maxFiles: null,
    /**
   * An optional object to send additional headers to the server. Eg:
   * `{ "My-Awesome-Header": "header value" }`
   */ headers: null,
    /**
   * Should the default headers be set or not?
   * Accept: application/json <- for requesting json response
   * Cache-Control: no-cache <- Request shouldnt be cached
   * X-Requested-With: XMLHttpRequest <- We sent the request via XMLHttpRequest
   */ defaultHeaders: true,
    /**
   * If `true`, the dropzone element itself will be clickable, if `false`
   * nothing will be clickable.
   *
   * You can also pass an HTML element, a CSS selector (for multiple elements)
   * or an array of those. In that case, all of those elements will trigger an
   * upload when clicked.
   */ clickable: true,
    /**
   * Whether hidden files in directories should be ignored.
   */ ignoreHiddenFiles: true,
    /**
   * The default implementation of `accept` checks the file's mime type or
   * extension against this list. This is a comma separated list of mime
   * types or file extensions.
   *
   * Eg.: `image/*,application/pdf,.psd`
   *
   * If the Dropzone is `clickable` this option will also be used as
   * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
   * parameter on the hidden file input as well.
   */ acceptedFiles: null,
    /**
   * **Deprecated!**
   * Use acceptedFiles instead.
   */ acceptedMimeTypes: null,
    /**
   * If false, files will be added to the queue but the queue will not be
   * processed automatically.
   * This can be useful if you need some additional user input before sending
   * files (or if you want want all files sent at once).
   * If you're ready to send the file simply call `myDropzone.processQueue()`.
   *
   * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
   * section for more information.
   */ autoProcessQueue: true,
    /**
   * If false, files added to the dropzone will not be queued by default.
   * You'll have to call `enqueueFile(file)` manually.
   */ autoQueue: true,
    /**
   * If `true`, this will add a link to every file preview to remove or cancel (if
   * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
   * and `dictRemoveFile` options are used for the wording.
   */ addRemoveLinks: false,
    /**
   * Defines where to display the file previews – if `null` the
   * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
   * selector. The element should have the `dropzone-previews` class so
   * the previews are displayed properly.
   */ previewsContainer: null,
    /**
   * Set this to `true` if you don't want previews to be shown.
   */ disablePreviews: false,
    /**
   * This is the element the hidden input field (which is used when clicking on the
   * dropzone to trigger file selection) will be appended to. This might
   * be important in case you use frameworks to switch the content of your page.
   *
   * Can be a selector string, or an element directly.
   */ hiddenInputContainer: "body",
    /**
   * If null, no capture type will be specified
   * If camera, mobile devices will skip the file selection and choose camera
   * If microphone, mobile devices will skip the file selection and choose the microphone
   * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
   * On apple devices multiple must be set to false.  AcceptedFiles may need to
   * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
   */ capture: null,
    /**
   * **Deprecated**. Use `renameFile` instead.
   */ renameFilename: null,
    /**
   * A function that is invoked before the file is uploaded to the server and renames the file.
   * This function gets the `File` as argument and can use the `file.name`. The actual name of the
   * file that gets used during the upload can be accessed through `file.upload.filename`.
   */ renameFile: null,
    /**
   * If `true` the fallback will be forced. This is very useful to test your server
   * implementations first and make sure that everything works as
   * expected without dropzone if you experience problems, and to test
   * how your fallbacks will look.
   */ forceFallback: false,
    /**
   * The text used before any files are dropped.
   */ dictDefaultMessage: "Drop files here to upload",
    /**
   * The text that replaces the default message text it the browser is not supported.
   */ dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
    /**
   * The text that will be added before the fallback form.
   * If you provide a  fallback element yourself, or if this option is `null` this will
   * be ignored.
   */ dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
    /**
   * If the filesize is too big.
   * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
   */ dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
    /**
   * If the file doesn't match the file type.
   */ dictInvalidFileType: "You can't upload files of this type.",
    /**
   * If the server response was invalid.
   * `{{statusCode}}` will be replaced with the servers status code.
   */ dictResponseError: "Server responded with {{statusCode}} code.",
    /**
   * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
   */ dictCancelUpload: "Cancel upload",
    /**
   * The text that is displayed if an upload was manually canceled
   */ dictUploadCanceled: "Upload canceled.",
    /**
   * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
   */ dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
    /**
   * If `addRemoveLinks` is true, the text to be used to remove a file.
   */ dictRemoveFile: "Remove file",
    /**
   * If this is not null, then the user will be prompted before removing a file.
   */ dictRemoveFileConfirmation: null,
    /**
   * Displayed if `maxFiles` is st and exceeded.
   * The string `{{maxFiles}}` will be replaced by the configuration value.
   */ dictMaxFilesExceeded: "You can not upload any more files.",
    /**
   * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
   * `b` for bytes.
   */ dictFileSizeUnits: {
        tb: "TB",
        gb: "GB",
        mb: "MB",
        kb: "KB",
        b: "b"
    },
    /**
   * Called when dropzone initialized
   * You can add event listeners here
   */ init () {},
    /**
   * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
   * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
   * of a function, this needs to return a map.
   *
   * The default implementation does nothing for normal uploads, but adds relevant information for
   * chunked uploads.
   *
   * This is the same as adding hidden input fields in the form element.
   */ params (files, xhr, chunk) {
        if (chunk) return {
            dzuuid: chunk.file.upload.uuid,
            dzchunkindex: chunk.index,
            dztotalfilesize: chunk.file.size,
            dzchunksize: this.options.chunkSize,
            dztotalchunkcount: chunk.file.upload.totalChunkCount,
            dzchunkbyteoffset: chunk.index * this.options.chunkSize
        };
    },
    /**
   * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
   * and a `done` function as parameters.
   *
   * If the done function is invoked without arguments, the file is "accepted" and will
   * be processed. If you pass an error message, the file is rejected, and the error
   * message will be displayed.
   * This function will not be called if the file is too big or doesn't match the mime types.
   */ accept (file, done) {
        return done();
    },
    /**
   * The callback that will be invoked when all chunks have been uploaded for a file.
   * It gets the file for which the chunks have been uploaded as the first parameter,
   * and the `done` function as second. `done()` needs to be invoked when everything
   * needed to finish the upload process is done.
   */ chunksUploaded: function(file, done) {
        done();
    },
    /**
   * Sends the file as binary blob in body instead of form data.
   * If this is set, the `params` option will be ignored.
   * It's an error to set this to `true` along with `uploadMultiple` since
   * multiple files cannot be in a single binary body.
   */ binaryBody: false,
    /**
   * Gets called when the browser is not supported.
   * The default implementation shows the fallback input field and adds
   * a text.
   */ fallback () {
        // This code should pass in IE7... :(
        let messageElement;
        this.element.className = `${this.element.className} dz-browser-not-supported`;
        for (let child of this.element.getElementsByTagName("div"))if (/(^| )dz-message($| )/.test(child.className)) {
            messageElement = child;
            child.className = "dz-message"; // Removes the 'dz-default' class
            break;
        }
        if (!messageElement) {
            messageElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement('<div class="dz-message"><span></span></div>');
            this.element.appendChild(messageElement);
        }
        let span = messageElement.getElementsByTagName("span")[0];
        if (span) {
            if (span.textContent != null) span.textContent = this.options.dictFallbackMessage;
            else if (span.innerText != null) span.innerText = this.options.dictFallbackMessage;
        }
        return this.element.appendChild(this.getFallbackForm());
    },
    /**
   * Gets called to calculate the thumbnail dimensions.
   *
   * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
   *
   *  - `srcWidth` & `srcHeight` (required)
   *  - `trgWidth` & `trgHeight` (required)
   *  - `srcX` & `srcY` (optional, default `0`)
   *  - `trgX` & `trgY` (optional, default `0`)
   *
   * Those values are going to be used by `ctx.drawImage()`.
   */ resize (file, width, height, resizeMethod) {
        let info = {
            srcX: 0,
            srcY: 0,
            srcWidth: file.width,
            srcHeight: file.height
        };
        let srcRatio = file.width / file.height;
        // Automatically calculate dimensions if not specified
        if (width == null && height == null) {
            width = info.srcWidth;
            height = info.srcHeight;
        } else if (width == null) width = height * srcRatio;
        else if (height == null) height = width / srcRatio;
        // Make sure images aren't upscaled
        width = Math.min(width, info.srcWidth);
        height = Math.min(height, info.srcHeight);
        let trgRatio = width / height;
        if (info.srcWidth > width || info.srcHeight > height) {
            // Image is bigger and needs rescaling
            if (resizeMethod === "crop") {
                if (srcRatio > trgRatio) {
                    info.srcHeight = file.height;
                    info.srcWidth = info.srcHeight * trgRatio;
                } else {
                    info.srcWidth = file.width;
                    info.srcHeight = info.srcWidth / trgRatio;
                }
            } else if (resizeMethod === "contain") {
                // Method 'contain'
                if (srcRatio > trgRatio) height = width / srcRatio;
                else width = height * srcRatio;
            } else throw new Error(`Unknown resizeMethod '${resizeMethod}'`);
        }
        info.srcX = (file.width - info.srcWidth) / 2;
        info.srcY = (file.height - info.srcHeight) / 2;
        info.trgWidth = width;
        info.trgHeight = height;
        return info;
    },
    /**
   * Can be used to transform the file (for example, resize an image if necessary).
   *
   * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
   * images according to those dimensions.
   *
   * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
   * to be invoked with the file when the transformation is done.
   */ transformFile (file, done) {
        if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
        else return done(file);
    },
    /**
   * A string that contains the template used for each dropped
   * file. Change it to fulfill your needs but make sure to properly
   * provide all elements.
   *
   * If you want to use an actual HTML element instead of providing a String
   * as a config option, you could create a div with the id `tpl`,
   * put the template inside it and provide the element like this:
   *
   *     document
   *       .querySelector('#tpl')
   *       .innerHTML
   *
   */ previewTemplate: /*@__PURE__*/ $parcel$interopDefault($fd6031f88dce2e32$exports),
    /*
   Those functions register themselves to the events on init and handle all
   the user interface specific stuff. Overwriting them won't break the upload
   but can break the way it's displayed.
   You can overwrite them if you don't like the default behavior. If you just
   want to add an additional event handler, register it on the dropzone object
   and don't overwrite those options.
   */ // Those are self explanatory and simply concern the DragnDrop.
    drop (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    dragstart (e) {},
    dragend (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    dragenter (e) {
        return this.element.classList.add("dz-drag-hover");
    },
    dragover (e) {
        return this.element.classList.add("dz-drag-hover");
    },
    dragleave (e) {
        return this.element.classList.remove("dz-drag-hover");
    },
    paste (e) {},
    // Called whenever there are no files left in the dropzone anymore, and the
    // dropzone should be displayed as if in the initial state.
    reset () {
        return this.element.classList.remove("dz-started");
    },
    // Called when a file is added to the queue
    // Receives `file`
    addedfile (file) {
        if (this.element === this.previewsContainer) this.element.classList.add("dz-started");
        if (this.previewsContainer && !this.options.disablePreviews) {
            file.previewElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(this.options.previewTemplate.trim());
            file.previewTemplate = file.previewElement; // Backwards compatibility
            this.previewsContainer.appendChild(file.previewElement);
            for (var node of file.previewElement.querySelectorAll("[data-dz-name]"))node.textContent = file.name;
            for (node of file.previewElement.querySelectorAll("[data-dz-size]"))node.innerHTML = this.filesize(file.size);
            if (this.options.addRemoveLinks) {
                file._removeLink = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<a class="dz-remove" href="javascript:undefined;" data-dz-remove>${this.options.dictRemoveFile}</a>`);
                file.previewElement.appendChild(file._removeLink);
            }
            let removeFileEvent = (e)=>{
                e.preventDefault();
                e.stopPropagation();
                if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(this.options.dictCancelUploadConfirmation, ()=>this.removeFile(file));
                else {
                    if (this.options.dictRemoveFileConfirmation) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(this.options.dictRemoveFileConfirmation, ()=>this.removeFile(file));
                    else return this.removeFile(file);
                }
            };
            for (let removeLink of file.previewElement.querySelectorAll("[data-dz-remove]"))removeLink.addEventListener("click", removeFileEvent);
        }
    },
    // Called whenever a file is removed.
    removedfile (file) {
        if (file.previewElement != null && file.previewElement.parentNode != null) file.previewElement.parentNode.removeChild(file.previewElement);
        return this._updateMaxFilesReachedClass();
    },
    // Called when a thumbnail has been generated
    // Receives `file` and `dataUrl`
    thumbnail (file, dataUrl) {
        if (file.previewElement) {
            file.previewElement.classList.remove("dz-file-preview");
            for (let thumbnailElement of file.previewElement.querySelectorAll("[data-dz-thumbnail]")){
                thumbnailElement.alt = file.name;
                thumbnailElement.src = dataUrl;
            }
            return setTimeout(()=>file.previewElement.classList.add("dz-image-preview"), 1);
        }
    },
    // Called whenever an error occurs
    // Receives `file` and `message`
    error (file, message) {
        if (file.previewElement) {
            file.previewElement.classList.add("dz-error");
            if (typeof message !== "string" && message.error) message = message.error;
            for (let node of file.previewElement.querySelectorAll("[data-dz-errormessage]"))node.textContent = message;
        }
    },
    errormultiple () {},
    // Called when a file gets processed. Since there is a cue, not all added
    // files are processed immediately.
    // Receives `file`
    processing (file) {
        if (file.previewElement) {
            file.previewElement.classList.add("dz-processing");
            if (file._removeLink) return file._removeLink.innerHTML = this.options.dictCancelUpload;
        }
    },
    processingmultiple () {},
    // Called whenever the upload progress gets updated.
    // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
    // To get the total number of bytes of the file, use `file.size`
    uploadprogress (file, progress, bytesSent) {
        if (file.previewElement) for (let node of file.previewElement.querySelectorAll("[data-dz-uploadprogress]"))node.nodeName === "PROGRESS" ? node.value = progress : node.style.width = `${progress}%`;
    },
    // Called whenever the total upload progress gets updated.
    // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
    totaluploadprogress () {},
    // Called just before the file is sent. Gets the `xhr` object as second
    // parameter, so you can modify it (for example to add a CSRF token) and a
    // `formData` object to add additional information.
    sending () {},
    sendingmultiple () {},
    // When the complete upload is finished and successful
    // Receives `file`
    success (file) {
        if (file.previewElement) return file.previewElement.classList.add("dz-success");
    },
    successmultiple () {},
    // When the upload is canceled.
    canceled (file) {
        return this.emit("error", file, this.options.dictUploadCanceled);
    },
    canceledmultiple () {},
    // When the upload is finished, either with success or an error.
    // Receives `file`
    complete (file) {
        if (file._removeLink) file._removeLink.innerHTML = this.options.dictRemoveFile;
        if (file.previewElement) return file.previewElement.classList.add("dz-complete");
    },
    completemultiple () {},
    maxfilesexceeded () {},
    maxfilesreached () {},
    queuecomplete () {},
    addedfiles () {}
};
var $4ca367182776f80b$export$2e2bcd8739ae039 = $4ca367182776f80b$var$defaultOptions;
class $3ed269f2f0fb224b$export$2e2bcd8739ae039 extends $4040acfd8584338d$export$2e2bcd8739ae039 {
    static initClass() {
        // Exposing the emitter class, mainly for tests
        this.prototype.Emitter = $4040acfd8584338d$export$2e2bcd8739ae039;
        /*
     This is a list of all available events you can register on a dropzone object.

     You can register an event handler like this:

     dropzone.on("dragEnter", function() { });

     */ this.prototype.events = [
            "drop",
            "dragstart",
            "dragend",
            "dragenter",
            "dragover",
            "dragleave",
            "addedfile",
            "addedfiles",
            "removedfile",
            "thumbnail",
            "error",
            "errormultiple",
            "processing",
            "processingmultiple",
            "uploadprogress",
            "totaluploadprogress",
            "sending",
            "sendingmultiple",
            "success",
            "successmultiple",
            "canceled",
            "canceledmultiple",
            "complete",
            "completemultiple",
            "reset",
            "maxfilesexceeded",
            "maxfilesreached",
            "queuecomplete"
        ];
        this.prototype._thumbnailQueue = [];
        this.prototype._processingThumbnail = false;
    }
    // Returns all files that have been accepted
    getAcceptedFiles() {
        return this.files.filter((file)=>file.accepted).map((file)=>file);
    }
    // Returns all files that have been rejected
    // Not sure when that's going to be useful, but added for completeness.
    getRejectedFiles() {
        return this.files.filter((file)=>!file.accepted).map((file)=>file);
    }
    getFilesWithStatus(status) {
        return this.files.filter((file)=>file.status === status).map((file)=>file);
    }
    // Returns all files that are in the queue
    getQueuedFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED);
    }
    getUploadingFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING);
    }
    getAddedFiles() {
        return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED);
    }
    // Files that are either queued or uploading
    getActiveFiles() {
        return this.files.filter((file)=>file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED).map((file)=>file);
    }
    // The function that gets called when Dropzone is initialized. You
    // can (and should) setup event listeners inside this function.
    init() {
        // In case it isn't set already
        if (this.element.tagName === "form") this.element.setAttribute("enctype", "multipart/form-data");
        if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) this.element.appendChild($3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<div class="dz-default dz-message"><button class="dz-button" type="button">${this.options.dictDefaultMessage}</button></div>`));
        if (this.clickableElements.length) {
            let setupHiddenFileInput = ()=>{
                if (this.hiddenFileInput) this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
                this.hiddenFileInput = document.createElement("input");
                this.hiddenFileInput.setAttribute("type", "file");
                if (this.options.maxFiles === null || this.options.maxFiles > 1) this.hiddenFileInput.setAttribute("multiple", "multiple");
                this.hiddenFileInput.className = "dz-hidden-input";
                if (this.options.acceptedFiles !== null) this.hiddenFileInput.setAttribute("accept", this.options.acceptedFiles);
                if (this.options.capture !== null) this.hiddenFileInput.setAttribute("capture", this.options.capture);
                // Making sure that no one can "tab" into this field.
                this.hiddenFileInput.setAttribute("tabindex", "-1");
                // Not setting `display="none"` because some browsers don't accept clicks
                // on elements that aren't displayed.
                this.hiddenFileInput.style.visibility = "hidden";
                this.hiddenFileInput.style.position = "absolute";
                this.hiddenFileInput.style.top = "0";
                this.hiddenFileInput.style.left = "0";
                this.hiddenFileInput.style.height = "0";
                this.hiddenFileInput.style.width = "0";
                $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.hiddenInputContainer, "hiddenInputContainer").appendChild(this.hiddenFileInput);
                this.hiddenFileInput.addEventListener("change", ()=>{
                    let { files: files  } = this.hiddenFileInput;
                    if (files.length) for (let file of files)this.addFile(file);
                    this.emit("addedfiles", files);
                    setupHiddenFileInput();
                });
            };
            setupHiddenFileInput();
        }
        this.URL = window.URL !== null ? window.URL : window.webkitURL;
        // Setup all event listeners on the Dropzone object itself.
        // They're not in @setupEventListeners() because they shouldn't be removed
        // again when the dropzone gets disabled.
        for (let eventName of this.events)this.on(eventName, this.options[eventName]);
        this.on("uploadprogress", ()=>this.updateTotalUploadProgress());
        this.on("removedfile", ()=>this.updateTotalUploadProgress());
        this.on("canceled", (file)=>this.emit("complete", file));
        // Emit a `queuecomplete` event if all files finished uploading.
        this.on("complete", (file)=>{
            if (this.getAddedFiles().length === 0 && this.getUploadingFiles().length === 0 && this.getQueuedFiles().length === 0) return setTimeout(()=>this.emit("queuecomplete"), 0);
        });
        const containsFiles = function(e) {
            if (e.dataTransfer.types) // IE, we need to iterate like this instead of
            // using e.dataTransfer.types.some()
            for(var i = 0; i < e.dataTransfer.types.length; i++){
                if (e.dataTransfer.types[i] === "Files") return true;
            }
            return false;
        };
        let noPropagation = function(e) {
            // If there are no files, we don't want to stop
            // propagation so we don't interfere with other
            // drag and drop behaviour.
            if (!containsFiles(e)) return;
            e.stopPropagation();
            if (e.preventDefault) return e.preventDefault();
            else return e.returnValue = false;
        };
        // Create the listeners
        this.listeners = [
            {
                element: this.element,
                events: {
                    dragstart: (e)=>{
                        return this.emit("dragstart", e);
                    },
                    dragenter: (e)=>{
                        noPropagation(e);
                        return this.emit("dragenter", e);
                    },
                    dragover: (e)=>{
                        // Makes it possible to drag files from chrome's download bar
                        // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
                        // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
                        let efct;
                        try {
                            efct = e.dataTransfer.effectAllowed;
                        } catch (error) {}
                        e.dataTransfer.dropEffect = "move" === efct || "linkMove" === efct ? "move" : "copy";
                        noPropagation(e);
                        return this.emit("dragover", e);
                    },
                    dragleave: (e)=>{
                        return this.emit("dragleave", e);
                    },
                    drop: (e)=>{
                        noPropagation(e);
                        return this.drop(e);
                    },
                    dragend: (e)=>{
                        return this.emit("dragend", e);
                    }
                }
            }
        ];
        this.clickableElements.forEach((clickableElement)=>{
            return this.listeners.push({
                element: clickableElement,
                events: {
                    click: (evt)=>{
                        // Only the actual dropzone or the message element should trigger file selection
                        if (clickableElement !== this.element || evt.target === this.element || $3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside(evt.target, this.element.querySelector(".dz-message"))) this.hiddenFileInput.click(); // Forward the click
                        return true;
                    }
                }
            });
        });
        this.enable();
        return this.options.init.call(this);
    }
    // Not fully tested yet
    destroy() {
        this.disable();
        this.removeAllFiles(true);
        if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
            this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
            this.hiddenFileInput = null;
        }
        delete this.element.dropzone;
        return $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.splice($3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.indexOf(this), 1);
    }
    updateTotalUploadProgress() {
        let totalUploadProgress;
        let totalBytesSent = 0;
        let totalBytes = 0;
        let activeFiles = this.getActiveFiles();
        if (activeFiles.length) {
            for (let file of this.getActiveFiles()){
                totalBytesSent += file.upload.bytesSent;
                totalBytes += file.upload.total;
            }
            totalUploadProgress = 100 * totalBytesSent / totalBytes;
        } else totalUploadProgress = 100;
        return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
    }
    // @options.paramName can be a function taking one parameter rather than a string.
    // A parameter name for a file is obtained simply by calling this with an index number.
    _getParamName(n) {
        if (typeof this.options.paramName === "function") return this.options.paramName(n);
        else return `${this.options.paramName}${this.options.uploadMultiple ? `[${n}]` : ""}`;
    }
    // If @options.renameFile is a function,
    // the function will be used to rename the file.name before appending it to the formData
    _renameFile(file) {
        if (typeof this.options.renameFile !== "function") return file.name;
        return this.options.renameFile(file);
    }
    // Returns a form that can be used as fallback if the browser does not support DragnDrop
    //
    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
    // This code has to pass in IE7 :(
    getFallbackForm() {
        let existingFallback, form;
        if (existingFallback = this.getExistingFallback()) return existingFallback;
        let fieldsString = '<div class="dz-fallback">';
        if (this.options.dictFallbackText) fieldsString += `<p>${this.options.dictFallbackText}</p>`;
        fieldsString += `<input type="file" name="${this._getParamName(0)}" ${this.options.uploadMultiple ? 'multiple="multiple"' : undefined} /><input type="submit" value="Upload!"></div>`;
        let fields = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(fieldsString);
        if (this.element.tagName !== "FORM") {
            form = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<form action="${this.options.url}" enctype="multipart/form-data" method="${this.options.method}"></form>`);
            form.appendChild(fields);
        } else {
            // Make sure that the enctype and method attributes are set properly
            this.element.setAttribute("enctype", "multipart/form-data");
            this.element.setAttribute("method", this.options.method);
        }
        return form != null ? form : fields;
    }
    // Returns the fallback elements if they exist already
    //
    // This code has to pass in IE7 :(
    getExistingFallback() {
        let getFallback = function(elements) {
            for (let el of elements){
                if (/(^| )fallback($| )/.test(el.className)) return el;
            }
        };
        for (let tagName of [
            "div",
            "form"
        ]){
            var fallback;
            if (fallback = getFallback(this.element.getElementsByTagName(tagName))) return fallback;
        }
    }
    // Activates all listeners stored in @listeners
    setupEventListeners() {
        return this.listeners.map((elementListeners)=>(()=>{
                let result = [];
                for(let event in elementListeners.events){
                    let listener = elementListeners.events[event];
                    result.push(elementListeners.element.addEventListener(event, listener, false));
                }
                return result;
            })());
    }
    // Deactivates all listeners stored in @listeners
    removeEventListeners() {
        return this.listeners.map((elementListeners)=>(()=>{
                let result = [];
                for(let event in elementListeners.events){
                    let listener = elementListeners.events[event];
                    result.push(elementListeners.element.removeEventListener(event, listener, false));
                }
                return result;
            })());
    }
    // Removes all event listeners and cancels all files in the queue or being processed.
    disable() {
        this.clickableElements.forEach((element)=>element.classList.remove("dz-clickable"));
        this.removeEventListeners();
        this.disabled = true;
        return this.files.map((file)=>this.cancelUpload(file));
    }
    enable() {
        delete this.disabled;
        this.clickableElements.forEach((element)=>element.classList.add("dz-clickable"));
        return this.setupEventListeners();
    }
    // Returns a nicely formatted filesize
    filesize(size) {
        let selectedSize = 0;
        let selectedUnit = "b";
        if (size > 0) {
            let units = [
                "tb",
                "gb",
                "mb",
                "kb",
                "b"
            ];
            for(let i = 0; i < units.length; i++){
                let unit = units[i];
                let cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
                if (size >= cutoff) {
                    selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
                    selectedUnit = unit;
                    break;
                }
            }
            selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
        }
        return `<strong>${selectedSize}</strong> ${this.options.dictFileSizeUnits[selectedUnit]}`;
    }
    // Adds or removes the `dz-max-files-reached` class from the form.
    _updateMaxFilesReachedClass() {
        if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
            if (this.getAcceptedFiles().length === this.options.maxFiles) this.emit("maxfilesreached", this.files);
            return this.element.classList.add("dz-max-files-reached");
        } else return this.element.classList.remove("dz-max-files-reached");
    }
    drop(e) {
        if (!e.dataTransfer) return;
        this.emit("drop", e);
        // Convert the FileList to an Array
        // This is necessary for IE11
        let files = [];
        for(let i = 0; i < e.dataTransfer.files.length; i++)files[i] = e.dataTransfer.files[i];
        // Even if it's a folder, files.length will contain the folders.
        if (files.length) {
            let { items: items  } = e.dataTransfer;
            if (items && items.length && items[0].webkitGetAsEntry != null) this._addFilesFromItems(items);
            else this.handleFiles(files);
        }
        this.emit("addedfiles", files);
    }
    paste(e) {
        if ($3ed269f2f0fb224b$var$__guard__(e != null ? e.clipboardData : undefined, (x)=>x.items) == null) return;
        this.emit("paste", e);
        let { items: items  } = e.clipboardData;
        if (items.length) return this._addFilesFromItems(items);
    }
    handleFiles(files) {
        for (let file of files)this.addFile(file);
    }
    // When a folder is dropped (or files are pasted), items must be handled
    // instead of files.
    _addFilesFromItems(items) {
        return (()=>{
            let result = [];
            for (let item of items){
                var entry;
                if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
                    if (entry.isFile) result.push(this.addFile(item.getAsFile()));
                    else if (entry.isDirectory) result.push(this._addFilesFromDirectory(entry, entry.name));
                    else result.push(undefined);
                } else if (item.getAsFile != null) {
                    if (item.kind == null || item.kind === "file") result.push(this.addFile(item.getAsFile()));
                    else result.push(undefined);
                } else result.push(undefined);
            }
            return result;
        })();
    }
    // Goes through the directory, and adds each file it finds recursively
    _addFilesFromDirectory(directory, path) {
        let dirReader = directory.createReader();
        let errorHandler = (error)=>$3ed269f2f0fb224b$var$__guardMethod__(console, "log", (o)=>o.log(error));
        var readEntries = ()=>{
            return dirReader.readEntries((entries)=>{
                if (entries.length > 0) {
                    for (let entry of entries){
                        if (entry.isFile) entry.file((file)=>{
                            if (this.options.ignoreHiddenFiles && file.name.substring(0, 1) === ".") return;
                            file.fullPath = `${path}/${file.name}`;
                            return this.addFile(file);
                        });
                        else if (entry.isDirectory) this._addFilesFromDirectory(entry, `${path}/${entry.name}`);
                    }
                    // Recursively call readEntries() again, since browser only handle
                    // the first 100 entries.
                    // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries
                    readEntries();
                }
                return null;
            }, errorHandler);
        };
        return readEntries();
    }
    // If `done()` is called without argument the file is accepted
    // If you call it with an error message, the file is rejected
    // (This allows for asynchronous validation)
    //
    // This function checks the filesize, and if the file.type passes the
    // `acceptedFiles` check.
    accept(file, done) {
        if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1048576) done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
        else if (!$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile(file, this.options.acceptedFiles)) done(this.options.dictInvalidFileType);
        else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
            done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
            this.emit("maxfilesexceeded", file);
        } else this.options.accept.call(this, file, done);
    }
    addFile(file) {
        file.upload = {
            uuid: $3ed269f2f0fb224b$export$2e2bcd8739ae039.uuidv4(),
            progress: 0,
            // Setting the total upload size to file.size for the beginning
            // It's actual different than the size to be transmitted.
            total: file.size,
            bytesSent: 0,
            filename: this._renameFile(file)
        };
        this.files.push(file);
        file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED;
        this.emit("addedfile", file);
        this._enqueueThumbnail(file);
        this.accept(file, (error)=>{
            if (error) {
                file.accepted = false;
                this._errorProcessing([
                    file
                ], error); // Will set the file.status
            } else {
                file.accepted = true;
                if (this.options.autoQueue) this.enqueueFile(file);
            // Will set .accepted = true
            }
            this._updateMaxFilesReachedClass();
        });
    }
    // Wrapper for enqueueFile
    enqueueFiles(files) {
        for (let file of files)this.enqueueFile(file);
        return null;
    }
    enqueueFile(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED && file.accepted === true) {
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
            if (this.options.autoProcessQueue) return setTimeout(()=>this.processQueue(), 0); // Deferring the call
        } else throw new Error("This file can't be queued because it has already been processed or was rejected.");
    }
    _enqueueThumbnail(file) {
        if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1048576) {
            this._thumbnailQueue.push(file);
            return setTimeout(()=>this._processThumbnailQueue(), 0); // Deferring the call
        }
    }
    _processThumbnailQueue() {
        if (this._processingThumbnail || this._thumbnailQueue.length === 0) return;
        this._processingThumbnail = true;
        let file = this._thumbnailQueue.shift();
        return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, (dataUrl)=>{
            this.emit("thumbnail", file, dataUrl);
            this._processingThumbnail = false;
            return this._processThumbnailQueue();
        });
    }
    // Can be called by the user to remove a file
    removeFile(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) this.cancelUpload(file);
        this.files = $3ed269f2f0fb224b$var$without(this.files, file);
        this.emit("removedfile", file);
        if (this.files.length === 0) return this.emit("reset");
    }
    // Removes all files that aren't currently processed from the list
    removeAllFiles(cancelIfNecessary) {
        // Create a copy of files since removeFile() changes the @files array.
        if (cancelIfNecessary == null) cancelIfNecessary = false;
        for (let file of this.files.slice())if (file.status !== $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || cancelIfNecessary) this.removeFile(file);
        return null;
    }
    // Resizes an image before it gets sent to the server. This function is the default behavior of
    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
    // the resized blob.
    resizeImage(file, width, height, resizeMethod, callback) {
        return this.createThumbnail(file, width, height, resizeMethod, true, (dataUrl, canvas)=>{
            if (canvas == null) return callback(file);
            else {
                let { resizeMimeType: resizeMimeType  } = this.options;
                if (resizeMimeType == null) resizeMimeType = file.type;
                let resizedDataURL = canvas.toDataURL(resizeMimeType, this.options.resizeQuality);
                if (resizeMimeType === "image/jpeg" || resizeMimeType === "image/jpg") resizedDataURL = $3ed269f2f0fb224b$var$ExifRestore.restore(file.dataURL, resizedDataURL);
                return callback($3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob(resizedDataURL));
            }
        });
    }
    createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
        let fileReader = new FileReader();
        fileReader.onload = ()=>{
            file.dataURL = fileReader.result;
            // Don't bother creating a thumbnail for SVG images since they're vector
            if (file.type === "image/svg+xml") {
                if (callback != null) callback(fileReader.result);
                return;
            }
            this.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
        };
        fileReader.readAsDataURL(file);
    }
    // `mockFile` needs to have these attributes:
    //
    //     { name: 'name', size: 12345, imageUrl: '' }
    //
    // `callback` will be invoked when the image has been downloaded and displayed.
    // `crossOrigin` will be added to the `img` tag when accessing the file.
    displayExistingFile(mockFile, imageUrl, callback, crossOrigin, resizeThumbnail = true) {
        this.emit("addedfile", mockFile);
        this.emit("complete", mockFile);
        if (!resizeThumbnail) {
            this.emit("thumbnail", mockFile, imageUrl);
            if (callback) callback();
        } else {
            let onDone = (thumbnail)=>{
                this.emit("thumbnail", mockFile, thumbnail);
                if (callback) callback();
            };
            mockFile.dataURL = imageUrl;
            this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, this.options.fixOrientation, onDone, crossOrigin);
        }
    }
    createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
        // Not using `new Image` here because of a bug in latest Chrome versions.
        // See https://github.com/enyo/dropzone/pull/226
        let img = document.createElement("img");
        if (crossOrigin) img.crossOrigin = crossOrigin;
        // fixOrientation is not needed anymore with browsers handling imageOrientation
        fixOrientation = getComputedStyle(document.body)["imageOrientation"] == "from-image" ? false : fixOrientation;
        img.onload = ()=>{
            let loadExif = (callback)=>callback(1);
            if (typeof EXIF !== "undefined" && EXIF !== null && fixOrientation) loadExif = (callback)=>EXIF.getData(img, function() {
                    return callback(EXIF.getTag(this, "Orientation"));
                });
            return loadExif((orientation)=>{
                file.width = img.width;
                file.height = img.height;
                let resizeInfo = this.options.resize.call(this, file, width, height, resizeMethod);
                let canvas = document.createElement("canvas");
                let ctx = canvas.getContext("2d");
                canvas.width = resizeInfo.trgWidth;
                canvas.height = resizeInfo.trgHeight;
                if (orientation > 4) {
                    canvas.width = resizeInfo.trgHeight;
                    canvas.height = resizeInfo.trgWidth;
                }
                switch(orientation){
                    case 2:
                        // horizontal flip
                        ctx.translate(canvas.width, 0);
                        ctx.scale(-1, 1);
                        break;
                    case 3:
                        // 180° rotate left
                        ctx.translate(canvas.width, canvas.height);
                        ctx.rotate(Math.PI);
                        break;
                    case 4:
                        // vertical flip
                        ctx.translate(0, canvas.height);
                        ctx.scale(1, -1);
                        break;
                    case 5:
                        // vertical flip + 90 rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.scale(1, -1);
                        break;
                    case 6:
                        // 90° rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.translate(0, -canvas.width);
                        break;
                    case 7:
                        // horizontal flip + 90 rotate right
                        ctx.rotate(0.5 * Math.PI);
                        ctx.translate(canvas.height, -canvas.width);
                        ctx.scale(-1, 1);
                        break;
                    case 8:
                        // 90° rotate left
                        ctx.rotate(-0.5 * Math.PI);
                        ctx.translate(-canvas.height, 0);
                        break;
                }
                // This is a bugfix for iOS' scaling bug.
                $3ed269f2f0fb224b$var$drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
                let thumbnail = canvas.toDataURL("image/png");
                if (callback != null) return callback(thumbnail, canvas);
            });
        };
        if (callback != null) img.onerror = callback;
        return img.src = file.dataURL;
    }
    // Goes through the queue and processes files if there aren't too many already.
    processQueue() {
        let { parallelUploads: parallelUploads  } = this.options;
        let processingLength = this.getUploadingFiles().length;
        let i = processingLength;
        // There are already at least as many files uploading than should be
        if (processingLength >= parallelUploads) return;
        let queuedFiles = this.getQueuedFiles();
        if (!(queuedFiles.length > 0)) return;
        if (this.options.uploadMultiple) return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
        else while(i < parallelUploads){
            if (!queuedFiles.length) return;
            // Nothing left to process
            this.processFile(queuedFiles.shift());
            i++;
        }
    }
    // Wrapper for `processFiles`
    processFile(file) {
        return this.processFiles([
            file
        ]);
    }
    // Loads the file, then calls finishedLoading()
    processFiles(files) {
        for (let file of files){
            file.processing = true; // Backwards compatibility
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING;
            this.emit("processing", file);
        }
        if (this.options.uploadMultiple) this.emit("processingmultiple", files);
        return this.uploadFiles(files);
    }
    _getFilesWithXhr(xhr) {
        let files;
        return files = this.files.filter((file)=>file.xhr === xhr).map((file)=>file);
    }
    // Cancels the file upload and sets the status to CANCELED
    // **if** the file is actually being uploaded.
    // If it's still in the queue, the file is being removed from it and the status
    // set to CANCELED.
    cancelUpload(file) {
        if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) {
            let groupedFiles = this._getFilesWithXhr(file.xhr);
            for (let groupedFile of groupedFiles)groupedFile.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
            if (typeof file.xhr !== "undefined") file.xhr.abort();
            for (let groupedFile1 of groupedFiles)this.emit("canceled", groupedFile1);
            if (this.options.uploadMultiple) this.emit("canceledmultiple", groupedFiles);
        } else if (file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED || file.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED) {
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
            this.emit("canceled", file);
            if (this.options.uploadMultiple) this.emit("canceledmultiple", [
                file
            ]);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    resolveOption(option, ...args) {
        if (typeof option === "function") return option.apply(this, args);
        return option;
    }
    uploadFile(file) {
        return this.uploadFiles([
            file
        ]);
    }
    uploadFiles(files) {
        this._transformFiles(files, (transformedFiles)=>{
            if (this.options.chunking) {
                // Chunking is not allowed to be used with `uploadMultiple` so we know
                // that there is only __one__file.
                let transformedFile = transformedFiles[0];
                files[0].upload.chunked = this.options.chunking && (this.options.forceChunking || transformedFile.size > this.options.chunkSize);
                files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / this.options.chunkSize);
            }
            if (files[0].upload.chunked) {
                // This file should be sent in chunks!
                // If the chunking option is set, we **know** that there can only be **one** file, since
                // uploadMultiple is not allowed with this option.
                let file = files[0];
                let transformedFile = transformedFiles[0];
                let startedChunkCount = 0;
                file.upload.chunks = [];
                let handleNextChunk = ()=>{
                    let chunkIndex = 0;
                    // Find the next item in file.upload.chunks that is not defined yet.
                    while(file.upload.chunks[chunkIndex] !== undefined)chunkIndex++;
                    // This means, that all chunks have already been started.
                    if (chunkIndex >= file.upload.totalChunkCount) return;
                    startedChunkCount++;
                    let start = chunkIndex * this.options.chunkSize;
                    let end = Math.min(start + this.options.chunkSize, transformedFile.size);
                    let dataBlock = {
                        name: this._getParamName(0),
                        data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),
                        filename: file.upload.filename,
                        chunkIndex: chunkIndex
                    };
                    file.upload.chunks[chunkIndex] = {
                        file: file,
                        index: chunkIndex,
                        dataBlock: dataBlock,
                        status: $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING,
                        progress: 0,
                        retries: 0
                    };
                    this._uploadData(files, [
                        dataBlock
                    ]);
                };
                file.upload.finishedChunkUpload = (chunk, response)=>{
                    let allFinished = true;
                    chunk.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
                    // Clear the data from the chunk
                    chunk.dataBlock = null;
                    chunk.response = chunk.xhr.responseText;
                    chunk.responseHeaders = chunk.xhr.getAllResponseHeaders();
                    // Leaving this reference to xhr will cause memory leaks.
                    chunk.xhr = null;
                    for(let i = 0; i < file.upload.totalChunkCount; i++){
                        if (file.upload.chunks[i] === undefined) return handleNextChunk();
                        if (file.upload.chunks[i].status !== $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS) allFinished = false;
                    }
                    if (allFinished) this.options.chunksUploaded(file, ()=>{
                        this._finished(files, response, null);
                    });
                };
                if (this.options.parallelChunkUploads) for(let i = 0; i < file.upload.totalChunkCount; i++)handleNextChunk();
                else handleNextChunk();
            } else {
                let dataBlocks = [];
                for(let i = 0; i < files.length; i++)dataBlocks[i] = {
                    name: this._getParamName(i),
                    data: transformedFiles[i],
                    filename: files[i].upload.filename
                };
                this._uploadData(files, dataBlocks);
            }
        });
    }
    /// Returns the right chunk for given file and xhr
    _getChunk(file, xhr) {
        for(let i = 0; i < file.upload.totalChunkCount; i++){
            if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) return file.upload.chunks[i];
        }
    }
    // This function actually uploads the file(s) to the server.
    //
    //  If dataBlocks contains the actual data to upload (meaning, that this could
    // either be transformed files, or individual chunks for chunked upload) then
    // they will be used for the actual data to upload.
    _uploadData(files, dataBlocks) {
        let xhr = new XMLHttpRequest();
        // Put the xhr object in the file objects to be able to reference it later.
        for (let file of files)file.xhr = xhr;
        if (files[0].upload.chunked) // later, and found with _getChunk.
        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
        let method = this.resolveOption(this.options.method, files, dataBlocks);
        let url = this.resolveOption(this.options.url, files, dataBlocks);
        xhr.open(method, url, true);
        // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8
        let timeout = this.resolveOption(this.options.timeout, files);
        if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files);
        // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179
        xhr.withCredentials = !!this.options.withCredentials;
        xhr.onload = (e)=>{
            this._finishedUploading(files, xhr, e);
        };
        xhr.ontimeout = ()=>{
            this._handleUploadError(files, xhr, `Request timedout after ${this.options.timeout / 1000} seconds`);
        };
        xhr.onerror = ()=>{
            this._handleUploadError(files, xhr);
        };
        // Some browsers do not have the .upload property
        let progressObj = xhr.upload != null ? xhr.upload : xhr;
        progressObj.onprogress = (e)=>this._updateFilesUploadProgress(files, xhr, e);
        let headers = this.options.defaultHeaders ? {
            Accept: "application/json",
            "Cache-Control": "no-cache",
            "X-Requested-With": "XMLHttpRequest"
        } : {};
        if (this.options.binaryBody) headers["Content-Type"] = files[0].type;
        if (this.options.headers) (0, _justExtendDefault.default)(headers, this.options.headers);
        for(let headerName in headers){
            let headerValue = headers[headerName];
            if (headerValue) xhr.setRequestHeader(headerName, headerValue);
        }
        if (this.options.binaryBody) {
            // Since the file is going to be sent as binary body, it doesn't make
            // any sense to generate `FormData` for it.
            for (let file of files)this.emit("sending", file, xhr);
            if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr);
            this.submitRequest(xhr, null, files);
        } else {
            let formData = new FormData();
            // Adding all @options parameters
            if (this.options.params) {
                let additionalParams = this.options.params;
                if (typeof additionalParams === "function") additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
                for(let key in additionalParams){
                    let value = additionalParams[key];
                    if (Array.isArray(value)) // so lets iterate over it to attach each value
                    // individually.
                    for(let i = 0; i < value.length; i++)formData.append(key, value[i]);
                    else formData.append(key, value);
                }
            }
            // Let the user add additional data if necessary
            for (let file of files)this.emit("sending", file, xhr, formData);
            if (this.options.uploadMultiple) this.emit("sendingmultiple", files, xhr, formData);
            this._addFormElementData(formData);
            // Finally add the files
            // Has to be last because some servers (eg: S3) expect the file to be the last parameter
            for(let i = 0; i < dataBlocks.length; i++){
                let dataBlock = dataBlocks[i];
                formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
            }
            this.submitRequest(xhr, formData, files);
        }
    }
    // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
    _transformFiles(files, done) {
        let transformedFiles = [];
        // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.
        let doneCounter = 0;
        for(let i = 0; i < files.length; i++)this.options.transformFile.call(this, files[i], (transformedFile)=>{
            transformedFiles[i] = transformedFile;
            if (++doneCounter === files.length) done(transformedFiles);
        });
    }
    // Takes care of adding other input elements of the form to the AJAX request
    _addFormElementData(formData) {
        // Take care of other input elements
        if (this.element.tagName === "FORM") for (let input of this.element.querySelectorAll("input, textarea, select, button")){
            let inputName = input.getAttribute("name");
            let inputType = input.getAttribute("type");
            if (inputType) inputType = inputType.toLowerCase();
            // If the input doesn't have a name, we can't use it.
            if (typeof inputName === "undefined" || inputName === null) continue;
            if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
                // Possibly multiple values
                for (let option of input.options)if (option.selected) formData.append(inputName, option.value);
            } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) formData.append(inputName, input.value);
        }
    }
    // Invoked when there is new progress information about given files.
    // If e is not provided, it is assumed that the upload is finished.
    _updateFilesUploadProgress(files, xhr, e) {
        if (!files[0].upload.chunked) for (let file of files){
            if (file.upload.total && file.upload.bytesSent && file.upload.bytesSent == file.upload.total) continue;
            if (e) {
                file.upload.progress = 100 * e.loaded / e.total;
                file.upload.total = e.total;
                file.upload.bytesSent = e.loaded;
            } else {
                // No event, so we're at 100%
                file.upload.progress = 100;
                file.upload.bytesSent = file.upload.total;
            }
            this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
        }
        else {
            // Handle chunked file uploads
            // Chunked upload is not compatible with uploading multiple files in one
            // request, so we know there's only one file.
            let file = files[0];
            // Since this is a chunked upload, we need to update the appropriate chunk
            // progress.
            let chunk = this._getChunk(file, xhr);
            if (e) {
                chunk.progress = 100 * e.loaded / e.total;
                chunk.total = e.total;
                chunk.bytesSent = e.loaded;
            } else {
                // No event, so we're at 100%
                chunk.progress = 100;
                chunk.bytesSent = chunk.total;
            }
            // Now tally the *file* upload progress from its individual chunks
            file.upload.progress = 0;
            file.upload.total = 0;
            file.upload.bytesSent = 0;
            for(let i = 0; i < file.upload.totalChunkCount; i++)if (file.upload.chunks[i] && typeof file.upload.chunks[i].progress !== "undefined") {
                file.upload.progress += file.upload.chunks[i].progress;
                file.upload.total += file.upload.chunks[i].total;
                file.upload.bytesSent += file.upload.chunks[i].bytesSent;
            }
            // Since the process is a percentage, we need to divide by the amount of
            // chunks we've used.
            file.upload.progress = file.upload.progress / file.upload.totalChunkCount;
            this.emit("uploadprogress", file, file.upload.progress, file.upload.bytesSent);
        }
    }
    _finishedUploading(files, xhr, e) {
        let response;
        if (files[0].status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED) return;
        if (xhr.readyState !== 4) return;
        if (xhr.responseType !== "arraybuffer" && xhr.responseType !== "blob") {
            response = xhr.responseText;
            if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) try {
                response = JSON.parse(response);
            } catch (error) {
                e = error;
                response = "Invalid JSON response from server.";
            }
        }
        this._updateFilesUploadProgress(files, xhr);
        if (!(200 <= xhr.status && xhr.status < 300)) this._handleUploadError(files, xhr, response);
        else if (files[0].upload.chunked) files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response);
        else this._finished(files, response, e);
    }
    _handleUploadError(files, xhr, response) {
        if (files[0].status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED) return;
        if (files[0].upload.chunked && this.options.retryChunks) {
            let chunk = this._getChunk(files[0], xhr);
            if (chunk.retries++ < this.options.retryChunksLimit) {
                this._uploadData(files, [
                    chunk.dataBlock
                ]);
                return;
            } else console.warn("Retried this chunk too often. Giving up.");
        }
        this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
    }
    submitRequest(xhr, formData, files) {
        if (xhr.readyState != 1) {
            console.warn("Cannot send this request because the XMLHttpRequest.readyState is not OPENED.");
            return;
        }
        if (this.options.binaryBody) {
            if (files[0].upload.chunked) {
                const chunk = this._getChunk(files[0], xhr);
                xhr.send(chunk.dataBlock.data);
            } else xhr.send(files[0]);
        } else xhr.send(formData);
    }
    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.
    _finished(files, responseText, e) {
        for (let file of files){
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
            this.emit("success", file, responseText, e);
            this.emit("complete", file);
        }
        if (this.options.uploadMultiple) {
            this.emit("successmultiple", files, responseText, e);
            this.emit("completemultiple", files);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.
    _errorProcessing(files, message, xhr) {
        for (let file of files){
            file.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR;
            this.emit("error", file, message, xhr);
            this.emit("complete", file);
        }
        if (this.options.uploadMultiple) {
            this.emit("errormultiple", files, message, xhr);
            this.emit("completemultiple", files);
        }
        if (this.options.autoProcessQueue) return this.processQueue();
    }
    static uuidv4() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            let r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
            return v.toString(16);
        });
    }
    constructor(el, options){
        super();
        let fallback, left;
        this.element = el;
        this.clickableElements = [];
        this.listeners = [];
        this.files = []; // All files
        if (typeof this.element === "string") this.element = document.querySelector(this.element);
        // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.
        if (!this.element || this.element.nodeType == null) throw new Error("Invalid dropzone element.");
        if (this.element.dropzone) throw new Error("Dropzone already attached.");
        // Now add this dropzone to the instances.
        $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.push(this);
        // Put the dropzone inside the element itself.
        this.element.dropzone = this;
        let elementOptions = (left = $3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(this.element)) != null ? left : {};
        this.options = (0, _justExtendDefault.default)(true, {}, $4ca367182776f80b$export$2e2bcd8739ae039, elementOptions, options != null ? options : {});
        this.options.previewTemplate = this.options.previewTemplate.replace(/\n*/g, "");
        // If the browser failed, just call the fallback and leave
        if (this.options.forceFallback || !$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported()) return this.options.fallback.call(this);
        // @options.url = @element.getAttribute "action" unless @options.url?
        if (this.options.url == null) this.options.url = this.element.getAttribute("action");
        if (!this.options.url) throw new Error("No URL provided.");
        if (this.options.acceptedFiles && this.options.acceptedMimeTypes) throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
        if (this.options.uploadMultiple && this.options.chunking) throw new Error("You cannot set both: uploadMultiple and chunking.");
        if (this.options.binaryBody && this.options.uploadMultiple) throw new Error("You cannot set both: binaryBody and uploadMultiple.");
        // Backwards compatibility
        if (this.options.acceptedMimeTypes) {
            this.options.acceptedFiles = this.options.acceptedMimeTypes;
            delete this.options.acceptedMimeTypes;
        }
        // Backwards compatibility
        if (this.options.renameFilename != null) this.options.renameFile = (file)=>this.options.renameFilename.call(this, file.name, file);
        if (typeof this.options.method === "string") this.options.method = this.options.method.toUpperCase();
        if ((fallback = this.getExistingFallback()) && fallback.parentNode) fallback.parentNode.removeChild(fallback);
        // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false
        if (this.options.previewsContainer !== false) {
            if (this.options.previewsContainer) this.previewsContainer = $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.previewsContainer, "previewsContainer");
            else this.previewsContainer = this.element;
        }
        if (this.options.clickable) {
            if (this.options.clickable === true) this.clickableElements = [
                this.element
            ];
            else this.clickableElements = $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements(this.options.clickable, "clickable");
        }
        this.init();
    }
}
$3ed269f2f0fb224b$export$2e2bcd8739ae039.initClass();
// This is a map of options for your different dropzones. Add configurations
// to this object for your different dropzone elemens.
//
// Example:
//
//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
//
// And in html:
//
//     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>
$3ed269f2f0fb224b$export$2e2bcd8739ae039.options = {};
// Returns the options for an element or undefined if none available.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement = function(element) {
    // Get the `Dropzone.options.elementId` for this element if it exists
    if (element.getAttribute("id")) return $3ed269f2f0fb224b$export$2e2bcd8739ae039.options[$3ed269f2f0fb224b$var$camelize(element.getAttribute("id"))];
    else return undefined;
};
// Holds a list of all dropzone instances
$3ed269f2f0fb224b$export$2e2bcd8739ae039.instances = [];
// Returns the dropzone for given element if any
$3ed269f2f0fb224b$export$2e2bcd8739ae039.forElement = function(element) {
    if (typeof element === "string") element = document.querySelector(element);
    if ((element != null ? element.dropzone : undefined) == null) throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
    return element.dropzone;
};
// Looks for all .dropzone elements and creates a dropzone for them
$3ed269f2f0fb224b$export$2e2bcd8739ae039.discover = function() {
    let dropzones;
    if (document.querySelectorAll) dropzones = document.querySelectorAll(".dropzone");
    else {
        dropzones = [];
        // IE :(
        let checkElements = (elements)=>(()=>{
                let result = [];
                for (let el of elements)if (/(^| )dropzone($| )/.test(el.className)) result.push(dropzones.push(el));
                else result.push(undefined);
                return result;
            })();
        checkElements(document.getElementsByTagName("div"));
        checkElements(document.getElementsByTagName("form"));
    }
    return (()=>{
        let result = [];
        for (let dropzone of dropzones)if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(dropzone) !== false) result.push(new $3ed269f2f0fb224b$export$2e2bcd8739ae039(dropzone));
        else result.push(undefined);
        return result;
    })();
};
// Some browsers support drag and drog functionality, but not correctly.
//
// So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.
// But what to do when browsers *theoretically* support an API, but crash
// when using it.
//
// This is a list of regular expressions tested against navigator.userAgent
//
// ** It should only be used on browser that *do* support the API, but
// incorrectly **
$3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = [
    // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
    /opera.*(Macintosh|Windows Phone).*version\/12/i
];
// Checks if the browser is supported
$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported = function() {
    let capableBrowser = true;
    if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
        if (!("classList" in document.createElement("a"))) capableBrowser = false;
        else {
            if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers !== undefined) // configuration.
            $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = $3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers;
            // The browser supports the API, but may be blocked.
            for (let regex of $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers)if (regex.test(navigator.userAgent)) {
                capableBrowser = false;
                continue;
            }
        }
    } else capableBrowser = false;
    return capableBrowser;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob = function(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    let byteString = atob(dataURI.split(",")[1]);
    // separate out the mime component
    let mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];
    // write the bytes of the string to an ArrayBuffer
    let ab = new ArrayBuffer(byteString.length);
    let ia = new Uint8Array(ab);
    for(let i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--)ia[i] = byteString.charCodeAt(i);
    // write the ArrayBuffer to a blob
    return new Blob([
        ab
    ], {
        type: mimeString
    });
};
// Returns an array without the rejected item
const $3ed269f2f0fb224b$var$without = (list, rejectedItem)=>list.filter((item)=>item !== rejectedItem).map((item)=>item);
// abc-def_ghi -> abcDefGhi
const $3ed269f2f0fb224b$var$camelize = (str)=>str.replace(/[\-_](\w)/g, (match)=>match.charAt(1).toUpperCase());
// Creates an element from string
$3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement = function(string) {
    let div = document.createElement("div");
    div.innerHTML = string;
    return div.childNodes[0];
};
// Tests if given element is inside (or simply is) the container
$3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside = function(element, container) {
    if (element === container) return true;
    // Coffeescript doesn't support do/while loops
    while(element = element.parentNode){
        if (element === container) return true;
    }
    return false;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement = function(el, name) {
    let element;
    if (typeof el === "string") element = document.querySelector(el);
    else if (el.nodeType != null) element = el;
    if (element == null) throw new Error(`Invalid \`${name}\` option provided. Please provide a CSS selector or a plain HTML element.`);
    return element;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements = function(els, name) {
    let el, elements;
    if (els instanceof Array) {
        elements = [];
        try {
            for (el of els)elements.push(this.getElement(el, name));
        } catch (e) {
            elements = null;
        }
    } else if (typeof els === "string") {
        elements = [];
        for (el of document.querySelectorAll(els))elements.push(el);
    } else if (els.nodeType != null) elements = [
        els
    ];
    if (elements == null || !elements.length) throw new Error(`Invalid \`${name}\` option provided. Please provide a CSS selector, a plain HTML element or a list of those.`);
    return elements;
};
// Asks the user the question and calls accepted or rejected accordingly
//
// The default implementation just uses `window.confirm` and then calls the
// appropriate callback.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm = function(question, accepted, rejected) {
    if (window.confirm(question)) return accepted();
    else if (rejected != null) return rejected();
};
// Validates the mime type like this:
//
// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept
$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile = function(file, acceptedFiles) {
    if (!acceptedFiles) return true;
    // If there are no accepted mime types, it's OK
    acceptedFiles = acceptedFiles.split(",");
    let mimeType = file.type;
    let baseMimeType = mimeType.replace(/\/.*$/, "");
    for (let validType of acceptedFiles){
        validType = validType.trim();
        if (validType.charAt(0) === ".") {
            if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) return true;
        } else if (/\/\*$/.test(validType)) {
            // This is something like a image/* mime type
            if (baseMimeType === validType.replace(/\/.*$/, "")) return true;
        } else {
            if (mimeType === validType) return true;
        }
    }
    return false;
};
// Augment jQuery
if (typeof jQuery !== "undefined" && jQuery !== null) jQuery.fn.dropzone = function(options) {
    return this.each(function() {
        return new $3ed269f2f0fb224b$export$2e2bcd8739ae039(this, options);
    });
};
// Dropzone file status codes
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED = "added";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED = "queued";
// For backwards compatibility. Now, if a file is accepted, it's either queued
// or uploading.
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ACCEPTED = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING = "uploading";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.PROCESSING = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING; // alias
$3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED = "canceled";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR = "error";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS = "success";
/*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */ // Detecting vertical squash in loaded image.
// Fixes a bug which squash image vertically while drawing into canvas for some images.
// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
let $3ed269f2f0fb224b$var$detectVerticalSquash = function(img) {
    let iw = img.naturalWidth;
    let ih = img.naturalHeight;
    let canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = ih;
    let ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);
    let { data: data  } = ctx.getImageData(1, 0, 1, ih);
    // search image edge pixel position in case it is squashed vertically.
    let sy = 0;
    let ey = ih;
    let py = ih;
    while(py > sy){
        let alpha = data[(py - 1) * 4 + 3];
        if (alpha === 0) ey = py;
        else sy = py;
        py = ey + sy >> 1;
    }
    let ratio = py / ih;
    if (ratio === 0) return 1;
    else return ratio;
};
// A replacement for context.drawImage
// (args are for source and destination).
var $3ed269f2f0fb224b$var$drawImageIOSFix = function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
    let vertSquashRatio = $3ed269f2f0fb224b$var$detectVerticalSquash(img);
    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
};
// Based on MinifyJpeg
// Source: http://www.perry.cz/files/ExifRestorer.js
// http://elicon.blog57.fc2.com/blog-entry-206.html
class $3ed269f2f0fb224b$var$ExifRestore {
    static initClass() {
        this.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    }
    static encode64(input) {
        let output = "";
        let chr1 = undefined;
        let chr2 = undefined;
        let chr3 = "";
        let enc1 = undefined;
        let enc2 = undefined;
        let enc3 = undefined;
        let enc4 = "";
        let i = 0;
        while(true){
            chr1 = input[i++];
            chr2 = input[i++];
            chr3 = input[i++];
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) enc3 = enc4 = 64;
            else if (isNaN(chr3)) enc4 = 64;
            output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
            chr1 = chr2 = chr3 = "";
            enc1 = enc2 = enc3 = enc4 = "";
            if (!(i < input.length)) break;
        }
        return output;
    }
    static restore(origFileBase64, resizedFileBase64) {
        if (!origFileBase64.match("data:image/jpeg;base64,")) return resizedFileBase64;
        let rawImage = this.decode64(origFileBase64.replace("data:image/jpeg;base64,", ""));
        let segments = this.slice2Segments(rawImage);
        let image = this.exifManipulation(resizedFileBase64, segments);
        return `data:image/jpeg;base64,${this.encode64(image)}`;
    }
    static exifManipulation(resizedFileBase64, segments) {
        let exifArray = this.getExifArray(segments);
        let newImageArray = this.insertExif(resizedFileBase64, exifArray);
        let aBuffer = new Uint8Array(newImageArray);
        return aBuffer;
    }
    static getExifArray(segments) {
        let seg = undefined;
        let x = 0;
        while(x < segments.length){
            seg = segments[x];
            if (seg[0] === 255 & seg[1] === 225) return seg;
            x++;
        }
        return [];
    }
    static insertExif(resizedFileBase64, exifArray) {
        let imageData = resizedFileBase64.replace("data:image/jpeg;base64,", "");
        let buf = this.decode64(imageData);
        let separatePoint = buf.indexOf(255, 3);
        let mae = buf.slice(0, separatePoint);
        let ato = buf.slice(separatePoint);
        let array = mae;
        array = array.concat(exifArray);
        array = array.concat(ato);
        return array;
    }
    static slice2Segments(rawImageArray) {
        let head = 0;
        let segments = [];
        while(true){
            var length;
            if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) break;
            if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) head += 2;
            else {
                length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
                let endPoint = head + length + 2;
                let seg = rawImageArray.slice(head, endPoint);
                segments.push(seg);
                head = endPoint;
            }
            if (head > rawImageArray.length) break;
        }
        return segments;
    }
    static decode64(input) {
        let output = "";
        let chr1 = undefined;
        let chr2 = undefined;
        let chr3 = "";
        let enc1 = undefined;
        let enc2 = undefined;
        let enc3 = undefined;
        let enc4 = "";
        let i = 0;
        let buf = [];
        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
        let base64test = /[^A-Za-z0-9\+\/\=]/g;
        if (base64test.exec(input)) console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while(true){
            enc1 = this.KEY_STR.indexOf(input.charAt(i++));
            enc2 = this.KEY_STR.indexOf(input.charAt(i++));
            enc3 = this.KEY_STR.indexOf(input.charAt(i++));
            enc4 = this.KEY_STR.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            buf.push(chr1);
            if (enc3 !== 64) buf.push(chr2);
            if (enc4 !== 64) buf.push(chr3);
            chr1 = chr2 = chr3 = "";
            enc1 = enc2 = enc3 = enc4 = "";
            if (!(i < input.length)) break;
        }
        return buf;
    }
}
$3ed269f2f0fb224b$var$ExifRestore.initClass();
/*
 * contentloaded.js
 *
 * Author: Diego Perini (diego.perini at gmail.com)
 * Summary: cross-browser wrapper for DOMContentLoaded
 * Updated: 20101020
 * License: MIT
 * Version: 1.2
 *
 * URL:
 * http://javascript.nwbox.com/ContentLoaded/
 * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
 */ // @win window reference
// @fn function reference
let $3ed269f2f0fb224b$var$contentLoaded = function(win, fn) {
    let done = false;
    let top = true;
    let doc = win.document;
    let root = doc.documentElement;
    let add = doc.addEventListener ? "addEventListener" : "attachEvent";
    let rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
    let pre = doc.addEventListener ? "" : "on";
    var init = function(e) {
        if (e.type === "readystatechange" && doc.readyState !== "complete") return;
        (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
        if (!done && (done = true)) return fn.call(win, e.type || e);
    };
    var poll = function() {
        try {
            root.doScroll("left");
        } catch (e) {
            setTimeout(poll, 50);
            return;
        }
        return init("poll");
    };
    if (doc.readyState !== "complete") {
        if (doc.createEventObject && root.doScroll) {
            try {
                top = !win.frameElement;
            } catch (error) {}
            if (top) poll();
        }
        doc[add](pre + "DOMContentLoaded", init, false);
        doc[add](pre + "readystatechange", init, false);
        return win[add](pre + "load", init, false);
    }
};
function $3ed269f2f0fb224b$var$__guard__(value, transform) {
    return typeof value !== "undefined" && value !== null ? transform(value) : undefined;
}
function $3ed269f2f0fb224b$var$__guardMethod__(obj, methodName, transform) {
    if (typeof obj !== "undefined" && obj !== null && typeof obj[methodName] === "function") return transform(obj, methodName);
    else return undefined;
}

},{"just-extend":"gcxyD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gcxyD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>objectExtend);
var objectExtend = extend;
/*
  var obj = {a: 3, b: 5};
  extend(obj, {a: 4, c: 8}); // {a: 4, b: 5, c: 8}
  obj; // {a: 4, b: 5, c: 8}

  var obj = {a: 3, b: 5};
  extend({}, obj, {a: 4, c: 8}); // {a: 4, b: 5, c: 8}
  obj; // {a: 3, b: 5}

  var arr = [1, 2, 3];
  var obj = {a: 3, b: 5};
  extend(obj, {c: arr}); // {a: 3, b: 5, c: [1, 2, 3]}
  arr.push(4);
  obj; // {a: 3, b: 5, c: [1, 2, 3, 4]}

  var arr = [1, 2, 3];
  var obj = {a: 3, b: 5};
  extend(true, obj, {c: arr}); // {a: 3, b: 5, c: [1, 2, 3]}
  arr.push(4);
  obj; // {a: 3, b: 5, c: [1, 2, 3]}

  extend({a: 4, b: 5}); // {a: 4, b: 5}
  extend({a: 4, b: 5}, 3); {a: 4, b: 5}
  extend({a: 4, b: 5}, true); {a: 4, b: 5}
  extend('hello', {a: 4, b: 5}); // throws
  extend(3, {a: 4, b: 5}); // throws
*/ function extend() {
    var args = [].slice.call(arguments);
    var deep = false;
    if (typeof args[0] == "boolean") deep = args.shift();
    var result = args[0];
    if (isUnextendable(result)) throw new Error("extendee must be an object");
    var extenders = args.slice(1);
    var len = extenders.length;
    for(var i = 0; i < len; i++){
        var extender = extenders[i];
        for(var key in extender)if (Object.prototype.hasOwnProperty.call(extender, key)) {
            var value = extender[key];
            if (deep && isCloneable(value)) {
                var base = Array.isArray(value) ? [] : {};
                result[key] = extend(true, Object.prototype.hasOwnProperty.call(result, key) && !isUnextendable(result[key]) ? result[key] : base, value);
            } else result[key] = value;
        }
    }
    return result;
}
function isCloneable(obj) {
    return Array.isArray(obj) || ({}).toString.call(obj) == "[object Object]";
}
function isUnextendable(val) {
    return !val || typeof val != "object" && typeof val != "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"562rs":[function(require,module,exports) {
/* Mapbox GL JS is Copyright © 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */ (function(global, factory) {
    module.exports = factory();
})(this, function() {
    "use strict";
    /* eslint-disable */ var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) shared = chunk;
        else if (!worker) worker = chunk;
        else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([
                workerBundleString
            ], {
                type: "text/javascript"
            }));
        }
    }
    define([
        "exports"
    ], function(t1) {
        "use strict";
        var e1 = "undefined" != typeof self ? self : {}, r = "2.13.0";
        let n;
        const i = {
            API_URL: "https://api.mapbox.com",
            get API_URL_REGEX () {
                if (null == n) {
                    const t1 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                        n = t1;
                    } catch (e1) {
                        n = t1;
                    }
                }
                return n;
            },
            get API_TILEJSON_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
            },
            get API_SPRITE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
            },
            get API_FONTS_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
            },
            get API_STYLE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
            },
            get API_CDN_URL_REGEX () {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
            },
            get EVENTS_URL () {
                return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
            },
            SESSION_PATH: "/map-sessions/v1",
            FEEDBACK_URL: "https://apps.mapbox.com/feedback",
            TILE_URL_VERSION: "v4",
            RASTER_URL_PREFIX: "raster/v1",
            REQUIRE_ACCESS_TOKEN: !0,
            ACCESS_TOKEN: null,
            MAX_PARALLEL_IMAGE_REQUESTS: 16
        }, s = {
            supported: !1,
            testSupport: function(t1) {
                !l && o && (u ? c(t1) : a = t1);
            }
        };
        let a, o, l = !1, u = !1;
        function c(t1) {
            const e1 = t1.createTexture();
            t1.bindTexture(t1.TEXTURE_2D, e1);
            try {
                if (t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, o), t1.isContextLost()) return;
                s.supported = !0;
            } catch (t1) {}
            t1.deleteTexture(e1), l = !0;
        }
        e1.document && (o = e1.document.createElement("img"), o.onload = function() {
            a && c(a), a = null, u = !0;
        }, o.onerror = function() {
            l = !0, a = null;
        }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const h = "01";
        var p = f;
        function f(t1, e1, r, n) {
            this.cx = 3 * t1, this.bx = 3 * (r - t1) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e1, this.by = 3 * (n - e1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t1, this.p1y = e1, this.p2x = r, this.p2y = n;
        }
        f.prototype = {
            sampleCurveX: function(t1) {
                return ((this.ax * t1 + this.bx) * t1 + this.cx) * t1;
            },
            sampleCurveY: function(t1) {
                return ((this.ay * t1 + this.by) * t1 + this.cy) * t1;
            },
            sampleCurveDerivativeX: function(t1) {
                return (3 * this.ax * t1 + 2 * this.bx) * t1 + this.cx;
            },
            solveCurveX: function(t1, e1) {
                if (void 0 === e1 && (e1 = 1e-6), t1 < 0) return 0;
                if (t1 > 1) return 1;
                for(var r = t1, n = 0; n < 8; n++){
                    var i = this.sampleCurveX(r) - t1;
                    if (Math.abs(i) < e1) return r;
                    var s = this.sampleCurveDerivativeX(r);
                    if (Math.abs(s) < 1e-6) break;
                    r -= i / s;
                }
                var a = 0, o = 1;
                for(r = t1, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t1) < e1)); n++)t1 > i ? a = r : o = r, r = .5 * (o - a) + a;
                return r;
            },
            solve: function(t1, e1) {
                return this.sampleCurveY(this.solveCurveX(t1, e1));
            }
        };
        var d = y;
        function y(t1, e1) {
            this.x = t1, this.y = e1;
        }
        y.prototype = {
            clone: function() {
                return new y(this.x, this.y);
            },
            add: function(t1) {
                return this.clone()._add(t1);
            },
            sub: function(t1) {
                return this.clone()._sub(t1);
            },
            multByPoint: function(t1) {
                return this.clone()._multByPoint(t1);
            },
            divByPoint: function(t1) {
                return this.clone()._divByPoint(t1);
            },
            mult: function(t1) {
                return this.clone()._mult(t1);
            },
            div: function(t1) {
                return this.clone()._div(t1);
            },
            rotate: function(t1) {
                return this.clone()._rotate(t1);
            },
            rotateAround: function(t1, e1) {
                return this.clone()._rotateAround(t1, e1);
            },
            matMult: function(t1) {
                return this.clone()._matMult(t1);
            },
            unit: function() {
                return this.clone()._unit();
            },
            perp: function() {
                return this.clone()._perp();
            },
            round: function() {
                return this.clone()._round();
            },
            mag: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals: function(t1) {
                return this.x === t1.x && this.y === t1.y;
            },
            dist: function(t1) {
                return Math.sqrt(this.distSqr(t1));
            },
            distSqr: function(t1) {
                var e1 = t1.x - this.x, r = t1.y - this.y;
                return e1 * e1 + r * r;
            },
            angle: function() {
                return Math.atan2(this.y, this.x);
            },
            angleTo: function(t1) {
                return Math.atan2(this.y - t1.y, this.x - t1.x);
            },
            angleWith: function(t1) {
                return this.angleWithSep(t1.x, t1.y);
            },
            angleWithSep: function(t1, e1) {
                return Math.atan2(this.x * e1 - this.y * t1, this.x * t1 + this.y * e1);
            },
            _matMult: function(t1) {
                var e1 = t1[2] * this.x + t1[3] * this.y;
                return this.x = t1[0] * this.x + t1[1] * this.y, this.y = e1, this;
            },
            _add: function(t1) {
                return this.x += t1.x, this.y += t1.y, this;
            },
            _sub: function(t1) {
                return this.x -= t1.x, this.y -= t1.y, this;
            },
            _mult: function(t1) {
                return this.x *= t1, this.y *= t1, this;
            },
            _div: function(t1) {
                return this.x /= t1, this.y /= t1, this;
            },
            _multByPoint: function(t1) {
                return this.x *= t1.x, this.y *= t1.y, this;
            },
            _divByPoint: function(t1) {
                return this.x /= t1.x, this.y /= t1.y, this;
            },
            _unit: function() {
                return this._div(this.mag()), this;
            },
            _perp: function() {
                var t1 = this.y;
                return this.y = this.x, this.x = -t1, this;
            },
            _rotate: function(t1) {
                var e1 = Math.cos(t1), r = Math.sin(t1), n = r * this.x + e1 * this.y;
                return this.x = e1 * this.x - r * this.y, this.y = n, this;
            },
            _rotateAround: function(t1, e1) {
                var r = Math.cos(t1), n = Math.sin(t1), i = e1.y + n * (this.x - e1.x) + r * (this.y - e1.y);
                return this.x = e1.x + r * (this.x - e1.x) - n * (this.y - e1.y), this.y = i, this;
            },
            _round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            }
        }, y.convert = function(t1) {
            return t1 instanceof y ? t1 : Array.isArray(t1) ? new y(t1[0], t1[1]) : t1;
        };
        const m = Math.PI / 180, g = 180 / Math.PI;
        function x(t1) {
            return t1 * m;
        }
        function v(t1) {
            return t1 * g;
        }
        const b = [
            [
                0,
                0
            ],
            [
                1,
                0
            ],
            [
                1,
                1
            ],
            [
                0,
                1
            ]
        ];
        function w(t1) {
            if (t1 <= 0) return 0;
            if (t1 >= 1) return 1;
            const e1 = t1 * t1, r = e1 * t1;
            return 4 * (t1 < .5 ? r : 3 * (t1 - e1) + r - .75);
        }
        function _(t1, e1, r, n) {
            const i = new p(t1, e1, r, n);
            return function(t1) {
                return i.solve(t1);
            };
        }
        const A = _(.25, .1, .25, 1);
        function S(t1, e1, r) {
            return Math.min(r, Math.max(e1, t1));
        }
        function k(t1, e1, r) {
            return (r = S((r - t1) / (e1 - t1), 0, 1)) * r * (3 - 2 * r);
        }
        function I(t1, e1, r) {
            const n = r - e1, i = ((t1 - e1) % n + n) % n + e1;
            return i === e1 ? r : i;
        }
        function M(t1, e1, r) {
            if (!t1.length) return r(null, []);
            let n = t1.length;
            const i = new Array(t1.length);
            let s = null;
            t1.forEach((t1, a)=>{
                e1(t1, (t1, e1)=>{
                    t1 && (s = t1), i[a] = e1, 0 == --n && r(s, i);
                });
            });
        }
        function T(t1) {
            const e1 = [];
            for(const r in t1)e1.push(t1[r]);
            return e1;
        }
        function z(t1, ...e1) {
            for (const r of e1)for(const e1 in r)t1[e1] = r[e1];
            return t1;
        }
        let B = 1;
        function E() {
            return B++;
        }
        function C() {
            return function t1(e1) {
                return e1 ? (e1 ^ Math.random() * (16 >> e1 / 4)).toString(16) : ([
                    1e7
                ] + -[
                    1e3
                ] + -4000 + -8000 + -100000000000).replace(/[018]/g, t1);
            }();
        }
        function P(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t1) / Math.LN2));
        }
        function D(t1) {
            return !!t1 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t1);
        }
        function V(t1, e1) {
            t1.forEach((t1)=>{
                e1[t1] && (e1[t1] = e1[t1].bind(e1));
            });
        }
        function L(t1, e1) {
            return -1 !== t1.indexOf(e1, t1.length - e1.length);
        }
        function F(t1, e1, r) {
            const n = {};
            for(const i in t1)n[i] = e1.call(r || this, t1[i], i, t1);
            return n;
        }
        function R(t1, e1, r) {
            const n = {};
            for(const i in t1)e1.call(r || this, t1[i], i, t1) && (n[i] = t1[i]);
            return n;
        }
        function j(t1) {
            return Array.isArray(t1) ? t1.map(j) : "object" == typeof t1 && t1 ? F(t1, j) : t1;
        }
        const U = {};
        function $(t1) {
            U[t1] || ("undefined" != typeof console && console.warn(t1), U[t1] = !0);
        }
        function O(t1, e1, r) {
            return (r.y - t1.y) * (e1.x - t1.x) > (e1.y - t1.y) * (r.x - t1.x);
        }
        function q(t1) {
            let e1 = 0;
            for(let r, n, i = 0, s = t1.length, a = s - 1; i < s; a = i++)r = t1[i], n = t1[a], e1 += (n.x - r.x) * (r.y + n.y);
            return e1;
        }
        function N() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function G(t1) {
            const e1 = {};
            if (t1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t1, r, n, i)=>{
                const s = n || i;
                return e1[r] = !s || s.toLowerCase(), "";
            }), e1["max-age"]) {
                const t1 = parseInt(e1["max-age"], 10);
                isNaN(t1) ? delete e1["max-age"] : e1["max-age"] = t1;
            }
            return e1;
        }
        let X = null;
        function Z(t1) {
            if (null == X) {
                const e1 = t1.navigator ? t1.navigator.userAgent : null;
                X = !!t1.safari || !(!e1 || !(/\b(iPad|iPhone|iPod)\b/.test(e1) || e1.match("Safari") && !e1.match("Chrome")));
            }
            return X;
        }
        function K(t1) {
            try {
                const r = e1[t1];
                return r.setItem("_mapbox_test_", 1), r.removeItem("_mapbox_test_"), !0;
            } catch (t1) {
                return !1;
            }
        }
        function Y(t1, e1) {
            return [
                t1[4 * e1],
                t1[4 * e1 + 1],
                t1[4 * e1 + 2],
                t1[4 * e1 + 3]
            ];
        }
        const H = "mapbox-tiles";
        let W, J, Q = 500, tt = 50;
        function et() {
            try {
                return e1.caches;
            } catch (t1) {}
        }
        function rt() {
            et() && !W && (W = e1.caches.open(H));
        }
        function nt(t1) {
            const e1 = t1.indexOf("?");
            if (e1 < 0) return t1;
            const r = function(t1) {
                const e1 = t1.indexOf("?");
                return e1 > 0 ? t1.slice(e1 + 1).split("&") : [];
            }(t1), n = r.filter((t1)=>{
                const e1 = t1.split("=");
                return "language" === e1[0] || "worldview" === e1[0];
            });
            return n.length ? `${t1.slice(0, e1)}?${n.join("&")}` : t1.slice(0, e1);
        }
        let it = 1 / 0;
        const st = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Image: "Image"
        };
        "function" == typeof Object.freeze && Object.freeze(st);
        class at extends Error {
            constructor(t1, e1, r){
                401 === e1 && gt(r) && (t1 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t1), this.status = e1, this.url = r;
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
        }
        const ot = N() ? ()=>self.worker && self.worker.referrer : ()=>("blob:" === e1.location.protocol ? e1.parent : e1).location.href;
        const lt = function(t1, r) {
            if (!(/^file:/.test(n = t1.url) || /^file:/.test(ot()) && !/^\w+:/.test(n))) {
                if (e1.fetch && e1.Request && e1.AbortController && e1.Request.prototype.hasOwnProperty("signal")) return function(t1, r) {
                    const n = new e1.AbortController, i = new e1.Request(t1.url, {
                        method: t1.method || "GET",
                        body: t1.body,
                        credentials: t1.credentials,
                        headers: t1.headers,
                        referrer: ot(),
                        signal: n.signal
                    });
                    let s = !1, a = !1;
                    const o = (l = i.url).indexOf("sku=") > 0 && gt(l);
                    var l;
                    "json" === t1.type && i.headers.set("Accept", "application/json");
                    const u = (n, s, l)=>{
                        if (a) return;
                        if (n && "SecurityError" !== n.message && $(n), s && l) return c(s);
                        const u = Date.now();
                        e1.fetch(i).then((e1)=>{
                            if (e1.ok) {
                                const t1 = o ? e1.clone() : null;
                                return c(e1, t1, u);
                            }
                            return r(new at(e1.statusText, e1.status, t1.url));
                        }).catch((e1)=>{
                            "AbortError" !== e1.name && r(new Error(`${e1.message} ${t1.url}`));
                        });
                    }, c = (n, o, l)=>{
                        ("arrayBuffer" === t1.type ? n.arrayBuffer() : "json" === t1.type ? n.json() : n.text()).then((t1)=>{
                            a || (o && l && function(t1, r, n) {
                                if (rt(), !W) return;
                                const i = {
                                    status: r.status,
                                    statusText: r.statusText,
                                    headers: new e1.Headers
                                };
                                r.headers.forEach((t1, e1)=>i.headers.set(e1, t1));
                                const s = G(r.headers.get("Cache-Control") || "");
                                if (s["no-store"]) return;
                                s["max-age"] && i.headers.set("Expires", new Date(n + 1e3 * s["max-age"]).toUTCString());
                                const a = i.headers.get("Expires");
                                a && (new Date(a).getTime() - n < 42e4 || function(t1, e1) {
                                    if (void 0 === J) try {
                                        new Response(new ReadableStream), J = !0;
                                    } catch (t1) {
                                        J = !1;
                                    }
                                    J ? e1(t1.body) : t1.blob().then(e1);
                                }(r, (r)=>{
                                    const n = new e1.Response(r, i);
                                    rt(), W && W.then((e1)=>e1.put(nt(t1.url), n)).catch((t1)=>$(t1.message));
                                }));
                            }(i, o, l), s = !0, r(null, t1, n.headers.get("Cache-Control"), n.headers.get("Expires")));
                        }).catch((t1)=>{
                            a || r(new Error(t1.message));
                        });
                    };
                    return o ? function(t1, e1) {
                        if (rt(), !W) return e1(null);
                        const r = nt(t1.url);
                        W.then((t1)=>{
                            t1.match(r).then((n)=>{
                                const i = function(t1) {
                                    if (!t1) return !1;
                                    const e1 = new Date(t1.headers.get("Expires") || 0), r = G(t1.headers.get("Cache-Control") || "");
                                    return e1 > Date.now() && !r["no-cache"];
                                }(n);
                                t1.delete(r), i && t1.put(r, n.clone()), e1(null, n, i);
                            }).catch(e1);
                        }).catch(e1);
                    }(i, u) : u(null, null), {
                        cancel: ()=>{
                            a = !0, s || n.abort();
                        }
                    };
                }(t1, r);
                if (N() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t1, r, void 0, !0);
            }
            var n;
            return function(t1, r) {
                const n = new e1.XMLHttpRequest;
                n.open(t1.method || "GET", t1.url, !0), "arrayBuffer" === t1.type && (n.responseType = "arraybuffer");
                for(const e1 in t1.headers)n.setRequestHeader(e1, t1.headers[e1]);
                return "json" === t1.type && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = "include" === t1.credentials, n.onerror = ()=>{
                    r(new Error(n.statusText));
                }, n.onload = ()=>{
                    if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) {
                        let e1 = n.response;
                        if ("json" === t1.type) try {
                            e1 = JSON.parse(n.response);
                        } catch (t1) {
                            return r(t1);
                        }
                        r(null, e1, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires"));
                    } else r(new at(n.statusText, n.status, t1.url));
                }, n.send(t1.body), {
                    cancel: ()=>n.abort()
                };
            }(t1, r);
        }, ut = function(t1, e1) {
            return lt(z(t1, {
                type: "arrayBuffer"
            }), e1);
        };
        function ct(t1) {
            const r = e1.document.createElement("a");
            return r.href = t1, r.protocol === e1.document.location.protocol && r.host === e1.document.location.host;
        }
        const ht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let pt, ft;
        pt = [], ft = 0;
        const dt = function(t1, r) {
            if (s.supported && (t1.headers || (t1.headers = {}), t1.headers.accept = "image/webp,*/*"), ft >= i.MAX_PARALLEL_IMAGE_REQUESTS) {
                const e1 = {
                    requestParameters: t1,
                    callback: r,
                    cancelled: !1,
                    cancel () {
                        this.cancelled = !0;
                    }
                };
                return pt.push(e1), e1;
            }
            ft++;
            let n = !1;
            const a = ()=>{
                if (!n) for(n = !0, ft--; pt.length && ft < i.MAX_PARALLEL_IMAGE_REQUESTS;){
                    const t1 = pt.shift(), { requestParameters: e1 , callback: r , cancelled: n  } = t1;
                    n || (t1.cancel = dt(e1, r).cancel);
                }
            }, o = ut(t1, (t1, n, i, s)=>{
                a(), t1 ? r(t1) : n && (e1.createImageBitmap ? function(t1, r) {
                    const n = new e1.Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    e1.createImageBitmap(n).then((t1)=>{
                        r(null, t1);
                    }).catch((t1)=>{
                        r(new Error(`Could not load image because of ${t1.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    });
                }(n, (t1, e1)=>r(t1, e1, i, s)) : function(t1, r) {
                    const n = new e1.Image, i = e1.URL;
                    n.onload = ()=>{
                        r(null, n), i.revokeObjectURL(n.src), n.onload = null, e1.requestAnimationFrame(()=>{
                            n.src = ht;
                        });
                    }, n.onerror = ()=>r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const s = new e1.Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    n.src = t1.byteLength ? i.createObjectURL(s) : ht;
                }(n, (t1, e1)=>r(t1, e1, i, s)));
            });
            return {
                cancel: ()=>{
                    o.cancel(), a();
                }
            };
        }, yt = "NO_ACCESS_TOKEN";
        function mt(t1) {
            return 0 === t1.indexOf("mapbox:");
        }
        function gt(t1) {
            return i.API_URL_REGEX.test(t1);
        }
        function xt(t1) {
            return i.API_CDN_URL_REGEX.test(t1);
        }
        function vt(t1) {
            return i.API_STYLE_REGEX.test(t1) && !bt(t1);
        }
        function bt(t1) {
            return i.API_SPRITE_REGEX.test(t1);
        }
        const wt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function _t(t1) {
            const e1 = t1.match(wt);
            if (!e1) throw new Error("Unable to parse URL object");
            return {
                protocol: e1[1],
                authority: e1[2],
                path: e1[3] || "/",
                params: e1[4] ? e1[4].split("&") : []
            };
        }
        function At(t1) {
            const e1 = t1.params.length ? `?${t1.params.join("&")}` : "";
            return `${t1.protocol}://${t1.authority}${t1.path}${e1}`;
        }
        function St(t1) {
            if (!t1) return null;
            const r = t1.split(".");
            if (!r || 3 !== r.length) return null;
            try {
                return JSON.parse(decodeURIComponent(e1.atob(r[1]).split("").map((t1)=>"%" + ("00" + t1.charCodeAt(0).toString(16)).slice(-2)).join("")));
            } catch (t1) {
                return null;
            }
        }
        class kt {
            constructor(t1){
                this.type = t1, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t1) {
                const r = St(i.ACCESS_TOKEN);
                let n = "";
                return n = r && r.u ? e1.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, (t1, e1)=>String.fromCharCode(Number("0x" + e1)))) : i.ACCESS_TOKEN || "", t1 ? `mapbox.eventData.${t1}:${n}` : `mapbox.eventData:${n}`;
            }
            fetchEventData() {
                const t1 = K("localStorage"), r = this.getStorageKey(), n = this.getStorageKey("uuid");
                if (t1) try {
                    const t1 = e1.localStorage.getItem(r);
                    t1 && (this.eventData = JSON.parse(t1));
                    const i = e1.localStorage.getItem(n);
                    i && (this.anonId = i);
                } catch (t1) {
                    $("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
                const t1 = K("localStorage"), r = this.getStorageKey(), n = this.getStorageKey("uuid");
                if (t1) try {
                    e1.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && e1.localStorage.setItem(r, JSON.stringify(this.eventData));
                } catch (t1) {
                    $("Unable to write to LocalStorage");
                }
            }
            processRequests(t1) {}
            postEvent(t1, e1, r, n) {
                if (!i.EVENTS_URL) return;
                const s = _t(i.EVENTS_URL);
                s.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`);
                const a = {
                    event: this.type,
                    created: new Date(t1).toISOString()
                }, o = e1 ? z(a, e1) : a, l = {
                    url: At(s),
                    headers: {
                        "Content-Type": "text/plain"
                    },
                    body: JSON.stringify([
                        o
                    ])
                };
                this.pendingRequest = function(t1, e1) {
                    return lt(z(t1, {
                        method: "POST"
                    }), e1);
                }(l, (t1)=>{
                    this.pendingRequest = null, r(t1), this.saveEventData(), this.processRequests(n);
                });
            }
            queueRequest(t1, e1) {
                this.queue.push(t1), this.processRequests(e1);
            }
        }
        const It = new class extends kt {
            constructor(t1){
                super("appUserTurnstile"), this._customAccessToken = t1;
            }
            postTurnstileEvent(t1, e1) {
                i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t1) && t1.some((t1)=>mt(t1) || gt(t1)) && this.queueRequest(Date.now(), e1);
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                const e1 = St(i.ACCESS_TOKEN), n = e1 ? e1.u : i.ACCESS_TOKEN;
                let s = n !== this.eventData.tokenU;
                D(this.anonId) || (this.anonId = C(), s = !0);
                const a = this.queue.shift();
                if (this.eventData.lastSuccess) {
                    const t1 = new Date(this.eventData.lastSuccess), e1 = new Date(a), r = (a - this.eventData.lastSuccess) / 864e5;
                    s = s || r >= 1 || r < -1 || t1.getDate() !== e1.getDate();
                } else s = !0;
                s ? this.postEvent(a, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: r,
                    skuId: h,
                    "enabled.telemetry": !1,
                    userId: this.anonId
                }, (t1)=>{
                    t1 || (this.eventData.lastSuccess = a, this.eventData.tokenU = n);
                }, t1) : this.processRequests();
            }
        }, Mt = It.postTurnstileEvent.bind(It), Tt = new class extends kt {
            constructor(){
                super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t1, e1, r, n) {
                this.skuToken = e1, this.errorCb = n, i.EVENTS_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, r) : this.errorCb(new Error(yt)));
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: e1 , timestamp: n  } = this.queue.shift();
                e1 && this.success[e1] || (this.anonId || this.fetchEventData(), D(this.anonId) || (this.anonId = C()), this.postEvent(n, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: r,
                    skuId: h,
                    skuToken: this.skuToken,
                    userId: this.anonId
                }, (t1)=>{
                    t1 ? this.errorCb(t1) : e1 && (this.success[e1] = !0);
                }, t1));
            }
        }, zt = Tt.postMapLoadEvent.bind(Tt), Bt = new class extends kt {
            constructor(){
                super("gljs.performance");
            }
            postPerformanceEvent(t1, e1) {
                i.EVENTS_URL && (t1 || i.ACCESS_TOKEN) && this.queueRequest({
                    timestamp: Date.now(),
                    performanceData: e1
                }, t1);
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: n , performanceData: i  } = this.queue.shift(), s = function(t1) {
                    const n = e1.performance.getEntriesByType("resource"), i = e1.performance.getEntriesByType("mark"), s = function(t1) {
                        const e1 = {};
                        if (t1) {
                            for(const r in t1)if ("other" !== r) for (const n of t1[r]){
                                const t1 = `${r}ResolveRangeMin`, i = `${r}ResolveRangeMax`, s = `${r}RequestCount`, a = `${r}RequestCachedCount`;
                                e1[t1] = Math.min(e1[t1] || 1 / 0, n.startTime), e1[i] = Math.max(e1[i] || -1 / 0, n.responseEnd);
                                const o = (t1)=>{
                                    void 0 === e1[t1] && (e1[t1] = 0), ++e1[t1];
                                };
                                void 0 !== n.transferSize && 0 === n.transferSize && o(a), o(s);
                            }
                        }
                        return e1;
                    }(function(t1, e1) {
                        const r = {};
                        if (t1) for (const n of t1){
                            const t1 = e1(n);
                            void 0 === r[t1] && (r[t1] = []), r[t1].push(n);
                        }
                        return r;
                    }(n, Ft)), a = e1.devicePixelRatio, o = e1.navigator.connection || e1.navigator.mozConnection || e1.navigator.webkitConnection, l = {
                        counters: [],
                        metadata: [],
                        attributes: []
                    }, u = (t1, e1, r)=>{
                        null != r && t1.push({
                            name: e1,
                            value: r.toString()
                        });
                    };
                    for(const t1 in s)u(l.counters, t1, s[t1]);
                    if (t1.interactionRange[0] !== 1 / 0 && t1.interactionRange[1] !== -1 / 0 && (u(l.counters, "interactionRangeMin", t1.interactionRange[0]), u(l.counters, "interactionRangeMax", t1.interactionRange[1])), i) for (const t1 of Object.keys(Vt)){
                        const e1 = Vt[t1], r = i.find((t1)=>t1.name === e1);
                        r && u(l.counters, e1, r.startTime);
                    }
                    return u(l.counters, "visibilityHidden", t1.visibilityHidden), u(l.attributes, "style", function(t1) {
                        if (t1) for (const e1 of t1){
                            const t1 = e1.name.split("?")[0];
                            if (vt(t1)) {
                                const e1 = t1.split("/").slice(-2);
                                if (2 === e1.length) return `mapbox://styles/${e1[0]}/${e1[1]}`;
                            }
                        }
                    }(n)), u(l.attributes, "terrainEnabled", t1.terrainEnabled ? "true" : "false"), u(l.attributes, "fogEnabled", t1.fogEnabled ? "true" : "false"), u(l.attributes, "projection", t1.projection), u(l.attributes, "zoom", t1.zoom), u(l.metadata, "devicePixelRatio", a), u(l.metadata, "connectionEffectiveType", o ? o.effectiveType : void 0), u(l.metadata, "navigatorUserAgent", e1.navigator.userAgent), u(l.metadata, "screenWidth", e1.screen.width), u(l.metadata, "screenHeight", e1.screen.height), u(l.metadata, "windowWidth", e1.innerWidth), u(l.metadata, "windowHeight", e1.innerHeight), u(l.metadata, "mapWidth", t1.width / a), u(l.metadata, "mapHeight", t1.height / a), u(l.metadata, "webglRenderer", t1.renderer), u(l.metadata, "webglVendor", t1.vendor), u(l.metadata, "sdkVersion", r), u(l.metadata, "sdkIdentifier", "mapbox-gl-js"), l;
                }(i);
                for (const t1 of s.metadata);
                for (const t1 of s.counters);
                for (const t1 of s.attributes);
                this.postEvent(n, s, ()=>{}, t1);
            }
        }, Et = Bt.postPerformanceEvent.bind(Bt), Ct = new class extends kt {
            constructor(){
                super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t1, e1, r, n) {
                if (!i.API_URL || !i.SESSION_PATH) return;
                const s = _t(i.API_URL + i.SESSION_PATH);
                s.params.push(`sku=${e1 || ""}`), s.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`);
                const a = {
                    url: At(s),
                    headers: {
                        "Content-Type": "text/plain"
                    }
                };
                this.pendingRequest = function(t1, e1) {
                    return lt(z(t1, {
                        method: "GET"
                    }), e1);
                }(a, (t1)=>{
                    this.pendingRequest = null, r(t1), this.saveEventData(), this.processRequests(n);
                });
            }
            getSessionAPI(t1, e1, r, n) {
                this.skuToken = e1, this.errorCb = n, i.SESSION_PATH && i.API_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, r) : this.errorCb(new Error(yt)));
            }
            processRequests(t1) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: e1 , timestamp: r  } = this.queue.shift();
                e1 && this.success[e1] || this.getSession(r, this.skuToken, (t1)=>{
                    t1 ? this.errorCb(t1) : e1 && (this.success[e1] = !0);
                }, t1);
            }
        }, Pt = Ct.getSessionAPI.bind(Ct), Dt = new Set, Vt = {
            create: "create",
            load: "load",
            fullLoad: "fullLoad"
        }, Lt = {
            mark (t1) {
                e1.performance.mark(t1);
            },
            measure (t1, r, n) {
                e1.performance.measure(t1, r, n);
            }
        };
        function Ft(t1) {
            const e1 = t1.name.split("?")[0];
            return xt(e1) && e1.includes("mapbox-gl.js") ? "javascript" : xt(e1) && e1.includes("mapbox-gl.css") ? "css" : function(t1) {
                return i.API_FONTS_REGEX.test(t1);
            }(e1) ? "fontRange" : bt(e1) ? "sprite" : vt(e1) ? "style" : function(t1) {
                return i.API_TILEJSON_REGEX.test(t1);
            }(e1) ? "tilejson" : "other";
        }
        const Rt = e1.performance;
        function jt(t1) {
            const e1 = t1 ? t1.url.toString() : void 0;
            return Rt.getEntriesByName(e1);
        }
        let Ut, $t, Ot, qt;
        const Nt = {
            now: ()=>void 0 !== Ot ? Ot : e1.performance.now(),
            setNow (t1) {
                Ot = t1;
            },
            restoreNow () {
                Ot = void 0;
            },
            frame (t1) {
                const r = e1.requestAnimationFrame(t1);
                return {
                    cancel: ()=>e1.cancelAnimationFrame(r)
                };
            },
            getImageData (t1, r = 0) {
                const { width: n , height: i  } = t1;
                qt || (qt = e1.document.createElement("canvas"));
                const s = qt.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!s) throw new Error("failed to create canvas 2d context");
                return (n > qt.width || i > qt.height) && (qt.width = n, qt.height = i), s.clearRect(-r, -r, n + 2 * r, i + 2 * r), s.drawImage(t1, 0, 0, n, i), s.getImageData(-r, -r, n + 2 * r, i + 2 * r);
            },
            resolveURL: (t1)=>(Ut || (Ut = e1.document.createElement("a")), Ut.href = t1, Ut.href),
            get devicePixelRatio () {
                return e1.devicePixelRatio;
            },
            get prefersReducedMotion () {
                return !!e1.matchMedia && (null == $t && ($t = e1.matchMedia("(prefers-reduced-motion: reduce)")), $t.matches);
            }
        };
        function Gt(t1, e1, r) {
            r[t1] && -1 !== r[t1].indexOf(e1) || (r[t1] = r[t1] || [], r[t1].push(e1));
        }
        function Xt(t1, e1, r) {
            if (r && r[t1]) {
                const n = r[t1].indexOf(e1);
                -1 !== n && r[t1].splice(n, 1);
            }
        }
        class Zt {
            constructor(t1, e1 = {}){
                z(this, e1), this.type = t1;
            }
        }
        class Kt extends Zt {
            constructor(t1, e1 = {}){
                super("error", z({
                    error: t1
                }, e1));
            }
        }
        class Yt {
            on(t1, e1) {
                return this._listeners = this._listeners || {}, Gt(t1, e1, this._listeners), this;
            }
            off(t1, e1) {
                return Xt(t1, e1, this._listeners), Xt(t1, e1, this._oneTimeListeners), this;
            }
            once(t1, e1) {
                return e1 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Gt(t1, e1, this._oneTimeListeners), this) : new Promise((e1)=>this.once(t1, e1));
            }
            fire(t1, e1) {
                "string" == typeof t1 && (t1 = new Zt(t1, e1 || {}));
                const r = t1.type;
                if (this.listens(r)) {
                    t1.target = this;
                    const e1 = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];
                    for (const r of e1)r.call(this, t1);
                    const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];
                    for (const e1 of n)Xt(r, e1, this._oneTimeListeners), e1.call(this, t1);
                    const i = this._eventedParent;
                    i && (z(t1, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t1));
                } else t1 instanceof Kt && console.error(t1.error);
                return this;
            }
            listens(t1) {
                return !!(this._listeners && this._listeners[t1] && this._listeners[t1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t1] && this._oneTimeListeners[t1].length > 0 || this._eventedParent && this._eventedParent.listens(t1));
            }
            setEventedParent(t1, e1) {
                return this._eventedParent = t1, this._eventedParentData = e1, this;
            }
        }
        var Ht = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function Wt(t1, ...e1) {
            for (const r of e1)for(const e1 in r)t1[e1] = r[e1];
            return t1;
        }
        function Jt(t1) {
            return t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean ? t1.valueOf() : t1;
        }
        function Qt(t1) {
            if (Array.isArray(t1)) return t1.map(Qt);
            if (t1 instanceof Object && !(t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean)) {
                const e1 = {};
                for(const r in t1)e1[r] = Qt(t1[r]);
                return e1;
            }
            return Jt(t1);
        }
        class te extends Error {
            constructor(t1, e1){
                super(e1), this.message = e1, this.key = t1;
            }
        }
        var ee = te;
        class re {
            constructor(t1, e1 = []){
                this.parent = t1, this.bindings = {};
                for (const [t1, r] of e1)this.bindings[t1] = r;
            }
            concat(t1) {
                return new re(this, t1);
            }
            get(t1) {
                if (this.bindings[t1]) return this.bindings[t1];
                if (this.parent) return this.parent.get(t1);
                throw new Error(`${t1} not found in scope.`);
            }
            has(t1) {
                return !!this.bindings[t1] || !!this.parent && this.parent.has(t1);
            }
        }
        var ne = re;
        const ie = {
            kind: "null"
        }, se = {
            kind: "number"
        }, ae = {
            kind: "string"
        }, oe = {
            kind: "boolean"
        }, le = {
            kind: "color"
        }, ue = {
            kind: "object"
        }, ce = {
            kind: "value"
        }, he = {
            kind: "collator"
        }, pe = {
            kind: "formatted"
        }, fe = {
            kind: "resolvedImage"
        };
        function de(t1, e1) {
            return {
                kind: "array",
                itemType: t1,
                N: e1
            };
        }
        function ye(t1) {
            if ("array" === t1.kind) {
                const e1 = ye(t1.itemType);
                return "number" == typeof t1.N ? `array<${e1}, ${t1.N}>` : "value" === t1.itemType.kind ? "array" : `array<${e1}>`;
            }
            return t1.kind;
        }
        const me = [
            ie,
            se,
            ae,
            oe,
            le,
            pe,
            ue,
            de(ce),
            fe
        ];
        function ge(t1, e1) {
            if ("error" === e1.kind) return null;
            if ("array" === t1.kind) {
                if ("array" === e1.kind && (0 === e1.N && "value" === e1.itemType.kind || !ge(t1.itemType, e1.itemType)) && ("number" != typeof t1.N || t1.N === e1.N)) return null;
            } else {
                if (t1.kind === e1.kind) return null;
                if ("value" === t1.kind) {
                    for (const t1 of me)if (!ge(t1, e1)) return null;
                }
            }
            return `Expected ${ye(t1)} but found ${ye(e1)} instead.`;
        }
        function xe(t1, e1) {
            return e1.some((e1)=>e1.kind === t1.kind);
        }
        function ve(t1, e1) {
            return e1.some((e1)=>"null" === e1 ? null === t1 : "array" === e1 ? Array.isArray(t1) : "object" === e1 ? t1 && !Array.isArray(t1) && "object" == typeof t1 : e1 === typeof t1);
        }
        var be, we = {
            transparent: [
                0,
                0,
                0,
                0
            ],
            aliceblue: [
                240,
                248,
                255,
                1
            ],
            antiquewhite: [
                250,
                235,
                215,
                1
            ],
            aqua: [
                0,
                255,
                255,
                1
            ],
            aquamarine: [
                127,
                255,
                212,
                1
            ],
            azure: [
                240,
                255,
                255,
                1
            ],
            beige: [
                245,
                245,
                220,
                1
            ],
            bisque: [
                255,
                228,
                196,
                1
            ],
            black: [
                0,
                0,
                0,
                1
            ],
            blanchedalmond: [
                255,
                235,
                205,
                1
            ],
            blue: [
                0,
                0,
                255,
                1
            ],
            blueviolet: [
                138,
                43,
                226,
                1
            ],
            brown: [
                165,
                42,
                42,
                1
            ],
            burlywood: [
                222,
                184,
                135,
                1
            ],
            cadetblue: [
                95,
                158,
                160,
                1
            ],
            chartreuse: [
                127,
                255,
                0,
                1
            ],
            chocolate: [
                210,
                105,
                30,
                1
            ],
            coral: [
                255,
                127,
                80,
                1
            ],
            cornflowerblue: [
                100,
                149,
                237,
                1
            ],
            cornsilk: [
                255,
                248,
                220,
                1
            ],
            crimson: [
                220,
                20,
                60,
                1
            ],
            cyan: [
                0,
                255,
                255,
                1
            ],
            darkblue: [
                0,
                0,
                139,
                1
            ],
            darkcyan: [
                0,
                139,
                139,
                1
            ],
            darkgoldenrod: [
                184,
                134,
                11,
                1
            ],
            darkgray: [
                169,
                169,
                169,
                1
            ],
            darkgreen: [
                0,
                100,
                0,
                1
            ],
            darkgrey: [
                169,
                169,
                169,
                1
            ],
            darkkhaki: [
                189,
                183,
                107,
                1
            ],
            darkmagenta: [
                139,
                0,
                139,
                1
            ],
            darkolivegreen: [
                85,
                107,
                47,
                1
            ],
            darkorange: [
                255,
                140,
                0,
                1
            ],
            darkorchid: [
                153,
                50,
                204,
                1
            ],
            darkred: [
                139,
                0,
                0,
                1
            ],
            darksalmon: [
                233,
                150,
                122,
                1
            ],
            darkseagreen: [
                143,
                188,
                143,
                1
            ],
            darkslateblue: [
                72,
                61,
                139,
                1
            ],
            darkslategray: [
                47,
                79,
                79,
                1
            ],
            darkslategrey: [
                47,
                79,
                79,
                1
            ],
            darkturquoise: [
                0,
                206,
                209,
                1
            ],
            darkviolet: [
                148,
                0,
                211,
                1
            ],
            deeppink: [
                255,
                20,
                147,
                1
            ],
            deepskyblue: [
                0,
                191,
                255,
                1
            ],
            dimgray: [
                105,
                105,
                105,
                1
            ],
            dimgrey: [
                105,
                105,
                105,
                1
            ],
            dodgerblue: [
                30,
                144,
                255,
                1
            ],
            firebrick: [
                178,
                34,
                34,
                1
            ],
            floralwhite: [
                255,
                250,
                240,
                1
            ],
            forestgreen: [
                34,
                139,
                34,
                1
            ],
            fuchsia: [
                255,
                0,
                255,
                1
            ],
            gainsboro: [
                220,
                220,
                220,
                1
            ],
            ghostwhite: [
                248,
                248,
                255,
                1
            ],
            gold: [
                255,
                215,
                0,
                1
            ],
            goldenrod: [
                218,
                165,
                32,
                1
            ],
            gray: [
                128,
                128,
                128,
                1
            ],
            green: [
                0,
                128,
                0,
                1
            ],
            greenyellow: [
                173,
                255,
                47,
                1
            ],
            grey: [
                128,
                128,
                128,
                1
            ],
            honeydew: [
                240,
                255,
                240,
                1
            ],
            hotpink: [
                255,
                105,
                180,
                1
            ],
            indianred: [
                205,
                92,
                92,
                1
            ],
            indigo: [
                75,
                0,
                130,
                1
            ],
            ivory: [
                255,
                255,
                240,
                1
            ],
            khaki: [
                240,
                230,
                140,
                1
            ],
            lavender: [
                230,
                230,
                250,
                1
            ],
            lavenderblush: [
                255,
                240,
                245,
                1
            ],
            lawngreen: [
                124,
                252,
                0,
                1
            ],
            lemonchiffon: [
                255,
                250,
                205,
                1
            ],
            lightblue: [
                173,
                216,
                230,
                1
            ],
            lightcoral: [
                240,
                128,
                128,
                1
            ],
            lightcyan: [
                224,
                255,
                255,
                1
            ],
            lightgoldenrodyellow: [
                250,
                250,
                210,
                1
            ],
            lightgray: [
                211,
                211,
                211,
                1
            ],
            lightgreen: [
                144,
                238,
                144,
                1
            ],
            lightgrey: [
                211,
                211,
                211,
                1
            ],
            lightpink: [
                255,
                182,
                193,
                1
            ],
            lightsalmon: [
                255,
                160,
                122,
                1
            ],
            lightseagreen: [
                32,
                178,
                170,
                1
            ],
            lightskyblue: [
                135,
                206,
                250,
                1
            ],
            lightslategray: [
                119,
                136,
                153,
                1
            ],
            lightslategrey: [
                119,
                136,
                153,
                1
            ],
            lightsteelblue: [
                176,
                196,
                222,
                1
            ],
            lightyellow: [
                255,
                255,
                224,
                1
            ],
            lime: [
                0,
                255,
                0,
                1
            ],
            limegreen: [
                50,
                205,
                50,
                1
            ],
            linen: [
                250,
                240,
                230,
                1
            ],
            magenta: [
                255,
                0,
                255,
                1
            ],
            maroon: [
                128,
                0,
                0,
                1
            ],
            mediumaquamarine: [
                102,
                205,
                170,
                1
            ],
            mediumblue: [
                0,
                0,
                205,
                1
            ],
            mediumorchid: [
                186,
                85,
                211,
                1
            ],
            mediumpurple: [
                147,
                112,
                219,
                1
            ],
            mediumseagreen: [
                60,
                179,
                113,
                1
            ],
            mediumslateblue: [
                123,
                104,
                238,
                1
            ],
            mediumspringgreen: [
                0,
                250,
                154,
                1
            ],
            mediumturquoise: [
                72,
                209,
                204,
                1
            ],
            mediumvioletred: [
                199,
                21,
                133,
                1
            ],
            midnightblue: [
                25,
                25,
                112,
                1
            ],
            mintcream: [
                245,
                255,
                250,
                1
            ],
            mistyrose: [
                255,
                228,
                225,
                1
            ],
            moccasin: [
                255,
                228,
                181,
                1
            ],
            navajowhite: [
                255,
                222,
                173,
                1
            ],
            navy: [
                0,
                0,
                128,
                1
            ],
            oldlace: [
                253,
                245,
                230,
                1
            ],
            olive: [
                128,
                128,
                0,
                1
            ],
            olivedrab: [
                107,
                142,
                35,
                1
            ],
            orange: [
                255,
                165,
                0,
                1
            ],
            orangered: [
                255,
                69,
                0,
                1
            ],
            orchid: [
                218,
                112,
                214,
                1
            ],
            palegoldenrod: [
                238,
                232,
                170,
                1
            ],
            palegreen: [
                152,
                251,
                152,
                1
            ],
            paleturquoise: [
                175,
                238,
                238,
                1
            ],
            palevioletred: [
                219,
                112,
                147,
                1
            ],
            papayawhip: [
                255,
                239,
                213,
                1
            ],
            peachpuff: [
                255,
                218,
                185,
                1
            ],
            peru: [
                205,
                133,
                63,
                1
            ],
            pink: [
                255,
                192,
                203,
                1
            ],
            plum: [
                221,
                160,
                221,
                1
            ],
            powderblue: [
                176,
                224,
                230,
                1
            ],
            purple: [
                128,
                0,
                128,
                1
            ],
            rebeccapurple: [
                102,
                51,
                153,
                1
            ],
            red: [
                255,
                0,
                0,
                1
            ],
            rosybrown: [
                188,
                143,
                143,
                1
            ],
            royalblue: [
                65,
                105,
                225,
                1
            ],
            saddlebrown: [
                139,
                69,
                19,
                1
            ],
            salmon: [
                250,
                128,
                114,
                1
            ],
            sandybrown: [
                244,
                164,
                96,
                1
            ],
            seagreen: [
                46,
                139,
                87,
                1
            ],
            seashell: [
                255,
                245,
                238,
                1
            ],
            sienna: [
                160,
                82,
                45,
                1
            ],
            silver: [
                192,
                192,
                192,
                1
            ],
            skyblue: [
                135,
                206,
                235,
                1
            ],
            slateblue: [
                106,
                90,
                205,
                1
            ],
            slategray: [
                112,
                128,
                144,
                1
            ],
            slategrey: [
                112,
                128,
                144,
                1
            ],
            snow: [
                255,
                250,
                250,
                1
            ],
            springgreen: [
                0,
                255,
                127,
                1
            ],
            steelblue: [
                70,
                130,
                180,
                1
            ],
            tan: [
                210,
                180,
                140,
                1
            ],
            teal: [
                0,
                128,
                128,
                1
            ],
            thistle: [
                216,
                191,
                216,
                1
            ],
            tomato: [
                255,
                99,
                71,
                1
            ],
            turquoise: [
                64,
                224,
                208,
                1
            ],
            violet: [
                238,
                130,
                238,
                1
            ],
            wheat: [
                245,
                222,
                179,
                1
            ],
            white: [
                255,
                255,
                255,
                1
            ],
            whitesmoke: [
                245,
                245,
                245,
                1
            ],
            yellow: [
                255,
                255,
                0,
                1
            ],
            yellowgreen: [
                154,
                205,
                50,
                1
            ]
        };
        function _e(t1) {
            return (t1 = Math.round(t1)) < 0 ? 0 : t1 > 255 ? 255 : t1;
        }
        function Ae(t1) {
            return _e("%" === t1[t1.length - 1] ? parseFloat(t1) / 100 * 255 : parseInt(t1));
        }
        function Se(t1) {
            var e1;
            return (e1 = "%" === t1[t1.length - 1] ? parseFloat(t1) / 100 : parseFloat(t1)) < 0 ? 0 : e1 > 1 ? 1 : e1;
        }
        function ke(t1, e1, r) {
            return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t1 + (e1 - t1) * r * 6 : 2 * r < 1 ? e1 : 3 * r < 2 ? t1 + (e1 - t1) * (2 / 3 - r) * 6 : t1;
        }
        try {
            be = ({}).parseCSSColor = function(t1) {
                var e1, r = t1.replace(/ /g, "").toLowerCase();
                if (r in we) return we[r].slice();
                if ("#" === r[0]) return 4 === r.length ? (e1 = parseInt(r.substr(1), 16)) >= 0 && e1 <= 4095 ? [
                    (3840 & e1) >> 4 | (3840 & e1) >> 8,
                    240 & e1 | (240 & e1) >> 4,
                    15 & e1 | (15 & e1) << 4,
                    1
                ] : null : 7 === r.length && (e1 = parseInt(r.substr(1), 16)) >= 0 && e1 <= 16777215 ? [
                    (16711680 & e1) >> 16,
                    (65280 & e1) >> 8,
                    255 & e1,
                    1
                ] : null;
                var n = r.indexOf("("), i = r.indexOf(")");
                if (-1 !== n && i + 1 === r.length) {
                    var s = r.substr(0, n), a = r.substr(n + 1, i - (n + 1)).split(","), o = 1;
                    switch(s){
                        case "rgba":
                            if (4 !== a.length) return null;
                            o = Se(a.pop());
                        case "rgb":
                            return 3 !== a.length ? null : [
                                Ae(a[0]),
                                Ae(a[1]),
                                Ae(a[2]),
                                o
                            ];
                        case "hsla":
                            if (4 !== a.length) return null;
                            o = Se(a.pop());
                        case "hsl":
                            if (3 !== a.length) return null;
                            var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360, u = Se(a[1]), c = Se(a[2]), h = c <= .5 ? c * (u + 1) : c + u - c * u, p = 2 * c - h;
                            return [
                                _e(255 * ke(p, h, l + 1 / 3)),
                                _e(255 * ke(p, h, l)),
                                _e(255 * ke(p, h, l - 1 / 3)),
                                o
                            ];
                        default:
                            return null;
                    }
                }
                return null;
            };
        } catch (t1) {}
        class Ie {
            constructor(t1, e1, r, n = 1){
                this.r = t1, this.g = e1, this.b = r, this.a = n;
            }
            static parse(t1) {
                if (!t1) return;
                if (t1 instanceof Ie) return t1;
                if ("string" != typeof t1) return;
                const e1 = be(t1);
                return e1 ? new Ie(e1[0] / 255 * e1[3], e1[1] / 255 * e1[3], e1[2] / 255 * e1[3], e1[3]) : void 0;
            }
            toString() {
                const [t1, e1, r, n] = this.toArray();
                return `rgba(${Math.round(t1)},${Math.round(e1)},${Math.round(r)},${n})`;
            }
            toArray() {
                const { r: t1 , g: e1 , b: r , a: n  } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    255 * t1 / n,
                    255 * e1 / n,
                    255 * r / n,
                    n
                ];
            }
            toArray01() {
                const { r: t1 , g: e1 , b: r , a: n  } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    t1 / n,
                    e1 / n,
                    r / n,
                    n
                ];
            }
            toArray01PremultipliedAlpha() {
                const { r: t1 , g: e1 , b: r , a: n  } = this;
                return [
                    t1,
                    e1,
                    r,
                    n
                ];
            }
        }
        Ie.black = new Ie(0, 0, 0, 1), Ie.white = new Ie(1, 1, 1, 1), Ie.transparent = new Ie(0, 0, 0, 0), Ie.red = new Ie(1, 0, 0, 1), Ie.blue = new Ie(0, 0, 1, 1);
        var Me = Ie;
        class Te {
            constructor(t1, e1, r){
                this.sensitivity = t1 ? e1 ? "variant" : "case" : e1 ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t1, e1) {
                return this.collator.compare(t1, e1);
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }
        class ze {
            constructor(t1, e1, r, n, i){
                this.text = t1.normalize ? t1.normalize() : t1, this.image = e1, this.scale = r, this.fontStack = n, this.textColor = i;
            }
        }
        class Be {
            constructor(t1){
                this.sections = t1;
            }
            static fromString(t1) {
                return new Be([
                    new ze(t1, null, null, null, null)
                ]);
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t1)=>0 !== t1.text.length || t1.image && 0 !== t1.image.name.length);
            }
            static factory(t1) {
                return t1 instanceof Be ? t1 : Be.fromString(t1);
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t1)=>t1.text).join("");
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e1 of this.sections){
                    if (e1.image) {
                        t1.push([
                            "image",
                            e1.image.name
                        ]);
                        continue;
                    }
                    t1.push(e1.text);
                    const r = {};
                    e1.fontStack && (r["text-font"] = [
                        "literal",
                        e1.fontStack.split(",")
                    ]), e1.scale && (r["font-scale"] = e1.scale), e1.textColor && (r["text-color"] = [
                        "rgba"
                    ].concat(e1.textColor.toArray())), t1.push(r);
                }
                return t1;
            }
        }
        class Ee {
            constructor(t1){
                this.name = t1.name, this.available = t1.available;
            }
            toString() {
                return this.name;
            }
            static fromString(t1) {
                return t1 ? new Ee({
                    name: t1,
                    available: !1
                }) : null;
            }
            serialize() {
                return [
                    "image",
                    this.name
                ];
            }
        }
        function Ce(t1, e1, r, n) {
            return "number" == typeof t1 && t1 >= 0 && t1 <= 255 && "number" == typeof e1 && e1 >= 0 && e1 <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
                t1,
                e1,
                r,
                n
            ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [
                t1,
                e1,
                r,
                n
            ] : [
                t1,
                e1,
                r
            ]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Pe(t1) {
            if (null === t1) return !0;
            if ("string" == typeof t1) return !0;
            if ("boolean" == typeof t1) return !0;
            if ("number" == typeof t1) return !0;
            if (t1 instanceof Me) return !0;
            if (t1 instanceof Te) return !0;
            if (t1 instanceof Be) return !0;
            if (t1 instanceof Ee) return !0;
            if (Array.isArray(t1)) {
                for (const e1 of t1)if (!Pe(e1)) return !1;
                return !0;
            }
            if ("object" == typeof t1) {
                for(const e1 in t1)if (!Pe(t1[e1])) return !1;
                return !0;
            }
            return !1;
        }
        function De(t1) {
            if (null === t1) return ie;
            if ("string" == typeof t1) return ae;
            if ("boolean" == typeof t1) return oe;
            if ("number" == typeof t1) return se;
            if (t1 instanceof Me) return le;
            if (t1 instanceof Te) return he;
            if (t1 instanceof Be) return pe;
            if (t1 instanceof Ee) return fe;
            if (Array.isArray(t1)) {
                const e1 = t1.length;
                let r;
                for (const e1 of t1){
                    const t1 = De(e1);
                    if (r) {
                        if (r === t1) continue;
                        r = ce;
                        break;
                    }
                    r = t1;
                }
                return de(r || ce, e1);
            }
            return ue;
        }
        function Ve(t1) {
            const e1 = typeof t1;
            return null === t1 ? "" : "string" === e1 || "number" === e1 || "boolean" === e1 ? String(t1) : t1 instanceof Me || t1 instanceof Be || t1 instanceof Ee ? t1.toString() : JSON.stringify(t1);
        }
        class Le {
            constructor(t1, e1){
                this.type = t1, this.value = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`'literal' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (!Pe(t1[1])) return e1.error("invalid value");
                const r = t1[1];
                let n = De(r);
                const i = e1.expectedType;
                return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new Le(n, r);
            }
            evaluate() {
                return this.value;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? [
                    "literal",
                    this.value
                ] : this.value instanceof Me ? [
                    "rgba"
                ].concat(this.value.toArray()) : this.value instanceof Be ? this.value.serialize() : this.value;
            }
        }
        var Fe = Le, Re = class {
            constructor(t1){
                this.name = "ExpressionEvaluationError", this.message = t1;
            }
            toJSON() {
                return this.message;
            }
        };
        const je = {
            string: ae,
            number: se,
            boolean: oe,
            object: ue
        };
        class Ue {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                let r, n = 1;
                const i = t1[0];
                if ("array" === i) {
                    let i, s;
                    if (t1.length > 2) {
                        const r = t1[1];
                        if ("string" != typeof r || !(r in je) || "object" === r) return e1.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i = je[r], n++;
                    } else i = ce;
                    if (t1.length > 3) {
                        if (null !== t1[2] && ("number" != typeof t1[2] || t1[2] < 0 || t1[2] !== Math.floor(t1[2]))) return e1.error('The length argument to "array" must be a positive integer literal', 2);
                        s = t1[2], n++;
                    }
                    r = de(i, s);
                } else r = je[i];
                const s = [];
                for(; n < t1.length; n++){
                    const r = e1.parse(t1[n], n, ce);
                    if (!r) return null;
                    s.push(r);
                }
                return new Ue(r, s);
            }
            evaluate(t1) {
                for(let e1 = 0; e1 < this.args.length; e1++){
                    const r = this.args[e1].evaluate(t1);
                    if (!ge(this.type, De(r))) return r;
                    if (e1 === this.args.length - 1) throw new Re(`Expected value to be of type ${ye(this.type)}, but found ${ye(De(r))} instead.`);
                }
                return null;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = this.type, e1 = [
                    t1.kind
                ];
                if ("array" === t1.kind) {
                    const r = t1.itemType;
                    if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
                        e1.push(r.kind);
                        const n = t1.N;
                        ("number" == typeof n || this.args.length > 1) && e1.push(n);
                    }
                }
                return e1.concat(this.args.map((t1)=>t1.serialize()));
            }
        }
        var $e = Ue;
        class Oe {
            constructor(t1){
                this.type = pe, this.sections = t1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                const r = t1[1];
                if (!Array.isArray(r) && "object" == typeof r) return e1.error("First argument must be an image or text section.");
                const n = [];
                let i = !1;
                for(let r = 1; r <= t1.length - 1; ++r){
                    const s = t1[r];
                    if (i && "object" == typeof s && !Array.isArray(s)) {
                        i = !1;
                        let t1 = null;
                        if (s["font-scale"] && (t1 = e1.parse(s["font-scale"], 1, se), !t1)) return null;
                        let r = null;
                        if (s["text-font"] && (r = e1.parse(s["text-font"], 1, de(ae)), !r)) return null;
                        let a = null;
                        if (s["text-color"] && (a = e1.parse(s["text-color"], 1, le), !a)) return null;
                        const o = n[n.length - 1];
                        o.scale = t1, o.font = r, o.textColor = a;
                    } else {
                        const s = e1.parse(t1[r], 1, ce);
                        if (!s) return null;
                        const a = s.type.kind;
                        if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e1.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i = !0, n.push({
                            content: s,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new Oe(n);
            }
            evaluate(t1) {
                return new Be(this.sections.map((e1)=>{
                    const r = e1.content.evaluate(t1);
                    return De(r) === fe ? new ze("", r, null, null, null) : new ze(Ve(r), null, e1.scale ? e1.scale.evaluate(t1) : null, e1.font ? e1.font.evaluate(t1).join(",") : null, e1.textColor ? e1.textColor.evaluate(t1) : null);
                }));
            }
            eachChild(t1) {
                for (const e1 of this.sections)t1(e1.content), e1.scale && t1(e1.scale), e1.font && t1(e1.font), e1.textColor && t1(e1.textColor);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e1 of this.sections){
                    t1.push(e1.content.serialize());
                    const r = {};
                    e1.scale && (r["font-scale"] = e1.scale.serialize()), e1.font && (r["text-font"] = e1.font.serialize()), e1.textColor && (r["text-color"] = e1.textColor.serialize()), t1.push(r);
                }
                return t1;
            }
        }
        class qe {
            constructor(t1){
                this.type = fe, this.input = t1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error("Expected two arguments.");
                const r = e1.parse(t1[1], 1, ae);
                return r ? new qe(r) : e1.error("No image name provided.");
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1), r = Ee.fromString(e1);
                return r && t1.availableImages && (r.available = t1.availableImages.indexOf(e1) > -1), r;
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "image",
                    this.input.serialize()
                ];
            }
        }
        const Ne = {
            "to-boolean": oe,
            "to-color": le,
            "to-number": se,
            "to-string": ae
        };
        class Ge {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expected at least one argument.");
                const r = t1[0];
                if (("to-boolean" === r || "to-string" === r) && 2 !== t1.length) return e1.error("Expected one argument.");
                const n = Ne[r], i = [];
                for(let r = 1; r < t1.length; r++){
                    const n = e1.parse(t1[r], r, ce);
                    if (!n) return null;
                    i.push(n);
                }
                return new Ge(n, i);
            }
            evaluate(t1) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t1));
                if ("color" === this.type.kind) {
                    let e1, r;
                    for (const n of this.args){
                        if (e1 = n.evaluate(t1), r = null, e1 instanceof Me) return e1;
                        if ("string" == typeof e1) {
                            const r = t1.parseColor(e1);
                            if (r) return r;
                        } else if (Array.isArray(e1) && (r = e1.length < 3 || e1.length > 4 ? `Invalid rbga value ${JSON.stringify(e1)}: expected an array containing either three or four numeric values.` : Ce(e1[0], e1[1], e1[2], e1[3]), !r)) return new Me(e1[0] / 255, e1[1] / 255, e1[2] / 255, e1[3]);
                    }
                    throw new Re(r || `Could not parse color from value '${"string" == typeof e1 ? e1 : String(JSON.stringify(e1))}'`);
                }
                if ("number" === this.type.kind) {
                    let e1 = null;
                    for (const r of this.args){
                        if (e1 = r.evaluate(t1), null === e1) return 0;
                        const n = Number(e1);
                        if (!isNaN(n)) return n;
                    }
                    throw new Re(`Could not convert ${JSON.stringify(e1)} to number.`);
                }
                return "formatted" === this.type.kind ? Be.fromString(Ve(this.args[0].evaluate(t1))) : "resolvedImage" === this.type.kind ? Ee.fromString(Ve(this.args[0].evaluate(t1))) : Ve(this.args[0].evaluate(t1));
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                if ("formatted" === this.type.kind) return new Oe([
                    {
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }
                ]).serialize();
                if ("resolvedImage" === this.type.kind) return new qe(this.args[0]).serialize();
                const t1 = [
                    `to-${this.type.kind}`
                ];
                return this.eachChild((e1)=>{
                    t1.push(e1.serialize());
                }), t1;
            }
        }
        var Xe = Ge;
        const Ze = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        var Ke = class {
            constructor(){
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
            }
            id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? Ze[this.feature.type] : this.feature.type : null;
            }
            geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
                return this.canonical;
            }
            properties() {
                return this.feature && this.feature.properties || {};
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t1 = this.featureDistanceData.center, e1 = this.featureDistanceData.scale, { x: r , y: n  } = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (r * e1 - t1[0]) + this.featureDistanceData.bearing[1] * (n * e1 - t1[1]);
                }
                return 0;
            }
            parseColor(t1) {
                let e1 = this._parseColorCache[t1];
                return e1 || (e1 = this._parseColorCache[t1] = Me.parse(t1)), e1;
            }
        };
        class Ye {
            constructor(t1, e1, r, n){
                this.name = t1, this.type = e1, this._evaluate = r, this.args = n;
            }
            evaluate(t1) {
                return this._evaluate(t1, this.args);
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    this.name
                ].concat(this.args.map((t1)=>t1.serialize()));
            }
            static parse(t1, e1) {
                const r = t1[0], n = Ye.definitions[r];
                if (!n) return e1.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i = Array.isArray(n) ? n[0] : n.type, s = Array.isArray(n) ? [
                    [
                        n[1],
                        n[2]
                    ]
                ] : n.overloads, a = s.filter(([e1])=>!Array.isArray(e1) || e1.length === t1.length - 1);
                let o = null;
                for (const [n, s] of a){
                    o = new _r(e1.registry, e1.path, null, e1.scope);
                    const a = [];
                    let l = !1;
                    for(let e1 = 1; e1 < t1.length; e1++){
                        const r = t1[e1], i = Array.isArray(n) ? n[e1 - 1] : n.type, s = o.parse(r, 1 + a.length, i);
                        if (!s) {
                            l = !0;
                            break;
                        }
                        a.push(s);
                    }
                    if (!l) {
                        if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);
                        else {
                            for(let t1 = 0; t1 < a.length; t1++){
                                const e1 = Array.isArray(n) ? n[t1] : n.type, r = a[t1];
                                o.concat(t1 + 1).checkSubtype(e1, r.type);
                            }
                            if (0 === o.errors.length) return new Ye(r, i, s, a);
                        }
                    }
                }
                if (1 === a.length) e1.errors.push(...o.errors);
                else {
                    const r = (a.length ? a : s).map(([t1])=>{
                        var e1;
                        return e1 = t1, Array.isArray(e1) ? `(${e1.map(ye).join(", ")})` : `(${ye(e1.type)}...)`;
                    }).join(" | "), n = [];
                    for(let r = 1; r < t1.length; r++){
                        const i = e1.parse(t1[r], 1 + n.length);
                        if (!i) return null;
                        n.push(ye(i.type));
                    }
                    e1.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }
                return null;
            }
            static register(t1, e1) {
                Ye.definitions = e1;
                for(const r in e1)t1[r] = Ye;
            }
        }
        var He = Ye;
        class We {
            constructor(t1, e1, r){
                this.type = he, this.locale = r, this.caseSensitive = t1, this.diacriticSensitive = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error("Expected one argument.");
                const r = t1[1];
                if ("object" != typeof r || Array.isArray(r)) return e1.error("Collator options argument must be an object.");
                const n = e1.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, oe);
                if (!n) return null;
                const i = e1.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, oe);
                if (!i) return null;
                let s = null;
                return r.locale && (s = e1.parse(r.locale, 1, ae), !s) ? null : new We(n, i, s);
            }
            evaluate(t1) {
                return new Te(this.caseSensitive.evaluate(t1), this.diacriticSensitive.evaluate(t1), this.locale ? this.locale.evaluate(t1) : null);
            }
            eachChild(t1) {
                t1(this.caseSensitive), t1(this.diacriticSensitive), this.locale && t1(this.locale);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return t1["case-sensitive"] = this.caseSensitive.serialize(), t1["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t1.locale = this.locale.serialize()), [
                    "collator",
                    t1
                ];
            }
        }
        const Je = 8192;
        function Qe(t1, e1) {
            t1[0] = Math.min(t1[0], e1[0]), t1[1] = Math.min(t1[1], e1[1]), t1[2] = Math.max(t1[2], e1[0]), t1[3] = Math.max(t1[3], e1[1]);
        }
        function tr(t1, e1) {
            return !(t1[0] <= e1[0] || t1[2] >= e1[2] || t1[1] <= e1[1] || t1[3] >= e1[3]);
        }
        function er(t1, e1) {
            const r = (180 + t1[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1[1] * Math.PI / 360))) / 360, i = Math.pow(2, e1.z);
            return [
                Math.round(r * i * Je),
                Math.round(n * i * Je)
            ];
        }
        function rr(t1, e1, r) {
            const n = t1[0] - e1[0], i = t1[1] - e1[1], s = t1[0] - r[0], a = t1[1] - r[1];
            return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;
        }
        function nr(t1, e1) {
            let r = !1;
            for(let a = 0, o = e1.length; a < o; a++){
                const o = e1[a];
                for(let e1 = 0, a = o.length; e1 < a - 1; e1++){
                    if (rr(t1, o[e1], o[e1 + 1])) return !1;
                    (i = o[e1])[1] > (n = t1)[1] != (s = o[e1 + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);
                }
            }
            var n, i, s;
            return r;
        }
        function ir(t1, e1) {
            for(let r = 0; r < e1.length; r++)if (nr(t1, e1[r])) return !0;
            return !1;
        }
        function sr(t1, e1, r, n) {
            const i = n[0] - r[0], s = n[1] - r[1], a = (t1[0] - r[0]) * s - i * (t1[1] - r[1]), o = (e1[0] - r[0]) * s - i * (e1[1] - r[1]);
            return a > 0 && o < 0 || a < 0 && o > 0;
        }
        function ar(t1, e1, r) {
            for (const u of r)for(let r = 0; r < u.length - 1; ++r)if (0 != (o = [
                (a = u[r + 1])[0] - (s = u[r])[0],
                a[1] - s[1]
            ])[0] * (l = [
                (i = e1)[0] - (n = t1)[0],
                i[1] - n[1]
            ])[1] - o[1] * l[0] && sr(n, i, s, a) && sr(s, a, n, i)) return !0;
            var n, i, s, a, o, l;
            return !1;
        }
        function or(t1, e1) {
            for(let r = 0; r < t1.length; ++r)if (!nr(t1[r], e1)) return !1;
            for(let r = 0; r < t1.length - 1; ++r)if (ar(t1[r], t1[r + 1], e1)) return !1;
            return !0;
        }
        function lr(t1, e1) {
            for(let r = 0; r < e1.length; r++)if (or(t1, e1[r])) return !0;
            return !1;
        }
        function ur(t1, e1, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = [];
                for(let n = 0; n < t1[i].length; n++){
                    const a = er(t1[i][n], r);
                    Qe(e1, a), s.push(a);
                }
                n.push(s);
            }
            return n;
        }
        function cr(t1, e1, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const s = ur(t1[i], e1, r);
                n.push(s);
            }
            return n;
        }
        function hr(t1, e1, r, n) {
            if (t1[0] < r[0] || t1[0] > r[2]) {
                const e1 = .5 * n;
                let i = t1[0] - r[0] > e1 ? -n : r[0] - t1[0] > e1 ? n : 0;
                0 === i && (i = t1[0] - r[2] > e1 ? -n : r[2] - t1[0] > e1 ? n : 0), t1[0] += i;
            }
            Qe(e1, t1);
        }
        function pr(t1, e1, r, n) {
            const i = Math.pow(2, n.z) * Je, s = [
                n.x * Je,
                n.y * Je
            ], a = [];
            if (!t1) return a;
            for (const n of t1)for (const t1 of n){
                const n = [
                    t1.x + s[0],
                    t1.y + s[1]
                ];
                hr(n, e1, r, i), a.push(n);
            }
            return a;
        }
        function fr(t1, e1, r, n) {
            const i = Math.pow(2, n.z) * Je, s = [
                n.x * Je,
                n.y * Je
            ], a = [];
            if (!t1) return a;
            for (const r of t1){
                const t1 = [];
                for (const n of r){
                    const r = [
                        n.x + s[0],
                        n.y + s[1]
                    ];
                    Qe(e1, r), t1.push(r);
                }
                a.push(t1);
            }
            if (e1[2] - e1[0] <= i / 2) {
                (o = e1)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;
                for (const t1 of a)for (const n of t1)hr(n, e1, r, i);
            }
            var o;
            return a;
        }
        class dr {
            constructor(t1, e1){
                this.type = oe, this.geojson = t1, this.geometries = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`'within' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (Pe(t1[1])) {
                    const e1 = t1[1];
                    if ("FeatureCollection" === e1.type) for(let t1 = 0; t1 < e1.features.length; ++t1){
                        const r = e1.features[t1].geometry.type;
                        if ("Polygon" === r || "MultiPolygon" === r) return new dr(e1, e1.features[t1].geometry);
                    }
                    else if ("Feature" === e1.type) {
                        const t1 = e1.geometry.type;
                        if ("Polygon" === t1 || "MultiPolygon" === t1) return new dr(e1, e1.geometry);
                    } else if ("Polygon" === e1.type || "MultiPolygon" === e1.type) return new dr(e1, e1);
                }
                return e1.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t1) {
                if (null != t1.geometry() && null != t1.canonicalID()) {
                    if ("Point" === t1.geometryType()) return function(t1, e1) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e1.type) {
                            const s = ur(e1.coordinates, n, i), a = pr(t1.geometry(), r, n, i);
                            if (!tr(r, n)) return !1;
                            for (const t1 of a)if (!nr(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e1.type) {
                            const s = cr(e1.coordinates, n, i), a = pr(t1.geometry(), r, n, i);
                            if (!tr(r, n)) return !1;
                            for (const t1 of a)if (!ir(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e1) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e1.type) {
                            const s = ur(e1.coordinates, n, i), a = fr(t1.geometry(), r, n, i);
                            if (!tr(r, n)) return !1;
                            for (const t1 of a)if (!or(t1, s)) return !1;
                        }
                        if ("MultiPolygon" === e1.type) {
                            const s = cr(e1.coordinates, n, i), a = fr(t1.geometry(), r, n, i);
                            if (!tr(r, n)) return !1;
                            for (const t1 of a)if (!lr(t1, s)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                }
                return !1;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "within",
                    this.geojson
                ];
            }
        }
        var yr = dr;
        function mr(t1) {
            if (t1 instanceof He) {
                if ("get" === t1.name && 1 === t1.args.length) return !1;
                if ("feature-state" === t1.name) return !1;
                if ("has" === t1.name && 1 === t1.args.length) return !1;
                if ("properties" === t1.name || "geometry-type" === t1.name || "id" === t1.name) return !1;
                if (/^filter-/.test(t1.name)) return !1;
            }
            if (t1 instanceof yr) return !1;
            let e1 = !0;
            return t1.eachChild((t1)=>{
                e1 && !mr(t1) && (e1 = !1);
            }), e1;
        }
        function gr(t1) {
            if (t1 instanceof He && "feature-state" === t1.name) return !1;
            let e1 = !0;
            return t1.eachChild((t1)=>{
                e1 && !gr(t1) && (e1 = !1);
            }), e1;
        }
        function xr(t1, e1) {
            if (t1 instanceof He && e1.indexOf(t1.name) >= 0) return !1;
            let r = !0;
            return t1.eachChild((t1)=>{
                r && !xr(t1, e1) && (r = !1);
            }), r;
        }
        class vr {
            constructor(t1, e1){
                this.type = e1.type, this.name = t1, this.boundExpression = e1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length || "string" != typeof t1[1]) return e1.error("'var' expression requires exactly one string literal argument.");
                const r = t1[1];
                return e1.scope.has(r) ? new vr(r, e1.scope.get(r)) : e1.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t1) {
                return this.boundExpression.evaluate(t1);
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "var",
                    this.name
                ];
            }
        }
        var br = vr;
        class wr {
            constructor(t1, e1 = [], r, n = new ne, i = []){
                this.registry = t1, this.path = e1, this.key = e1.map((t1)=>`[${t1}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r;
            }
            parse(t1, e1, r, n, i = {}) {
                return e1 ? this.concat(e1, r, n)._parse(t1, i) : this._parse(t1, i);
            }
            _parse(t1, e1) {
                function r(t1, e1, r) {
                    return "assert" === r ? new $e(e1, [
                        t1
                    ]) : "coerce" === r ? new Xe(e1, [
                        t1
                    ]) : t1;
                }
                if (null !== t1 && "string" != typeof t1 && "boolean" != typeof t1 && "number" != typeof t1 || (t1 = [
                    "literal",
                    t1
                ]), Array.isArray(t1)) {
                    if (0 === t1.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n = t1[0];
                    if ("string" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                    const i = this.registry[n];
                    if (i) {
                        let n = i.parse(t1, this);
                        if (!n) return null;
                        if (this.expectedType) {
                            const t1 = this.expectedType, i = n.type;
                            if ("string" !== t1.kind && "number" !== t1.kind && "boolean" !== t1.kind && "object" !== t1.kind && "array" !== t1.kind || "value" !== i.kind) {
                                if ("color" !== t1.kind && "formatted" !== t1.kind && "resolvedImage" !== t1.kind || "value" !== i.kind && "string" !== i.kind) {
                                    if (this.checkSubtype(t1, i)) return null;
                                } else n = r(n, t1, e1.typeAnnotation || "coerce");
                            } else n = r(n, t1, e1.typeAnnotation || "assert");
                        }
                        if (!(n instanceof Fe) && "resolvedImage" !== n.type.kind && Ar(n)) {
                            const t1 = new Ke;
                            try {
                                n = new Fe(n.type, n.evaluate(t1));
                            } catch (t1) {
                                return this.error(t1.message), null;
                            }
                        }
                        return n;
                    }
                    return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
                }
                return this.error(void 0 === t1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t1 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t1} instead.`);
            }
            concat(t1, e1, r) {
                const n = "number" == typeof t1 ? this.path.concat(t1) : this.path, i = r ? this.scope.concat(r) : this.scope;
                return new wr(this.registry, n, e1 || null, i, this.errors);
            }
            error(t1, ...e1) {
                const r = `${this.key}${e1.map((t1)=>`[${t1}]`).join("")}`;
                this.errors.push(new ee(r, t1));
            }
            checkSubtype(t1, e1) {
                const r = ge(t1, e1);
                return r && this.error(r), r;
            }
        }
        var _r = wr;
        function Ar(t1) {
            if (t1 instanceof br) return Ar(t1.boundExpression);
            if (t1 instanceof He && "error" === t1.name) return !1;
            if (t1 instanceof We) return !1;
            if (t1 instanceof yr) return !1;
            const e1 = t1 instanceof Xe || t1 instanceof $e;
            let r = !0;
            return t1.eachChild((t1)=>{
                r = e1 ? r && Ar(t1) : r && t1 instanceof Fe;
            }), !!r && mr(t1) && xr(t1, [
                "zoom",
                "heatmap-density",
                "line-progress",
                "sky-radial-progress",
                "accumulated",
                "is-supported-script",
                "pitch",
                "distance-from-center"
            ]);
        }
        function Sr(t1, e1) {
            const r = t1.length - 1;
            let n, i, s = 0, a = r, o = 0;
            for(; s <= a;)if (o = Math.floor((s + a) / 2), n = t1[o], i = t1[o + 1], n <= e1) {
                if (o === r || e1 < i) return o;
                s = o + 1;
            } else {
                if (!(n > e1)) throw new Re("Input is not a number.");
                a = o - 1;
            }
            return 0;
        }
        class kr {
            constructor(t1, e1, r){
                this.type = t1, this.input = e1, this.labels = [], this.outputs = [];
                for (const [t1, e1] of r)this.labels.push(t1), this.outputs.push(e1);
            }
            static parse(t1, e1) {
                if (t1.length - 1 < 4) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e1.error("Expected an even number of arguments.");
                const r = e1.parse(t1[1], 1, se);
                if (!r) return null;
                const n = [];
                let i = null;
                e1.expectedType && "value" !== e1.expectedType.kind && (i = e1.expectedType);
                for(let r = 1; r < t1.length; r += 2){
                    const s = 1 === r ? -1 / 0 : t1[r], a = t1[r + 1], o = r, l = r + 1;
                    if ("number" != typeof s) return e1.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
                    if (n.length && n[n.length - 1][0] >= s) return e1.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
                    const u = e1.parse(a, l, i);
                    if (!u) return null;
                    i = i || u.type, n.push([
                        s,
                        u
                    ]);
                }
                return new kr(i, r, n);
            }
            evaluate(t1) {
                const e1 = this.labels, r = this.outputs;
                if (1 === e1.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e1[0]) return r[0].evaluate(t1);
                const i = e1.length;
                return n >= e1[i - 1] ? r[i - 1].evaluate(t1) : r[Sr(e1, n)].evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input);
                for (const e1 of this.outputs)t1(e1);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "step",
                    this.input.serialize()
                ];
                for(let e1 = 0; e1 < this.labels.length; e1++)e1 > 0 && t1.push(this.labels[e1]), t1.push(this.outputs[e1].serialize());
                return t1;
            }
        }
        var Ir = kr;
        function Mr(t1, e1, r) {
            return t1 * (1 - r) + e1 * r;
        }
        var Tr = Object.freeze({
            __proto__: null,
            number: Mr,
            color: function(t1, e1, r) {
                return new Me(Mr(t1.r, e1.r, r), Mr(t1.g, e1.g, r), Mr(t1.b, e1.b, r), Mr(t1.a, e1.a, r));
            },
            array: function(t1, e1, r) {
                return t1.map((t1, n)=>Mr(t1, e1[n], r));
            }
        });
        const zr = .95047, Br = 1.08883, Er = 4 / 29, Cr = 6 / 29, Pr = 3 * Cr * Cr, Dr = Math.PI / 180, Vr = 180 / Math.PI;
        function Lr(t1) {
            return t1 > .008856451679035631 ? Math.pow(t1, 1 / 3) : t1 / Pr + Er;
        }
        function Fr(t1) {
            return t1 > Cr ? t1 * t1 * t1 : Pr * (t1 - Er);
        }
        function Rr(t1) {
            return 255 * (t1 <= .0031308 ? 12.92 * t1 : 1.055 * Math.pow(t1, 1 / 2.4) - .055);
        }
        function jr(t1) {
            return (t1 /= 255) <= .04045 ? t1 / 12.92 : Math.pow((t1 + .055) / 1.055, 2.4);
        }
        function Ur(t1) {
            const e1 = jr(t1.r), r = jr(t1.g), n = jr(t1.b), i = Lr((.4124564 * e1 + .3575761 * r + .1804375 * n) / zr), s = Lr((.2126729 * e1 + .7151522 * r + .072175 * n) / 1);
            return {
                l: 116 * s - 16,
                a: 500 * (i - s),
                b: 200 * (s - Lr((.0193339 * e1 + .119192 * r + .9503041 * n) / Br)),
                alpha: t1.a
            };
        }
        function $r(t1) {
            let e1 = (t1.l + 16) / 116, r = isNaN(t1.a) ? e1 : e1 + t1.a / 500, n = isNaN(t1.b) ? e1 : e1 - t1.b / 200;
            return e1 = 1 * Fr(e1), r = zr * Fr(r), n = Br * Fr(n), new Me(Rr(3.2404542 * r - 1.5371385 * e1 - .4985314 * n), Rr(-0.969266 * r + 1.8760108 * e1 + .041556 * n), Rr(.0556434 * r - .2040259 * e1 + 1.0572252 * n), t1.alpha);
        }
        function Or(t1, e1, r) {
            const n = e1 - t1;
            return t1 + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
        }
        const qr = {
            forward: Ur,
            reverse: $r,
            interpolate: function(t1, e1, r) {
                return {
                    l: Mr(t1.l, e1.l, r),
                    a: Mr(t1.a, e1.a, r),
                    b: Mr(t1.b, e1.b, r),
                    alpha: Mr(t1.alpha, e1.alpha, r)
                };
            }
        }, Nr = {
            forward: function(t1) {
                const { l: e1 , a: r , b: n  } = Ur(t1), i = Math.atan2(n, r) * Vr;
                return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(r * r + n * n),
                    l: e1,
                    alpha: t1.a
                };
            },
            reverse: function(t1) {
                const e1 = t1.h * Dr, r = t1.c;
                return $r({
                    l: t1.l,
                    a: Math.cos(e1) * r,
                    b: Math.sin(e1) * r,
                    alpha: t1.alpha
                });
            },
            interpolate: function(t1, e1, r) {
                return {
                    h: Or(t1.h, e1.h, r),
                    c: Mr(t1.c, e1.c, r),
                    l: Mr(t1.l, e1.l, r),
                    alpha: Mr(t1.alpha, e1.alpha, r)
                };
            }
        };
        var Gr = Object.freeze({
            __proto__: null,
            lab: qr,
            hcl: Nr
        });
        class Xr {
            constructor(t1, e1, r, n, i){
                this.type = t1, this.operator = e1, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
                for (const [t1, e1] of i)this.labels.push(t1), this.outputs.push(e1);
            }
            static interpolationFactor(t1, e1, r, n) {
                let i = 0;
                if ("exponential" === t1.name) i = Zr(e1, t1.base, r, n);
                else if ("linear" === t1.name) i = Zr(e1, 1, r, n);
                else if ("cubic-bezier" === t1.name) {
                    const s = t1.controlPoints;
                    i = new p(s[0], s[1], s[2], s[3]).solve(Zr(e1, 1, r, n));
                }
                return i;
            }
            static parse(t1, e1) {
                let [r, n, i, ...s] = t1;
                if (!Array.isArray(n) || 0 === n.length) return e1.error("Expected an interpolation type expression.", 1);
                if ("linear" === n[0]) n = {
                    name: "linear"
                };
                else if ("exponential" === n[0]) {
                    const t1 = n[1];
                    if ("number" != typeof t1) return e1.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n = {
                        name: "exponential",
                        base: t1
                    };
                } else {
                    if ("cubic-bezier" !== n[0]) return e1.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                    {
                        const t1 = n.slice(1);
                        if (4 !== t1.length || t1.some((t1)=>"number" != typeof t1 || t1 < 0 || t1 > 1)) return e1.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n = {
                            name: "cubic-bezier",
                            controlPoints: t1
                        };
                    }
                }
                if (t1.length - 1 < 4) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e1.error("Expected an even number of arguments.");
                if (i = e1.parse(i, 2, se), !i) return null;
                const a = [];
                let o = null;
                "interpolate-hcl" === r || "interpolate-lab" === r ? o = le : e1.expectedType && "value" !== e1.expectedType.kind && (o = e1.expectedType);
                for(let t1 = 0; t1 < s.length; t1 += 2){
                    const r = s[t1], n = s[t1 + 1], i = t1 + 3, l = t1 + 4;
                    if ("number" != typeof r) return e1.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
                    if (a.length && a[a.length - 1][0] >= r) return e1.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
                    const u = e1.parse(n, l, o);
                    if (!u) return null;
                    o = o || u.type, a.push([
                        r,
                        u
                    ]);
                }
                return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new Xr(o, r, n, i, a) : e1.error(`Type ${ye(o)} is not interpolatable.`);
            }
            evaluate(t1) {
                const e1 = this.labels, r = this.outputs;
                if (1 === e1.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e1[0]) return r[0].evaluate(t1);
                const i = e1.length;
                if (n >= e1[i - 1]) return r[i - 1].evaluate(t1);
                const s = Sr(e1, n), a = Xr.interpolationFactor(this.interpolation, n, e1[s], e1[s + 1]), o = r[s].evaluate(t1), l = r[s + 1].evaluate(t1);
                return "interpolate" === this.operator ? Tr[this.type.kind.toLowerCase()](o, l, a) : "interpolate-hcl" === this.operator ? Nr.reverse(Nr.interpolate(Nr.forward(o), Nr.forward(l), a)) : qr.reverse(qr.interpolate(qr.forward(o), qr.forward(l), a));
            }
            eachChild(t1) {
                t1(this.input);
                for (const e1 of this.outputs)t1(e1);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                let t1;
                t1 = "linear" === this.interpolation.name ? [
                    "linear"
                ] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? [
                    "linear"
                ] : [
                    "exponential",
                    this.interpolation.base
                ] : [
                    "cubic-bezier"
                ].concat(this.interpolation.controlPoints);
                const e1 = [
                    this.operator,
                    t1,
                    this.input.serialize()
                ];
                for(let t1 = 0; t1 < this.labels.length; t1++)e1.push(this.labels[t1], this.outputs[t1].serialize());
                return e1;
            }
        }
        function Zr(t1, e1, r, n) {
            const i = n - r, s = t1 - r;
            return 0 === i ? 0 : 1 === e1 ? s / i : (Math.pow(e1, s) - 1) / (Math.pow(e1, i) - 1);
        }
        var Kr = Xr;
        class Yr {
            constructor(t1, e1){
                this.type = t1, this.args = e1;
            }
            static parse(t1, e1) {
                if (t1.length < 2) return e1.error("Expectected at least one argument.");
                let r = null;
                const n = e1.expectedType;
                n && "value" !== n.kind && (r = n);
                const i = [];
                for (const n of t1.slice(1)){
                    const t1 = e1.parse(n, 1 + i.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t1) return null;
                    r = r || t1.type, i.push(t1);
                }
                const s = n && i.some((t1)=>ge(n, t1.type));
                return new Yr(s ? ce : r, i);
            }
            evaluate(t1) {
                let e1, r = null, n = 0;
                for (const i of this.args){
                    if (n++, r = i.evaluate(t1), r && r instanceof Ee && !r.available && (e1 || (e1 = r), r = null, n === this.args.length)) return e1;
                    if (null !== r) break;
                }
                return r;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "coalesce"
                ];
                return this.eachChild((e1)=>{
                    t1.push(e1.serialize());
                }), t1;
            }
        }
        var Hr = Yr;
        class Wr {
            constructor(t1, e1){
                this.type = e1.type, this.bindings = [].concat(t1), this.result = e1;
            }
            evaluate(t1) {
                return this.result.evaluate(t1);
            }
            eachChild(t1) {
                for (const e1 of this.bindings)t1(e1[1]);
                t1(this.result);
            }
            static parse(t1, e1) {
                if (t1.length < 4) return e1.error(`Expected at least 3 arguments, but found ${t1.length - 1} instead.`);
                const r = [];
                for(let n = 1; n < t1.length - 1; n += 2){
                    const i = t1[n];
                    if ("string" != typeof i) return e1.error(`Expected string, but found ${typeof i} instead.`, n);
                    if (/[^a-zA-Z0-9_]/.test(i)) return e1.error("Variable names must contain only alphanumeric characters or '_'.", n);
                    const s = e1.parse(t1[n + 1], n + 1);
                    if (!s) return null;
                    r.push([
                        i,
                        s
                    ]);
                }
                const n = e1.parse(t1[t1.length - 1], t1.length - 1, e1.expectedType, r);
                return n ? new Wr(r, n) : null;
            }
            outputDefined() {
                return this.result.outputDefined();
            }
            serialize() {
                const t1 = [
                    "let"
                ];
                for (const [e1, r] of this.bindings)t1.push(e1, r.serialize());
                return t1.push(this.result.serialize()), t1;
            }
        }
        var Jr = Wr;
        class Qr {
            constructor(t1, e1, r){
                this.type = t1, this.index = e1, this.input = r;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, se), n = e1.parse(t1[2], 2, de(e1.expectedType || ce));
                return r && n ? new Qr(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e1 = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e1 < 0) throw new Re(`Array index out of bounds: ${e1} < 0.`);
                if (e1 >= r.length) throw new Re(`Array index out of bounds: ${e1} > ${r.length - 1}.`);
                if (e1 !== Math.floor(e1)) throw new Re(`Array index must be an integer, but found ${e1} instead.`);
                return r[e1];
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        var tn = Qr;
        class en {
            constructor(t1, e1){
                this.type = oe, this.needle = t1, this.haystack = e1;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, ce), n = e1.parse(t1[2], 2, ce);
                return r && n ? xe(r.type, [
                    oe,
                    ae,
                    se,
                    ie,
                    ce
                ]) ? new en(r, n) : e1.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r.type)} instead`) : null;
            }
            evaluate(t1) {
                const e1 = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (null == r) return !1;
                if (!ve(e1, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e1))} instead.`);
                if (!ve(r, [
                    "string",
                    "array"
                ])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r))} instead.`);
                return r.indexOf(e1) >= 0;
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack);
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "in",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        var rn = en;
        class nn {
            constructor(t1, e1, r){
                this.type = se, this.needle = t1, this.haystack = e1, this.fromIndex = r;
            }
            static parse(t1, e1) {
                if (t1.length <= 2 || t1.length >= 5) return e1.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, ce), n = e1.parse(t1[2], 2, ce);
                if (!r || !n) return null;
                if (!xe(r.type, [
                    oe,
                    ae,
                    se,
                    ie,
                    ce
                ])) return e1.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e1.parse(t1[3], 3, se);
                    return i ? new nn(r, n, i) : null;
                }
                return new nn(r, n);
            }
            evaluate(t1) {
                const e1 = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (!ve(e1, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e1))} instead.`);
                if (!ve(r, [
                    "string",
                    "array"
                ])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r))} instead.`);
                if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t1);
                    return r.indexOf(e1, n);
                }
                return r.indexOf(e1);
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack), this.fromIndex && t1(this.fromIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t1 = this.fromIndex.serialize();
                    return [
                        "index-of",
                        this.needle.serialize(),
                        this.haystack.serialize(),
                        t1
                    ];
                }
                return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        var sn = nn;
        class an {
            constructor(t1, e1, r, n, i, s){
                this.inputType = t1, this.type = e1, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;
            }
            static parse(t1, e1) {
                if (t1.length < 5) return e1.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 1) return e1.error("Expected an even number of arguments.");
                let r, n;
                e1.expectedType && "value" !== e1.expectedType.kind && (n = e1.expectedType);
                const i = {}, s = [];
                for(let a = 2; a < t1.length - 1; a += 2){
                    let o = t1[a];
                    const l = t1[a + 1];
                    Array.isArray(o) || (o = [
                        o
                    ]);
                    const u = e1.concat(a);
                    if (0 === o.length) return u.error("Expected at least one branch label.");
                    for (const t1 of o){
                        if ("number" != typeof t1 && "string" != typeof t1) return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t1 && Math.abs(t1) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t1 && Math.floor(t1) !== t1) return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, De(t1))) return null;
                        } else r = De(t1);
                        if (void 0 !== i[String(t1)]) return u.error("Branch labels must be unique.");
                        i[String(t1)] = s.length;
                    }
                    const c = e1.parse(l, a, n);
                    if (!c) return null;
                    n = n || c.type, s.push(c);
                }
                const a = e1.parse(t1[1], 1, ce);
                if (!a) return null;
                const o = e1.parse(t1[t1.length - 1], t1.length - 1, n);
                return o ? "value" !== a.type.kind && e1.concat(1).checkSubtype(r, a.type) ? null : new an(r, n, a, i, s, o) : null;
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1);
                return (De(e1) === this.inputType && this.outputs[this.cases[e1]] || this.otherwise).evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input), this.outputs.forEach(t1), t1(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "match",
                    this.input.serialize()
                ], e1 = Object.keys(this.cases).sort(), r = [], n = {};
                for (const t1 of e1){
                    const e1 = n[this.cases[t1]];
                    void 0 === e1 ? (n[this.cases[t1]] = r.length, r.push([
                        this.cases[t1],
                        [
                            t1
                        ]
                    ])) : r[e1][1].push(t1);
                }
                const i = (t1)=>"number" === this.inputType.kind ? Number(t1) : t1;
                for (const [e1, n] of r)t1.push(1 === n.length ? i(n[0]) : n.map(i)), t1.push(this.outputs[e1].serialize());
                return t1.push(this.otherwise.serialize()), t1;
            }
        }
        var on = an;
        class ln {
            constructor(t1, e1, r){
                this.type = t1, this.branches = e1, this.otherwise = r;
            }
            static parse(t1, e1) {
                if (t1.length < 4) return e1.error(`Expected at least 3 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 0) return e1.error("Expected an odd number of arguments.");
                let r;
                e1.expectedType && "value" !== e1.expectedType.kind && (r = e1.expectedType);
                const n = [];
                for(let i = 1; i < t1.length - 1; i += 2){
                    const s = e1.parse(t1[i], i, oe);
                    if (!s) return null;
                    const a = e1.parse(t1[i + 1], i + 1, r);
                    if (!a) return null;
                    n.push([
                        s,
                        a
                    ]), r = r || a.type;
                }
                const i = e1.parse(t1[t1.length - 1], t1.length - 1, r);
                return i ? new ln(r, n, i) : null;
            }
            evaluate(t1) {
                for (const [e1, r] of this.branches)if (e1.evaluate(t1)) return r.evaluate(t1);
                return this.otherwise.evaluate(t1);
            }
            eachChild(t1) {
                for (const [e1, r] of this.branches)t1(e1), t1(r);
                t1(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(([t1, e1])=>e1.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "case"
                ];
                return this.eachChild((e1)=>{
                    t1.push(e1.serialize());
                }), t1;
            }
        }
        var un = ln;
        class cn {
            constructor(t1, e1, r, n){
                this.type = t1, this.input = e1, this.beginIndex = r, this.endIndex = n;
            }
            static parse(t1, e1) {
                if (t1.length <= 2 || t1.length >= 5) return e1.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1, ce), n = e1.parse(t1[2], 2, se);
                if (!r || !n) return null;
                if (!xe(r.type, [
                    de(ce),
                    ae,
                    ce
                ])) return e1.error(`Expected first argument to be of type array or string, but found ${ye(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e1.parse(t1[3], 3, se);
                    return i ? new cn(r.type, r, n, i) : null;
                }
                return new cn(r.type, r, n);
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1), r = this.beginIndex.evaluate(t1);
                if (!ve(e1, [
                    "string",
                    "array"
                ])) throw new Re(`Expected first argument to be of type array or string, but found ${ye(De(e1))} instead.`);
                if (this.endIndex) {
                    const n = this.endIndex.evaluate(t1);
                    return e1.slice(r, n);
                }
                return e1.slice(r);
            }
            eachChild(t1) {
                t1(this.input), t1(this.beginIndex), this.endIndex && t1(this.endIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t1 = this.endIndex.serialize();
                    return [
                        "slice",
                        this.input.serialize(),
                        this.beginIndex.serialize(),
                        t1
                    ];
                }
                return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize()
                ];
            }
        }
        var hn = cn;
        function pn(t1, e1) {
            return "==" === t1 || "!=" === t1 ? "boolean" === e1.kind || "string" === e1.kind || "number" === e1.kind || "null" === e1.kind || "value" === e1.kind : "string" === e1.kind || "number" === e1.kind || "value" === e1.kind;
        }
        function fn(t1, e1, r, n) {
            return 0 === n.compare(e1, r);
        }
        function dn(t1, e1, r) {
            const n = "==" !== t1 && "!=" !== t1;
            return class i {
                constructor(t1, e1, r){
                    this.type = oe, this.lhs = t1, this.rhs = e1, this.collator = r, this.hasUntypedArgument = "value" === t1.type.kind || "value" === e1.type.kind;
                }
                static parse(t1, e1) {
                    if (3 !== t1.length && 4 !== t1.length) return e1.error("Expected two or three arguments.");
                    const r = t1[0];
                    let s = e1.parse(t1[1], 1, ce);
                    if (!s) return null;
                    if (!pn(r, s.type)) return e1.concat(1).error(`"${r}" comparisons are not supported for type '${ye(s.type)}'.`);
                    let a = e1.parse(t1[2], 2, ce);
                    if (!a) return null;
                    if (!pn(r, a.type)) return e1.concat(2).error(`"${r}" comparisons are not supported for type '${ye(a.type)}'.`);
                    if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e1.error(`Cannot compare types '${ye(s.type)}' and '${ye(a.type)}'.`);
                    n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new $e(a.type, [
                        s
                    ]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new $e(s.type, [
                        a
                    ])));
                    let o = null;
                    if (4 === t1.length) {
                        if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e1.error("Cannot use collator to compare non-string types.");
                        if (o = e1.parse(t1[3], 3, he), !o) return null;
                    }
                    return new i(s, a, o);
                }
                evaluate(i) {
                    const s = this.lhs.evaluate(i), a = this.rhs.evaluate(i);
                    if (n && this.hasUntypedArgument) {
                        const e1 = De(s), r = De(a);
                        if (e1.kind !== r.kind || "string" !== e1.kind && "number" !== e1.kind) throw new Re(`Expected arguments for "${t1}" to be (string, string) or (number, number), but found (${e1.kind}, ${r.kind}) instead.`);
                    }
                    if (this.collator && !n && this.hasUntypedArgument) {
                        const t1 = De(s), r = De(a);
                        if ("string" !== t1.kind || "string" !== r.kind) return e1(i, s, a);
                    }
                    return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e1(i, s, a);
                }
                eachChild(t1) {
                    t1(this.lhs), t1(this.rhs), this.collator && t1(this.collator);
                }
                outputDefined() {
                    return !0;
                }
                serialize() {
                    const e1 = [
                        t1
                    ];
                    return this.eachChild((t1)=>{
                        e1.push(t1.serialize());
                    }), e1;
                }
            };
        }
        const yn = dn("==", function(t1, e1, r) {
            return e1 === r;
        }, fn), mn = dn("!=", function(t1, e1, r) {
            return e1 !== r;
        }, function(t1, e1, r, n) {
            return !fn(0, e1, r, n);
        }), gn = dn("<", function(t1, e1, r) {
            return e1 < r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) < 0;
        }), xn = dn(">", function(t1, e1, r) {
            return e1 > r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) > 0;
        }), vn = dn("<=", function(t1, e1, r) {
            return e1 <= r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) <= 0;
        }), bn = dn(">=", function(t1, e1, r) {
            return e1 >= r;
        }, function(t1, e1, r, n) {
            return n.compare(e1, r) >= 0;
        });
        class wn {
            constructor(t1, e1, r, n, i, s){
                this.type = ae, this.number = t1, this.locale = e1, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;
            }
            static parse(t1, e1) {
                if (3 !== t1.length) return e1.error("Expected two arguments.");
                const r = e1.parse(t1[1], 1, se);
                if (!r) return null;
                const n = t1[2];
                if ("object" != typeof n || Array.isArray(n)) return e1.error("NumberFormat options argument must be an object.");
                let i = null;
                if (n.locale && (i = e1.parse(n.locale, 1, ae), !i)) return null;
                let s = null;
                if (n.currency && (s = e1.parse(n.currency, 1, ae), !s)) return null;
                let a = null;
                if (n.unit && (a = e1.parse(n.unit, 1, ae), !a)) return null;
                let o = null;
                if (n["min-fraction-digits"] && (o = e1.parse(n["min-fraction-digits"], 1, se), !o)) return null;
                let l = null;
                return n["max-fraction-digits"] && (l = e1.parse(n["max-fraction-digits"], 1, se), !l) ? null : new wn(r, i, s, a, o, l);
            }
            evaluate(t1) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t1) : [], {
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t1) : void 0,
                    unit: this.unit ? this.unit.evaluate(t1) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t1) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t1) : void 0
                }).format(this.number.evaluate(t1));
            }
            eachChild(t1) {
                t1(this.number), this.locale && t1(this.locale), this.currency && t1(this.currency), this.unit && t1(this.unit), this.minFractionDigits && t1(this.minFractionDigits), this.maxFractionDigits && t1(this.maxFractionDigits);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return this.locale && (t1.locale = this.locale.serialize()), this.currency && (t1.currency = this.currency.serialize()), this.unit && (t1.unit = this.unit.serialize()), this.minFractionDigits && (t1["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t1["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
                    "number-format",
                    this.number.serialize(),
                    t1
                ];
            }
        }
        class _n {
            constructor(t1){
                this.type = se, this.input = t1;
            }
            static parse(t1, e1) {
                if (2 !== t1.length) return e1.error(`Expected 1 argument, but found ${t1.length - 1} instead.`);
                const r = e1.parse(t1[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e1.error(`Expected argument of type string or array, but found ${ye(r.type)} instead.`) : new _n(r) : null;
            }
            evaluate(t1) {
                const e1 = this.input.evaluate(t1);
                if ("string" == typeof e1) return e1.length;
                if (Array.isArray(e1)) return e1.length;
                throw new Re(`Expected value to be of type string or array, but found ${ye(De(e1))} instead.`);
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "length"
                ];
                return this.eachChild((e1)=>{
                    t1.push(e1.serialize());
                }), t1;
            }
        }
        const An = {
            "==": yn,
            "!=": mn,
            ">": xn,
            "<": gn,
            ">=": bn,
            "<=": vn,
            array: $e,
            at: tn,
            boolean: $e,
            case: un,
            coalesce: Hr,
            collator: We,
            format: Oe,
            image: qe,
            in: rn,
            "index-of": sn,
            interpolate: Kr,
            "interpolate-hcl": Kr,
            "interpolate-lab": Kr,
            length: _n,
            let: Jr,
            literal: Fe,
            match: on,
            number: $e,
            "number-format": wn,
            object: $e,
            slice: hn,
            step: Ir,
            string: $e,
            "to-boolean": Xe,
            "to-color": Xe,
            "to-number": Xe,
            "to-string": Xe,
            var: br,
            within: yr
        };
        function Sn(t1, [e1, r, n, i]) {
            e1 = e1.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const s = i ? i.evaluate(t1) : 1, a = Ce(e1, r, n, s);
            if (a) throw new Re(a);
            return new Me(e1 / 255 * s, r / 255 * s, n / 255 * s, s);
        }
        function kn(t1, e1) {
            return t1 in e1;
        }
        function In(t1, e1) {
            const r = e1[t1];
            return void 0 === r ? null : r;
        }
        function Mn(t1) {
            return {
                type: t1
            };
        }
        He.register(An, {
            error: [
                {
                    kind: "error"
                },
                [
                    ae
                ],
                (t1, [e1])=>{
                    throw new Re(e1.evaluate(t1));
                }
            ],
            typeof: [
                ae,
                [
                    ce
                ],
                (t1, [e1])=>ye(De(e1.evaluate(t1)))
            ],
            "to-rgba": [
                de(se, 4),
                [
                    le
                ],
                (t1, [e1])=>e1.evaluate(t1).toArray()
            ],
            rgb: [
                le,
                [
                    se,
                    se,
                    se
                ],
                Sn
            ],
            rgba: [
                le,
                [
                    se,
                    se,
                    se,
                    se
                ],
                Sn
            ],
            has: {
                type: oe,
                overloads: [
                    [
                        [
                            ae
                        ],
                        (t1, [e1])=>kn(e1.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            ae,
                            ue
                        ],
                        (t1, [e1, r])=>kn(e1.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            get: {
                type: ce,
                overloads: [
                    [
                        [
                            ae
                        ],
                        (t1, [e1])=>In(e1.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            ae,
                            ue
                        ],
                        (t1, [e1, r])=>In(e1.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            "feature-state": [
                ce,
                [
                    ae
                ],
                (t1, [e1])=>In(e1.evaluate(t1), t1.featureState || {})
            ],
            properties: [
                ue,
                [],
                (t1)=>t1.properties()
            ],
            "geometry-type": [
                ae,
                [],
                (t1)=>t1.geometryType()
            ],
            id: [
                ce,
                [],
                (t1)=>t1.id()
            ],
            zoom: [
                se,
                [],
                (t1)=>t1.globals.zoom
            ],
            pitch: [
                se,
                [],
                (t1)=>t1.globals.pitch || 0
            ],
            "distance-from-center": [
                se,
                [],
                (t1)=>t1.distanceFromCenter()
            ],
            "heatmap-density": [
                se,
                [],
                (t1)=>t1.globals.heatmapDensity || 0
            ],
            "line-progress": [
                se,
                [],
                (t1)=>t1.globals.lineProgress || 0
            ],
            "sky-radial-progress": [
                se,
                [],
                (t1)=>t1.globals.skyRadialProgress || 0
            ],
            accumulated: [
                ce,
                [],
                (t1)=>void 0 === t1.globals.accumulated ? null : t1.globals.accumulated
            ],
            "+": [
                se,
                Mn(se),
                (t1, e1)=>{
                    let r = 0;
                    for (const n of e1)r += n.evaluate(t1);
                    return r;
                }
            ],
            "*": [
                se,
                Mn(se),
                (t1, e1)=>{
                    let r = 1;
                    for (const n of e1)r *= n.evaluate(t1);
                    return r;
                }
            ],
            "-": {
                type: se,
                overloads: [
                    [
                        [
                            se,
                            se
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) - r.evaluate(t1)
                    ],
                    [
                        [
                            se
                        ],
                        (t1, [e1])=>-e1.evaluate(t1)
                    ]
                ]
            },
            "/": [
                se,
                [
                    se,
                    se
                ],
                (t1, [e1, r])=>e1.evaluate(t1) / r.evaluate(t1)
            ],
            "%": [
                se,
                [
                    se,
                    se
                ],
                (t1, [e1, r])=>e1.evaluate(t1) % r.evaluate(t1)
            ],
            ln2: [
                se,
                [],
                ()=>Math.LN2
            ],
            pi: [
                se,
                [],
                ()=>Math.PI
            ],
            e: [
                se,
                [],
                ()=>Math.E
            ],
            "^": [
                se,
                [
                    se,
                    se
                ],
                (t1, [e1, r])=>Math.pow(e1.evaluate(t1), r.evaluate(t1))
            ],
            sqrt: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.sqrt(e1.evaluate(t1))
            ],
            log10: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1)) / Math.LN10
            ],
            ln: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1))
            ],
            log2: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.log(e1.evaluate(t1)) / Math.LN2
            ],
            sin: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.sin(e1.evaluate(t1))
            ],
            cos: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.cos(e1.evaluate(t1))
            ],
            tan: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.tan(e1.evaluate(t1))
            ],
            asin: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.asin(e1.evaluate(t1))
            ],
            acos: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.acos(e1.evaluate(t1))
            ],
            atan: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.atan(e1.evaluate(t1))
            ],
            min: [
                se,
                Mn(se),
                (t1, e1)=>Math.min(...e1.map((e1)=>e1.evaluate(t1)))
            ],
            max: [
                se,
                Mn(se),
                (t1, e1)=>Math.max(...e1.map((e1)=>e1.evaluate(t1)))
            ],
            abs: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.abs(e1.evaluate(t1))
            ],
            round: [
                se,
                [
                    se
                ],
                (t1, [e1])=>{
                    const r = e1.evaluate(t1);
                    return r < 0 ? -Math.round(-r) : Math.round(r);
                }
            ],
            floor: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.floor(e1.evaluate(t1))
            ],
            ceil: [
                se,
                [
                    se
                ],
                (t1, [e1])=>Math.ceil(e1.evaluate(t1))
            ],
            "filter-==": [
                oe,
                [
                    ae,
                    ce
                ],
                (t1, [e1, r])=>t1.properties()[e1.value] === r.value
            ],
            "filter-id-==": [
                oe,
                [
                    ce
                ],
                (t1, [e1])=>t1.id() === e1.value
            ],
            "filter-type-==": [
                oe,
                [
                    ae
                ],
                (t1, [e1])=>t1.geometryType() === e1.value
            ],
            "filter-<": [
                oe,
                [
                    ae,
                    ce
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n < i;
                }
            ],
            "filter-id-<": [
                oe,
                [
                    ce
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r < n;
                }
            ],
            "filter->": [
                oe,
                [
                    ae,
                    ce
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n > i;
                }
            ],
            "filter-id->": [
                oe,
                [
                    ce
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r > n;
                }
            ],
            "filter-<=": [
                oe,
                [
                    ae,
                    ce
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n <= i;
                }
            ],
            "filter-id-<=": [
                oe,
                [
                    ce
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r <= n;
                }
            ],
            "filter->=": [
                oe,
                [
                    ae,
                    ce
                ],
                (t1, [e1, r])=>{
                    const n = t1.properties()[e1.value], i = r.value;
                    return typeof n == typeof i && n >= i;
                }
            ],
            "filter-id->=": [
                oe,
                [
                    ce
                ],
                (t1, [e1])=>{
                    const r = t1.id(), n = e1.value;
                    return typeof r == typeof n && r >= n;
                }
            ],
            "filter-has": [
                oe,
                [
                    ce
                ],
                (t1, [e1])=>e1.value in t1.properties()
            ],
            "filter-has-id": [
                oe,
                [],
                (t1)=>null !== t1.id() && void 0 !== t1.id()
            ],
            "filter-type-in": [
                oe,
                [
                    de(ae)
                ],
                (t1, [e1])=>e1.value.indexOf(t1.geometryType()) >= 0
            ],
            "filter-id-in": [
                oe,
                [
                    de(ce)
                ],
                (t1, [e1])=>e1.value.indexOf(t1.id()) >= 0
            ],
            "filter-in-small": [
                oe,
                [
                    ae,
                    de(ce)
                ],
                (t1, [e1, r])=>r.value.indexOf(t1.properties()[e1.value]) >= 0
            ],
            "filter-in-large": [
                oe,
                [
                    ae,
                    de(ce)
                ],
                (t1, [e1, r])=>(function(t1, e1, r, n) {
                        for(; r <= n;){
                            const i = r + n >> 1;
                            if (e1[i] === t1) return !0;
                            e1[i] > t1 ? n = i - 1 : r = i + 1;
                        }
                        return !1;
                    })(t1.properties()[e1.value], r.value, 0, r.value.length - 1)
            ],
            all: {
                type: oe,
                overloads: [
                    [
                        [
                            oe,
                            oe
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) && r.evaluate(t1)
                    ],
                    [
                        Mn(oe),
                        (t1, e1)=>{
                            for (const r of e1)if (!r.evaluate(t1)) return !1;
                            return !0;
                        }
                    ]
                ]
            },
            any: {
                type: oe,
                overloads: [
                    [
                        [
                            oe,
                            oe
                        ],
                        (t1, [e1, r])=>e1.evaluate(t1) || r.evaluate(t1)
                    ],
                    [
                        Mn(oe),
                        (t1, e1)=>{
                            for (const r of e1)if (r.evaluate(t1)) return !0;
                            return !1;
                        }
                    ]
                ]
            },
            "!": [
                oe,
                [
                    oe
                ],
                (t1, [e1])=>!e1.evaluate(t1)
            ],
            "is-supported-script": [
                oe,
                [
                    ae
                ],
                (t1, [e1])=>{
                    const r = t1.globals && t1.globals.isSupportedScript;
                    return !r || r(e1.evaluate(t1));
                }
            ],
            upcase: [
                ae,
                [
                    ae
                ],
                (t1, [e1])=>e1.evaluate(t1).toUpperCase()
            ],
            downcase: [
                ae,
                [
                    ae
                ],
                (t1, [e1])=>e1.evaluate(t1).toLowerCase()
            ],
            concat: [
                ae,
                Mn(ce),
                (t1, e1)=>e1.map((e1)=>Ve(e1.evaluate(t1))).join("")
            ],
            "resolved-locale": [
                ae,
                [
                    he
                ],
                (t1, [e1])=>e1.evaluate(t1).resolvedLocale()
            ]
        });
        var Tn = An;
        function zn(t1) {
            return {
                result: "success",
                value: t1
            };
        }
        function Bn(t1) {
            return {
                result: "error",
                value: t1
            };
        }
        function En(t1) {
            return "data-driven" === t1["property-type"];
        }
        function Cn(t1) {
            return !!t1.expression && t1.expression.parameters.indexOf("zoom") > -1;
        }
        function Pn(t1) {
            return !!t1.expression && t1.expression.interpolated;
        }
        function Dn(t1) {
            return t1 instanceof Number ? "number" : t1 instanceof String ? "string" : t1 instanceof Boolean ? "boolean" : Array.isArray(t1) ? "array" : null === t1 ? "null" : typeof t1;
        }
        function Vn(t1) {
            return "object" == typeof t1 && null !== t1 && !Array.isArray(t1);
        }
        function Ln(t1) {
            return t1;
        }
        function Fn(t1, e1) {
            const r = "color" === e1.type, n = t1.stops && "object" == typeof t1.stops[0][0], i = n || !(n || void 0 !== t1.property), s = t1.type || (Pn(e1) ? "exponential" : "interval");
            if (r && ((t1 = Wt({}, t1)).stops && (t1.stops = t1.stops.map((t1)=>[
                    t1[0],
                    Me.parse(t1[1])
                ])), t1.default = Me.parse(t1.default ? t1.default : e1.default)), t1.colorSpace && "rgb" !== t1.colorSpace && !Gr[t1.colorSpace]) throw new Error(`Unknown color space: ${t1.colorSpace}`);
            let a, o, l;
            if ("exponential" === s) a = $n;
            else if ("interval" === s) a = Un;
            else if ("categorical" === s) {
                a = jn, o = Object.create(null);
                for (const e1 of t1.stops)o[e1[0]] = e1[1];
                l = typeof t1.stops[0][0];
            } else {
                if ("identity" !== s) throw new Error(`Unknown function type "${s}"`);
                a = On;
            }
            if (n) {
                const r = {}, n = [];
                for(let e1 = 0; e1 < t1.stops.length; e1++){
                    const i = t1.stops[e1], s = i[0].zoom;
                    void 0 === r[s] && (r[s] = {
                        zoom: s,
                        type: t1.type,
                        property: t1.property,
                        default: t1.default,
                        stops: []
                    }, n.push(s)), r[s].stops.push([
                        i[0].value,
                        i[1]
                    ]);
                }
                const i = [];
                for (const t1 of n)i.push([
                    r[t1].zoom,
                    Fn(r[t1], e1)
                ]);
                const s = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: s,
                    interpolationFactor: Kr.interpolationFactor.bind(void 0, s),
                    zoomStops: i.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r  }, n)=>$n({
                            stops: i,
                            base: t1.base
                        }, e1, r).evaluate(r, n)
                };
            }
            if (i) {
                const r = "exponential" === s ? {
                    name: "exponential",
                    base: void 0 !== t1.base ? t1.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r,
                    interpolationFactor: Kr.interpolationFactor.bind(void 0, r),
                    zoomStops: t1.stops.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r  })=>a(t1, e1, r, o, l)
                };
            }
            return {
                kind: "source",
                evaluate (r, n) {
                    const i = n && n.properties ? n.properties[t1.property] : void 0;
                    return void 0 === i ? Rn(t1.default, e1.default) : a(t1, e1, i, o, l);
                }
            };
        }
        function Rn(t1, e1, r) {
            return void 0 !== t1 ? t1 : void 0 !== e1 ? e1 : void 0 !== r ? r : void 0;
        }
        function jn(t1, e1, r, n, i) {
            return Rn(typeof r === i ? n[r] : void 0, t1.default, e1.default);
        }
        function Un(t1, e1, r) {
            if ("number" !== Dn(r)) return Rn(t1.default, e1.default);
            const n = t1.stops.length;
            if (1 === n) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[n - 1][0]) return t1.stops[n - 1][1];
            const i = Sr(t1.stops.map((t1)=>t1[0]), r);
            return t1.stops[i][1];
        }
        function $n(t1, e1, r) {
            const n = void 0 !== t1.base ? t1.base : 1;
            if ("number" !== Dn(r)) return Rn(t1.default, e1.default);
            const i = t1.stops.length;
            if (1 === i) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[i - 1][0]) return t1.stops[i - 1][1];
            const s = Sr(t1.stops.map((t1)=>t1[0]), r), a = function(t1, e1, r, n) {
                const i = n - r, s = t1 - r;
                return 0 === i ? 0 : 1 === e1 ? s / i : (Math.pow(e1, s) - 1) / (Math.pow(e1, i) - 1);
            }(r, n, t1.stops[s][0], t1.stops[s + 1][0]), o = t1.stops[s][1], l = t1.stops[s + 1][1];
            let u = Tr[e1.type] || Ln;
            if (t1.colorSpace && "rgb" !== t1.colorSpace) {
                const e1 = Gr[t1.colorSpace];
                u = (t1, r)=>e1.reverse(e1.interpolate(e1.forward(t1), e1.forward(r), a));
            }
            return "function" == typeof o.evaluate ? {
                evaluate (...t1) {
                    const e1 = o.evaluate.apply(void 0, t1), r = l.evaluate.apply(void 0, t1);
                    if (void 0 !== e1 && void 0 !== r) return u(e1, r, a);
                }
            } : u(o, l, a);
        }
        function On(t1, e1, r) {
            return "color" === e1.type ? r = Me.parse(r) : "formatted" === e1.type ? r = Be.fromString(r.toString()) : "resolvedImage" === e1.type ? r = Ee.fromString(r.toString()) : Dn(r) === e1.type || "enum" === e1.type && e1.values[r] || (r = void 0), Rn(r, t1.default, e1.default);
        }
        class qn {
            constructor(t1, e1){
                this.expression = t1, this._warningHistory = {}, this._evaluator = new Ke, this._defaultValue = e1 ? function(t1) {
                    return "color" === t1.type && (Vn(t1.default) || Array.isArray(t1.default)) ? new Me(0, 0, 0, 0) : "color" === t1.type ? Me.parse(t1.default) || null : void 0 === t1.default ? null : t1.default;
                }(e1) : null, this._enumValues = e1 && "enum" === e1.type ? e1.values : null;
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, s, a, o) {
                return this._evaluator.globals = t1, this._evaluator.feature = e1, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t1, e1, r, n, i, s, a, o) {
                this._evaluator.globals = t1, this._evaluator.feature = e1 || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;
                try {
                    const t1 = this.expression.evaluate(this._evaluator);
                    if (null == t1 || "number" == typeof t1 && t1 != t1) return this._defaultValue;
                    if (this._enumValues && !(t1 in this._enumValues)) throw new Re(`Expected value to be one of ${Object.keys(this._enumValues).map((t1)=>JSON.stringify(t1)).join(", ")}, but found ${JSON.stringify(t1)} instead.`);
                    return t1;
                } catch (t1) {
                    return this._warningHistory[t1.message] || (this._warningHistory[t1.message] = !0, "undefined" != typeof console && console.warn(t1.message)), this._defaultValue;
                }
            }
        }
        function Nn(t1) {
            return Array.isArray(t1) && t1.length > 0 && "string" == typeof t1[0] && t1[0] in Tn;
        }
        function Gn(t1, e1) {
            const r = new _r(Tn, [], e1 ? function(t1) {
                const e1 = {
                    color: le,
                    string: ae,
                    number: se,
                    enum: ae,
                    boolean: oe,
                    formatted: pe,
                    resolvedImage: fe
                };
                return "array" === t1.type ? de(e1[t1.value] || ce, t1.length) : e1[t1.type];
            }(e1) : void 0), n = r.parse(t1, void 0, void 0, void 0, e1 && "string" === e1.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return n ? zn(new qn(n, e1)) : Bn(r.errors);
        }
        class Xn {
            constructor(t1, e1){
                this.kind = t1, this._styleExpression = e1, this.isStateDependent = "constant" !== t1 && !gr(e1.expression);
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e1, r, n, i, s);
            }
            evaluate(t1, e1, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e1, r, n, i, s);
            }
        }
        class Zn {
            constructor(t1, e1, r, n){
                this.kind = t1, this.zoomStops = r, this._styleExpression = e1, this.isStateDependent = "camera" !== t1 && !gr(e1.expression), this.interpolationType = n;
            }
            evaluateWithoutErrorHandling(t1, e1, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e1, r, n, i, s);
            }
            evaluate(t1, e1, r, n, i, s) {
                return this._styleExpression.evaluate(t1, e1, r, n, i, s);
            }
            interpolationFactor(t1, e1, r) {
                return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, t1, e1, r) : 0;
            }
        }
        function Kn(t1, e1) {
            if ("error" === (t1 = Gn(t1, e1)).result) return t1;
            const r = t1.value.expression, n = mr(r);
            if (!n && !En(e1)) return Bn([
                new ee("", "data expressions not supported")
            ]);
            const i = xr(r, [
                "zoom",
                "pitch",
                "distance-from-center"
            ]);
            if (!i && !Cn(e1)) return Bn([
                new ee("", "zoom expressions not supported")
            ]);
            const s = Hn(r);
            return s || i ? s instanceof ee ? Bn([
                s
            ]) : s instanceof Kr && !Pn(e1) ? Bn([
                new ee("", '"interpolate" expressions cannot be used with this property')
            ]) : zn(s ? new Zn(n ? "camera" : "composite", t1.value, s.labels, s instanceof Kr ? s.interpolation : void 0) : new Xn(n ? "constant" : "source", t1.value)) : Bn([
                new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')
            ]);
        }
        class Yn {
            constructor(t1, e1){
                this._parameters = t1, this._specification = e1, Wt(this, Fn(this._parameters, this._specification));
            }
            static deserialize(t1) {
                return new Yn(t1._parameters, t1._specification);
            }
            static serialize(t1) {
                return {
                    _parameters: t1._parameters,
                    _specification: t1._specification
                };
            }
        }
        function Hn(t1) {
            let e1 = null;
            if (t1 instanceof Jr) e1 = Hn(t1.result);
            else if (t1 instanceof Hr) {
                for (const r of t1.args)if (e1 = Hn(r), e1) break;
            } else (t1 instanceof Ir || t1 instanceof Kr) && t1.input instanceof He && "zoom" === t1.input.name && (e1 = t1);
            return e1 instanceof ee || t1.eachChild((t1)=>{
                const r = Hn(t1);
                r instanceof ee ? e1 = r : !e1 && r ? e1 = new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e1 && r && e1 !== r && (e1 = new ee("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e1;
        }
        class Wn {
            constructor(t1, e1, r, n){
                this.message = (t1 ? `${t1}: ` : "") + r, n && (this.identifier = n), null != e1 && e1.__line__ && (this.line = e1.__line__);
            }
        }
        function Jn(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec || {}, i = t1.objectElementValidators || {}, s = t1.style, a = t1.styleSpec;
            let o = [];
            const l = Dn(r);
            if ("object" !== l) return [
                new Wn(e1, r, `object expected, ${l} found`)
            ];
            for(const t1 in r){
                const l = t1.split(".")[0], u = n[l] || n["*"];
                let c;
                i[l] ? c = i[l] : n[l] ? c = Ci : i["*"] ? c = i["*"] : n["*"] && (c = Ci), c ? o = o.concat(c({
                    key: (e1 ? `${e1}.` : e1) + t1,
                    value: r[t1],
                    valueSpec: u,
                    style: s,
                    styleSpec: a,
                    object: r,
                    objectKey: t1
                }, r)) : o.push(new Wn(e1, r[t1], `unknown property "${t1}"`));
            }
            for(const t1 in n)i[t1] || n[t1].required && void 0 === n[t1].default && void 0 === r[t1] && o.push(new Wn(e1, r, `missing required property "${t1}"`));
            return o;
        }
        function Qn(t1) {
            const e1 = t1.value, r = t1.valueSpec, n = t1.style, i = t1.styleSpec, s = t1.key, a = t1.arrayElementValidator || Ci;
            if ("array" !== Dn(e1)) return [
                new Wn(s, e1, `array expected, ${Dn(e1)} found`)
            ];
            if (r.length && e1.length !== r.length) return [
                new Wn(s, e1, `array length ${r.length} expected, length ${e1.length} found`)
            ];
            if (r["min-length"] && e1.length < r["min-length"]) return [
                new Wn(s, e1, `array length at least ${r["min-length"]} expected, length ${e1.length} found`)
            ];
            let o = {
                type: r.value,
                values: r.values,
                minimum: r.minimum,
                maximum: r.maximum,
                function: void 0
            };
            i.$version < 7 && (o.function = r.function), "object" === Dn(r.value) && (o = r.value);
            let l = [];
            for(let t1 = 0; t1 < e1.length; t1++)l = l.concat(a({
                array: e1,
                arrayIndex: t1,
                value: e1[t1],
                valueSpec: o,
                style: n,
                styleSpec: i,
                key: `${s}[${t1}]`
            }));
            return l;
        }
        function ti(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec;
            let i = Dn(r);
            if ("number" === i && r != r && (i = "NaN"), "number" !== i) return [
                new Wn(e1, r, `number expected, ${i} found`)
            ];
            if ("minimum" in n) {
                let i = n.minimum;
                if ("array" === Dn(n.minimum) && (i = n.minimum[t1.arrayIndex]), r < i) return [
                    new Wn(e1, r, `${r} is less than the minimum value ${i}`)
                ];
            }
            if ("maximum" in n) {
                let i = n.maximum;
                if ("array" === Dn(n.maximum) && (i = n.maximum[t1.arrayIndex]), r > i) return [
                    new Wn(e1, r, `${r} is greater than the maximum value ${i}`)
                ];
            }
            return [];
        }
        function ei(t1) {
            const e1 = t1.valueSpec, r = Jt(t1.value.type);
            let n, i, s, a = {};
            const o = "categorical" !== r && void 0 === t1.value.property, l = !o, u = "array" === Dn(t1.value.stops) && "array" === Dn(t1.value.stops[0]) && "object" === Dn(t1.value.stops[0][0]), c = Jn({
                key: t1.key,
                value: t1.value,
                valueSpec: t1.styleSpec.function,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    stops: function(t1) {
                        if ("identity" === r) return [
                            new Wn(t1.key, t1.value, 'identity function may not have a "stops" property')
                        ];
                        let e1 = [];
                        const n = t1.value;
                        return e1 = e1.concat(Qn({
                            key: t1.key,
                            value: n,
                            valueSpec: t1.valueSpec,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            arrayElementValidator: h
                        })), "array" === Dn(n) && 0 === n.length && e1.push(new Wn(t1.key, n, "array must have at least one stop")), e1;
                    },
                    default: function(t1) {
                        return Ci({
                            key: t1.key,
                            value: t1.value,
                            valueSpec: e1,
                            style: t1.style,
                            styleSpec: t1.styleSpec
                        });
                    }
                }
            });
            return "identity" === r && o && c.push(new Wn(t1.key, t1.value, 'missing required property "property"')), "identity" === r || t1.value.stops || c.push(new Wn(t1.key, t1.value, 'missing required property "stops"')), "exponential" === r && t1.valueSpec.expression && !Pn(t1.valueSpec) && c.push(new Wn(t1.key, t1.value, "exponential functions not supported")), t1.styleSpec.$version >= 8 && (l && !En(t1.valueSpec) ? c.push(new Wn(t1.key, t1.value, "property functions not supported")) : o && !Cn(t1.valueSpec) && c.push(new Wn(t1.key, t1.value, "zoom functions not supported"))), "categorical" !== r && !u || void 0 !== t1.value.property || c.push(new Wn(t1.key, t1.value, '"property" property is required')), c;
            function h(t1) {
                let r = [];
                const n = t1.value, o = t1.key;
                if ("array" !== Dn(n)) return [
                    new Wn(o, n, `array expected, ${Dn(n)} found`)
                ];
                if (2 !== n.length) return [
                    new Wn(o, n, `array length 2 expected, length ${n.length} found`)
                ];
                if (u) {
                    if ("object" !== Dn(n[0])) return [
                        new Wn(o, n, `object expected, ${Dn(n[0])} found`)
                    ];
                    if (void 0 === n[0].zoom) return [
                        new Wn(o, n, "object stop key must have zoom")
                    ];
                    if (void 0 === n[0].value) return [
                        new Wn(o, n, "object stop key must have value")
                    ];
                    const e1 = Jt(n[0].zoom);
                    if ("number" != typeof e1) return [
                        new Wn(o, n[0].zoom, "stop zoom values must be numbers")
                    ];
                    if (s && s > e1) return [
                        new Wn(o, n[0].zoom, "stop zoom values must appear in ascending order")
                    ];
                    e1 !== s && (s = e1, i = void 0, a = {}), r = r.concat(Jn({
                        key: `${o}[0]`,
                        value: n[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t1.style,
                        styleSpec: t1.styleSpec,
                        objectElementValidators: {
                            zoom: ti,
                            value: p
                        }
                    }));
                } else r = r.concat(p({
                    key: `${o}[0]`,
                    value: n[0],
                    valueSpec: {},
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }, n));
                return Nn(Qt(n[1])) ? r.concat([
                    new Wn(`${o}[1]`, n[1], "expressions are not allowed in function stops.")
                ]) : r.concat(Ci({
                    key: `${o}[1]`,
                    value: n[1],
                    valueSpec: e1,
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }));
            }
            function p(t1, s) {
                const o = Dn(t1.value), l = Jt(t1.value), u = null !== t1.value ? t1.value : s;
                if (n) {
                    if (o !== n) return [
                        new Wn(t1.key, u, `${o} stop domain type must match previous stop domain type ${n}`)
                    ];
                } else n = o;
                if ("number" !== o && "string" !== o && "boolean" !== o && "number" != typeof l && "string" != typeof l && "boolean" != typeof l) return [
                    new Wn(t1.key, u, "stop domain value must be a number, string, or boolean")
                ];
                if ("number" !== o && "categorical" !== r) {
                    let n = `number expected, ${o} found`;
                    return En(e1) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [
                        new Wn(t1.key, u, n)
                    ];
                }
                return "categorical" !== r || "number" !== o || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && "number" == typeof l && "number" == typeof i && void 0 !== i && l < i ? [
                    new Wn(t1.key, u, "stop domain values must appear in ascending order")
                ] : (i = l, "categorical" === r && l in a ? [
                    new Wn(t1.key, u, "stop domain values must be unique")
                ] : (a[l] = !0, [])) : [
                    new Wn(t1.key, u, `integer expected, found ${String(l)}`)
                ];
            }
        }
        function ri(t1) {
            const e1 = ("property" === t1.expressionContext ? Kn : Gn)(Qt(t1.value), t1.valueSpec);
            if ("error" === e1.result) return e1.value.map((e1)=>new Wn(`${t1.key}${e1.key}`, t1.value, e1.message));
            const r = e1.value.expression || e1.value._styleExpression.expression;
            if ("property" === t1.expressionContext && "text-font" === t1.propertyKey && !r.outputDefined()) return [
                new Wn(t1.key, t1.value, `Invalid data expression for "${t1.propertyKey}". Output values must be contained as literals within the expression.`)
            ];
            if ("property" === t1.expressionContext && "layout" === t1.propertyType && !gr(r)) return [
                new Wn(t1.key, t1.value, '"feature-state" data expressions are not supported with layout properties.')
            ];
            if ("filter" === t1.expressionContext) return ni(r, t1);
            if (t1.expressionContext && 0 === t1.expressionContext.indexOf("cluster")) {
                if (!xr(r, [
                    "zoom",
                    "feature-state"
                ])) return [
                    new Wn(t1.key, t1.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
                ];
                if ("cluster-initial" === t1.expressionContext && !mr(r)) return [
                    new Wn(t1.key, t1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
                ];
            }
            return [];
        }
        function ni(t1, e1) {
            const r = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center"
            ]);
            if (e1.valueSpec && e1.valueSpec.expression) for (const t1 of e1.valueSpec.expression.parameters)r.delete(t1);
            if (0 === r.size) return [];
            const n = [];
            return t1 instanceof He && r.has(t1.name) ? [
                new Wn(e1.key, e1.value, `["${t1.name}"] expression is not supported in a filter for a ${e1.object.type} layer with id: ${e1.object.id}`)
            ] : (t1.eachChild((t1)=>{
                n.push(...ni(t1, e1));
            }), n);
        }
        function ii(t1) {
            const e1 = t1.key, r = t1.value, n = t1.valueSpec, i = [];
            return Array.isArray(n.values) ? -1 === n.values.indexOf(Jt(r)) && i.push(new Wn(e1, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(Jt(r)) && i.push(new Wn(e1, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), i;
        }
        function si(t1) {
            if (!0 === t1 || !1 === t1) return !0;
            if (!Array.isArray(t1) || 0 === t1.length) return !1;
            switch(t1[0]){
                case "has":
                    return t1.length >= 2 && "$id" !== t1[1] && "$type" !== t1[1];
                case "in":
                    return t1.length >= 3 && ("string" != typeof t1[1] || Array.isArray(t1[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t1.length || Array.isArray(t1[1]) || Array.isArray(t1[2]);
                case "any":
                case "all":
                    for (const e1 of t1.slice(1))if (!si(e1) && "boolean" != typeof e1) return !1;
                    return !0;
                default:
                    return !0;
            }
        }
        function ai(t1, e1 = "fill") {
            if (null == t1) return {
                filter: ()=>!0,
                needGeometry: !1,
                needFeature: !1
            };
            si(t1) || (t1 = fi(t1));
            const r = t1;
            let n = !0;
            try {
                n = function(t1) {
                    if (!ui(t1)) return t1;
                    let e1 = Qt(t1);
                    return li(e1), e1 = oi(e1), e1;
                }(r);
            } catch (t1) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r, null, 2)}\n        `);
            }
            const i = Ht[`filter_${e1}`], s = Gn(n, i);
            let a = null;
            if ("error" === s.result) throw new Error(s.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
            a = (t1, e1, r)=>s.value.evaluate(t1, e1, {}, r);
            let o = null, l = null;
            if (n !== r) {
                const t1 = Gn(r, i);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                o = (e1, r, n, i, s)=>t1.value.evaluate(e1, r, {}, n, void 0, void 0, i, s), l = !mr(t1.value.expression);
            }
            return {
                filter: a,
                dynamicFilter: o || void 0,
                needGeometry: pi(n),
                needFeature: !!l
            };
        }
        function oi(t1) {
            if (!Array.isArray(t1)) return t1;
            const e1 = function(t1) {
                if (ci.has(t1[0])) {
                    for(let e1 = 1; e1 < t1.length; e1++)if (ui(t1[e1])) return !0;
                }
                return t1;
            }(t1);
            return !0 === e1 ? e1 : e1.map((t1)=>oi(t1));
        }
        function li(t1) {
            let e1 = !1;
            const r = [];
            if ("case" === t1[0]) {
                for(let n = 1; n < t1.length - 1; n += 2)e1 = e1 || ui(t1[n]), r.push(t1[n + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("match" === t1[0]) {
                e1 = e1 || ui(t1[1]);
                for(let e1 = 2; e1 < t1.length - 1; e1 += 2)r.push(t1[e1 + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("step" === t1[0]) {
                e1 = e1 || ui(t1[1]);
                for(let e1 = 1; e1 < t1.length - 1; e1 += 2)r.push(t1[e1 + 1]);
            }
            e1 && (t1.length = 0, t1.push("any", ...r));
            for(let e1 = 1; e1 < t1.length; e1++)li(t1[e1]);
        }
        function ui(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("pitch" === (e1 = t1[0]) || "distance-from-center" === e1) return !0;
            var e1;
            for(let e1 = 1; e1 < t1.length; e1++)if (ui(t1[e1])) return !0;
            return !1;
        }
        const ci = new Set([
            "in",
            "==",
            "!=",
            ">",
            ">=",
            "<",
            "<=",
            "to-boolean"
        ]);
        function hi(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function pi(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("within" === t1[0]) return !0;
            for(let e1 = 1; e1 < t1.length; e1++)if (pi(t1[e1])) return !0;
            return !1;
        }
        function fi(t1) {
            if (!t1) return !0;
            const e1 = t1[0];
            var r;
            return t1.length <= 1 ? "any" !== e1 : "==" === e1 ? di(t1[1], t1[2], "==") : "!=" === e1 ? gi(di(t1[1], t1[2], "==")) : "<" === e1 || ">" === e1 || "<=" === e1 || ">=" === e1 ? di(t1[1], t1[2], e1) : "any" === e1 ? (r = t1.slice(1), [
                "any"
            ].concat(r.map(fi))) : "all" === e1 ? [
                "all"
            ].concat(t1.slice(1).map(fi)) : "none" === e1 ? [
                "all"
            ].concat(t1.slice(1).map(fi).map(gi)) : "in" === e1 ? yi(t1[1], t1.slice(2)) : "!in" === e1 ? gi(yi(t1[1], t1.slice(2))) : "has" === e1 ? mi(t1[1]) : "!has" === e1 ? gi(mi(t1[1])) : "within" !== e1 || t1;
        }
        function di(t1, e1, r) {
            switch(t1){
                case "$type":
                    return [
                        `filter-type-${r}`,
                        e1
                    ];
                case "$id":
                    return [
                        `filter-id-${r}`,
                        e1
                    ];
                default:
                    return [
                        `filter-${r}`,
                        t1,
                        e1
                    ];
            }
        }
        function yi(t1, e1) {
            if (0 === e1.length) return !1;
            switch(t1){
                case "$type":
                    return [
                        "filter-type-in",
                        [
                            "literal",
                            e1
                        ]
                    ];
                case "$id":
                    return [
                        "filter-id-in",
                        [
                            "literal",
                            e1
                        ]
                    ];
                default:
                    return e1.length > 200 && !e1.some((t1)=>typeof t1 != typeof e1[0]) ? [
                        "filter-in-large",
                        t1,
                        [
                            "literal",
                            e1.sort(hi)
                        ]
                    ] : [
                        "filter-in-small",
                        t1,
                        [
                            "literal",
                            e1
                        ]
                    ];
            }
        }
        function mi(t1) {
            switch(t1){
                case "$type":
                    return !0;
                case "$id":
                    return [
                        "filter-has-id"
                    ];
                default:
                    return [
                        "filter-has",
                        t1
                    ];
            }
        }
        function gi(t1) {
            return [
                "!",
                t1
            ];
        }
        function xi(t1) {
            return si(Qt(t1.value)) ? ri(Wt({}, t1, {
                expressionContext: "filter",
                valueSpec: t1.styleSpec[`filter_${t1.layerType || "fill"}`]
            })) : vi(t1);
        }
        function vi(t1) {
            const e1 = t1.value, r = t1.key;
            if ("array" !== Dn(e1)) return [
                new Wn(r, e1, `array expected, ${Dn(e1)} found`)
            ];
            const n = t1.styleSpec;
            let i, s = [];
            if (e1.length < 1) return [
                new Wn(r, e1, "filter array must have at least 1 element")
            ];
            switch(s = s.concat(ii({
                key: `${r}[0]`,
                value: e1[0],
                valueSpec: n.filter_operator,
                style: t1.style,
                styleSpec: t1.styleSpec
            })), Jt(e1[0])){
                case "<":
                case "<=":
                case ">":
                case ">=":
                    e1.length >= 2 && "$type" === Jt(e1[1]) && s.push(new Wn(r, e1, `"$type" cannot be use with operator "${e1[0]}"`));
                case "==":
                case "!=":
                    3 !== e1.length && s.push(new Wn(r, e1, `filter array for operator "${e1[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    e1.length >= 2 && (i = Dn(e1[1]), "string" !== i && s.push(new Wn(`${r}[1]`, e1[1], `string expected, ${i} found`)));
                    for(let a = 2; a < e1.length; a++)i = Dn(e1[a]), "$type" === Jt(e1[1]) ? s = s.concat(ii({
                        key: `${r}[${a}]`,
                        value: e1[a],
                        valueSpec: n.geometry_type,
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    })) : "string" !== i && "number" !== i && "boolean" !== i && s.push(new Wn(`${r}[${a}]`, e1[a], `string, number, or boolean expected, ${i} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for(let n = 1; n < e1.length; n++)s = s.concat(vi({
                        key: `${r}[${n}]`,
                        value: e1[n],
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    }));
                    break;
                case "has":
                case "!has":
                    i = Dn(e1[1]), 2 !== e1.length ? s.push(new Wn(r, e1, `filter array for "${e1[0]}" operator must have 2 elements`)) : "string" !== i && s.push(new Wn(`${r}[1]`, e1[1], `string expected, ${i} found`));
                    break;
                case "within":
                    i = Dn(e1[1]), 2 !== e1.length ? s.push(new Wn(r, e1, `filter array for "${e1[0]}" operator must have 2 elements`)) : "object" !== i && s.push(new Wn(`${r}[1]`, e1[1], `object expected, ${i} found`));
            }
            return s;
        }
        function bi(t1, e1) {
            const r = t1.key, n = t1.style, i = t1.styleSpec, s = t1.value, a = t1.objectKey, o = i[`${e1}_${t1.layerType}`];
            if (!o) return [];
            const l = a.match(/^(.*)-transition$/);
            if ("paint" === e1 && l && o[l[1]] && o[l[1]].transition) return Ci({
                key: r,
                value: s,
                valueSpec: i.transition,
                style: n,
                styleSpec: i
            });
            const u = t1.valueSpec || o[a];
            if (!u) return [
                new Wn(r, s, `unknown property "${a}"`)
            ];
            let c;
            if ("string" === Dn(s) && En(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) return [
                new Wn(r, s, `"${a}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c[1])} }\`.`)
            ];
            const h = [];
            return "symbol" === t1.layerType && ("text-field" === a && n && !n.glyphs && h.push(new Wn(r, s, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a && Vn(Qt(s)) && "identity" === Jt(s.type) && h.push(new Wn(r, s, '"text-font" does not support identity functions'))), h.concat(Ci({
                key: t1.key,
                value: s,
                valueSpec: u,
                style: n,
                styleSpec: i,
                expressionContext: "property",
                propertyType: e1,
                propertyKey: a
            }));
        }
        function wi(t1) {
            return bi(t1, "paint");
        }
        function _i(t1) {
            return bi(t1, "layout");
        }
        function Ai(t1) {
            let e1 = [];
            const r = t1.value, n = t1.key, i = t1.style, s = t1.styleSpec;
            r.type || r.ref || e1.push(new Wn(n, r, 'either "type" or "ref" is required'));
            let a = Jt(r.type);
            const o = Jt(r.ref);
            if (r.id) {
                const s = Jt(r.id);
                for(let a = 0; a < t1.arrayIndex; a++){
                    const t1 = i.layers[a];
                    Jt(t1.id) === s && e1.push(new Wn(n, r.id, `duplicate layer id "${r.id}", previously used at line ${t1.id.__line__}`));
                }
            }
            if ("ref" in r) {
                let t1;
                [
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout"
                ].forEach((t1)=>{
                    t1 in r && e1.push(new Wn(n, r[t1], `"${t1}" is prohibited for ref layers`));
                }), i.layers.forEach((e1)=>{
                    Jt(e1.id) === o && (t1 = e1);
                }), t1 ? t1.ref ? e1.push(new Wn(n, r.ref, "ref cannot reference another ref layer")) : a = Jt(t1.type) : "string" == typeof o && e1.push(new Wn(n, r.ref, `ref layer "${o}" not found`));
            } else if ("background" !== a && "sky" !== a) {
                if (r.source) {
                    const t1 = i.sources && i.sources[r.source], s = t1 && Jt(t1.type);
                    t1 ? "vector" === s && "raster" === a ? e1.push(new Wn(n, r.source, `layer "${r.id}" requires a raster source`)) : "raster" === s && "raster" !== a ? e1.push(new Wn(n, r.source, `layer "${r.id}" requires a vector source`)) : "vector" !== s || r["source-layer"] ? "raster-dem" === s && "hillshade" !== a ? e1.push(new Wn(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a || !r.paint || !r.paint["line-gradient"] && !r.paint["line-trim-offset"] || "geojson" === s && t1.lineMetrics || e1.push(new Wn(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e1.push(new Wn(n, r, `layer "${r.id}" must specify a "source-layer"`)) : e1.push(new Wn(n, r.source, `source "${r.source}" not found`));
                } else e1.push(new Wn(n, r, 'missing required property "source"'));
            }
            return e1 = e1.concat(Jn({
                key: n,
                value: r,
                valueSpec: s.layer,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    "*": ()=>[],
                    type: ()=>Ci({
                            key: `${n}.type`,
                            value: r.type,
                            valueSpec: s.layer.type,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            object: r,
                            objectKey: "type"
                        }),
                    filter: (t1)=>xi(Wt({
                            layerType: a
                        }, t1)),
                    layout: (t1)=>Jn({
                            layer: r,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>_i(Wt({
                                        layerType: a
                                    }, t1))
                            }
                        }),
                    paint: (t1)=>Jn({
                            layer: r,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>wi(Wt({
                                        layerType: a
                                    }, t1))
                            }
                        })
                }
            })), e1;
        }
        function Si(t1) {
            const e1 = t1.value, r = t1.key, n = Dn(e1);
            return "string" !== n ? [
                new Wn(r, e1, `string expected, ${n} found`)
            ] : [];
        }
        const ki = {
            promoteId: function({ key: t1 , value: e1  }) {
                if ("string" === Dn(e1)) return Si({
                    key: t1,
                    value: e1
                });
                {
                    const r = [];
                    for(const n in e1)r.push(...Si({
                        key: `${t1}.${n}`,
                        value: e1[n]
                    }));
                    return r;
                }
            }
        };
        function Ii(t1) {
            const e1 = t1.value, r = t1.key, n = t1.styleSpec, i = t1.style;
            if (!e1.type) return [
                new Wn(r, e1, '"type" is required')
            ];
            const s = Jt(e1.type);
            let a;
            switch(s){
                case "vector":
                case "raster":
                case "raster-dem":
                    return a = Jn({
                        key: r,
                        value: e1,
                        valueSpec: n[`source_${s.replace("-", "_")}`],
                        style: t1.style,
                        styleSpec: n,
                        objectElementValidators: ki
                    }), a;
                case "geojson":
                    if (a = Jn({
                        key: r,
                        value: e1,
                        valueSpec: n.source_geojson,
                        style: i,
                        styleSpec: n,
                        objectElementValidators: ki
                    }), e1.cluster) for(const t1 in e1.clusterProperties){
                        const [n, i] = e1.clusterProperties[t1], s = "string" == typeof n ? [
                            n,
                            [
                                "accumulated"
                            ],
                            [
                                "get",
                                t1
                            ]
                        ] : n;
                        a.push(...ri({
                            key: `${r}.${t1}.map`,
                            value: i,
                            expressionContext: "cluster-map"
                        })), a.push(...ri({
                            key: `${r}.${t1}.reduce`,
                            value: s,
                            expressionContext: "cluster-reduce"
                        }));
                    }
                    return a;
                case "video":
                    return Jn({
                        key: r,
                        value: e1,
                        valueSpec: n.source_video,
                        style: i,
                        styleSpec: n
                    });
                case "image":
                    return Jn({
                        key: r,
                        value: e1,
                        valueSpec: n.source_image,
                        style: i,
                        styleSpec: n
                    });
                case "canvas":
                    return [
                        new Wn(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
                    ];
                default:
                    return ii({
                        key: `${r}.type`,
                        value: e1.type,
                        valueSpec: {
                            values: Mi(n)
                        },
                        style: i,
                        styleSpec: n
                    });
            }
        }
        function Mi(t1) {
            return t1.source.reduce((e1, r)=>{
                const n = t1[r];
                return "enum" === n.type.type && (e1 = e1.concat(Object.keys(n.type.values))), e1;
            }, []);
        }
        function Ti(t1) {
            const e1 = t1.value, r = t1.styleSpec, n = r.light, i = t1.style;
            let s = [];
            const a = Dn(e1);
            if (void 0 === e1) return s;
            if ("object" !== a) return s = s.concat([
                new Wn("light", e1, `object expected, ${a} found`)
            ]), s;
            for(const t1 in e1){
                const a = t1.match(/^(.*)-transition$/);
                s = s.concat(a && n[a[1]] && n[a[1]].transition ? Ci({
                    key: t1,
                    value: e1[t1],
                    valueSpec: r.transition,
                    style: i,
                    styleSpec: r
                }) : n[t1] ? Ci({
                    key: t1,
                    value: e1[t1],
                    valueSpec: n[t1],
                    style: i,
                    styleSpec: r
                }) : [
                    new Wn(t1, e1[t1], `unknown property "${t1}"`)
                ]);
            }
            return s;
        }
        function zi(t1) {
            const e1 = t1.value, r = t1.key, n = t1.style, i = t1.styleSpec, s = i.terrain;
            let a = [];
            const o = Dn(e1);
            if (void 0 === e1) return a;
            if ("object" !== o) return a = a.concat([
                new Wn("terrain", e1, `object expected, ${o} found`)
            ]), a;
            for(const t1 in e1){
                const r = t1.match(/^(.*)-transition$/);
                a = a.concat(r && s[r[1]] && s[r[1]].transition ? Ci({
                    key: t1,
                    value: e1[t1],
                    valueSpec: i.transition,
                    style: n,
                    styleSpec: i
                }) : s[t1] ? Ci({
                    key: t1,
                    value: e1[t1],
                    valueSpec: s[t1],
                    style: n,
                    styleSpec: i
                }) : [
                    new Wn(t1, e1[t1], `unknown property "${t1}"`)
                ]);
            }
            if (e1.source) {
                const t1 = n.sources && n.sources[e1.source], i = t1 && Jt(t1.type);
                t1 ? "raster-dem" !== i && a.push(new Wn(r, e1.source, `terrain cannot be used with a source of type ${String(i)}, it only be used with a "raster-dem" source type`)) : a.push(new Wn(r, e1.source, `source "${e1.source}" not found`));
            } else a.push(new Wn(r, e1, 'terrain is missing required property "source"'));
            return a;
        }
        function Bi(t1) {
            const e1 = t1.value, r = t1.style, n = t1.styleSpec, i = n.fog;
            let s = [];
            const a = Dn(e1);
            if (void 0 === e1) return s;
            if ("object" !== a) return s = s.concat([
                new Wn("fog", e1, `object expected, ${a} found`)
            ]), s;
            for(const t1 in e1){
                const a = t1.match(/^(.*)-transition$/);
                s = s.concat(a && i[a[1]] && i[a[1]].transition ? Ci({
                    key: t1,
                    value: e1[t1],
                    valueSpec: n.transition,
                    style: r,
                    styleSpec: n
                }) : i[t1] ? Ci({
                    key: t1,
                    value: e1[t1],
                    valueSpec: i[t1],
                    style: r,
                    styleSpec: n
                }) : [
                    new Wn(t1, e1[t1], `unknown property "${t1}"`)
                ]);
            }
            return s;
        }
        const Ei = {
            "*": ()=>[],
            array: Qn,
            boolean: function(t1) {
                const e1 = t1.value, r = t1.key, n = Dn(e1);
                return "boolean" !== n ? [
                    new Wn(r, e1, `boolean expected, ${n} found`)
                ] : [];
            },
            number: ti,
            color: function(t1) {
                const e1 = t1.key, r = t1.value, n = Dn(r);
                return "string" !== n ? [
                    new Wn(e1, r, `color expected, ${n} found`)
                ] : null === be(r) ? [
                    new Wn(e1, r, `color expected, "${r}" found`)
                ] : [];
            },
            enum: ii,
            filter: xi,
            function: ei,
            layer: Ai,
            object: Jn,
            source: Ii,
            light: Ti,
            terrain: zi,
            fog: Bi,
            string: Si,
            formatted: function(t1) {
                return 0 === Si(t1).length ? [] : ri(t1);
            },
            resolvedImage: function(t1) {
                return 0 === Si(t1).length ? [] : ri(t1);
            },
            projection: function(t1) {
                const e1 = t1.value, r = t1.styleSpec, n = r.projection, i = t1.style;
                let s = [];
                const a = Dn(e1);
                if ("object" === a) for(const t1 in e1)s = s.concat(Ci({
                    key: t1,
                    value: e1[t1],
                    valueSpec: n[t1],
                    style: i,
                    styleSpec: r
                }));
                else "string" !== a && (s = s.concat([
                    new Wn("projection", e1, `object or string expected, ${a} found`)
                ]));
                return s;
            }
        };
        function Ci(t1) {
            const e1 = t1.value, r = t1.valueSpec, n = t1.styleSpec;
            return r.expression && Vn(Jt(e1)) ? ei(t1) : r.expression && Nn(Qt(e1)) ? ri(t1) : r.type && Ei[r.type] ? Ei[r.type](t1) : Jn(Wt({}, t1, {
                valueSpec: r.type ? n[r.type] : r
            }));
        }
        function Pi(t1) {
            const e1 = t1.value, r = t1.key, n = Si(t1);
            return n.length || (-1 === e1.indexOf("{fontstack}") && n.push(new Wn(r, e1, '"glyphs" url must include a "{fontstack}" token')), -1 === e1.indexOf("{range}") && n.push(new Wn(r, e1, '"glyphs" url must include a "{range}" token'))), n;
        }
        function Di(t1, e1 = Ht) {
            return Fi(Ci({
                key: "",
                value: t1,
                valueSpec: e1.$root,
                styleSpec: e1,
                style: t1,
                objectElementValidators: {
                    glyphs: Pi,
                    "*": ()=>[]
                }
            }));
        }
        const Vi = (t1)=>Fi(wi(t1)), Li = (t1)=>Fi(_i(t1));
        function Fi(t1) {
            return t1.slice().sort((t1, e1)=>t1.line && e1.line ? t1.line - e1.line : 0);
        }
        function Ri(t1, e1) {
            let r = !1;
            if (e1 && e1.length) for (const n of e1)t1.fire(new Kt(new Error(n.message))), r = !0;
            return r;
        }
        var ji = Ui;
        function Ui(t1, e1, r) {
            var n = this.cells = [];
            if (t1 instanceof ArrayBuffer) {
                this.arrayBuffer = t1;
                var i = new Int32Array(this.arrayBuffer);
                t1 = i[0], this.d = (e1 = i[1]) + 2 * (r = i[2]);
                for(var s = 0; s < this.d * this.d; s++){
                    var a = i[3 + s], o = i[3 + s + 1];
                    n.push(a === o ? null : i.subarray(a, o));
                }
                var l = i[3 + n.length + 1];
                this.keys = i.subarray(i[3 + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;
            } else {
                this.d = e1 + 2 * r;
                for(var u = 0; u < this.d * this.d; u++)n.push([]);
                this.keys = [], this.bboxes = [];
            }
            this.n = e1, this.extent = t1, this.padding = r, this.scale = e1 / t1, this.uid = 0;
            var c = r / e1 * t1;
            this.min = -c, this.max = t1 + c;
        }
        Ui.prototype.insert = function(t1, e1, r, n, i) {
            this._forEachCell(e1, r, n, i, this._insertCell, this.uid++), this.keys.push(t1), this.bboxes.push(e1), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
        }, Ui.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, Ui.prototype._insertCell = function(t1, e1, r, n, i, s) {
            this.cells[i].push(s);
        }, Ui.prototype.query = function(t1, e1, r, n, i) {
            var s = this.min, a = this.max;
            if (t1 <= s && e1 <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);
            var o = [];
            return this._forEachCell(t1, e1, r, n, this._queryCell, o, {}, i), o;
        }, Ui.prototype._queryCell = function(t1, e1, r, n, i, s, a, o) {
            var l = this.cells[i];
            if (null !== l) for(var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++){
                var p = l[h];
                if (void 0 === a[p]) {
                    var f = 4 * p;
                    (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t1 <= c[f + 2] && e1 <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;
                }
            }
        }, Ui.prototype._forEachCell = function(t1, e1, r, n, i, s, a, o) {
            for(var l = this._convertToCellCoord(t1), u = this._convertToCellCoord(e1), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++)for(var f = u; f <= h; f++){
                var d = this.d * f + p;
                if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t1, e1, r, n, d, s, a, o)) return;
            }
        }, Ui.prototype._convertFromCellCoord = function(t1) {
            return (t1 - this.padding) / this.scale;
        }, Ui.prototype._convertToCellCoord = function(t1) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t1 * this.scale) + this.padding));
        }, Ui.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer) return this.arrayBuffer;
            for(var t1 = this.cells, e1 = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++)r += this.cells[n].length;
            var i = new Int32Array(e1 + r + this.keys.length + this.bboxes.length);
            i[0] = this.extent, i[1] = this.n, i[2] = this.padding;
            for(var s = e1, a = 0; a < t1.length; a++){
                var o = t1[a];
                i[3 + a] = s, i.set(o, s), s += o.length;
            }
            return i[3 + t1.length] = s, i.set(this.keys, s), i[3 + t1.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;
        };
        const $i = {};
        function Oi(t1, e1, r = {}) {
            Object.defineProperty(t1, "_classRegistryKey", {
                value: e1,
                writeable: !1
            }), $i[e1] = {
                klass: t1,
                omit: r.omit || []
            };
        }
        Oi(Object, "Object"), ji.serialize = function(t1, e1) {
            const r = t1.toArrayBuffer();
            return e1 && e1.push(r), {
                buffer: r
            };
        }, ji.deserialize = function(t1) {
            return new ji(t1.buffer);
        }, Object.defineProperty(ji, "name", {
            value: "Grid"
        }), Oi(ji, "Grid"), Oi(Me, "Color"), Oi(Error, "Error"), Oi(at, "AJAXError"), Oi(Ee, "ResolvedImage"), Oi(Yn, "StylePropertyFunction"), Oi(qn, "StyleExpression", {
            omit: [
                "_evaluator"
            ]
        }), Oi(Zn, "ZoomDependentExpression"), Oi(Xn, "ZoomConstantExpression"), Oi(He, "CompoundExpression", {
            omit: [
                "_evaluate"
            ]
        });
        for(const t1 in Tn)$i[Tn[t1]._classRegistryKey] || Oi(Tn[t1], `Expression${t1}`);
        function qi(t1) {
            return t1 && "undefined" != typeof ArrayBuffer && (t1 instanceof ArrayBuffer || t1.constructor && "ArrayBuffer" === t1.constructor.name);
        }
        function Ni(t1) {
            return e1.ImageBitmap && t1 instanceof e1.ImageBitmap;
        }
        function Gi(t1, r) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp) return t1;
            if (qi(t1) || Ni(t1)) return r && r.push(t1), t1;
            if (ArrayBuffer.isView(t1)) {
                const e1 = t1;
                return r && r.push(e1.buffer), e1;
            }
            if (t1 instanceof e1.ImageData) return r && r.push(t1.data.buffer), t1;
            if (Array.isArray(t1)) {
                const e1 = [];
                for (const n of t1)e1.push(Gi(n, r));
                return e1;
            }
            if ("object" == typeof t1) {
                const e1 = t1.constructor, n = e1._classRegistryKey;
                if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);
                const i = e1.serialize ? e1.serialize(t1, r) : {};
                if (!e1.serialize) {
                    for(const e1 in t1)t1.hasOwnProperty(e1) && ($i[n].omit.indexOf(e1) >= 0 || (i[e1] = Gi(t1[e1], r)));
                    t1 instanceof Error && (i.message = t1.message);
                }
                if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n && (i.$name = n), i;
            }
            throw new Error("can't serialize object of type " + typeof t1);
        }
        function Xi(t1) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp || qi(t1) || Ni(t1) || ArrayBuffer.isView(t1) || t1 instanceof e1.ImageData) return t1;
            if (Array.isArray(t1)) return t1.map(Xi);
            if ("object" == typeof t1) {
                const e1 = t1.$name || "Object", { klass: r  } = $i[e1];
                if (!r) throw new Error(`can't deserialize unregistered class ${e1}`);
                if (r.deserialize) return r.deserialize(t1);
                const n = Object.create(r.prototype);
                for (const e1 of Object.keys(t1))"$name" !== e1 && (n[e1] = Xi(t1[e1]));
                return n;
            }
            throw new Error("can't deserialize object of type " + typeof t1);
        }
        const Zi = (t1)=>t1 >= 1536 && t1 <= 1791, Ki = (t1)=>t1 >= 1872 && t1 <= 1919, Yi = (t1)=>t1 >= 2208 && t1 <= 2303, Hi = (t1)=>t1 >= 11904 && t1 <= 12031, Wi = (t1)=>t1 >= 12032 && t1 <= 12255, Ji = (t1)=>t1 >= 12272 && t1 <= 12287, Qi = (t1)=>t1 >= 12288 && t1 <= 12351, ts = (t1)=>t1 >= 12352 && t1 <= 12447, es = (t1)=>t1 >= 12448 && t1 <= 12543, rs = (t1)=>t1 >= 12544 && t1 <= 12591, ns = (t1)=>t1 >= 12704 && t1 <= 12735, is = (t1)=>t1 >= 12736 && t1 <= 12783, ss = (t1)=>t1 >= 12784 && t1 <= 12799, as = (t1)=>t1 >= 12800 && t1 <= 13055, os = (t1)=>t1 >= 13056 && t1 <= 13311, ls = (t1)=>t1 >= 13312 && t1 <= 19903, us = (t1)=>t1 >= 19968 && t1 <= 40959, cs = (t1)=>t1 >= 40960 && t1 <= 42127, hs = (t1)=>t1 >= 42128 && t1 <= 42191, ps = (t1)=>t1 >= 44032 && t1 <= 55215, fs = (t1)=>t1 >= 63744 && t1 <= 64255, ds = (t1)=>t1 >= 64336 && t1 <= 65023, ys = (t1)=>t1 >= 65040 && t1 <= 65055, ms = (t1)=>t1 >= 65072 && t1 <= 65103, gs = (t1)=>t1 >= 65104 && t1 <= 65135, xs = (t1)=>t1 >= 65136 && t1 <= 65279, vs = (t1)=>t1 >= 65280 && t1 <= 65519;
        function bs(t1) {
            for (const e1 of t1)if (As(e1.charCodeAt(0))) return !0;
            return !1;
        }
        function ws(t1) {
            for (const e1 of t1)if (!_s(e1.charCodeAt(0))) return !1;
            return !0;
        }
        function _s(t1) {
            return !(Zi(t1) || Ki(t1) || Yi(t1) || ds(t1) || xs(t1));
        }
        function As(t1) {
            return !(746 !== t1 && 747 !== t1 && (t1 < 4352 || !(ns(t1) || rs(t1) || ms(t1) && !(t1 >= 65097 && t1 <= 65103) || fs(t1) || os(t1) || Hi(t1) || is(t1) || !(!Qi(t1) || t1 >= 12296 && t1 <= 12305 || t1 >= 12308 && t1 <= 12319 || 12336 === t1) || ls(t1) || us(t1) || as(t1) || ((t1)=>t1 >= 12592 && t1 <= 12687)(t1) || ((t1)=>t1 >= 43360 && t1 <= 43391)(t1) || ((t1)=>t1 >= 55216 && t1 <= 55295)(t1) || ((t1)=>t1 >= 4352 && t1 <= 4607)(t1) || ps(t1) || ts(t1) || Ji(t1) || ((t1)=>t1 >= 12688 && t1 <= 12703)(t1) || Wi(t1) || ss(t1) || es(t1) && 12540 !== t1 || !(!vs(t1) || 65288 === t1 || 65289 === t1 || 65293 === t1 || t1 >= 65306 && t1 <= 65310 || 65339 === t1 || 65341 === t1 || 65343 === t1 || t1 >= 65371 && t1 <= 65503 || 65507 === t1 || t1 >= 65512 && t1 <= 65519) || !(!gs(t1) || t1 >= 65112 && t1 <= 65118 || t1 >= 65123 && t1 <= 65126) || ((t1)=>t1 >= 5120 && t1 <= 5759)(t1) || ((t1)=>t1 >= 6320 && t1 <= 6399)(t1) || ys(t1) || ((t1)=>t1 >= 19904 && t1 <= 19967)(t1) || cs(t1) || hs(t1))));
        }
        function Ss(t1) {
            return !(As(t1) || function(t1) {
                return !!(((t1)=>t1 >= 128 && t1 <= 255)(t1) && (167 === t1 || 169 === t1 || 174 === t1 || 177 === t1 || 188 === t1 || 189 === t1 || 190 === t1 || 215 === t1 || 247 === t1) || ((t1)=>t1 >= 8192 && t1 <= 8303)(t1) && (8214 === t1 || 8224 === t1 || 8225 === t1 || 8240 === t1 || 8241 === t1 || 8251 === t1 || 8252 === t1 || 8258 === t1 || 8263 === t1 || 8264 === t1 || 8265 === t1 || 8273 === t1) || ((t1)=>t1 >= 8448 && t1 <= 8527)(t1) || ((t1)=>t1 >= 8528 && t1 <= 8591)(t1) || ((t1)=>t1 >= 8960 && t1 <= 9215)(t1) && (t1 >= 8960 && t1 <= 8967 || t1 >= 8972 && t1 <= 8991 || t1 >= 8996 && t1 <= 9e3 || 9003 === t1 || t1 >= 9085 && t1 <= 9114 || t1 >= 9150 && t1 <= 9165 || 9167 === t1 || t1 >= 9169 && t1 <= 9179 || t1 >= 9186 && t1 <= 9215) || ((t1)=>t1 >= 9216 && t1 <= 9279)(t1) && 9251 !== t1 || ((t1)=>t1 >= 9280 && t1 <= 9311)(t1) || ((t1)=>t1 >= 9312 && t1 <= 9471)(t1) || ((t1)=>t1 >= 9632 && t1 <= 9727)(t1) || ((t1)=>t1 >= 9728 && t1 <= 9983)(t1) && !(t1 >= 9754 && t1 <= 9759) || ((t1)=>t1 >= 11008 && t1 <= 11263)(t1) && (t1 >= 11026 && t1 <= 11055 || t1 >= 11088 && t1 <= 11097 || t1 >= 11192 && t1 <= 11243) || Qi(t1) || es(t1) || ((t1)=>t1 >= 57344 && t1 <= 63743)(t1) || ms(t1) || gs(t1) || vs(t1) || 8734 === t1 || 8756 === t1 || 8757 === t1 || t1 >= 9984 && t1 <= 10087 || t1 >= 10102 && t1 <= 10131 || 65532 === t1 || 65533 === t1);
            }(t1));
        }
        function ks(t1) {
            return t1 >= 1424 && t1 <= 2303 || ds(t1) || xs(t1);
        }
        function Is(t1, e1) {
            return !(!e1 && ks(t1) || t1 >= 2304 && t1 <= 3583 || t1 >= 3840 && t1 <= 4255 || ((t1)=>t1 >= 6016 && t1 <= 6143)(t1));
        }
        function Ms(t1) {
            for (const e1 of t1)if (ks(e1.charCodeAt(0))) return !0;
            return !1;
        }
        const Ts = "deferred", zs = "loading", Bs = "loaded";
        let Es = null, Cs = "unavailable", Ps = null;
        const Ds = function(t1) {
            t1 && "string" == typeof t1 && t1.indexOf("NetworkError") > -1 && (Cs = "error"), Es && Es(t1);
        };
        function Vs() {
            Ls.fire(new Zt("pluginStateChange", {
                pluginStatus: Cs,
                pluginURL: Ps
            }));
        }
        const Ls = new Yt, Fs = function() {
            return Cs;
        }, Rs = function() {
            if (Cs !== Ts || !Ps) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Cs = zs, Vs(), Ps && ut({
                url: Ps
            }, (t1)=>{
                t1 ? Ds(t1) : (Cs = Bs, Vs());
            });
        }, js = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>Cs === Bs || null != js.applyArabicShaping,
            isLoading: ()=>Cs === zs,
            setState (t1) {
                Cs = t1.pluginStatus, Ps = t1.pluginURL;
            },
            isParsed: ()=>null != js.applyArabicShaping && null != js.processBidirectionalText && null != js.processStyledBidirectionalText,
            getPluginURL: ()=>Ps
        };
        class Us {
            constructor(t1, e1){
                this.zoom = t1, e1 ? (this.now = e1.now, this.fadeDuration = e1.fadeDuration, this.transition = e1.transition, this.pitch = e1.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
            }
            isSupportedScript(t1) {
                return function(t1, e1) {
                    for (const r of t1)if (!Is(r.charCodeAt(0), e1)) return !1;
                    return !0;
                }(t1, js.isLoaded());
            }
        }
        class $s {
            constructor(t1, e1){
                this.property = t1, this.value = e1, this.expression = function(t1, e1) {
                    if (Vn(t1)) return new Yn(t1, e1);
                    if (Nn(t1)) {
                        const r = Kn(t1, e1);
                        if ("error" === r.result) throw new Error(r.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                        return r.value;
                    }
                    {
                        let r = t1;
                        return "string" == typeof t1 && "color" === e1.type && (r = Me.parse(t1)), {
                            kind: "constant",
                            evaluate: ()=>r
                        };
                    }
                }(void 0 === e1 ? t1.specification.default : e1, t1.specification);
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t1, e1, r) {
                return this.property.possiblyEvaluate(this, t1, e1, r);
            }
        }
        class Os {
            constructor(t1){
                this.property = t1, this.value = new $s(t1, void 0);
            }
            transitioned(t1, e1) {
                return new Ns(this.property, this.value, e1, z({}, t1.transition, this.transition), t1.now);
            }
            untransitioned() {
                return new Ns(this.property, this.value, null, {}, 0);
            }
        }
        class qs {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitionablePropertyValues);
            }
            getValue(t1) {
                return j(this._values[t1].value.value);
            }
            setValue(t1, e1) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new Os(this._values[t1].property)), this._values[t1].value = new $s(this._values[t1].property, null === e1 ? void 0 : j(e1));
            }
            getTransition(t1) {
                return j(this._values[t1].transition);
            }
            setTransition(t1, e1) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new Os(this._values[t1].property)), this._values[t1].transition = j(e1) || void 0;
            }
            serialize() {
                const t1 = {};
                for (const e1 of Object.keys(this._values)){
                    const r = this.getValue(e1);
                    void 0 !== r && (t1[e1] = r);
                    const n = this.getTransition(e1);
                    void 0 !== n && (t1[`${e1}-transition`] = n);
                }
                return t1;
            }
            transitioned(t1, e1) {
                const r = new Gs(this._properties);
                for (const n of Object.keys(this._values))r._values[n] = this._values[n].transitioned(t1, e1._values[n]);
                return r;
            }
            untransitioned() {
                const t1 = new Gs(this._properties);
                for (const e1 of Object.keys(this._values))t1._values[e1] = this._values[e1].untransitioned();
                return t1;
            }
        }
        class Ns {
            constructor(t1, e1, r, n, i){
                const s = n.delay || 0, a = n.duration || 0;
                i = i || 0, this.property = t1, this.value = e1, this.begin = i + s, this.end = this.begin + a, t1.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }
            possiblyEvaluate(t1, e1, r) {
                const n = t1.now || 0, i = this.value.possiblyEvaluate(t1, e1, r), s = this.prior;
                if (s) {
                    if (n > this.end) return this.prior = null, i;
                    if (this.value.isDataDriven()) return this.prior = null, i;
                    if (n < this.begin) return s.possiblyEvaluate(t1, e1, r);
                    {
                        const a = (n - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(s.possiblyEvaluate(t1, e1, r), i, w(a));
                    }
                }
                return i;
            }
        }
        class Gs {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t1, e1, r) {
                const n = new Ks(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e1, r);
                return n;
            }
            hasTransition() {
                for (const t1 of Object.keys(this._values))if (this._values[t1].prior) return !0;
                return !1;
            }
        }
        class Xs {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPropertyValues);
            }
            getValue(t1) {
                return j(this._values[t1].value);
            }
            setValue(t1, e1) {
                this._values[t1] = new $s(this._values[t1].property, null === e1 ? void 0 : j(e1));
            }
            serialize() {
                const t1 = {};
                for (const e1 of Object.keys(this._values)){
                    const r = this.getValue(e1);
                    void 0 !== r && (t1[e1] = r);
                }
                return t1;
            }
            possiblyEvaluate(t1, e1, r) {
                const n = new Ks(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e1, r);
                return n;
            }
        }
        class Zs {
            constructor(t1, e1, r){
                this.property = t1, this.value = e1, this.parameters = r;
            }
            isConstant() {
                return "constant" === this.value.kind;
            }
            constantOr(t1) {
                return "constant" === this.value.kind ? this.value.value : t1;
            }
            evaluate(t1, e1, r, n) {
                return this.property.evaluate(this.value, this.parameters, t1, e1, r, n);
            }
        }
        class Ks {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPossiblyEvaluatedValues);
            }
            get(t1) {
                return this._values[t1];
            }
        }
        class Ys {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e1) {
                return t1.expression.evaluate(e1);
            }
            interpolate(t1, e1, r) {
                const n = Tr[this.specification.type];
                return n ? n(t1, e1, r) : t1;
            }
        }
        class Hs {
            constructor(t1, e1){
                this.specification = t1, this.overrides = e1;
            }
            possiblyEvaluate(t1, e1, r, n) {
                return new Zs(this, "constant" === t1.expression.kind || "camera" === t1.expression.kind ? {
                    kind: "constant",
                    value: t1.expression.evaluate(e1, null, {}, r, n)
                } : t1.expression, e1);
            }
            interpolate(t1, e1, r) {
                if ("constant" !== t1.value.kind || "constant" !== e1.value.kind) return t1;
                if (void 0 === t1.value.value || void 0 === e1.value.value) return new Zs(this, {
                    kind: "constant",
                    value: void 0
                }, t1.parameters);
                const n = Tr[this.specification.type];
                return n ? new Zs(this, {
                    kind: "constant",
                    value: n(t1.value.value, e1.value.value, r)
                }, t1.parameters) : t1;
            }
            evaluate(t1, e1, r, n, i, s) {
                return "constant" === t1.kind ? t1.value : t1.evaluate(e1, r, n, i, s);
            }
        }
        class Ws {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e1, r, n) {
                return !!t1.expression.evaluate(e1, null, {}, r, n);
            }
            interpolate() {
                return !1;
            }
        }
        class Js {
            constructor(t1){
                this.properties = t1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                const e1 = new Us(0, {});
                for(const r in t1){
                    const n = t1[r];
                    n.specification.overridable && this.overridableProperties.push(r);
                    const i = this.defaultPropertyValues[r] = new $s(n, void 0), s = this.defaultTransitionablePropertyValues[r] = new Os(n);
                    this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e1);
                }
            }
        }
        function Qs(t1, e1) {
            return 256 * (t1 = S(Math.floor(t1), 0, 255)) + S(Math.floor(e1), 0, 255);
        }
        Oi(Hs, "DataDrivenProperty"), Oi(Ys, "DataConstantProperty"), Oi(Ws, "ColorRampProperty");
        const ta = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class ea {
            constructor(t1, e1){
                this._structArray = t1, this._pos1 = e1 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }
        class ra {
            constructor(){
                this.isTransferred = !1, this.capacity = -1, this.resize(0);
            }
            static serialize(t1, e1) {
                return t1._trim(), e1 && (t1.isTransferred = !0, e1.push(t1.arrayBuffer)), {
                    length: t1.length,
                    arrayBuffer: t1.arrayBuffer
                };
            }
            static deserialize(t1) {
                const e1 = Object.create(this.prototype);
                return e1.arrayBuffer = t1.arrayBuffer, e1.length = t1.length, e1.capacity = t1.arrayBuffer.byteLength / e1.bytesPerElement, e1._refreshViews(), e1;
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t1) {
                this.reserve(t1), this.length = t1;
            }
            reserve(t1) {
                if (t1 > this.capacity) {
                    this.capacity = Math.max(t1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e1 = this.uint8;
                    this._refreshViews(), e1 && this.uint8.set(e1);
                }
            }
            _refreshViews() {
                throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
        }
        function na(t1, e1 = 1) {
            let r = 0, n = 0;
            return {
                members: t1.map((t1)=>{
                    const i = ta[t1.type].BYTES_PER_ELEMENT, s = r = ia(r, Math.max(e1, i)), a = t1.components || 1;
                    return n = Math.max(n, i), r += i * a, {
                        name: t1.name,
                        type: t1.type,
                        components: a,
                        offset: s
                    };
                }),
                size: ia(r, Math.max(n, e1)),
                alignment: e1
            };
        }
        function ia(t1, e1) {
            return Math.ceil(t1 / e1) * e1;
        }
        class sa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.int16[n + 0] = e1, this.int16[n + 1] = r, t1;
            }
        }
        sa.prototype.bytesPerElement = 4, Oi(sa, "StructArrayLayout2i4");
        class aa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.int16[i + 0] = e1, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        aa.prototype.bytesPerElement = 6, Oi(aa, "StructArrayLayout3i6");
        class oa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 4 * t1;
                return this.int16[s + 0] = e1, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t1;
            }
        }
        oa.prototype.bytesPerElement = 8, Oi(oa, "StructArrayLayout4i8");
        class la extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e1, r, n, i, s, a);
            }
            emplace(t1, e1, r, n, i, s, a, o) {
                const l = 6 * t1, u = 12 * t1, c = 3 * t1;
                return this.int16[l + 0] = e1, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t1;
            }
        }
        la.prototype.bytesPerElement = 12, Oi(la, "StructArrayLayout2i4ub1f12");
        class ua extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 4 * t1;
                return this.float32[s + 0] = e1, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t1;
            }
        }
        ua.prototype.bytesPerElement = 16, Oi(ua, "StructArrayLayout4f16");
        class ca extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i);
            }
            emplace(t1, e1, r, n, i, s) {
                const a = 6 * t1, o = 3 * t1;
                return this.uint16[a + 0] = e1, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, this.float32[o + 2] = s, t1;
            }
        }
        ca.prototype.bytesPerElement = 12, Oi(ca, "StructArrayLayout4ui1f12");
        class ha extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 4 * t1;
                return this.uint16[s + 0] = e1, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t1;
            }
        }
        ha.prototype.bytesPerElement = 8, Oi(ha, "StructArrayLayout4ui8");
        class pa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e1, r, n, i, s);
            }
            emplace(t1, e1, r, n, i, s, a) {
                const o = 6 * t1;
                return this.int16[o + 0] = e1, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t1;
            }
        }
        pa.prototype.bytesPerElement = 12, Oi(pa, "StructArrayLayout6i12");
        class fa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a, o, l, u, c, h) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t1, e1, r, n, i, s, a, o, l, u, c, h);
            }
            emplace(t1, e1, r, n, i, s, a, o, l, u, c, h, p) {
                const f = 12 * t1;
                return this.int16[f + 0] = e1, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = s, this.uint16[f + 5] = a, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t1;
            }
        }
        fa.prototype.bytesPerElement = 24, Oi(fa, "StructArrayLayout4i4ui4i24");
        class da extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e1, r, n, i, s);
            }
            emplace(t1, e1, r, n, i, s, a) {
                const o = 10 * t1, l = 5 * t1;
                return this.int16[o + 0] = e1, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t1;
            }
        }
        da.prototype.bytesPerElement = 20, Oi(da, "StructArrayLayout3i3f20");
        class ya extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.uint32[1 * t1 + 0] = e1, t1;
            }
        }
        ya.prototype.bytesPerElement = 4, Oi(ya, "StructArrayLayout1ul4");
        class ma extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a, o, l, u, c, h, p) {
                const f = this.length;
                return this.resize(f + 1), this.emplace(f, t1, e1, r, n, i, s, a, o, l, u, c, h, p);
            }
            emplace(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d = 20 * t1, y = 10 * t1;
                return this.int16[d + 0] = e1, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = s, this.float32[y + 3] = a, this.float32[y + 4] = o, this.float32[y + 5] = l, this.float32[y + 6] = u, this.int16[d + 14] = c, this.uint32[y + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t1;
            }
        }
        ma.prototype.bytesPerElement = 40, Oi(ma, "StructArrayLayout5i4f1i1ul2ui40");
        class ga extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e1, r, n, i, s, a);
            }
            emplace(t1, e1, r, n, i, s, a, o) {
                const l = 8 * t1;
                return this.int16[l + 0] = e1, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t1;
            }
        }
        ga.prototype.bytesPerElement = 16, Oi(ga, "StructArrayLayout3i2i2i16");
        class xa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i);
            }
            emplace(t1, e1, r, n, i, s) {
                const a = 4 * t1, o = 8 * t1;
                return this.float32[a + 0] = e1, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t1;
            }
        }
        xa.prototype.bytesPerElement = 16, Oi(xa, "StructArrayLayout2f1f2i16");
        class va extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 12 * t1, a = 3 * t1;
                return this.uint8[s + 0] = e1, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t1;
            }
        }
        va.prototype.bytesPerElement = 12, Oi(va, "StructArrayLayout2ub2f12");
        class ba extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.float32[i + 0] = e1, this.float32[i + 1] = r, this.float32[i + 2] = n, t1;
            }
        }
        ba.prototype.bytesPerElement = 12, Oi(ba, "StructArrayLayout3f12");
        class wa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e1, r);
            }
            emplace(t1, e1, r, n) {
                const i = 3 * t1;
                return this.uint16[i + 0] = e1, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t1;
            }
        }
        wa.prototype.bytesPerElement = 6, Oi(wa, "StructArrayLayout3ui6");
        class _a extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b) {
                const w = this.length;
                return this.resize(w + 1), this.emplace(w, t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b);
            }
            emplace(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w) {
                const _ = 30 * t1, A = 15 * t1, S = 60 * t1;
                return this.int16[_ + 0] = e1, this.int16[_ + 1] = r, this.int16[_ + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[_ + 8] = a, this.uint16[_ + 9] = o, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[_ + 16] = h, this.uint16[_ + 17] = p, this.uint16[_ + 18] = f, this.float32[A + 10] = d, this.float32[A + 11] = y, this.uint8[S + 48] = m, this.uint8[S + 49] = g, this.uint8[S + 50] = x, this.uint32[A + 13] = v, this.int16[_ + 28] = b, this.uint8[S + 58] = w, t1;
            }
        }
        _a.prototype.bytesPerElement = 60, Oi(_a, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Aa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z) {
                const B = this.length;
                return this.resize(B + 1), this.emplace(B, t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z);
            }
            emplace(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z, B) {
                const E = 38 * t1, C = 19 * t1;
                return this.int16[E + 0] = e1, this.int16[E + 1] = r, this.int16[E + 2] = n, this.float32[C + 2] = i, this.float32[C + 3] = s, this.int16[E + 8] = a, this.int16[E + 9] = o, this.int16[E + 10] = l, this.int16[E + 11] = u, this.int16[E + 12] = c, this.int16[E + 13] = h, this.uint16[E + 14] = p, this.uint16[E + 15] = f, this.uint16[E + 16] = d, this.uint16[E + 17] = y, this.uint16[E + 18] = m, this.uint16[E + 19] = g, this.uint16[E + 20] = x, this.uint16[E + 21] = v, this.uint16[E + 22] = b, this.uint16[E + 23] = w, this.uint16[E + 24] = _, this.uint16[E + 25] = A, this.uint16[E + 26] = S, this.uint16[E + 27] = k, this.uint16[E + 28] = I, this.uint32[C + 15] = M, this.float32[C + 16] = T, this.float32[C + 17] = z, this.float32[C + 18] = B, t1;
            }
        }
        Aa.prototype.bytesPerElement = 76, Oi(Aa, "StructArrayLayout3i2f6i15ui1ul3f76");
        class Sa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.float32[1 * t1 + 0] = e1, t1;
            }
        }
        Sa.prototype.bytesPerElement = 4, Oi(Sa, "StructArrayLayout1f4");
        class ka extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n, i) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e1, r, n, i);
            }
            emplace(t1, e1, r, n, i, s) {
                const a = 5 * t1;
                return this.float32[a + 0] = e1, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t1;
            }
        }
        ka.prototype.bytesPerElement = 20, Oi(ka, "StructArrayLayout5f20");
        class Ia extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e1, r, n);
            }
            emplace(t1, e1, r, n, i) {
                const s = 6 * t1;
                return this.uint32[3 * t1 + 0] = e1, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t1;
            }
        }
        Ia.prototype.bytesPerElement = 12, Oi(Ia, "StructArrayLayout1ul3ui12");
        class Ma extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.uint16[n + 0] = e1, this.uint16[n + 1] = r, t1;
            }
        }
        Ma.prototype.bytesPerElement = 4, Oi(Ma, "StructArrayLayout2ui4");
        class Ta extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e1 = this.length;
                return this.resize(e1 + 1), this.emplace(e1, t1);
            }
            emplace(t1, e1) {
                return this.uint16[1 * t1 + 0] = e1, t1;
            }
        }
        Ta.prototype.bytesPerElement = 2, Oi(Ta, "StructArrayLayout1ui2");
        class za extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e1) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e1);
            }
            emplace(t1, e1, r) {
                const n = 2 * t1;
                return this.float32[n + 0] = e1, this.float32[n + 1] = r, t1;
            }
        }
        za.prototype.bytesPerElement = 8, Oi(za, "StructArrayLayout2f8");
        class Ba extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
        }
        Ba.prototype.size = 40;
        class Ea extends ma {
            get(t1) {
                return new Ba(this, t1);
            }
        }
        Oi(Ea, "CollisionBoxArray");
        class Ca extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t1) {
                this._structArray.uint8[this._pos1 + 49] = t1;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t1) {
                this._structArray.uint8[this._pos1 + 50] = t1;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 13] = t1;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t1) {
                this._structArray.uint8[this._pos1 + 58] = t1;
            }
        }
        Ca.prototype.size = 60;
        class Pa extends _a {
            get(t1) {
                return new Ca(this, t1);
            }
        }
        Oi(Pa, "PlacedSymbolArray");
        class Da extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 13];
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 21];
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 22];
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 23];
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 25];
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 27];
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 28];
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 15];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 15] = t1;
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 16];
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 17];
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 18];
            }
        }
        Da.prototype.size = 76;
        class Va extends Aa {
            get(t1) {
                return new Da(this, t1);
            }
        }
        Oi(Va, "SymbolInstanceArray");
        class La extends Sa {
            getoffsetX(t1) {
                return this.float32[1 * t1 + 0];
            }
        }
        Oi(La, "GlyphOffsetArray");
        class Fa extends sa {
            getx(t1) {
                return this.int16[2 * t1 + 0];
            }
            gety(t1) {
                return this.int16[2 * t1 + 1];
            }
        }
        Oi(Fa, "SymbolLineVertexArray");
        class Ra extends ea {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
            }
        }
        Ra.prototype.size = 12;
        class ja extends Ia {
            get(t1) {
                return new Ra(this, t1);
            }
        }
        Oi(ja, "FeatureIndexArray");
        class Ua extends Ma {
            geta_centroid_pos0(t1) {
                return this.uint16[2 * t1 + 0];
            }
            geta_centroid_pos1(t1) {
                return this.uint16[2 * t1 + 1];
            }
        }
        Oi(Ua, "FillExtrusionCentroidArray");
        const $a = na([
            {
                name: "a_pattern",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio",
                components: 1,
                type: "Float32"
            }
        ]), Oa = na([
            {
                name: "a_dash",
                components: 4,
                type: "Uint16"
            }
        ]);
        var qa = {}, Na = {
            get exports () {
                return qa;
            },
            set exports (t){
                qa = t;
            }
        }, Ga = {};
        ({
            get exports () {
                return Ga;
            },
            set exports (t){
                Ga = t;
            }
        }).exports = function(t1, e1) {
            var r, n, i, s, a, o, l, u;
            for(n = t1.length - (r = 3 & t1.length), i = e1, a = 3432918353, o = 461845907, u = 0; u < n;)l = 255 & t1.charCodeAt(u) | (255 & t1.charCodeAt(++u)) << 8 | (255 & t1.charCodeAt(++u)) << 16 | (255 & t1.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);
            switch(l = 0, r){
                case 3:
                    l ^= (255 & t1.charCodeAt(u + 2)) << 16;
                case 2:
                    l ^= (255 & t1.charCodeAt(u + 1)) << 8;
                case 1:
                    i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t1.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
            }
            return i ^= t1.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
        };
        var Xa = {};
        ({
            get exports () {
                return Xa;
            },
            set exports (t){
                Xa = t;
            }
        }).exports = function(t1, e1) {
            for(var r, n = t1.length, i = e1 ^ n, s = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & t1.charCodeAt(s) | (255 & t1.charCodeAt(++s)) << 8 | (255 & t1.charCodeAt(++s)) << 16 | (255 & t1.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;
            switch(n){
                case 3:
                    i ^= (255 & t1.charCodeAt(s + 2)) << 16;
                case 2:
                    i ^= (255 & t1.charCodeAt(s + 1)) << 8;
                case 1:
                    i = 1540483477 * (65535 & (i ^= 255 & t1.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);
            }
            return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
        };
        var Za = Ga, Ka = Xa;
        Na.exports = Za, qa.murmur3 = Za, qa.murmur2 = Ka;
        class Ya {
            constructor(){
                this.ids = [], this.positions = [], this.indexed = !1;
            }
            add(t1, e1, r, n) {
                this.ids.push(Ha(t1)), this.positions.push(e1, r, n);
            }
            getPositions(t1) {
                const e1 = Ha(t1);
                let r = 0, n = this.ids.length - 1;
                for(; r < n;){
                    const t1 = r + n >> 1;
                    this.ids[t1] >= e1 ? n = t1 : r = t1 + 1;
                }
                const i = [];
                for(; this.ids[r] === e1;)i.push({
                    index: this.positions[3 * r],
                    start: this.positions[3 * r + 1],
                    end: this.positions[3 * r + 2]
                }), r++;
                return i;
            }
            static serialize(t1, e1) {
                const r = new Float64Array(t1.ids), n = new Uint32Array(t1.positions);
                return Wa(r, n, 0, r.length - 1), e1 && e1.push(r.buffer, n.buffer), {
                    ids: r,
                    positions: n
                };
            }
            static deserialize(t1) {
                const e1 = new Ya;
                return e1.ids = t1.ids, e1.positions = t1.positions, e1.indexed = !0, e1;
            }
        }
        function Ha(t1) {
            const e1 = +t1;
            return !isNaN(e1) && Number.MIN_SAFE_INTEGER <= e1 && e1 <= Number.MAX_SAFE_INTEGER ? e1 : qa(String(t1));
        }
        function Wa(t1, e1, r, n) {
            for(; r < n;){
                const i = t1[r + n >> 1];
                let s = r - 1, a = n + 1;
                for(;;){
                    do s++;
                    while (t1[s] < i);
                    do a--;
                    while (t1[a] > i);
                    if (s >= a) break;
                    Ja(t1, s, a), Ja(e1, 3 * s, 3 * a), Ja(e1, 3 * s + 1, 3 * a + 1), Ja(e1, 3 * s + 2, 3 * a + 2);
                }
                a - r < n - a ? (Wa(t1, e1, r, a), r = a + 1) : (Wa(t1, e1, a + 1, n), n = a);
            }
        }
        function Ja(t1, e1, r) {
            const n = t1[e1];
            t1[e1] = t1[r], t1[r] = n;
        }
        Oi(Ya, "FeaturePositionMap");
        class Qa {
            constructor(t1){
                this.gl = t1.gl, this.initialized = !1;
            }
            fetchUniformLocation(t1, e1) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t1, e1), this.initialized = !0), !!this.location;
            }
        }
        class to extends Qa {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
            }
        }
        class eo extends Qa {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0,
                    0
                ];
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }
        class ro extends Qa {
            constructor(t1){
                super(t1), this.current = Me.transparent;
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }
        const no = new Float32Array(16), io = new Float32Array(9), so = new Float32Array(4);
        function ao(t1) {
            return [
                Qs(255 * t1.r, 255 * t1.g),
                Qs(255 * t1.b, 255 * t1.a)
            ];
        }
        class oo {
            constructor(t1, e1, r){
                this.value = t1, this.uniformNames = e1.map((t1)=>`u_${t1}`), this.type = r;
            }
            setUniform(t1, e1, r, n, i) {
                e1.set(t1, i, n.constantOr(this.value));
            }
            getBinding(t1, e1) {
                return "color" === this.type ? new ro(t1) : new to(t1);
            }
        }
        class lo {
            constructor(t1, e1){
                this.uniformNames = e1.map((t1)=>`u_${t1}`), this.pattern = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t1) {
                this.pixelRatio = t1.pixelRatio || 1, this.pattern = t1.tl.concat(t1.br);
            }
            setUniform(t1, e1, r, n, i) {
                const s = "u_pattern" === i || "u_dash" === i ? this.pattern : "u_pixel_ratio" === i ? this.pixelRatio : null;
                s && e1.set(t1, i, s);
            }
            getBinding(t1, e1) {
                return "u_pattern" === e1 || "u_dash" === e1 ? new eo(t1) : new to(t1);
            }
        }
        class uo {
            constructor(t1, e1, r, n){
                this.expression = t1, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e1.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e1, r, n, i, s) {
                const a = this.paintVertexArray.length, o = this.expression.evaluate(new Us(0), e1, {}, i, n, s);
                this.paintVertexArray.resize(t1), this._setPaintValue(a, t1, o);
            }
            updatePaintArray(t1, e1, r, n, i) {
                const s = this.expression.evaluate({
                    zoom: 0
                }, r, n, void 0, i);
                this._setPaintValue(t1, e1, s);
            }
            _setPaintValue(t1, e1, r) {
                if ("color" === this.type) {
                    const n = ao(r);
                    for(let r = t1; r < e1; r++)this.paintVertexArray.emplace(r, n[0], n[1]);
                } else {
                    for(let n = t1; n < e1; n++)this.paintVertexArray.emplace(n, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class co {
            constructor(t1, e1, r, n, i, s){
                this.expression = t1, this.uniformNames = e1.map((t1)=>`u_${t1}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e1.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new s;
            }
            populatePaintArray(t1, e1, r, n, i, s) {
                const a = this.expression.evaluate(new Us(this.zoom), e1, {}, i, n, s), o = this.expression.evaluate(new Us(this.zoom + 1), e1, {}, i, n, s), l = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValue(l, t1, a, o);
            }
            updatePaintArray(t1, e1, r, n, i) {
                const s = this.expression.evaluate({
                    zoom: this.zoom
                }, r, n, void 0, i), a = this.expression.evaluate({
                    zoom: this.zoom + 1
                }, r, n, void 0, i);
                this._setPaintValue(t1, e1, s, a);
            }
            _setPaintValue(t1, e1, r, n) {
                if ("color" === this.type) {
                    const i = ao(r), s = ao(n);
                    for(let r = t1; r < e1; r++)this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);
                } else {
                    for(let i = t1; i < e1; i++)this.paintVertexArray.emplace(i, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t1, e1, r, n, i) {
                const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, a = S(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);
                e1.set(t1, i, a);
            }
            getBinding(t1, e1) {
                return new to(t1);
            }
        }
        class ho {
            constructor(t1, e1, r, n, i){
                this.expression = t1, this.layerId = i, this.paintVertexAttributes = ("array" === r ? Oa : $a).members;
                for(let t1 = 0; t1 < e1.length; ++t1);
                this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e1, r) {
                const n = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValues(n, t1, e1.patterns && e1.patterns[this.layerId], r);
            }
            updatePaintArray(t1, e1, r, n, i, s) {
                this._setPaintValues(t1, e1, r.patterns && r.patterns[this.layerId], s);
            }
            _setPaintValues(t1, e1, r, n) {
                if (!n || !r) return;
                const i = n[r];
                if (!i) return;
                const { tl: s , br: a , pixelRatio: o  } = i;
                for(let r = t1; r < e1; r++)this.paintVertexArray.emplace(r, s[0], s[1], a[0], a[1], o);
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class po {
            constructor(t1, e1, r = ()=>!0){
                this.binders = {}, this._buffers = [];
                const n = [];
                for(const i in t1.paint._values){
                    if (!r(i)) continue;
                    const s = t1.paint.get(i);
                    if (!(s instanceof Zs && En(s.property.specification))) continue;
                    const a = mo(i, t1.type), o = s.value, l = s.property.specification.type, u = s.property.useIntegerZoom, c = "line-dasharray" === i || i.endsWith("pattern"), h = "line-dasharray" === i && "constant" !== t1.layout.get("line-cap").value.kind;
                    if ("constant" !== o.kind || h) {
                        if ("source" === o.kind || h || c) {
                            const e1 = vo(i, l, "source");
                            this.binders[i] = c ? new ho(o, a, l, e1, t1.id) : new uo(o, a, l, e1), n.push(`/a_${i}`);
                        } else {
                            const t1 = vo(i, l, "composite");
                            this.binders[i] = new co(o, a, l, u, e1, t1), n.push(`/z_${i}`);
                        }
                    } else this.binders[i] = c ? new lo(o.value, a) : new oo(o.value, a, l), n.push(`/u_${i}`);
                }
                this.cacheKey = n.sort().join("");
            }
            getMaxValue(t1) {
                const e1 = this.binders[t1];
                return e1 instanceof uo || e1 instanceof co ? e1.maxValue : 0;
            }
            populatePaintArrays(t1, e1, r, n, i, s) {
                for(const a in this.binders){
                    const o = this.binders[a];
                    (o instanceof uo || o instanceof co || o instanceof ho) && o.populatePaintArray(t1, e1, r, n, i, s);
                }
            }
            setConstantPatternPositions(t1) {
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    r instanceof lo && r.setConstantPatternPositions(t1);
                }
            }
            updatePaintArrays(t1, e1, r, n, i, s) {
                let a = !1;
                for(const o in t1){
                    const l = e1.getPositions(o);
                    for (const e1 of l){
                        const l = r.feature(e1.index);
                        for(const r in this.binders){
                            const u = this.binders[r];
                            if ((u instanceof uo || u instanceof co || u instanceof ho) && !0 === u.expression.isStateDependent) {
                                const c = n.paint.get(r);
                                u.expression = c.value, u.updatePaintArray(e1.start, e1.end, l, t1[o], i, s), a = !0;
                            }
                        }
                    }
                }
                return a;
            }
            defines() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    (r instanceof oo || r instanceof lo) && t1.push(...r.uniformNames.map((t1)=>`#define HAS_UNIFORM_${t1}`));
                }
                return t1;
            }
            getBinderAttributes() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    if (r instanceof uo || r instanceof co || r instanceof ho) for(let e1 = 0; e1 < r.paintVertexAttributes.length; e1++)t1.push(r.paintVertexAttributes[e1].name);
                }
                return t1;
            }
            getBinderUniforms() {
                const t1 = [];
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    if (r instanceof oo || r instanceof lo || r instanceof co) for (const e1 of r.uniformNames)t1.push(e1);
                }
                return t1;
            }
            getPaintVertexBuffers() {
                return this._buffers;
            }
            getUniforms(t1) {
                const e1 = [];
                for(const r in this.binders){
                    const n = this.binders[r];
                    if (n instanceof oo || n instanceof lo || n instanceof co) for (const i of n.uniformNames)e1.push({
                        name: i,
                        property: r,
                        binding: n.getBinding(t1, i)
                    });
                }
                return e1;
            }
            setUniforms(t1, e1, r, n, i) {
                for (const { name: e1 , property: s , binding: a  } of r)this.binders[s].setUniform(t1, a, i, n.get(s), e1);
            }
            updatePaintBuffers() {
                this._buffers = [];
                for(const t1 in this.binders){
                    const e1 = this.binders[t1];
                    (e1 instanceof uo || e1 instanceof co || e1 instanceof ho) && e1.paintVertexBuffer && this._buffers.push(e1.paintVertexBuffer);
                }
            }
            upload(t1) {
                for(const e1 in this.binders){
                    const r = this.binders[e1];
                    (r instanceof uo || r instanceof co || r instanceof ho) && r.upload(t1);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for(const t1 in this.binders){
                    const e1 = this.binders[t1];
                    (e1 instanceof uo || e1 instanceof co || e1 instanceof ho) && e1.destroy();
                }
            }
        }
        class fo {
            constructor(t1, e1, r = ()=>!0){
                this.programConfigurations = {};
                for (const n of t1)this.programConfigurations[n.id] = new po(n, e1, r);
                this.needsUpload = !1, this._featureMap = new Ya, this._bufferOffset = 0;
            }
            populatePaintArrays(t1, e1, r, n, i, s, a) {
                for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t1, e1, n, i, s, a);
                void 0 !== e1.id && this._featureMap.add(e1.id, r, this._bufferOffset, t1), this._bufferOffset = t1, this.needsUpload = !0;
            }
            updatePaintArrays(t1, e1, r, n, i) {
                for (const s of r)this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t1, this._featureMap, e1, s, n, i) || this.needsUpload;
            }
            get(t1) {
                return this.programConfigurations[t1];
            }
            upload(t1) {
                if (this.needsUpload) {
                    for(const e1 in this.programConfigurations)this.programConfigurations[e1].upload(t1);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for(const t1 in this.programConfigurations)this.programConfigurations[t1].destroy();
            }
        }
        const yo = {
            "text-opacity": [
                "opacity"
            ],
            "icon-opacity": [
                "opacity"
            ],
            "text-color": [
                "fill_color"
            ],
            "icon-color": [
                "fill_color"
            ],
            "text-halo-color": [
                "halo_color"
            ],
            "icon-halo-color": [
                "halo_color"
            ],
            "text-halo-blur": [
                "halo_blur"
            ],
            "icon-halo-blur": [
                "halo_blur"
            ],
            "text-halo-width": [
                "halo_width"
            ],
            "icon-halo-width": [
                "halo_width"
            ],
            "line-gap-width": [
                "gapwidth"
            ],
            "line-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-extrusion-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "line-dasharray": [
                "dash"
            ]
        };
        function mo(t1, e1) {
            return yo[t1] || [
                t1.replace(`${e1}-`, "").replace(/-/g, "_")
            ];
        }
        const go = {
            "line-pattern": {
                source: ca,
                composite: ca
            },
            "fill-pattern": {
                source: ca,
                composite: ca
            },
            "fill-extrusion-pattern": {
                source: ca,
                composite: ca
            },
            "line-dasharray": {
                source: ha,
                composite: ha
            }
        }, xo = {
            color: {
                source: za,
                composite: ua
            },
            number: {
                source: Sa,
                composite: za
            }
        };
        function vo(t1, e1, r) {
            const n = go[t1];
            return n && n[r] || xo[e1][r];
        }
        Oi(oo, "ConstantBinder"), Oi(lo, "PatternConstantBinder"), Oi(uo, "SourceExpressionBinder"), Oi(ho, "PatternCompositeBinder"), Oi(co, "CompositeExpressionBinder"), Oi(po, "ProgramConfiguration", {
            omit: [
                "_buffers"
            ]
        }), Oi(fo, "ProgramConfigurationSet");
        const bo = "-transition";
        class wo extends Yt {
            constructor(t1, e1){
                if (super(), this.id = t1.id, this.type = t1.type, this._featureFilter = {
                    filter: ()=>!0,
                    needGeometry: !1,
                    needFeature: !1
                }, this._filterCompiled = !1, "custom" !== t1.type && (this.metadata = t1.metadata, this.minzoom = t1.minzoom, this.maxzoom = t1.maxzoom, "background" !== t1.type && "sky" !== t1.type && (this.source = t1.source, this.sourceLayer = t1["source-layer"], this.filter = t1.filter), e1.layout && (this._unevaluatedLayout = new Xs(e1.layout)), e1.paint)) {
                    this._transitionablePaint = new qs(e1.paint);
                    for(const e1 in t1.paint)this.setPaintProperty(e1, t1.paint[e1], {
                        validate: !1
                    });
                    for(const e1 in t1.layout)this.setLayoutProperty(e1, t1.layout[e1], {
                        validate: !1
                    });
                    this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ks(e1.paint);
                }
            }
            getLayoutProperty(t1) {
                return "visibility" === t1 ? this.visibility : this._unevaluatedLayout.getValue(t1);
            }
            setLayoutProperty(t1, e1, r = {}) {
                null != e1 && this._validate(Li, `layers.${this.id}.layout.${t1}`, t1, e1, r) || ("visibility" !== t1 ? this._unevaluatedLayout.setValue(t1, e1) : this.visibility = e1);
            }
            getPaintProperty(t1) {
                return L(t1, bo) ? this._transitionablePaint.getTransition(t1.slice(0, -bo.length)) : this._transitionablePaint.getValue(t1);
            }
            setPaintProperty(t1, e1, r = {}) {
                if (null != e1 && this._validate(Vi, `layers.${this.id}.paint.${t1}`, t1, e1, r)) return !1;
                if (L(t1, bo)) return this._transitionablePaint.setTransition(t1.slice(0, -bo.length), e1 || void 0), !1;
                {
                    const r = this._transitionablePaint._values[t1], n = r.value.isDataDriven(), i = r.value;
                    this._transitionablePaint.setValue(t1, e1), this._handleSpecialPaintPropertyUpdate(t1);
                    const s = this._transitionablePaint._values[t1].value, a = s.isDataDriven(), o = L(t1, "pattern") || "line-dasharray" === t1;
                    return a || n || o || this._handleOverridablePaintPropertyUpdate(t1, i, s);
                }
            }
            _handleSpecialPaintPropertyUpdate(t1) {}
            getProgramIds() {
                return null;
            }
            getProgramConfiguration(t1) {
                return null;
            }
            _handleOverridablePaintPropertyUpdate(t1, e1, r) {
                return !1;
            }
            isHidden(t1) {
                return !!(this.minzoom && t1 < this.minzoom) || !!(this.maxzoom && t1 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t1) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t1, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition();
            }
            recalculate(t1, e1) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t1, void 0, e1)), this.paint = this._transitioningPaint.possiblyEvaluate(t1, void 0, e1);
            }
            serialize() {
                const t1 = {
                    id: this.id,
                    type: this.type,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                };
                return this.visibility && (t1.layout = t1.layout || {}, t1.layout.visibility = this.visibility), R(t1, (t1, e1)=>!(void 0 === t1 || "layout" === e1 && !Object.keys(t1).length || "paint" === e1 && !Object.keys(t1).length));
            }
            _validate(t1, e1, r, n, i = {}) {
                return (!i || !1 !== i.validate) && Ri(this, t1.call(Di, {
                    key: e1,
                    layerType: this.type,
                    objectKey: r,
                    value: n,
                    styleSpec: Ht,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    }
                }));
            }
            is3D() {
                return !1;
            }
            isSky() {
                return !1;
            }
            isTileClipped() {
                return !1;
            }
            hasOffscreenPass() {
                return !1;
            }
            resize() {}
            isStateDependent() {
                for(const t1 in this.paint._values){
                    const e1 = this.paint.get(t1);
                    if (e1 instanceof Zs && En(e1.property.specification) && ("source" === e1.value.kind || "composite" === e1.value.kind) && e1.value.isStateDependent) return !0;
                }
                return !1;
            }
            compileFilter() {
                this._filterCompiled || (this._featureFilter = ai(this.filter), this._filterCompiled = !0);
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
            }
        }
        const _o = na([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), Ao = na([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]);
        class So {
            constructor(t1 = []){
                this.segments = t1;
            }
            prepareSegment(t1, e1, r, n) {
                let i = this.segments[this.segments.length - 1];
                return t1 > So.MAX_VERTEX_ARRAY_LENGTH && $(`Max vertices per segment is ${So.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t1}`), (!i || i.vertexLength + t1 > So.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
                    vertexOffset: e1.length,
                    primitiveOffset: r.length,
                    vertexLength: 0,
                    primitiveLength: 0
                }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
            }
            get() {
                return this.segments;
            }
            destroy() {
                for (const t1 of this.segments)for(const e1 in t1.vaos)t1.vaos[e1].destroy();
            }
            static simpleSegment(t1, e1, r, n) {
                return new So([
                    {
                        vertexOffset: t1,
                        primitiveOffset: e1,
                        vertexLength: r,
                        primitiveLength: n,
                        vaos: {},
                        sortKey: 0
                    }
                ]);
            }
        }
        So.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Oi(So, "SegmentVector");
        var ko = 8192;
        class Io {
            constructor(t1, e1){
                t1 && (e1 ? this.setSouthWest(t1).setNorthEast(e1) : 4 === t1.length ? this.setSouthWest([
                    t1[0],
                    t1[1]
                ]).setNorthEast([
                    t1[2],
                    t1[3]
                ]) : this.setSouthWest(t1[0]).setNorthEast(t1[1]));
            }
            setNorthEast(t1) {
                return this._ne = t1 instanceof ru ? new ru(t1.lng, t1.lat) : ru.convert(t1), this;
            }
            setSouthWest(t1) {
                return this._sw = t1 instanceof ru ? new ru(t1.lng, t1.lat) : ru.convert(t1), this;
            }
            extend(t1) {
                const e1 = this._sw, r = this._ne;
                let n, i;
                if (t1 instanceof ru) n = t1, i = t1;
                else {
                    if (!(t1 instanceof Io)) return Array.isArray(t1) ? 4 === t1.length || t1.every(Array.isArray) ? this.extend(Io.convert(t1)) : this.extend(ru.convert(t1)) : "object" == typeof t1 && null !== t1 && t1.hasOwnProperty("lat") && t1.hasOwnProperty("lon") ? this.extend(ru.convert(t1)) : this;
                    if (n = t1._sw, i = t1._ne, !n || !i) return this;
                }
                return e1 || r ? (e1.lng = Math.min(n.lng, e1.lng), e1.lat = Math.min(n.lat, e1.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new ru(n.lng, n.lat), this._ne = new ru(i.lng, i.lat)), this;
            }
            getCenter() {
                return new ru((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
                return this._sw;
            }
            getNorthEast() {
                return this._ne;
            }
            getNorthWest() {
                return new ru(this.getWest(), this.getNorth());
            }
            getSouthEast() {
                return new ru(this.getEast(), this.getSouth());
            }
            getWest() {
                return this._sw.lng;
            }
            getSouth() {
                return this._sw.lat;
            }
            getEast() {
                return this._ne.lng;
            }
            getNorth() {
                return this._ne.lat;
            }
            toArray() {
                return [
                    this._sw.toArray(),
                    this._ne.toArray()
                ];
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
                return !(this._sw && this._ne);
            }
            contains(t1) {
                const { lng: e1 , lat: r  } = ru.convert(t1);
                let n = this._sw.lng <= e1 && e1 <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e1 && e1 >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
            }
            static convert(t1) {
                return !t1 || t1 instanceof Io ? t1 : new Io(t1);
            }
        }
        var Mo = 1e-6, To = "undefined" != typeof Float32Array ? Float32Array : Array;
        function zo() {
            var t1 = new To(9);
            return To != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[0] = 1, t1[4] = 1, t1[8] = 1, t1;
        }
        function Bo(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = e1[4], l = e1[5], u = e1[6], c = e1[7], h = e1[8], p = r[0], f = r[1], d = r[2], y = r[3], m = r[4], g = r[5], x = r[6], v = r[7], b = r[8];
            return t1[0] = p * n + f * a + d * u, t1[1] = p * i + f * o + d * c, t1[2] = p * s + f * l + d * h, t1[3] = y * n + m * a + g * u, t1[4] = y * i + m * o + g * c, t1[5] = y * s + m * l + g * h, t1[6] = x * n + v * a + b * u, t1[7] = x * i + v * o + b * c, t1[8] = x * s + v * l + b * h, t1;
        }
        function Eo(t1) {
            return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function Co(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = e1[3], a = e1[4], o = e1[5], l = e1[6], u = e1[7], c = e1[8], h = e1[9], p = e1[10], f = e1[11], d = e1[12], y = e1[13], m = e1[14], g = e1[15], x = r * o - n * a, v = r * l - i * a, b = r * u - s * a, w = n * l - i * o, _ = n * u - s * o, A = i * u - s * l, S = c * y - h * d, k = c * m - p * d, I = c * g - f * d, M = h * m - p * y, T = h * g - f * y, z = p * g - f * m, B = x * z - v * T + b * M + w * I - _ * k + A * S;
            return B ? (t1[0] = (o * z - l * T + u * M) * (B = 1 / B), t1[1] = (i * T - n * z - s * M) * B, t1[2] = (y * A - m * _ + g * w) * B, t1[3] = (p * _ - h * A - f * w) * B, t1[4] = (l * I - a * z - u * k) * B, t1[5] = (r * z - i * I + s * k) * B, t1[6] = (m * b - d * A - g * v) * B, t1[7] = (c * A - p * b + f * v) * B, t1[8] = (a * T - o * I + u * S) * B, t1[9] = (n * I - r * T - s * S) * B, t1[10] = (d * _ - y * b + g * x) * B, t1[11] = (h * b - c * _ - f * x) * B, t1[12] = (o * k - a * M - l * S) * B, t1[13] = (r * M - n * k + i * S) * B, t1[14] = (y * v - d * w - m * x) * B, t1[15] = (c * w - h * v + p * x) * B, t1) : null;
        }
        function Po(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = e1[4], l = e1[5], u = e1[6], c = e1[7], h = e1[8], p = e1[9], f = e1[10], d = e1[11], y = e1[12], m = e1[13], g = e1[14], x = e1[15], v = r[0], b = r[1], w = r[2], _ = r[3];
            return t1[0] = v * n + b * o + w * h + _ * y, t1[1] = v * i + b * l + w * p + _ * m, t1[2] = v * s + b * u + w * f + _ * g, t1[3] = v * a + b * c + w * d + _ * x, t1[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * y, t1[5] = v * i + b * l + w * p + _ * m, t1[6] = v * s + b * u + w * f + _ * g, t1[7] = v * a + b * c + w * d + _ * x, t1[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * y, t1[9] = v * i + b * l + w * p + _ * m, t1[10] = v * s + b * u + w * f + _ * g, t1[11] = v * a + b * c + w * d + _ * x, t1[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * y, t1[13] = v * i + b * l + w * p + _ * m, t1[14] = v * s + b * u + w * f + _ * g, t1[15] = v * a + b * c + w * d + _ * x, t1;
        }
        function Do(t1, e1, r) {
            var n, i, s, a, o, l, u, c, h, p, f, d, y = r[0], m = r[1], g = r[2];
            return e1 === t1 ? (t1[12] = e1[0] * y + e1[4] * m + e1[8] * g + e1[12], t1[13] = e1[1] * y + e1[5] * m + e1[9] * g + e1[13], t1[14] = e1[2] * y + e1[6] * m + e1[10] * g + e1[14], t1[15] = e1[3] * y + e1[7] * m + e1[11] * g + e1[15]) : (i = e1[1], s = e1[2], a = e1[3], o = e1[4], l = e1[5], u = e1[6], c = e1[7], h = e1[8], p = e1[9], f = e1[10], d = e1[11], t1[0] = n = e1[0], t1[1] = i, t1[2] = s, t1[3] = a, t1[4] = o, t1[5] = l, t1[6] = u, t1[7] = c, t1[8] = h, t1[9] = p, t1[10] = f, t1[11] = d, t1[12] = n * y + o * m + h * g + e1[12], t1[13] = i * y + l * m + p * g + e1[13], t1[14] = s * y + u * m + f * g + e1[14], t1[15] = a * y + c * m + d * g + e1[15]), t1;
        }
        function Vo(t1, e1, r) {
            var n = r[0], i = r[1], s = r[2];
            return t1[0] = e1[0] * n, t1[1] = e1[1] * n, t1[2] = e1[2] * n, t1[3] = e1[3] * n, t1[4] = e1[4] * i, t1[5] = e1[5] * i, t1[6] = e1[6] * i, t1[7] = e1[7] * i, t1[8] = e1[8] * s, t1[9] = e1[9] * s, t1[10] = e1[10] * s, t1[11] = e1[11] * s, t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15], t1;
        }
        function Lo(t1, e1, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e1[4], a = e1[5], o = e1[6], l = e1[7], u = e1[8], c = e1[9], h = e1[10], p = e1[11];
            return e1 !== t1 && (t1[0] = e1[0], t1[1] = e1[1], t1[2] = e1[2], t1[3] = e1[3], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15]), t1[4] = s * i + u * n, t1[5] = a * i + c * n, t1[6] = o * i + h * n, t1[7] = l * i + p * n, t1[8] = u * i - s * n, t1[9] = c * i - a * n, t1[10] = h * i - o * n, t1[11] = p * i - l * n, t1;
        }
        function Fo(t1, e1, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e1[0], a = e1[1], o = e1[2], l = e1[3], u = e1[8], c = e1[9], h = e1[10], p = e1[11];
            return e1 !== t1 && (t1[4] = e1[4], t1[5] = e1[5], t1[6] = e1[6], t1[7] = e1[7], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15]), t1[0] = s * i - u * n, t1[1] = a * i - c * n, t1[2] = o * i - h * n, t1[3] = l * i - p * n, t1[8] = s * n + u * i, t1[9] = a * n + c * i, t1[10] = o * n + h * i, t1[11] = l * n + p * i, t1;
        }
        function Ro(t1, e1) {
            return t1[0] = e1[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = e1[1], t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = e1[2], t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }
        function jo(t1, e1, r) {
            var n, i, s, a = r[0], o = r[1], l = r[2], u = Math.hypot(a, o, l);
            return u < Mo ? null : (a *= u = 1 / u, o *= u, l *= u, n = Math.sin(e1), i = Math.cos(e1), t1[0] = a * a * (s = 1 - i) + i, t1[1] = o * a * s + l * n, t1[2] = l * a * s - o * n, t1[3] = 0, t1[4] = a * o * s - l * n, t1[5] = o * o * s + i, t1[6] = l * o * s + a * n, t1[7] = 0, t1[8] = a * l * s + o * n, t1[9] = o * l * s - a * n, t1[10] = l * l * s + i, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1);
        }
        Math.hypot || (Math.hypot = function() {
            for(var t1 = 0, e1 = arguments.length; e1--;)t1 += arguments[e1] * arguments[e1];
            return Math.sqrt(t1);
        });
        var Uo = Po;
        function $o() {
            var t1 = new To(3);
            return To != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1;
        }
        function Oo(t1) {
            var e1 = new To(3);
            return e1[0] = t1[0], e1[1] = t1[1], e1[2] = t1[2], e1;
        }
        function qo(t1) {
            return Math.hypot(t1[0], t1[1], t1[2]);
        }
        function No(t1, e1, r) {
            var n = new To(3);
            return n[0] = t1, n[1] = e1, n[2] = r, n;
        }
        function Go(t1, e1, r) {
            return t1[0] = e1[0] + r[0], t1[1] = e1[1] + r[1], t1[2] = e1[2] + r[2], t1;
        }
        function Xo(t1, e1, r) {
            return t1[0] = e1[0] - r[0], t1[1] = e1[1] - r[1], t1[2] = e1[2] - r[2], t1;
        }
        function Zo(t1, e1, r) {
            return t1[0] = e1[0] * r[0], t1[1] = e1[1] * r[1], t1[2] = e1[2] * r[2], t1;
        }
        function Ko(t1, e1, r) {
            return t1[0] = Math.min(e1[0], r[0]), t1[1] = Math.min(e1[1], r[1]), t1[2] = Math.min(e1[2], r[2]), t1;
        }
        function Yo(t1, e1, r) {
            return t1[0] = Math.max(e1[0], r[0]), t1[1] = Math.max(e1[1], r[1]), t1[2] = Math.max(e1[2], r[2]), t1;
        }
        function Ho(t1, e1, r) {
            return t1[0] = e1[0] * r, t1[1] = e1[1] * r, t1[2] = e1[2] * r, t1;
        }
        function Wo(t1, e1, r, n) {
            return t1[0] = e1[0] + r[0] * n, t1[1] = e1[1] + r[1] * n, t1[2] = e1[2] + r[2] * n, t1;
        }
        function Jo(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = r * r + n * n + i * i;
            return s > 0 && (s = 1 / Math.sqrt(s)), t1[0] = e1[0] * s, t1[1] = e1[1] * s, t1[2] = e1[2] * s, t1;
        }
        function Qo(t1, e1) {
            return t1[0] * e1[0] + t1[1] * e1[1] + t1[2] * e1[2];
        }
        function tl(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = r[0], o = r[1], l = r[2];
            return t1[0] = i * l - s * o, t1[1] = s * a - n * l, t1[2] = n * o - i * a, t1;
        }
        function el(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = r[3] * n + r[7] * i + r[11] * s + r[15];
            return t1[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t1[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t1[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t1;
        }
        function rl(t1, e1, r) {
            var n = r[0], i = r[1], s = r[2], a = e1[0], o = e1[1], l = e1[2], u = i * l - s * o, c = s * a - n * l, h = n * o - i * a, p = i * h - s * c, f = s * u - n * h, d = n * c - i * u, y = 2 * r[3];
            return c *= y, h *= y, f *= 2, d *= 2, t1[0] = a + (u *= y) + (p *= 2), t1[1] = o + c + f, t1[2] = l + h + d, t1;
        }
        var nl, il = Xo, sl = Zo, al = qo;
        function ol(t1, e1, r) {
            return t1[0] = e1[0] * r, t1[1] = e1[1] * r, t1[2] = e1[2] * r, t1[3] = e1[3] * r, t1;
        }
        function ll(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = e1[3], a = r * r + n * n + i * i + s * s;
            return a > 0 && (a = 1 / Math.sqrt(a)), t1[0] = r * a, t1[1] = n * a, t1[2] = i * a, t1[3] = s * a, t1;
        }
        function ul(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3];
            return t1[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t1[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t1[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t1[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t1;
        }
        function cl() {
            var t1 = new To(4);
            return To != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1[3] = 1, t1;
        }
        function hl(t1) {
            return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1;
        }
        function pl(t1, e1, r) {
            r *= .5;
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + a * o, t1[1] = i * l + s * o, t1[2] = s * l - i * o, t1[3] = a * l - n * o, t1;
        }
        function fl(t1, e1, r) {
            r *= .5;
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l - s * o, t1[1] = i * l + a * o, t1[2] = s * l + n * o, t1[3] = a * l - i * o, t1;
        }
        $o(), nl = new To(4), To != Float32Array && (nl[0] = 0, nl[1] = 0, nl[2] = 0, nl[3] = 0);
        var dl = ll;
        $o(), No(1, 0, 0), No(0, 1, 0), cl(), cl(), zo();
        const yl = na([
            {
                type: "Float32",
                name: "a_globe_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]), { members: ml  } = yl, gl = na([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }
        ]);
        var xl = na([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            }
        ]);
        class vl {
            constructor(t1, e1){
                this.pos = t1, this.dir = e1;
            }
            intersectsPlane(t1, e1, r) {
                const n = Qo(e1, this.dir);
                if (Math.abs(n) < 1e-6) return !1;
                const i = ((t1[0] - this.pos[0]) * e1[0] + (t1[1] - this.pos[1]) * e1[1] + (t1[2] - this.pos[2]) * e1[2]) / n;
                return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;
            }
            closestPointOnSphere(t1, e1, r) {
                if (function(t1, e1) {
                    var r = t1[0], n = t1[1], i = t1[2], s = e1[0], a = e1[1], o = e1[2];
                    return Math.abs(r - s) <= Mo * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= Mo * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= Mo * Math.max(1, Math.abs(i), Math.abs(o));
                }(this.pos, t1) || 0 === e1) return r[0] = r[1] = r[2] = 0, !1;
                const [n, i, s] = this.dir, a = this.pos[0] - t1[0], o = this.pos[1] - t1[1], l = this.pos[2] - t1[2], u = n * n + i * i + s * s, c = 2 * (a * n + o * i + l * s), h = c * c - 4 * u * (a * a + o * o + l * l - e1 * e1);
                if (h < 0) {
                    const t1 = Math.max(-c / 2, 0), u = a + n * t1, h = o + i * t1, p = l + s * t1, f = Math.hypot(u, h, p);
                    return r[0] = u * e1 / f, r[1] = h * e1 / f, r[2] = p * e1 / f, !1;
                }
                {
                    const t1 = (-c - Math.sqrt(h)) / (2 * u);
                    if (t1 < 0) {
                        const t1 = Math.hypot(a, o, l);
                        return r[0] = a * e1 / t1, r[1] = o * e1 / t1, r[2] = l * e1 / t1, !1;
                    }
                    return r[0] = a + n * t1, r[1] = o + i * t1, r[2] = l + s * t1, !0;
                }
            }
        }
        class bl {
            constructor(t1, e1, r, n, i){
                this.TL = t1, this.TR = e1, this.BR = r, this.BL = n, this.horizon = i;
            }
            static fromInvProjectionMatrix(t1, e1, r) {
                const n = [
                    -1,
                    1,
                    1
                ], i = [
                    1,
                    1,
                    1
                ], s = [
                    1,
                    -1,
                    1
                ], a = [
                    -1,
                    -1,
                    1
                ], o = el(n, n, t1), l = el(i, i, t1), u = el(s, s, t1), c = el(a, a, t1);
                return new bl(o, l, u, c, e1 / r);
            }
        }
        class wl {
            constructor(t1, e1){
                this.points = t1, this.planes = e1;
            }
            static fromInvProjectionMatrix(t1, e1, r, n) {
                const i = Math.pow(2, r), s = [
                    [
                        -1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        -1,
                        1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        1,
                        1
                    ]
                ].map((r)=>{
                    const s = ul([], r, t1), a = 1 / s[3] / e1 * i;
                    return function(t1, e1, r) {
                        return t1[0] = e1[0] * r[0], t1[1] = e1[1] * r[1], t1[2] = e1[2] * r[2], t1[3] = e1[3] * r[3], t1;
                    }(s, s, [
                        a,
                        a,
                        n ? 1 / s[3] : a,
                        a
                    ]);
                }), a = [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        0,
                        3,
                        7
                    ],
                    [
                        2,
                        1,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        0,
                        4,
                        5
                    ]
                ].map((t1)=>{
                    const e1 = Jo([], tl([], il([], s[t1[0]], s[t1[1]]), il([], s[t1[2]], s[t1[1]]))), r = -Qo(e1, s[t1[1]]);
                    return e1.concat(r);
                });
                return new wl(s, a);
            }
        }
        class _l {
            static fromPoints(t1) {
                const e1 = [
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], r = [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const n of t1)Ko(e1, e1, n), Yo(r, r, n);
                return new _l(e1, r);
            }
            static applyTransform(t1, e1) {
                const r = t1.getCorners();
                for(let t1 = 0; t1 < r.length; ++t1)el(r[t1], r[t1], e1);
                return _l.fromPoints(r);
            }
            constructor(t1, e1){
                this.min = t1, this.max = e1, this.center = Ho([], Go([], this.min, this.max), .5);
            }
            quadrant(t1) {
                const e1 = [
                    t1 % 2 == 0,
                    t1 < 2
                ], r = Oo(this.min), n = Oo(this.max);
                for(let t1 = 0; t1 < e1.length; t1++)r[t1] = e1[t1] ? this.min[t1] : this.center[t1], n[t1] = e1[t1] ? this.center[t1] : this.max[t1];
                return n[2] = this.max[2], new _l(r, n);
            }
            distanceX(t1) {
                return Math.max(Math.min(this.max[0], t1[0]), this.min[0]) - t1[0];
            }
            distanceY(t1) {
                return Math.max(Math.min(this.max[1], t1[1]), this.min[1]) - t1[1];
            }
            distanceZ(t1) {
                return Math.max(Math.min(this.max[2], t1[2]), this.min[2]) - t1[2];
            }
            getCorners() {
                const t1 = this.min, e1 = this.max;
                return [
                    [
                        t1[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e1[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e1[0],
                        e1[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        e1[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        t1[1],
                        e1[2]
                    ],
                    [
                        e1[0],
                        t1[1],
                        e1[2]
                    ],
                    [
                        e1[0],
                        e1[1],
                        e1[2]
                    ],
                    [
                        t1[0],
                        e1[1],
                        e1[2]
                    ]
                ];
            }
            intersects(t1) {
                const e1 = this.getCorners();
                let r = !0;
                for(let n = 0; n < t1.planes.length; n++){
                    const i = t1.planes[n];
                    let s = 0;
                    for(let t1 = 0; t1 < e1.length; t1++)s += Qo(i, e1[t1]) + i[3] >= 0;
                    if (0 === s) return 0;
                    s !== e1.length && (r = !1);
                }
                if (r) return 2;
                for(let e1 = 0; e1 < 3; e1++){
                    let r = Number.MAX_VALUE, n = -Number.MAX_VALUE;
                    for(let i = 0; i < t1.points.length; i++){
                        const s = t1.points[i][e1] - this.min[e1];
                        r = Math.min(r, s), n = Math.max(n, s);
                    }
                    if (n < 0 || r > this.max[e1] - this.min[e1]) return 0;
                }
                return 1;
            }
        }
        const Al = ko / Math.PI / 2, Sl = 64, kl = [
            Sl,
            32,
            16
        ], Il = -Al, Ml = Al, Tl = [
            new _l([
                Il,
                Il,
                Il
            ], [
                Ml,
                Ml,
                Ml
            ]),
            new _l([
                Il,
                Il,
                Il
            ], [
                0,
                0,
                Ml
            ]),
            new _l([
                0,
                Il,
                Il
            ], [
                Ml,
                0,
                Ml
            ]),
            new _l([
                Il,
                0,
                Il
            ], [
                0,
                Ml,
                Ml
            ]),
            new _l([
                0,
                0,
                Il
            ], [
                Ml,
                Ml,
                Ml
            ])
        ];
        function zl(t1) {
            return t1 * Al / tu;
        }
        function Bl(t1, e1, r, n = !0) {
            const i = Ho([], t1._camera.position, t1.worldSize), s = [
                e1,
                r,
                1,
                1
            ];
            ul(s, s, t1.pixelMatrixInverse), ol(s, s, 1 / s[3]);
            const a = Jo([], il([], s, i)), o = t1.globeMatrix, l = [
                o[12],
                o[13],
                o[14]
            ], u = il([], l, i), c = qo(u), h = Jo([], u), p = t1.worldSize / (2 * Math.PI), f = Qo(h, a), d = Math.asin(p / c);
            if (d < Math.acos(f)) {
                if (!n) return null;
                const t1 = [], e1 = [];
                Ho(t1, a, c / f), Jo(e1, il(e1, t1, u)), Jo(a, Go(a, u, Ho(a, e1, Math.tan(d) * c)));
            }
            const y = [];
            new vl(i, a).closestPointOnSphere(l, p, y);
            const m = Jo([], Y(o, 0)), g = Jo([], Y(o, 1)), x = Jo([], Y(o, 2)), b = Qo(m, y), w = Qo(g, y), _ = Qo(x, y), A = v(Math.asin(-w / p));
            let k = v(Math.atan2(b, _));
            k = t1.center.lng + function(t1, e1) {
                const r = (e1 - t1 + 180) % 360 - 180;
                return r < -180 ? r + 360 : r;
            }(t1.center.lng, k);
            const I = iu(k), M = S(su(A), 0, 1);
            return new pu(I, M);
        }
        class El {
            constructor(t1, e1, r){
                this.a = il([], t1, r), this.b = il([], e1, r), this.center = r;
                const n = Jo([], this.a), i = Jo([], this.b);
                this.angle = Math.acos(Qo(n, i));
            }
        }
        function Cl(t1, e1) {
            if (0 === t1.angle) return null;
            let r;
            return r = 0 === t1.a[e1] ? 1 / t1.angle * .5 * Math.PI : 1 / t1.angle * Math.atan(t1.b[e1] / t1.a[e1] / Math.sin(t1.angle) - 1 / Math.tan(t1.angle)), r < 0 || r > 1 ? null : function(t1, e1, r, n) {
                const i = Math.sin(r);
                return t1 * (Math.sin((1 - n) * r) / i) + e1 * (Math.sin(n * r) / i);
            }(t1.a[e1], t1.b[e1], t1.angle, S(r, 0, 1)) + t1.center[e1];
        }
        function Pl(t1) {
            if (t1.z <= 1) return Tl[t1.z + 2 * t1.y + t1.x];
            const e1 = jl(Rl(t1));
            return _l.fromPoints(e1);
        }
        function Dl(t1, e1, r) {
            return Ho(t1, t1, 1 - r), Wo(t1, t1, e1, r);
        }
        function Vl(t1, e1) {
            const r = Kl(e1.zoom);
            if (0 === r) return Pl(t1);
            const n = Rl(t1), i = jl(n), s = iu(n.getWest()) * e1.worldSize, a = iu(n.getEast()) * e1.worldSize, o = su(n.getNorth()) * e1.worldSize, l = su(n.getSouth()) * e1.worldSize, u = [
                s,
                o,
                0
            ], c = [
                a,
                o,
                0
            ], h = [
                s,
                l,
                0
            ], p = [
                a,
                l,
                0
            ], f = Co([], e1.globeMatrix);
            return el(u, u, f), el(c, c, f), el(h, h, f), el(p, p, f), i[0] = Dl(i[0], h, r), i[1] = Dl(i[1], p, r), i[2] = Dl(i[2], c, r), i[3] = Dl(i[3], u, r), _l.fromPoints(i);
        }
        function Ll(t1, e1, r) {
            for (const n of t1)el(n, n, e1), Ho(n, n, r);
        }
        function Fl(t1, e1, r) {
            const n = e1 / t1.worldSize, i = t1.globeMatrix;
            if (r.z <= 1) {
                const t1 = Pl(r).getCorners();
                return Ll(t1, i, n), _l.fromPoints(t1);
            }
            const s = Rl(r), a = jl(s);
            Ll(a, i, n);
            const o = Number.MAX_VALUE, l = [
                -o,
                -o,
                -o
            ], u = [
                o,
                o,
                o
            ];
            if (s.contains(t1.center)) {
                for (const t1 of a)Ko(u, u, t1), Yo(l, l, t1);
                l[2] = 0;
                const e1 = t1.point, r = [
                    e1.x * n,
                    e1.y * n,
                    0
                ];
                return Ko(u, u, r), Yo(l, l, r), new _l(u, l);
            }
            const c = [
                i[12] * n,
                i[13] * n,
                i[14] * n
            ], h = s.getCenter(), p = S(t1.center.lat, -cu, cu), f = S(h.lat, -cu, cu), d = iu(t1.center.lng), y = su(p);
            let m = d - iu(h.lng);
            const g = y - su(f);
            m > .5 ? m -= 1 : m < -0.5 && (m += 1);
            let v = 0;
            Math.abs(m) > Math.abs(g) ? v = m >= 0 ? 1 : 3 : (v = g >= 0 ? 0 : 2, Wo(c, c, [
                i[4] * n,
                i[5] * n,
                i[6] * n
            ], -Math.sin(x(g >= 0 ? s.getSouth() : s.getNorth())) * Al));
            const b = a[v], w = a[(v + 1) % 4], _ = new El(b, w, c), A = [
                Cl(_, 0) || b[0],
                Cl(_, 1) || b[1],
                Cl(_, 2) || b[2]
            ], k = Kl(t1.zoom);
            if (k > 0) {
                const n = function({ x: t1 , y: e1 , z: r  }, n, i, s, a) {
                    const o = 1 / (1 << r);
                    let l = t1 * o, u = l + o, c = e1 * o, h = c + o, p = 0;
                    const f = (l + u) / 2 - s;
                    return f > .5 ? p = -1 : f < -0.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (a *= n)) * i + a, h = (h * n - a) * i + a, [
                        [
                            l,
                            h,
                            0
                        ],
                        [
                            u,
                            h,
                            0
                        ],
                        [
                            u,
                            c,
                            0
                        ],
                        [
                            l,
                            c,
                            0
                        ]
                    ];
                }(r, e1, t1._pixelsPerMercatorPixel, d, y);
                for(let t1 = 0; t1 < a.length; t1++)Dl(a[t1], n[t1], k);
                const i = Go([], n[v], n[(v + 1) % 4]);
                Ho(i, i, .5), Dl(A, i, k);
            }
            for (const t1 of a)Ko(u, u, t1), Yo(l, l, t1);
            return u[2] = Math.min(b[2], w[2]), Ko(u, u, A), Yo(l, l, A), new _l(u, l);
        }
        function Rl({ x: t1 , y: e1 , z: r  }) {
            const n = 1 / (1 << r), i = new ru(ou(t1 * n), lu((e1 + 1) * n)), s = new ru(ou((t1 + 1) * n), lu(e1 * n));
            return new Io(i, s);
        }
        function jl(t1) {
            const e1 = x(t1.getNorth()), r = x(t1.getSouth()), n = Math.cos(e1), i = Math.cos(r), s = Math.sin(e1), a = Math.sin(r), o = t1.getWest(), l = t1.getEast();
            return [
                Ul(i, a, o),
                Ul(i, a, l),
                Ul(n, s, l),
                Ul(n, s, o)
            ];
        }
        function Ul(t1, e1, r, n = Al) {
            return r = x(r), [
                t1 * Math.sin(r) * n,
                -e1 * n,
                t1 * Math.cos(r) * n
            ];
        }
        function $l(t1, e1, r) {
            return Ul(Math.cos(x(t1)), Math.sin(x(t1)), e1, r);
        }
        function Ol(t1, e1, r, n) {
            const i = 1 << r.z, s = (t1 / ko + r.x) / i;
            return $l(lu((e1 / ko + r.y) / i), ou(s), n);
        }
        function ql({ min: t1 , max: e1  }) {
            return 16383 / Math.max(e1[0] - t1[0], e1[1] - t1[1], e1[2] - t1[2]);
        }
        const Nl = new Float64Array(16);
        function Gl(t1) {
            const e1 = ql(t1), r = Ro(Nl, [
                e1,
                e1,
                e1
            ]);
            var n, i;
            return Do(r, r, ((n = [])[0] = -(i = t1.min)[0], n[1] = -i[1], n[2] = -i[2], n));
        }
        function Xl(t1) {
            const e1 = (n = t1.min, (r = Nl)[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r);
            var r, n;
            const i = 1 / ql(t1);
            return Vo(e1, e1, [
                i,
                i,
                i
            ]);
        }
        function Zl(t1, e1, r, n, i) {
            const s = function(t1) {
                const e1 = ko / (2 * Math.PI);
                return t1 / (2 * Math.PI) / e1;
            }(r), a = [
                t1,
                e1,
                -r / (2 * Math.PI)
            ], o = Eo(new Float64Array(16));
            return Do(o, o, a), Vo(o, o, [
                s,
                s,
                s
            ]), Lo(o, o, x(-i)), Fo(o, o, x(-n)), o;
        }
        function Kl(t1) {
            return k(5, 6, t1);
        }
        function Yl(t1, e1) {
            const r = $l(e1.lat, e1.lng), n = function(t1) {
                const e1 = $l(t1._center.lat, t1._center.lng);
                let r = tl([], No(0, 1, 0), e1);
                const n = jo([], -t1.angle, e1);
                r = el(r, r, n), jo(n, -t1._pitch, r);
                const i = Jo([], e1);
                return Ho(i, i, zl(t1.cameraToCenterDistance / t1.pixelsPerMeter)), el(i, i, n), Go([], e1, i);
            }(t1);
            var i, s, a, o, l, u, c, h, p, f;
            return a = (i = Xo([], n, r))[0], o = i[1], l = i[2], u = (s = r)[0], c = s[1], h = s[2], f = (p = Math.sqrt(a * a + o * o + l * l) * Math.sqrt(u * u + c * c + h * h)) && Qo(i, s) / p, Math.acos(Math.min(Math.max(f, -1), 1));
        }
        function Hl(t1, e1) {
            return Yl(t1, e1) > Math.PI / 2 * 1.01;
        }
        const Wl = x(85), Jl = Math.cos(Wl), Ql = Math.sin(Wl), tu = 6371008.8, eu = 2 * Math.PI * tu;
        class ru {
            constructor(t1, e1){
                if (isNaN(t1) || isNaN(e1)) throw new Error(`Invalid LngLat object: (${t1}, ${e1})`);
                if (this.lng = +t1, this.lat = +e1, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
                return new ru(I(this.lng, -180, 180), this.lat);
            }
            toArray() {
                return [
                    this.lng,
                    this.lat
                ];
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t1) {
                const e1 = Math.PI / 180, r = this.lat * e1, n = t1.lat * e1, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t1.lng - this.lng) * e1);
                return tu * Math.acos(Math.min(i, 1));
            }
            toBounds(t1 = 0) {
                const e1 = 360 * t1 / 40075017, r = e1 / Math.cos(Math.PI / 180 * this.lat);
                return new Io(new ru(this.lng - r, this.lat - e1), new ru(this.lng + r, this.lat + e1));
            }
            toEcef(t1) {
                const e1 = zl(t1);
                return $l(this.lat, this.lng, Al + e1);
            }
            static convert(t1) {
                if (t1 instanceof ru) return t1;
                if (Array.isArray(t1) && (2 === t1.length || 3 === t1.length)) return new ru(Number(t1[0]), Number(t1[1]));
                if (!Array.isArray(t1) && "object" == typeof t1 && null !== t1) return new ru(Number("lng" in t1 ? t1.lng : t1.lon), Number(t1.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }
        function nu(t1) {
            return eu * Math.cos(t1 * Math.PI / 180);
        }
        function iu(t1) {
            return (180 + t1) / 360;
        }
        function su(t1) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1 * Math.PI / 360))) / 360;
        }
        function au(t1, e1) {
            return t1 / nu(e1);
        }
        function ou(t1) {
            return 360 * t1 - 180;
        }
        function lu(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function uu(t1, e1) {
            return t1 * nu(lu(e1));
        }
        const cu = 85.051129;
        function hu(t1) {
            return 1 / Math.cos(t1 * Math.PI / 180);
        }
        class pu {
            constructor(t1, e1, r = 0){
                this.x = +t1, this.y = +e1, this.z = +r;
            }
            static fromLngLat(t1, e1 = 0) {
                const r = ru.convert(t1);
                return new pu(iu(r.lng), su(r.lat), au(e1, r.lat));
            }
            toLngLat() {
                return new ru(ou(this.x), lu(this.y));
            }
            toAltitude() {
                return uu(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
                return 1 / eu * hu(lu(this.y));
            }
        }
        function fu(t1, e1, r, n, i, s, a, o, l) {
            const u = (e1 + n) / 2, c = (r + i) / 2, h = new d(u, c);
            o(h), function(t1, e1, r, n, i, s) {
                const a = r - i, o = n - s;
                return Math.abs((n - e1) * a - (r - t1) * o) / Math.hypot(a, o);
            }(h.x, h.y, s.x, s.y, a.x, a.y) >= l ? (fu(t1, e1, r, u, c, s, h, o, l), fu(t1, u, c, n, i, h, a, o, l)) : t1.push(a);
        }
        function du(t1, e1, r) {
            let n = t1[0], i = n.x, s = n.y;
            e1(n);
            const a = [
                n
            ];
            for(let o = 1; o < t1.length; o++){
                const l = t1[o], { x: u , y: c  } = l;
                e1(l), fu(a, i, s, u, c, n, l, e1, r), i = u, s = c, n = l;
            }
            return a;
        }
        function yu(t1, e1, r, n) {
            if (n(e1, r)) {
                const i = e1.add(r)._mult(.5);
                yu(t1, e1, i, n), yu(t1, i, r, n);
            } else t1.push(r);
        }
        function mu(t1, e1) {
            let r = t1[0];
            const n = [
                r
            ];
            for(let i = 1; i < t1.length; i++){
                const s = t1[i];
                yu(n, r, s, e1), r = s;
            }
            return n;
        }
        const gu = Math.pow(2, 14) - 1, xu = -gu - 1;
        function vu(t1, e1) {
            const r = Math.round(t1.x * e1), n = Math.round(t1.y * e1);
            return t1.x = S(r, xu, gu), t1.y = S(n, xu, gu), (r < t1.x || r > t1.x + 1 || n < t1.y || n > t1.y + 1) && $("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t1;
        }
        function bu(t1, e1, r) {
            const n = t1.loadGeometry(), i = t1.extent, s = ko / i;
            if (e1 && r && r.projection.isReprojectedInTileSpace) {
                const s = 1 << e1.z, { scale: a , x: o , y: l , projection: u  } = r, c = (t1)=>{
                    const r = ou((e1.x + t1.x / i) / s), n = lu((e1.y + t1.y / i) / s), c = u.project(r, n);
                    t1.x = (c.x * a - o) * i, t1.y = (c.y * a - l) * i;
                };
                for(let e1 = 0; e1 < n.length; e1++)if (1 !== t1.type) n[e1] = du(n[e1], c, 1);
                else {
                    const t1 = [];
                    for (const r of n[e1])r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t1.push(r));
                    n[e1] = t1;
                }
            }
            for (const t1 of n)for (const e1 of t1)vu(e1, s);
            return n;
        }
        function wu(t1, e1) {
            return {
                type: t1.type,
                id: t1.id,
                properties: t1.properties,
                geometry: e1 ? bu(t1) : []
            };
        }
        function _u(t1, e1, r, n, i) {
            t1.emplaceBack(2 * e1 + (n + 1) / 2, 2 * r + (i + 1) / 2);
        }
        function Au(t1, e1, r) {
            const n = 16384;
            t1.emplaceBack(e1.x, e1.y, e1.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class Su {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.projection = t1.projection, this.layoutVertexArray = new sa, this.indexArray = new wa, this.segments = new So, this.programConfigurations = new fo(t1.layers, t1.zoom), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            populate(t1, e1, r, n) {
                const i = this.layers[0], s = [];
                let a = null;
                "circle" === i.type && (a = i.layout.get("circle-sort-key"));
                for (const { feature: e1 , id: i , index: o , sourceLayerIndex: l  } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = wu(e1, t1);
                    if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u, r)) continue;
                    const c = a ? a.evaluate(u, {}, r) : void 0, h = {
                        id: i,
                        properties: e1.properties,
                        type: e1.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : bu(e1, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    s.push(h);
                }
                a && s.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                let o = null;
                "globe" === n.projection.name && (this.globeExtVertexArray = new pa, o = n.projection);
                for (const n of s){
                    const { geometry: i , index: s , sourceLayerIndex: a  } = n, l = t1[s].feature;
                    this.addFeature(n, i, s, e1.availableImages, r, o), e1.featureIndex.insert(l, i, s, a, this.index);
                }
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, _o.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, Ao.members))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t1, e1, r, n, i, s) {
                for (const r of e1)for (const e1 of r){
                    const r = e1.x, n = e1.y;
                    if (r < 0 || r >= ko || n < 0 || n >= ko) continue;
                    if (s) {
                        const t1 = s.projectTilePoint(r, n, i), e1 = s.upVector(i, r, n), a = this.globeExtVertexArray;
                        Au(a, t1, e1), Au(a, t1, e1), Au(a, t1, e1), Au(a, t1, e1);
                    }
                    const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t1.sortKey), o = a.vertexLength;
                    _u(this.layoutVertexArray, r, n, -1, -1), _u(this.layoutVertexArray, r, n, 1, -1), _u(this.layoutVertexArray, r, n, 1, 1), _u(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), a.vertexLength += 4, a.primitiveLength += 2;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, {}, n, i);
            }
        }
        function ku(t1, e1) {
            for(let r = 0; r < t1.length; r++)if (Du(e1, t1[r])) return !0;
            for(let r = 0; r < e1.length; r++)if (Du(t1, e1[r])) return !0;
            return !!zu(t1, e1);
        }
        function Iu(t1, e1, r) {
            return !!Du(t1, e1) || !!Eu(e1, t1, r);
        }
        function Mu(t1, e1) {
            if (1 === t1.length) return Pu(e1, t1[0]);
            for(let r = 0; r < e1.length; r++){
                const n = e1[r];
                for(let e1 = 0; e1 < n.length; e1++)if (Du(t1, n[e1])) return !0;
            }
            for(let r = 0; r < t1.length; r++)if (Pu(e1, t1[r])) return !0;
            for(let r = 0; r < e1.length; r++)if (zu(t1, e1[r])) return !0;
            return !1;
        }
        function Tu(t1, e1, r) {
            if (t1.length > 1) {
                if (zu(t1, e1)) return !0;
                for(let n = 0; n < e1.length; n++)if (Eu(e1[n], t1, r)) return !0;
            }
            for(let n = 0; n < t1.length; n++)if (Eu(t1[n], e1, r)) return !0;
            return !1;
        }
        function zu(t1, e1) {
            if (0 === t1.length || 0 === e1.length) return !1;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1];
                for(let t1 = 0; t1 < e1.length - 1; t1++)if (Bu(n, i, e1[t1], e1[t1 + 1])) return !0;
            }
            return !1;
        }
        function Bu(t1, e1, r, n) {
            return O(t1, r, n) !== O(e1, r, n) && O(t1, e1, r) !== O(t1, e1, n);
        }
        function Eu(t1, e1, r) {
            const n = r * r;
            if (1 === e1.length) return t1.distSqr(e1[0]) < n;
            for(let r = 1; r < e1.length; r++)if (Cu(t1, e1[r - 1], e1[r]) < n) return !0;
            return !1;
        }
        function Cu(t1, e1, r) {
            const n = e1.distSqr(r);
            if (0 === n) return t1.distSqr(e1);
            const i = ((t1.x - e1.x) * (r.x - e1.x) + (t1.y - e1.y) * (r.y - e1.y)) / n;
            return t1.distSqr(i < 0 ? e1 : i > 1 ? r : r.sub(e1)._mult(i)._add(e1));
        }
        function Pu(t1, e1) {
            let r, n, i, s = !1;
            for(let a = 0; a < t1.length; a++){
                r = t1[a];
                for(let t1 = 0, a = r.length - 1; t1 < r.length; a = t1++)n = r[t1], i = r[a], n.y > e1.y != i.y > e1.y && e1.x < (i.x - n.x) * (e1.y - n.y) / (i.y - n.y) + n.x && (s = !s);
            }
            return s;
        }
        function Du(t1, e1) {
            let r = !1;
            for(let n = 0, i = t1.length - 1; n < t1.length; i = n++){
                const s = t1[n], a = t1[i];
                s.y > e1.y != a.y > e1.y && e1.x < (a.x - s.x) * (e1.y - s.y) / (a.y - s.y) + s.x && (r = !r);
            }
            return r;
        }
        function Vu(t1, e1, r, n, i) {
            for (const s of t1)if (e1 <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;
            const s = [
                new d(e1, r),
                new d(e1, i),
                new d(n, i),
                new d(n, r)
            ];
            if (t1.length > 2) {
                for (const e1 of s)if (Du(t1, e1)) return !0;
            }
            for(let e1 = 0; e1 < t1.length - 1; e1++)if (Lu(t1[e1], t1[e1 + 1], s)) return !0;
            return !1;
        }
        function Lu(t1, e1, r) {
            const n = r[0], i = r[2];
            if (t1.x < n.x && e1.x < n.x || t1.x > i.x && e1.x > i.x || t1.y < n.y && e1.y < n.y || t1.y > i.y && e1.y > i.y) return !1;
            const s = O(t1, e1, r[0]);
            return s !== O(t1, e1, r[1]) || s !== O(t1, e1, r[2]) || s !== O(t1, e1, r[3]);
        }
        function Fu(t1, e1, r) {
            const n = e1.paint.get(t1).value;
            return "constant" === n.kind ? n.value : r.programConfigurations.get(e1.id).getMaxValue(t1);
        }
        function Ru(t1) {
            return Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]);
        }
        function ju(t1, e1, r, n, i) {
            if (!e1[0] && !e1[1]) return t1;
            const s = d.convert(e1)._mult(i);
            "viewport" === r && s._rotate(-n);
            const a = [];
            for(let e1 = 0; e1 < t1.length; e1++)a.push(t1[e1].sub(s));
            return a;
        }
        function Uu(t1, e1, r, n) {
            const i = d.convert(t1)._mult(n);
            return "viewport" === e1 && i._rotate(-r), i;
        }
        Oi(Su, "CircleBucket", {
            omit: [
                "layers"
            ]
        });
        const $u = new Js({
            "circle-sort-key": new Hs(Ht.layout_circle["circle-sort-key"])
        });
        var Ou = {
            paint: new Js({
                "circle-radius": new Hs(Ht.paint_circle["circle-radius"]),
                "circle-color": new Hs(Ht.paint_circle["circle-color"]),
                "circle-blur": new Hs(Ht.paint_circle["circle-blur"]),
                "circle-opacity": new Hs(Ht.paint_circle["circle-opacity"]),
                "circle-translate": new Ys(Ht.paint_circle["circle-translate"]),
                "circle-translate-anchor": new Ys(Ht.paint_circle["circle-translate-anchor"]),
                "circle-pitch-scale": new Ys(Ht.paint_circle["circle-pitch-scale"]),
                "circle-pitch-alignment": new Ys(Ht.paint_circle["circle-pitch-alignment"]),
                "circle-stroke-width": new Hs(Ht.paint_circle["circle-stroke-width"]),
                "circle-stroke-color": new Hs(Ht.paint_circle["circle-stroke-color"]),
                "circle-stroke-opacity": new Hs(Ht.paint_circle["circle-stroke-opacity"])
            }),
            layout: $u
        };
        function qu(t1, e1, r, n, i, s, a, o, l) {
            if (s && t1.queryGeometry.isAboveHorizon) return !1;
            s && (l *= t1.pixelToTileUnitsFactor);
            const u = t1.tileID.canonical, c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;
            for (const h of e1)for (const e1 of h){
                const h = e1.add(o), p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0, f = r.projection.projectTilePoint(h.x, h.y, u);
                if (p > 0) {
                    const t1 = r.projection.upVector(u, h.x, h.y);
                    f.x += t1[0] * c * p, f.y += t1[1] * c * p, f.z += t1[2] * c * p;
                }
                const d = s ? h : Nu(f.x, f.y, f.z, n), y = s ? t1.tilespaceRays.map((t1)=>Zu(t1, p)) : t1.queryGeometry.screenGeometry, m = ul([], [
                    f.x,
                    f.y,
                    f.z,
                    1
                ], n);
                if (!a && s ? l *= m[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / m[3]), s) {
                    const t1 = lu((e1.y / ko + u.y) / (1 << u.z));
                    l /= r.projection.pixelsPerMeter(t1, 1) / au(1, t1);
                }
                if (Iu(y, d, l)) return !0;
            }
            return !1;
        }
        function Nu(t1, e1, r, n) {
            const i = ul([], [
                t1,
                e1,
                r,
                1
            ], n);
            return new d(i[0] / i[3], i[1] / i[3]);
        }
        const Gu = No(0, 0, 0), Xu = No(0, 0, 1);
        function Zu(t1, e1) {
            const r = $o();
            return Gu[2] = e1, t1.intersectsPlane(Gu, Xu, r), new d(r[0], r[1]);
        }
        class Ku extends Su {
        }
        function Yu(t1, { width: e1 , height: r  }, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);
                else if (i.length !== e1 * r * n) throw new RangeError("mismatched image size");
            } else i = new Uint8Array(e1 * r * n);
            return t1.width = e1, t1.height = r, t1.data = i, t1;
        }
        function Hu(t1, e1, r) {
            const { width: n , height: i  } = e1;
            n === t1.width && i === t1.height || (Wu(t1, e1, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t1.width, n),
                height: Math.min(t1.height, i)
            }, r), t1.width = n, t1.height = i, t1.data = e1.data);
        }
        function Wu(t1, e1, r, n, i, s) {
            if (0 === i.width || 0 === i.height) return e1;
            if (i.width > t1.width || i.height > t1.height || r.x > t1.width - i.width || r.y > t1.height - i.height) throw new RangeError("out of range source coordinates for image copy");
            if (i.width > e1.width || i.height > e1.height || n.x > e1.width - i.width || n.y > e1.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
            const a = t1.data, o = e1.data;
            for(let l = 0; l < i.height; l++){
                const u = ((r.y + l) * t1.width + r.x) * s, c = ((n.y + l) * e1.width + n.x) * s;
                for(let t1 = 0; t1 < i.width * s; t1++)o[c + t1] = a[u + t1];
            }
            return e1;
        }
        Oi(Ku, "HeatmapBucket", {
            omit: [
                "layers"
            ]
        });
        class Ju {
            constructor(t1, e1){
                Yu(this, t1, 1, e1);
            }
            resize(t1) {
                Hu(this, new Ju(t1), 1);
            }
            clone() {
                return new Ju({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e1, r, n, i) {
                Wu(t1, e1, r, n, i, 1);
            }
        }
        class Qu {
            constructor(t1, e1){
                Yu(this, t1, 4, e1);
            }
            resize(t1) {
                Hu(this, new Qu(t1), 4);
            }
            replace(t1, e1) {
                e1 ? this.data.set(t1) : this.data = t1 instanceof Uint8ClampedArray ? new Uint8Array(t1.buffer) : t1;
            }
            clone() {
                return new Qu({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e1, r, n, i) {
                Wu(t1, e1, r, n, i, 4);
            }
        }
        Oi(Ju, "AlphaImage"), Oi(Qu, "RGBAImage");
        var tc = {
            paint: new Js({
                "heatmap-radius": new Hs(Ht.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new Hs(Ht.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new Ys(Ht.paint_heatmap["heatmap-intensity"]),
                "heatmap-color": new Ws(Ht.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new Ys(Ht.paint_heatmap["heatmap-opacity"])
            })
        };
        function ec(t1) {
            const e1 = {}, r = t1.resolution || 256, n = t1.clips ? t1.clips.length : 1, i = t1.image || new Qu({
                width: r,
                height: n
            }), s = (r, n, s)=>{
                e1[t1.evaluationKey] = s;
                const a = t1.expression.evaluate(e1);
                i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a);
            };
            if (t1.clips) for(let e1 = 0, i = 0; e1 < n; ++e1, i += 4 * r)for(let n = 0, a = 0; n < r; n++, a += 4){
                const o = n / (r - 1), { start: l , end: u  } = t1.clips[e1];
                s(i, a, l * (1 - o) + u * o);
            }
            else for(let t1 = 0, e1 = 0; t1 < r; t1++, e1 += 4)s(0, e1, t1 / (r - 1));
            return i;
        }
        var rc = {
            paint: new Js({
                "hillshade-illumination-direction": new Ys(Ht.paint_hillshade["hillshade-illumination-direction"]),
                "hillshade-illumination-anchor": new Ys(Ht.paint_hillshade["hillshade-illumination-anchor"]),
                "hillshade-exaggeration": new Ys(Ht.paint_hillshade["hillshade-exaggeration"]),
                "hillshade-shadow-color": new Ys(Ht.paint_hillshade["hillshade-shadow-color"]),
                "hillshade-highlight-color": new Ys(Ht.paint_hillshade["hillshade-highlight-color"]),
                "hillshade-accent-color": new Ys(Ht.paint_hillshade["hillshade-accent-color"])
            })
        };
        const nc = na([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), { members: ic  } = nc;
        var sc = {};
        function ac(t1, e1, r) {
            r = r || 2;
            var n, i, s, a, o, l, u, c = e1 && e1.length, h = c ? e1[0] * r : t1.length, p = oc(t1, 0, h, r, !0), f = [];
            if (!p || p.next === p.prev) return f;
            if (c && (p = function(t1, e1, r, n) {
                var i, s, a, o = [];
                for(i = 0, s = e1.length; i < s; i++)(a = oc(t1, e1[i] * n, i < s - 1 ? e1[i + 1] * n : t1.length, n, !1)) === a.next && (a.steiner = !0), o.push(xc(a));
                for(o.sort(dc), i = 0; i < o.length; i++)r = yc(o[i], r);
                return r;
            }(t1, e1, p, r)), t1.length > 80 * r) {
                n = s = t1[0], i = a = t1[1];
                for(var d = r; d < h; d += r)(o = t1[d]) < n && (n = o), (l = t1[d + 1]) < i && (i = l), o > s && (s = o), l > a && (a = l);
                u = 0 !== (u = Math.max(s - n, a - i)) ? 32767 / u : 0;
            }
            return uc(p, f, r, n, i, u, 0), f;
        }
        function oc(t1, e1, r, n, i) {
            var s, a;
            if (i === Ec(t1, e1, r, n) > 0) for(s = e1; s < r; s += n)a = Tc(s, t1[s], t1[s + 1], a);
            else for(s = r - n; s >= e1; s -= n)a = Tc(s, t1[s], t1[s + 1], a);
            return a && _c(a, a.next) && (zc(a), a = a.next), a;
        }
        function lc(t1, e1) {
            if (!t1) return t1;
            e1 || (e1 = t1);
            var r, n = t1;
            do if (r = !1, n.steiner || !_c(n, n.next) && 0 !== wc(n.prev, n, n.next)) n = n.next;
            else {
                if (zc(n), (n = e1 = n.prev) === n.next) break;
                r = !0;
            }
            while (r || n !== e1);
            return e1;
        }
        function uc(t1, e1, r, n, i, s, a) {
            if (t1) {
                !a && s && function(t1, e1, r, n) {
                    var i = t1;
                    do 0 === i.z && (i.z = gc(i.x, i.y, e1, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                    while (i !== t1);
                    i.prevZ.nextZ = null, i.prevZ = null, function(t1) {
                        var e1, r, n, i, s, a, o, l, u = 1;
                        do {
                            for(r = t1, t1 = null, s = null, a = 0; r;){
                                for(a++, n = r, o = 0, e1 = 0; e1 < u && (o++, n = n.nextZ); e1++);
                                for(l = u; o > 0 || l > 0 && n;)0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t1 = i, i.prevZ = s, s = i;
                                r = n;
                            }
                            s.nextZ = null, u *= 2;
                        }while (a > 1);
                    }(i);
                }(t1, n, i, s);
                for(var o, l, u = t1; t1.prev !== t1.next;)if (o = t1.prev, l = t1.next, s ? hc(t1, n, i, s) : cc(t1)) e1.push(o.i / r | 0), e1.push(t1.i / r | 0), e1.push(l.i / r | 0), zc(t1), t1 = l.next, u = l.next;
                else if ((t1 = l) === u) {
                    a ? 1 === a ? uc(t1 = pc(lc(t1), e1, r), e1, r, n, i, s, 2) : 2 === a && fc(t1, e1, r, n, i, s) : uc(lc(t1), e1, r, n, i, s, 1);
                    break;
                }
            }
        }
        function cc(t1) {
            var e1 = t1.prev, r = t1, n = t1.next;
            if (wc(e1, r, n) >= 0) return !1;
            for(var i = e1.x, s = r.x, a = n.x, o = e1.y, l = r.y, u = n.y, c = i < s ? i < a ? i : a : s < a ? s : a, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > s ? i > a ? i : a : s > a ? s : a, f = o > l ? o > u ? o : u : l > u ? l : u, d = n.next; d !== e1;){
                if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && vc(i, o, s, l, a, u, d.x, d.y) && wc(d.prev, d, d.next) >= 0) return !1;
                d = d.next;
            }
            return !0;
        }
        function hc(t1, e1, r, n) {
            var i = t1.prev, s = t1, a = t1.next;
            if (wc(i, s, a) >= 0) return !1;
            for(var o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, f = o < l ? o < u ? o : u : l < u ? l : u, d = c < h ? c < p ? c : p : h < p ? h : p, y = o > l ? o > u ? o : u : l > u ? l : u, m = c > h ? c > p ? c : p : h > p ? h : p, g = gc(f, d, e1, r, n), x = gc(y, m, e1, r, n), v = t1.prevZ, b = t1.nextZ; v && v.z >= g && b && b.z <= x;){
                if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && vc(o, c, l, h, u, p, v.x, v.y) && wc(v.prev, v, v.next) >= 0) return !1;
                if (v = v.prevZ, b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && vc(o, c, l, h, u, p, b.x, b.y) && wc(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            for(; v && v.z >= g;){
                if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && vc(o, c, l, h, u, p, v.x, v.y) && wc(v.prev, v, v.next) >= 0) return !1;
                v = v.prevZ;
            }
            for(; b && b.z <= x;){
                if (b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && vc(o, c, l, h, u, p, b.x, b.y) && wc(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            return !0;
        }
        function pc(t1, e1, r) {
            var n = t1;
            do {
                var i = n.prev, s = n.next.next;
                !_c(i, s) && Ac(i, n, n.next, s) && Ic(i, s) && Ic(s, i) && (e1.push(i.i / r | 0), e1.push(n.i / r | 0), e1.push(s.i / r | 0), zc(n), zc(n.next), n = t1 = s), n = n.next;
            }while (n !== t1);
            return lc(n);
        }
        function fc(t1, e1, r, n, i, s) {
            var a = t1;
            do {
                for(var o = a.next.next; o !== a.prev;){
                    if (a.i !== o.i && bc(a, o)) {
                        var l = Mc(a, o);
                        return a = lc(a, a.next), l = lc(l, l.next), uc(a, e1, r, n, i, s, 0), void uc(l, e1, r, n, i, s, 0);
                    }
                    o = o.next;
                }
                a = a.next;
            }while (a !== t1);
        }
        function dc(t1, e1) {
            return t1.x - e1.x;
        }
        function yc(t1, e1) {
            var r = function(t1, e1) {
                var r, n = e1, i = t1.x, s = t1.y, a = -1 / 0;
                do {
                    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                        var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (o <= i && o > a && (a = o, r = n.x < n.next.x ? n : n.next, o === i)) return r;
                    }
                    n = n.next;
                }while (n !== e1);
                if (!r) return null;
                var l, u = r, c = r.x, h = r.y, p = 1 / 0;
                n = r;
                do i >= n.x && n.x >= c && i !== n.x && vc(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), Ic(n, t1) && (l < p || l === p && (n.x > r.x || n.x === r.x && mc(r, n))) && (r = n, p = l)), n = n.next;
                while (n !== u);
                return r;
            }(t1, e1);
            if (!r) return e1;
            var n = Mc(r, t1);
            return lc(n, n.next), lc(r, r.next);
        }
        function mc(t1, e1) {
            return wc(t1.prev, t1, e1.prev) < 0 && wc(e1.next, t1, t1.next) < 0;
        }
        function gc(t1, e1, r, n, i) {
            return (t1 = 1431655765 & ((t1 = 858993459 & ((t1 = 252645135 & ((t1 = 16711935 & ((t1 = (t1 - r) * i | 0) | t1 << 8)) | t1 << 4)) | t1 << 2)) | t1 << 1)) | (e1 = 1431655765 & ((e1 = 858993459 & ((e1 = 252645135 & ((e1 = 16711935 & ((e1 = (e1 - n) * i | 0) | e1 << 8)) | e1 << 4)) | e1 << 2)) | e1 << 1)) << 1;
        }
        function xc(t1) {
            var e1 = t1, r = t1;
            do (e1.x < r.x || e1.x === r.x && e1.y < r.y) && (r = e1), e1 = e1.next;
            while (e1 !== t1);
            return r;
        }
        function vc(t1, e1, r, n, i, s, a, o) {
            return (i - a) * (e1 - o) >= (t1 - a) * (s - o) && (t1 - a) * (n - o) >= (r - a) * (e1 - o) && (r - a) * (s - o) >= (i - a) * (n - o);
        }
        function bc(t1, e1) {
            return t1.next.i !== e1.i && t1.prev.i !== e1.i && !function(t1, e1) {
                var r = t1;
                do {
                    if (r.i !== t1.i && r.next.i !== t1.i && r.i !== e1.i && r.next.i !== e1.i && Ac(r, r.next, t1, e1)) return !0;
                    r = r.next;
                }while (r !== t1);
                return !1;
            }(t1, e1) && (Ic(t1, e1) && Ic(e1, t1) && function(t1, e1) {
                var r = t1, n = !1, i = (t1.x + e1.x) / 2, s = (t1.y + e1.y) / 2;
                do r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
                while (r !== t1);
                return n;
            }(t1, e1) && (wc(t1.prev, t1, e1.prev) || wc(t1, e1.prev, e1)) || _c(t1, e1) && wc(t1.prev, t1, t1.next) > 0 && wc(e1.prev, e1, e1.next) > 0);
        }
        function wc(t1, e1, r) {
            return (e1.y - t1.y) * (r.x - e1.x) - (e1.x - t1.x) * (r.y - e1.y);
        }
        function _c(t1, e1) {
            return t1.x === e1.x && t1.y === e1.y;
        }
        function Ac(t1, e1, r, n) {
            var i = kc(wc(t1, e1, r)), s = kc(wc(t1, e1, n)), a = kc(wc(r, n, t1)), o = kc(wc(r, n, e1));
            return i !== s && a !== o || !(0 !== i || !Sc(t1, r, e1)) || !(0 !== s || !Sc(t1, n, e1)) || !(0 !== a || !Sc(r, t1, n)) || !(0 !== o || !Sc(r, e1, n));
        }
        function Sc(t1, e1, r) {
            return e1.x <= Math.max(t1.x, r.x) && e1.x >= Math.min(t1.x, r.x) && e1.y <= Math.max(t1.y, r.y) && e1.y >= Math.min(t1.y, r.y);
        }
        function kc(t1) {
            return t1 > 0 ? 1 : t1 < 0 ? -1 : 0;
        }
        function Ic(t1, e1) {
            return wc(t1.prev, t1, t1.next) < 0 ? wc(t1, e1, t1.next) >= 0 && wc(t1, t1.prev, e1) >= 0 : wc(t1, e1, t1.prev) < 0 || wc(t1, t1.next, e1) < 0;
        }
        function Mc(t1, e1) {
            var r = new Bc(t1.i, t1.x, t1.y), n = new Bc(e1.i, e1.x, e1.y), i = t1.next, s = e1.prev;
            return t1.next = e1, e1.prev = t1, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
        }
        function Tc(t1, e1, r, n) {
            var i = new Bc(t1, e1, r);
            return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
        }
        function zc(t1) {
            t1.next.prev = t1.prev, t1.prev.next = t1.next, t1.prevZ && (t1.prevZ.nextZ = t1.nextZ), t1.nextZ && (t1.nextZ.prevZ = t1.prevZ);
        }
        function Bc(t1, e1, r) {
            this.i = t1, this.x = e1, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        function Ec(t1, e1, r, n) {
            for(var i = 0, s = e1, a = r - n; s < r; s += n)i += (t1[a] - t1[s]) * (t1[s + 1] + t1[a + 1]), a = s;
            return i;
        }
        function Cc(t1, e1, r, n, i) {
            Pc(t1, e1, r || 0, n || t1.length - 1, i || Vc);
        }
        function Pc(t1, e1, r, n, i) {
            for(; n > r;){
                if (n - r > 600) {
                    var s = n - r + 1, a = e1 - r + 1, o = Math.log(s), l = .5 * Math.exp(2 * o / 3), u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);
                    Pc(t1, e1, Math.max(r, Math.floor(e1 - a * l / s + u)), Math.min(n, Math.floor(e1 + (s - a) * l / s + u)), i);
                }
                var c = t1[e1], h = r, p = n;
                for(Dc(t1, r, e1), i(t1[n], c) > 0 && Dc(t1, r, n); h < p;){
                    for(Dc(t1, h, p), h++, p--; i(t1[h], c) < 0;)h++;
                    for(; i(t1[p], c) > 0;)p--;
                }
                0 === i(t1[r], c) ? Dc(t1, r, p) : Dc(t1, ++p, n), p <= e1 && (r = p + 1), e1 <= p && (n = p - 1);
            }
        }
        function Dc(t1, e1, r) {
            var n = t1[e1];
            t1[e1] = t1[r], t1[r] = n;
        }
        function Vc(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function Lc(t1, e1) {
            const r = t1.length;
            if (r <= 1) return [
                t1
            ];
            const n = [];
            let i, s;
            for(let e1 = 0; e1 < r; e1++){
                const r = q(t1[e1]);
                0 !== r && (t1[e1].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [
                    t1[e1]
                ]) : i.push(t1[e1]));
            }
            if (i && n.push(i), e1 > 1) for(let t1 = 0; t1 < n.length; t1++)n[t1].length <= e1 || (Cc(n[t1], e1, 1, n[t1].length - 1, Fc), n[t1] = n[t1].slice(0, e1));
            return n;
        }
        function Fc(t1, e1) {
            return e1.area - t1.area;
        }
        function Rc(t1, e1, r) {
            const n = r.patternDependencies;
            let i = !1;
            for (const r of e1){
                const e1 = r.paint.get(`${t1}-pattern`);
                e1.isConstant() || (i = !0);
                const s = e1.constantOr(null);
                s && (i = !0, n[s] = !0);
            }
            return i;
        }
        function jc(t1, e1, r, n, i) {
            const s = i.patternDependencies;
            for (const a of e1){
                const e1 = a.paint.get(`${t1}-pattern`).value;
                if ("constant" !== e1.kind) {
                    let t1 = e1.evaluate({
                        zoom: n
                    }, r, {}, i.availableImages);
                    t1 = t1 && t1.name ? t1.name : t1, s[t1] = !0, r.patterns[a.id] = t1;
                }
            }
            return r;
        }
        ({
            get exports () {
                return sc;
            },
            set exports (t){
                sc = t;
            }
        }).exports = ac, sc.default = ac, ac.deviation = function(t1, e1, r, n) {
            var i = e1 && e1.length, s = Math.abs(Ec(t1, 0, i ? e1[0] * r : t1.length, r));
            if (i) for(var a = 0, o = e1.length; a < o; a++)s -= Math.abs(Ec(t1, e1[a] * r, a < o - 1 ? e1[a + 1] * r : t1.length, r));
            var l = 0;
            for(a = 0; a < n.length; a += 3){
                var u = n[a] * r, c = n[a + 1] * r, h = n[a + 2] * r;
                l += Math.abs((t1[u] - t1[h]) * (t1[c + 1] - t1[u + 1]) - (t1[u] - t1[c]) * (t1[h + 1] - t1[u + 1]));
            }
            return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);
        }, ac.flatten = function(t1) {
            for(var e1 = t1[0][0].length, r = {
                vertices: [],
                holes: [],
                dimensions: e1
            }, n = 0, i = 0; i < t1.length; i++){
                for(var s = 0; s < t1[i].length; s++)for(var a = 0; a < e1; a++)r.vertices.push(t1[i][s][a]);
                i > 0 && r.holes.push(n += t1[i - 1].length);
            }
            return r;
        };
        class Uc {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new sa, this.indexArray = new wa, this.indexArray2 = new Ma, this.programConfigurations = new fo(t1.layers, t1.zoom), this.segments = new So, this.segments2 = new So, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.projection = t1.projection;
            }
            populate(t1, e1, r, n) {
                this.hasPattern = Rc("fill", this.layers, e1);
                const i = this.layers[0].layout.get("fill-sort-key"), s = [];
                for (const { feature: a , id: o , index: l , sourceLayerIndex: u  } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = wu(a, t1);
                    if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), c, r)) continue;
                    const h = i ? i.evaluate(c, {}, r, e1.availableImages) : void 0, p = {
                        id: o,
                        properties: a.properties,
                        type: a.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : bu(a, r, n),
                        patterns: {},
                        sortKey: h
                    };
                    s.push(p);
                }
                i && s.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                for (const n of s){
                    const { geometry: i , index: s , sourceLayerIndex: a  } = n;
                    if (this.hasPattern) {
                        const t1 = jc("fill", this.layers, n, this.zoom, e1);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, {}, e1.availableImages);
                    e1.featureIndex.insert(t1[s].feature, i, s, a, this.index);
                }
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r, n);
            }
            addFeatures(t1, e1, r, n, i) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e1, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, ic), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t1, e1, r, n, i, s = []) {
                for (const t1 of Lc(e1, 500)){
                    let e1 = 0;
                    for (const r of t1)e1 += r.length;
                    const r = this.segments.prepareSegment(e1, this.layoutVertexArray, this.indexArray), n = r.vertexLength, i = [], s = [];
                    for (const e1 of t1){
                        if (0 === e1.length) continue;
                        e1 !== t1[0] && s.push(i.length / 2);
                        const r = this.segments2.prepareSegment(e1.length, this.layoutVertexArray, this.indexArray2), n = r.vertexLength;
                        this.layoutVertexArray.emplaceBack(e1[0].x, e1[0].y), this.indexArray2.emplaceBack(n + e1.length - 1, n), i.push(e1[0].x), i.push(e1[0].y);
                        for(let t1 = 1; t1 < e1.length; t1++)this.layoutVertexArray.emplaceBack(e1[t1].x, e1[t1].y), this.indexArray2.emplaceBack(n + t1 - 1, n + t1), i.push(e1[t1].x), i.push(e1[t1].y);
                        r.vertexLength += e1.length, r.primitiveLength += e1.length;
                    }
                    const a = sc(i, s);
                    for(let t1 = 0; t1 < a.length; t1 += 3)this.indexArray.emplaceBack(n + a[t1], n + a[t1 + 1], n + a[t1 + 2]);
                    r.vertexLength += e1, r.primitiveLength += a.length / 3;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n);
            }
        }
        Oi(Uc, "FillBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const $c = new Js({
            "fill-sort-key": new Hs(Ht.layout_fill["fill-sort-key"])
        });
        var Oc = {
            paint: new Js({
                "fill-antialias": new Ys(Ht.paint_fill["fill-antialias"]),
                "fill-opacity": new Hs(Ht.paint_fill["fill-opacity"]),
                "fill-color": new Hs(Ht.paint_fill["fill-color"]),
                "fill-outline-color": new Hs(Ht.paint_fill["fill-outline-color"]),
                "fill-translate": new Ys(Ht.paint_fill["fill-translate"]),
                "fill-translate-anchor": new Ys(Ht.paint_fill["fill-translate-anchor"]),
                "fill-pattern": new Hs(Ht.paint_fill["fill-pattern"])
            }),
            layout: $c
        };
        const qc = na([
            {
                name: "a_pos_normal_ed",
                components: 4,
                type: "Int16"
            }
        ]), Nc = na([
            {
                name: "a_centroid_pos",
                components: 2,
                type: "Uint16"
            }
        ]), Gc = na([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), { members: Xc  } = qc;
        var Zc = {}, Kc = d, Yc = Hc;
        function Hc(t1, e1, r, n, i) {
            this.properties = {}, this.extent = r, this.type = 0, this._pbf = t1, this._geometry = -1, this._keys = n, this._values = i, t1.readFields(Wc, this, e1);
        }
        function Wc(t1, e1, r) {
            1 == t1 ? e1.id = r.readVarint() : 2 == t1 ? function(t1, e1) {
                for(var r = t1.readVarint() + t1.pos; t1.pos < r;){
                    var n = e1._keys[t1.readVarint()], i = e1._values[t1.readVarint()];
                    e1.properties[n] = i;
                }
            }(r, e1) : 3 == t1 ? e1.type = r.readVarint() : 4 == t1 && (e1._geometry = r.pos);
        }
        function Jc(t1) {
            for(var e1, r, n = 0, i = 0, s = t1.length, a = s - 1; i < s; a = i++)n += ((r = t1[a]).x - (e1 = t1[i]).x) * (e1.y + r.y);
            return n;
        }
        Hc.types = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ], Hc.prototype.loadGeometry = function() {
            var t1 = this._pbf;
            t1.pos = this._geometry;
            for(var e1, r = t1.readVarint() + t1.pos, n = 1, i = 0, s = 0, a = 0, o = []; t1.pos < r;){
                if (i <= 0) {
                    var l = t1.readVarint();
                    n = 7 & l, i = l >> 3;
                }
                if (i--, 1 === n || 2 === n) s += t1.readSVarint(), a += t1.readSVarint(), 1 === n && (e1 && o.push(e1), e1 = []), e1.push(new Kc(s, a));
                else {
                    if (7 !== n) throw new Error("unknown command " + n);
                    e1 && e1.push(e1[0].clone());
                }
            }
            return e1 && o.push(e1), o;
        }, Hc.prototype.bbox = function() {
            var t1 = this._pbf;
            t1.pos = this._geometry;
            for(var e1 = t1.readVarint() + t1.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t1.pos < e1;){
                if (n <= 0) {
                    var c = t1.readVarint();
                    r = 7 & c, n = c >> 3;
                }
                if (n--, 1 === r || 2 === r) (i += t1.readSVarint()) < a && (a = i), i > o && (o = i), (s += t1.readSVarint()) < l && (l = s), s > u && (u = s);
                else if (7 !== r) throw new Error("unknown command " + r);
            }
            return [
                a,
                l,
                o,
                u
            ];
        }, Hc.prototype.toGeoJSON = function(t1, e1, r) {
            var n, i, s = this.extent * Math.pow(2, r), a = this.extent * t1, o = this.extent * e1, l = this.loadGeometry(), u = Hc.types[this.type];
            function c(t1) {
                for(var e1 = 0; e1 < t1.length; e1++){
                    var r = t1[e1];
                    t1[e1] = [
                        360 * (r.x + a) / s - 180,
                        360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90
                    ];
                }
            }
            switch(this.type){
                case 1:
                    var h = [];
                    for(n = 0; n < l.length; n++)h[n] = l[n][0];
                    c(l = h);
                    break;
                case 2:
                    for(n = 0; n < l.length; n++)c(l[n]);
                    break;
                case 3:
                    for(l = function(t1) {
                        var e1 = t1.length;
                        if (e1 <= 1) return [
                            t1
                        ];
                        for(var r, n, i = [], s = 0; s < e1; s++){
                            var a = Jc(t1[s]);
                            0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [
                                t1[s]
                            ]) : r.push(t1[s]));
                        }
                        return r && i.push(r), i;
                    }(l), n = 0; n < l.length; n++)for(i = 0; i < l[n].length; i++)c(l[n][i]);
            }
            1 === l.length ? l = l[0] : u = "Multi" + u;
            var p = {
                type: "Feature",
                geometry: {
                    type: u,
                    coordinates: l
                },
                properties: this.properties
            };
            return "id" in this && (p.id = this.id), p;
        };
        var Qc = Yc, th = eh;
        function eh(t1, e1) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t1, this._keys = [], this._values = [], this._features = [], t1.readFields(rh, this, e1), this.length = this._features.length;
        }
        function rh(t1, e1, r) {
            15 === t1 ? e1.version = r.readVarint() : 1 === t1 ? e1.name = r.readString() : 5 === t1 ? e1.extent = r.readVarint() : 2 === t1 ? e1._features.push(r.pos) : 3 === t1 ? e1._keys.push(r.readString()) : 4 === t1 && e1._values.push(function(t1) {
                for(var e1 = null, r = t1.readVarint() + t1.pos; t1.pos < r;){
                    var n = t1.readVarint() >> 3;
                    e1 = 1 === n ? t1.readString() : 2 === n ? t1.readFloat() : 3 === n ? t1.readDouble() : 4 === n ? t1.readVarint64() : 5 === n ? t1.readVarint() : 6 === n ? t1.readSVarint() : 7 === n ? t1.readBoolean() : null;
                }
                return e1;
            }(r));
        }
        eh.prototype.feature = function(t1) {
            if (t1 < 0 || t1 >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t1];
            var e1 = this._pbf.readVarint() + this._pbf.pos;
            return new Qc(this._pbf, e1, this.extent, this._keys, this._values);
        };
        var nh = th;
        function ih(t1, e1, r) {
            if (3 === t1) {
                var n = new nh(r, r.readVarint() + r.pos);
                n.length && (e1[n.name] = n);
            }
        }
        var sh = Zc.VectorTile = function(t1, e1) {
            this.layers = t1.readFields(ih, {}, e1);
        }, ah = Zc.VectorTileFeature = Yc;
        function oh(t1, e1, r, n) {
            const i = [], s = 0 === n ? (t1, e1, r, n, i, s)=>{
                t1.push(new d(s, r + (s - e1) / (n - e1) * (i - r)));
            } : (t1, e1, r, n, i, s)=>{
                t1.push(new d(e1 + (s - r) / (i - r) * (n - e1), s));
            };
            for (const a of t1){
                const t1 = [];
                for (const i of a){
                    if (i.length <= 2) continue;
                    const a = [];
                    for(let t1 = 0; t1 < i.length - 1; t1++){
                        const o = i[t1].x, l = i[t1].y, u = i[t1 + 1].x, c = i[t1 + 1].y, h = 0 === n ? o : l, p = 0 === n ? u : c;
                        h < e1 ? p > e1 && s(a, o, l, u, c, e1) : h > r ? p < r && s(a, o, l, u, c, r) : a.push(i[t1]), p < e1 && h >= e1 && s(a, o, l, u, c, e1), p > r && h <= r && s(a, o, l, u, c, r);
                    }
                    let o = i[i.length - 1];
                    const l = 0 === n ? o.x : o.y;
                    l >= e1 && l <= r && a.push(o), a.length && (o = a[a.length - 1], a[0].x === o.x && a[0].y === o.y || a.push(a[0]), t1.push(a));
                }
                t1.length && i.push(t1);
            }
            return i;
        }
        Zc.VectorTileLayer = th;
        const lh = ah.types, uh = Math.pow(2, 13);
        function ch(t1, e1, r, n, i, s, a, o) {
            t1.emplaceBack((e1 << 1) + a, (r << 1) + s, (Math.floor(n * uh) << 1) + i, Math.round(o));
        }
        function hh(t1, e1, r) {
            const n = 16384;
            t1.emplaceBack(e1.x, e1.y, e1.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class ph {
            constructor(){
                this.acc = new d(0, 0), this.polyCount = [];
            }
            startRing(t1) {
                this.currentPolyCount = {
                    edges: 0,
                    top: 0
                }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new d(t1.x, t1.y), this.max = new d(t1.x, t1.y));
            }
            append(t1, e1) {
                this.currentPolyCount.edges++, this.acc._add(t1);
                const r = this.min, n = this.max;
                t1.x < r.x ? r.x = t1.x : t1.x > n.x && (n.x = t1.x), t1.y < r.y ? r.y = t1.y : t1.y > n.y && (n.y = t1.y), ((0 === t1.x || t1.x === ko) && t1.x === e1.x) != ((0 === t1.y || t1.y === ko) && t1.y === e1.y) && this.processBorderOverlap(t1, e1), e1.x < 0 != t1.x < 0 && this.addBorderIntersection(0, Mr(e1.y, t1.y, (0 - e1.x) / (t1.x - e1.x))), e1.x > ko != t1.x > ko && this.addBorderIntersection(1, Mr(e1.y, t1.y, (ko - e1.x) / (t1.x - e1.x))), e1.y < 0 != t1.y < 0 && this.addBorderIntersection(2, Mr(e1.x, t1.x, (0 - e1.y) / (t1.y - e1.y))), e1.y > ko != t1.y > ko && this.addBorderIntersection(3, Mr(e1.x, t1.x, (ko - e1.y) / (t1.y - e1.y)));
            }
            addBorderIntersection(t1, e1) {
                this.borders || (this.borders = [
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ]
                ]);
                const r = this.borders[t1];
                e1 < r[0] && (r[0] = e1), e1 > r[1] && (r[1] = e1);
            }
            processBorderOverlap(t1, e1) {
                if (t1.x === e1.x) {
                    if (t1.y === e1.y) return;
                    const r = 0 === t1.x ? 0 : 1;
                    this.addBorderIntersection(r, e1.y), this.addBorderIntersection(r, t1.y);
                } else {
                    const r = 0 === t1.y ? 2 : 3;
                    this.addBorderIntersection(r, e1.x), this.addBorderIntersection(r, t1.x);
                }
            }
            centroid() {
                const t1 = this.polyCount.reduce((t1, e1)=>t1 + e1.edges, 0);
                return 0 !== t1 ? this.acc.div(t1)._round() : new d(0, 0);
            }
            span() {
                return new d(this.max.x - this.min.x, this.max.y - this.min.y);
            }
            intersectsCount() {
                return this.borders.reduce((t1, e1)=>t1 + +(e1[0] !== Number.MAX_VALUE), 0);
            }
        }
        class fh {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t1.projection, this.layoutVertexArray = new oa, this.centroidVertexArray = new Ua, this.indexArray = new wa, this.programConfigurations = new fo(t1.layers, t1.zoom), this.segments = new So, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.enableTerrain = t1.enableTerrain;
            }
            populate(t1, e1, r, n) {
                this.features = [], this.hasPattern = Rc("fill-extrusion", this.layers, e1), this.featuresOnBorder = [], this.borders = [
                    [],
                    [],
                    [],
                    []
                ], this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ], this.tileToMeter = function(t1) {
                    const e1 = Math.exp(Math.PI * (1 - t1.y / (1 << t1.z) * 2));
                    return 80150034 * e1 / (e1 * e1 + 1) / ko / (1 << t1.z);
                }(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
                for (const { feature: i , id: s , index: a , sourceLayerIndex: o  } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = wu(i, t1);
                    if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), l, r)) continue;
                    const u = {
                        id: s,
                        sourceLayerIndex: o,
                        index: a,
                        geometry: t1 ? l.geometry : bu(i, r, n),
                        properties: i.properties,
                        type: i.type,
                        patterns: {}
                    }, c = this.layoutVertexArray.length;
                    this.hasPattern ? this.features.push(jc("fill-extrusion", this.layers, u, this.zoom, e1)) : this.addFeature(u, u.geometry, a, r, {}, e1.availableImages, n), e1.featureIndex.insert(i, u.geometry, a, o, this.index, c);
                }
                this.sortBorders();
            }
            addFeatures(t1, e1, r, n, i) {
                for (const t1 of this.features){
                    const { geometry: s  } = t1;
                    this.addFeature(t1, s, t1.index, e1, r, n, i);
                }
                this.sortBorders();
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Xc), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t1.createVertexBuffer(this.layoutVertexExtArray, Gc.members, !0))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            uploadCentroid(t1) {
                0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t1.createVertexBuffer(this.centroidVertexArray, Nc.members, !0), this.needsCentroidUpdate = !1);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t1, e1, r, n, i, s, a) {
                const o = [
                    new d(0, 0),
                    new d(ko, ko)
                ], l = a.projection, u = "globe" === l.name, c = this.enableTerrain && !u ? new ph : null, h = "Polygon" === lh[t1.type];
                u && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa);
                const p = Lc(e1, 500);
                for(let t1 = p.length - 1; t1 >= 0; t1--){
                    const e1 = p[t1];
                    (0 === e1.length || (f = e1[0]).every((t1)=>t1.x <= 0) || f.every((t1)=>t1.x >= ko) || f.every((t1)=>t1.y <= 0) || f.every((t1)=>t1.y >= ko)) && p.splice(t1, 1);
                }
                var f;
                let y;
                if (u) y = wh(p, o, n);
                else {
                    y = [];
                    for (const t1 of p)y.push({
                        polygon: t1,
                        bounds: o
                    });
                }
                const m = h ? this.edgeRadius : 0;
                for (const { polygon: t1 , bounds: e1  } of y){
                    let r = 0, i = 0;
                    for (const e1 of t1)h && !e1[0].equals(e1[e1.length - 1]) && e1.push(e1[0]), i += h ? e1.length - 1 : e1.length;
                    const s = this.segments.prepareSegment((h ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);
                    if (h) {
                        const e1 = [], i = [];
                        r = s.vertexLength;
                        for (const r of t1){
                            let a, o;
                            r.length && r !== t1[0] && i.push(e1.length / 2), a = r[1].sub(r[0])._perp()._unit();
                            for(let t1 = 1; t1 < r.length; t1++){
                                const i = r[t1], c = r[t1 === r.length - 1 ? 1 : t1 + 1];
                                let { x: h , y: p  } = i;
                                if (m) {
                                    o = c.sub(i)._perp()._unit();
                                    const t1 = a.add(o)._unit(), e1 = m * Math.min(4, 1 / (a.x * t1.x + a.y * t1.y));
                                    h += e1 * t1.x, p += e1 * t1.y, a = o;
                                }
                                ch(this.layoutVertexArray, h, p, 0, 0, 1, 1, 0), s.vertexLength++, e1.push(i.x, i.y), u && hh(this.layoutVertexExtArray, l.projectTilePoint(h, p, n), l.upVector(n, h, p));
                            }
                        }
                        const a = sc(e1, i);
                        for(let t1 = 0; t1 < a.length; t1 += 3)this.indexArray.emplaceBack(r + a[t1], r + a[t1 + 2], r + a[t1 + 1]), s.primitiveLength++;
                    }
                    for (const i of t1){
                        c && i.length && c.startRing(i[0]);
                        let t1, a, o, p = i.length > 4 && xh(i[i.length - 2], i[0], i[1]), f = m ? yh(i[i.length - 2], i[0], i[1], m) : 0;
                        a = i[1].sub(i[0])._perp()._unit();
                        let d = !0;
                        for(let y = 1, g = 0; y < i.length; y++){
                            let x = i[y - 1], v = i[y];
                            const b = i[y === i.length - 1 ? 1 : y + 1];
                            if (c && h && c.currentPolyCount.top++, gh(v, x, e1)) {
                                m && (a = b.sub(v)._perp()._unit(), d = !d);
                                continue;
                            }
                            c && c.append(v, x);
                            const w = v.sub(x)._perp(), _ = w.x / (Math.abs(w.x) + Math.abs(w.y)), A = w.y > 0 ? 1 : 0, S = x.dist(v);
                            if (g + S > 32768 && (g = 0), m) {
                                o = b.sub(v)._perp()._unit();
                                let t1 = mh(x, v, b, dh(a, o), m);
                                isNaN(t1) && (t1 = 0);
                                const e1 = v.sub(x)._unit();
                                x = x.add(e1.mult(f))._round(), v = v.add(e1.mult(-t1))._round(), f = t1, a = o;
                            }
                            const k = s.vertexLength, I = i.length > 4 && xh(x, v, b);
                            let M = vh(g, p, d);
                            if (ch(this.layoutVertexArray, x.x, x.y, _, A, 0, 0, M), ch(this.layoutVertexArray, x.x, x.y, _, A, 0, 1, M), g += S, M = vh(g, I, !d), p = I, ch(this.layoutVertexArray, v.x, v.y, _, A, 0, 0, M), ch(this.layoutVertexArray, v.x, v.y, _, A, 0, 1, M), s.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), s.primitiveLength += 2, m) {
                                const n = r + (1 === y ? i.length - 2 : y - 2), a = 1 === y ? r : n + 1;
                                if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, a, k + 3), s.primitiveLength += 2, void 0 === t1 && (t1 = k), !gh(b, i[y], e1)) {
                                    const e1 = y === i.length - 1 ? t1 : s.vertexLength;
                                    this.indexArray.emplaceBack(k + 2, k + 3, e1), this.indexArray.emplaceBack(k + 3, e1 + 1, e1), this.indexArray.emplaceBack(k + 3, a, e1 + 1), s.primitiveLength += 3;
                                }
                                d = !d;
                            }
                            if (u) {
                                const t1 = this.layoutVertexExtArray, e1 = l.projectTilePoint(x.x, x.y, n), r = l.projectTilePoint(v.x, v.y, n), i = l.upVector(n, x.x, x.y), s = l.upVector(n, v.x, v.y);
                                hh(t1, e1, i), hh(t1, e1, i), hh(t1, r, s), hh(t1, r, s);
                            }
                        }
                        h && (r += i.length - 1);
                    }
                }
                if (c && c.polyCount.length > 0) {
                    if (c.borders) {
                        c.vertexArrayOffset = this.centroidVertexArray.length;
                        const t1 = c.borders, e1 = this.featuresOnBorder.push(c) - 1;
                        for(let r = 0; r < 4; r++)t1[r][0] !== Number.MAX_VALUE && this.borders[r].push(e1);
                    }
                    this.encodeCentroid(c.borders ? void 0 : c.centroid(), c);
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n);
            }
            sortBorders() {
                for(let t1 = 0; t1 < 4; t1++)this.borders[t1].sort((e1, r)=>this.featuresOnBorder[e1].borders[t1][0] - this.featuresOnBorder[r].borders[t1][0]);
            }
            encodeCentroid(t1, e1, r = !0) {
                let n, i;
                if (t1) {
                    if (0 !== t1.y) {
                        const r = e1.span()._mult(this.tileToMeter);
                        n = (Math.max(t1.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(t1.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));
                    } else n = Math.ceil(7 * (t1.x + 450)), i = 0;
                } else n = 0, i = +r;
                let s = r ? this.centroidVertexArray.length : e1.vertexArrayOffset;
                for (const t1 of e1.polyCount){
                    r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t1.edges + t1.top);
                    for(let e1 = 0; e1 < t1.top; e1++)this.centroidVertexArray.emplace(s++, n, i);
                    for(let e1 = 0; e1 < 2 * t1.edges; e1++)this.centroidVertexArray.emplace(s++, 0, i), this.centroidVertexArray.emplace(s++, n, i);
                }
            }
        }
        function dh(t1, e1) {
            const r = t1.add(e1)._unit();
            return t1.x * r.x + t1.y * r.y;
        }
        function yh(t1, e1, r, n) {
            const i = e1.sub(t1)._perp()._unit(), s = r.sub(e1)._perp()._unit();
            return mh(t1, e1, r, dh(i, s), n);
        }
        function mh(t1, e1, r, n, i) {
            const s = Math.sqrt(1 - n * n);
            return Math.min(t1.dist(e1) / 3, e1.dist(r) / 3, i * s / n);
        }
        function gh(t1, e1, r) {
            return t1.x < r[0].x && e1.x < r[0].x || t1.x > r[1].x && e1.x > r[1].x || t1.y < r[0].y && e1.y < r[0].y || t1.y > r[1].y && e1.y > r[1].y;
        }
        function xh(t1, e1, r) {
            if (t1.x < 0 || t1.x >= ko || e1.x < 0 || e1.x >= ko || r.x < 0 || r.x >= ko) return !1;
            const n = r.sub(e1), i = n.perp(), s = t1.sub(e1);
            return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -0.866 && i.x * s.x + i.y * s.y < 0;
        }
        function vh(t1, e1, r) {
            const n = e1 ? 2 | t1 : -3 & t1;
            return r ? 1 | n : -2 & n;
        }
        function bh() {
            const t1 = Math.PI / 32, e1 = Math.tan(t1), r = tu;
            return r * Math.sqrt(1 + 2 * e1 * e1) - r;
        }
        function wh(t1, e1, r) {
            const n = 1 << r.z, i = ou(r.x / n), s = ou((r.x + 1) / n), a = lu(r.y / n), o = lu((r.y + 1) / n);
            return function(t1, e1, r, n, i = 0, s) {
                const a = [];
                if (!t1.length || !r || !n) return a;
                const o = (t1, e1)=>{
                    for (const r of t1)a.push({
                        polygon: r,
                        bounds: e1
                    });
                }, l = Math.ceil(Math.log2(r)), u = Math.ceil(Math.log2(n)), c = l - u, h = [];
                for(let t1 = 0; t1 < Math.abs(c); t1++)h.push(c > 0 ? 0 : 1);
                for(let t1 = 0; t1 < Math.min(l, u); t1++)h.push(0), h.push(1);
                let p = t1;
                if (p = oh(p, e1[0].y - i, e1[1].y + i, 1), p = oh(p, e1[0].x - i, e1[1].x + i, 0), !p.length) return a;
                const f = [];
                for(h.length ? f.push({
                    polygons: p,
                    bounds: e1,
                    depth: 0
                }) : o(p, e1); f.length;){
                    const t1 = f.pop(), e1 = t1.depth, r = h[e1], n = t1.bounds[0], a = t1.bounds[1], l = 0 === r ? n.x : n.y, u = 0 === r ? a.x : a.y, c = s ? s(r, l, u) : .5 * (l + u), p = oh(t1.polygons, l - i, c + i, r), y = oh(t1.polygons, c - i, u + i, r);
                    if (p.length) {
                        const t1 = [
                            n,
                            new d(0 === r ? c : a.x, 1 === r ? c : a.y)
                        ];
                        h.length > e1 + 1 ? f.push({
                            polygons: p,
                            bounds: t1,
                            depth: e1 + 1
                        }) : o(p, t1);
                    }
                    if (y.length) {
                        const t1 = [
                            new d(0 === r ? c : n.x, 1 === r ? c : n.y),
                            a
                        ];
                        h.length > e1 + 1 ? f.push({
                            polygons: y,
                            bounds: t1,
                            depth: e1 + 1
                        }) : o(y, t1);
                    }
                }
                return a;
            }(t1, e1, Math.ceil((s - i) / 11.25), Math.ceil((a - o) / 11.25), 1, (t1, e1, i)=>{
                if (0 === t1) return .5 * (e1 + i);
                {
                    const t1 = lu((r.y + e1 / ko) / n);
                    return (su(.5 * (lu((r.y + i / ko) / n) + t1)) * n - r.y) * ko;
                }
            });
        }
        Oi(fh, "FillExtrusionBucket", {
            omit: [
                "layers",
                "features"
            ]
        }), Oi(ph, "PartMetadata");
        const _h = new Js({
            "fill-extrusion-edge-radius": new Ys(Ht["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
        });
        var Ah = {
            paint: new Js({
                "fill-extrusion-opacity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                "fill-extrusion-color": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-color"]),
                "fill-extrusion-translate": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate"]),
                "fill-extrusion-translate-anchor": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                "fill-extrusion-pattern": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                "fill-extrusion-height": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-height"]),
                "fill-extrusion-base": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-base"]),
                "fill-extrusion-vertical-gradient": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                "fill-extrusion-ambient-occlusion-intensity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                "fill-extrusion-ambient-occlusion-radius": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"])
            }),
            layout: _h
        };
        function Sh(t1, e1, r) {
            var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
            return [
                t1 * n - 2 * Math.PI * 6378137 / 2,
                e1 * n - 2 * Math.PI * 6378137 / 2
            ];
        }
        class kh {
            constructor(t1, e1, r){
                this.z = t1, this.x = e1, this.y = r, this.key = Th(0, t1, t1, e1, r);
            }
            equals(t1) {
                return this.z === t1.z && this.x === t1.x && this.y === t1.y;
            }
            url(t1, e1) {
                const r = function(t1, e1, r) {
                    var n = Sh(256 * t1, 256 * (e1 = Math.pow(2, r) - e1 - 1), r), i = Sh(256 * (t1 + 1), 256 * (e1 + 1), r);
                    return n[0] + "," + n[1] + "," + i[0] + "," + i[1];
                }(this.x, this.y, this.z), n = function(t1, e1, r) {
                    let n, i = "";
                    for(let s = t1; s > 0; s--)n = 1 << s - 1, i += (e1 & n ? 1 : 0) + (r & n ? 2 : 0);
                    return i;
                }(this.z, this.x, this.y);
                return t1[(this.x + this.y) % t1.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e1 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }
        class Ih {
            constructor(t1, e1){
                this.wrap = t1, this.canonical = e1, this.key = Th(t1, e1.z, e1.z, e1.x, e1.y);
            }
        }
        class Mh {
            constructor(t1, e1, r, n, i){
                this.overscaledZ = t1, this.wrap = e1, this.canonical = new kh(r, +n, +i), this.key = 0 === e1 && t1 === r ? this.canonical.key : Th(e1, t1, r, n, i);
            }
            equals(t1) {
                return this.overscaledZ === t1.overscaledZ && this.wrap === t1.wrap && this.canonical.equals(t1.canonical);
            }
            scaledTo(t1) {
                const e1 = this.canonical.z - t1;
                return t1 > this.canonical.z ? new Mh(t1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Mh(t1, this.wrap, t1, this.canonical.x >> e1, this.canonical.y >> e1);
            }
            calculateScaledKey(t1, e1 = !0) {
                if (this.overscaledZ === t1 && e1) return this.key;
                if (t1 > this.canonical.z) return Th(this.wrap * +e1, t1, this.canonical.z, this.canonical.x, this.canonical.y);
                {
                    const r = this.canonical.z - t1;
                    return Th(this.wrap * +e1, t1, t1, this.canonical.x >> r, this.canonical.y >> r);
                }
            }
            isChildOf(t1) {
                if (t1.wrap !== this.wrap) return !1;
                const e1 = this.canonical.z - t1.canonical.z;
                return 0 === t1.overscaledZ || t1.overscaledZ < this.overscaledZ && t1.canonical.x === this.canonical.x >> e1 && t1.canonical.y === this.canonical.y >> e1;
            }
            children(t1) {
                if (this.overscaledZ >= t1) return [
                    new Mh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                ];
                const e1 = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y;
                return [
                    new Mh(e1, this.wrap, e1, r, n),
                    new Mh(e1, this.wrap, e1, r + 1, n),
                    new Mh(e1, this.wrap, e1, r, n + 1),
                    new Mh(e1, this.wrap, e1, r + 1, n + 1)
                ];
            }
            isLessThan(t1) {
                return this.wrap < t1.wrap || !(this.wrap > t1.wrap) && (this.overscaledZ < t1.overscaledZ || !(this.overscaledZ > t1.overscaledZ) && (this.canonical.x < t1.canonical.x || !(this.canonical.x > t1.canonical.x) && this.canonical.y < t1.canonical.y));
            }
            wrapped() {
                return new Mh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t1) {
                return new Mh(this.overscaledZ, t1, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
                return new Ih(this.wrap, this.canonical);
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
        }
        function Th(t1, e1, r, n, i) {
            const s = 1 << Math.min(r, 22);
            let a = s * (i % s) + n % s;
            return t1 && r < 22 && (a += s * s * ((t1 < 0 ? -2 * t1 - 1 : 2 * t1) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e1 - r);
        }
        Oi(kh, "CanonicalTileID"), Oi(Mh, "OverscaledTileID", {
            omit: [
                "projMatrix"
            ]
        });
        class zh extends d {
            constructor(t1, e1, r){
                super(t1, e1), this.z = r;
            }
        }
        function Bh(t1, e1) {
            return t1.x * e1.x + t1.y * e1.y;
        }
        function Eh(t1, e1) {
            if (1 === t1.length) {
                let r = 0;
                const n = e1[r++];
                let i;
                for(; !i || n.equals(i);)if (i = e1[r++], !i) return 1 / 0;
                for(; r < e1.length; r++){
                    const s = e1[r], a = t1[0], o = i.sub(n), l = s.sub(n), u = a.sub(n), c = Bh(o, o), h = Bh(o, l), p = Bh(l, l), f = Bh(u, o), d = Bh(u, l), y = c * p - h * h, m = (p * f - h * d) / y, g = (c * d - h * f) / y, x = n.z * (1 - m - g) + i.z * m + s.z * g;
                    if (isFinite(x)) return x;
                }
                return 1 / 0;
            }
            {
                let t1 = 1 / 0;
                for (const r of e1)t1 = Math.min(t1, r.z);
                return t1;
            }
        }
        function Ch(t1, e1, r, n, i, s, a, o) {
            const l = a * i.getElevationAt(t1, e1, !0, !0), u = 0 !== s[0], c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function(t1, e1, r) {
                const n = Math.floor(e1[0] / 8), i = Math.floor(e1[1] / 8), s = 10 * (e1[0] - 8 * n), a = 10 * (e1[1] - 8 * i), o = t1.getElevationAt(n, i, !0, !0), l = t1.getMeterToDEM(r), u = Math.floor(.5 * (s * l - 1)), c = Math.floor(.5 * (a * l - 1)), h = t1.tileCoordToPixel(n, i), p = 2 * u + 1, f = 2 * c + 1, d = function(t1, e1, r, n, i) {
                    return [
                        t1.getElevationAtPixel(e1, r, !0),
                        t1.getElevationAtPixel(e1 + i, r, !0),
                        t1.getElevationAtPixel(e1, r + i, !0),
                        t1.getElevationAtPixel(e1 + n, r + i, !0)
                    ];
                }(t1, h.x - u, h.y - c, p, f), y = Math.abs(d[0] - d[1]), m = Math.abs(d[2] - d[3]), g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]), x = Math.min(.25, .5 * l * (y + m) / p), v = Math.min(.25, .5 * l * g / f);
                return o + Math.max(x * s, v * a);
            }(i, s, o) : l;
            return {
                base: l + (0 === r) ? -1 : r,
                top: u ? Math.max(c + n, l + r + 2) : l + n
            };
        }
        const Ph = na([
            {
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint8"
            },
            {
                name: "a_linesofar",
                components: 1,
                type: "Float32"
            }
        ], 4), { members: Dh  } = Ph, Vh = na([
            {
                name: "a_packed",
                components: 4,
                type: "Float32"
            }
        ]), { members: Lh  } = Vh, Fh = ah.types, Rh = Math.cos(Math.PI / 180 * 37.5);
        class jh {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.projection = t1.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t1)=>{
                    this.gradients[t1.id] = {};
                }), this.layoutVertexArray = new la, this.layoutVertexArray2 = new ua, this.indexArray = new wa, this.programConfigurations = new fo(t1.layers, t1.zoom), this.segments = new So, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            populate(t1, e1, r, n) {
                this.hasPattern = Rc("line", this.layers, e1);
                const i = this.layers[0].layout.get("line-sort-key"), s = [];
                for (const { feature: e1 , id: a , index: o , sourceLayerIndex: l  } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = wu(e1, t1);
                    if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u, r)) continue;
                    const c = i ? i.evaluate(u, {}, r) : void 0, h = {
                        id: a,
                        properties: e1.properties,
                        type: e1.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : bu(e1, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    s.push(h);
                }
                i && s.sort((t1, e1)=>t1.sortKey - e1.sortKey);
                const { lineAtlas: a , featureIndex: o  } = e1, l = this.addConstantDashes(a);
                for (const n of s){
                    const { geometry: i , index: s , sourceLayerIndex: u  } = n;
                    if (l && this.addFeatureDashes(n, a), this.hasPattern) {
                        const t1 = jc("line", this.layers, n, this.zoom, e1);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, s, r, a.positions, e1.availableImages);
                    o.insert(t1[s].feature, i, s, u, this.index);
                }
            }
            addConstantDashes(t1) {
                let e1 = !1;
                for (const r of this.layers){
                    const n = r.paint.get("line-dasharray").value, i = r.layout.get("line-cap").value;
                    if ("constant" !== n.kind || "constant" !== i.kind) e1 = !0;
                    else {
                        const e1 = i.value, r = n.value;
                        if (!r) continue;
                        t1.addDash(r, e1);
                    }
                }
                return e1;
            }
            addFeatureDashes(t1, e1) {
                const r = this.zoom;
                for (const n of this.layers){
                    const i = n.paint.get("line-dasharray").value, s = n.layout.get("line-cap").value;
                    if ("constant" === i.kind && "constant" === s.kind) continue;
                    let a, o;
                    if ("constant" === i.kind) {
                        if (a = i.value, !a) continue;
                    } else a = i.evaluate({
                        zoom: r
                    }, t1);
                    o = "constant" === s.kind ? s.value : s.evaluate({
                        zoom: r
                    }, t1), e1.addDash(a, o), t1.patterns[n.id] = e1.getKey(a, o);
                }
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t1, e1, this.stateDependentLayers, r, n);
            }
            addFeatures(t1, e1, r, n, i) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e1, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t1.createVertexBuffer(this.layoutVertexArray2, Lh)), this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Dh), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t1) {
                if (t1.properties && t1.properties.hasOwnProperty("mapbox_clip_start") && t1.properties.hasOwnProperty("mapbox_clip_end")) return {
                    start: +t1.properties.mapbox_clip_start,
                    end: +t1.properties.mapbox_clip_end
                };
            }
            addFeature(t1, e1, r, n, i, s) {
                const a = this.layers[0].layout, o = a.get("line-join").evaluate(t1, {}), l = a.get("line-cap").evaluate(t1, {}), u = a.get("line-miter-limit"), c = a.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t1);
                for (const r of e1)this.addLine(r, t1, o, l, u, c);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, s, n);
            }
            addLine(t1, e1, r, n, i, s) {
                if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);
                    for(let e1 = 0; e1 < t1.length - 1; e1++)this.totalDistance += t1[e1].dist(t1[e1 + 1]);
                    this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                }
                const a = "Polygon" === Fh[e1.type];
                let o = t1.length;
                for(; o >= 2 && t1[o - 1].equals(t1[o - 2]);)o--;
                let l = 0;
                for(; l < o - 1 && t1[l].equals(t1[l + 1]);)l++;
                if (o < (a ? 3 : 2)) return;
                "bevel" === r && (i = 1.05);
                const u = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);
                let h, p, f, d, y;
                this.e1 = this.e2 = -1, a && (h = t1[o - 2], y = t1[l].sub(h)._unit()._perp());
                for(let e1 = l; e1 < o; e1++){
                    if (f = e1 === o - 1 ? a ? t1[l + 1] : void 0 : t1[e1 + 1], f && t1[e1].equals(f)) continue;
                    y && (d = y), h && (p = h), h = t1[e1], y = f ? f.sub(h)._unit()._perp() : d, d = d || y;
                    let m = d.add(y);
                    0 === m.x && 0 === m.y || m._unit();
                    const g = d.x * y.x + d.y * y.y, x = m.x * y.x + m.y * y.y, v = 0 !== x ? 1 / x : 1 / 0, b = 2 * Math.sqrt(2 - 2 * x), w = x < Rh && p && f, _ = d.x * y.y - d.y * y.x > 0;
                    if (w && e1 > l) {
                        const t1 = h.dist(p);
                        if (t1 > 2 * u) {
                            const e1 = h.sub(h.sub(p)._mult(u / t1)._round());
                            this.updateDistance(p, e1), this.addCurrentVertex(e1, d, 0, 0, c), p = e1;
                        }
                    }
                    const A = p && f;
                    let S = A ? r : a ? "butt" : n;
                    if (A && "round" === S && (v < s ? S = "miter" : v <= 2 && (S = "fakeround")), "miter" === S && v > i && (S = "bevel"), "bevel" === S && (v > 2 && (S = "flipbevel"), v < i && (S = "miter")), p && this.updateDistance(p, h), "miter" === S) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);
                    else if ("flipbevel" === S) {
                        if (v > 100) m = y.mult(-1);
                        else {
                            const t1 = v * d.add(y).mag() / d.sub(y).mag();
                            m._perp()._mult(t1 * (_ ? -1 : 1));
                        }
                        this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);
                    } else if ("bevel" === S || "fakeround" === S) {
                        const t1 = -Math.sqrt(v * v - 1), e1 = _ ? t1 : 0, r = _ ? 0 : t1;
                        if (p && this.addCurrentVertex(h, d, e1, r, c), "fakeround" === S) {
                            const t1 = Math.round(180 * b / Math.PI / 20);
                            for(let e1 = 1; e1 < t1; e1++){
                                let r = e1 / t1;
                                if (.5 !== r) {
                                    const t1 = r - .5;
                                    r += r * t1 * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t1 * t1 + (.848013 + g * (.215638 * g - 1.06021)));
                                }
                                const n = y.sub(d)._mult(r)._add(d)._unit()._mult(_ ? -1 : 1);
                                this.addHalfVertex(h, n.x, n.y, !1, _, 0, c);
                            }
                        }
                        f && this.addCurrentVertex(h, y, -e1, -r, c);
                    } else if ("butt" === S) this.addCurrentVertex(h, m, 0, 0, c);
                    else if ("square" === S) {
                        const t1 = p ? 1 : -1;
                        p || this.addCurrentVertex(h, m, t1, t1, c), this.addCurrentVertex(h, m, 0, 0, c), p && this.addCurrentVertex(h, m, t1, t1, c);
                    } else "round" === S && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));
                    if (w && e1 < o - 1) {
                        const t1 = h.dist(f);
                        if (t1 > 2 * u) {
                            const e1 = h.add(f.sub(h)._mult(u / t1)._round());
                            this.updateDistance(h, e1), this.addCurrentVertex(e1, y, 0, 0, c), h = e1;
                        }
                    }
                }
            }
            addCurrentVertex(t1, e1, r, n, i, s = !1) {
                const a = e1.y * n - e1.x, o = -e1.y - e1.x * n;
                this.addHalfVertex(t1, e1.x + e1.y * r, e1.y - e1.x * r, s, !1, r, i), this.addHalfVertex(t1, a, o, s, !0, -n, i);
            }
            addHalfVertex({ x: t1 , y: e1  }, r, n, i, s, a, o) {
                this.layoutVertexArray.emplaceBack((t1 << 1) + (i ? 1 : 0), (e1 << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                const l = o.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), s ? this.e2 = l : this.e1 = l;
            }
            updateScaledDistance() {
                if (this.lineClips) {
                    const t1 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                    this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t1 * this.lineClips.start + this.distance;
                } else this.lineSoFar = this.distance;
            }
            updateDistance(t1, e1) {
                this.distance += t1.dist(e1), this.updateScaledDistance();
            }
        }
        Oi(jh, "LineBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const Uh = new Js({
            "line-cap": new Hs(Ht.layout_line["line-cap"]),
            "line-join": new Hs(Ht.layout_line["line-join"]),
            "line-miter-limit": new Ys(Ht.layout_line["line-miter-limit"]),
            "line-round-limit": new Ys(Ht.layout_line["line-round-limit"]),
            "line-sort-key": new Hs(Ht.layout_line["line-sort-key"])
        });
        var $h = {
            paint: new Js({
                "line-opacity": new Hs(Ht.paint_line["line-opacity"]),
                "line-color": new Hs(Ht.paint_line["line-color"]),
                "line-translate": new Ys(Ht.paint_line["line-translate"]),
                "line-translate-anchor": new Ys(Ht.paint_line["line-translate-anchor"]),
                "line-width": new Hs(Ht.paint_line["line-width"]),
                "line-gap-width": new Hs(Ht.paint_line["line-gap-width"]),
                "line-offset": new Hs(Ht.paint_line["line-offset"]),
                "line-blur": new Hs(Ht.paint_line["line-blur"]),
                "line-dasharray": new Hs(Ht.paint_line["line-dasharray"]),
                "line-pattern": new Hs(Ht.paint_line["line-pattern"]),
                "line-gradient": new Ws(Ht.paint_line["line-gradient"]),
                "line-trim-offset": new Ys(Ht.paint_line["line-trim-offset"])
            }),
            layout: Uh
        };
        const Oh = new class extends Hs {
            possiblyEvaluate(t1, e1) {
                return e1 = new Us(Math.floor(e1.zoom), {
                    now: e1.now,
                    fadeDuration: e1.fadeDuration,
                    transition: e1.transition
                }), super.possiblyEvaluate(t1, e1);
            }
            evaluate(t1, e1, r, n) {
                return e1 = z({}, e1, {
                    zoom: Math.floor(e1.zoom)
                }), super.evaluate(t1, e1, r, n);
            }
        }($h.paint.properties["line-width"].specification);
        function qh(t1, e1) {
            return e1 > 0 ? e1 + 2 * t1 : t1;
        }
        Oh.useIntegerZoom = !0;
        const Nh = na([
            {
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }
        ], 4), Gh = na([
            {
                name: "a_globe_anchor",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_globe_normal",
                components: 3,
                type: "Float32"
            }
        ], 4), Xh = na([
            {
                name: "a_projected_pos",
                components: 4,
                type: "Float32"
            }
        ], 4);
        na([
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }
        ], 4);
        const Zh = na([
            {
                name: "a_placed",
                components: 2,
                type: "Uint8"
            },
            {
                name: "a_shift",
                components: 2,
                type: "Float32"
            }
        ]), Kh = na([
            {
                name: "a_size_scale",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_padding",
                components: 2,
                type: "Float32"
            }
        ]);
        na([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "tileAnchorX"
            },
            {
                type: "Int16",
                name: "tileAnchorY"
            },
            {
                type: "Float32",
                name: "x1"
            },
            {
                type: "Float32",
                name: "y1"
            },
            {
                type: "Float32",
                name: "x2"
            },
            {
                type: "Float32",
                name: "y2"
            },
            {
                type: "Int16",
                name: "padding"
            },
            {
                type: "Uint32",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "sourceLayerIndex"
            },
            {
                type: "Uint16",
                name: "bucketIndex"
            }
        ]);
        const Yh = na([
            {
                name: "a_pos",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }
        ], 4), Hh = na([
            {
                name: "a_pos_2f",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_radius",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }
        ], 4);
        na([
            {
                name: "triangle",
                components: 3,
                type: "Uint16"
            }
        ]), na([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Uint16",
                name: "glyphStartIndex"
            },
            {
                type: "Uint16",
                name: "numGlyphs"
            },
            {
                type: "Uint32",
                name: "vertexStartIndex"
            },
            {
                type: "Uint32",
                name: "lineStartIndex"
            },
            {
                type: "Uint32",
                name: "lineLength"
            },
            {
                type: "Uint16",
                name: "segment"
            },
            {
                type: "Uint16",
                name: "lowerSize"
            },
            {
                type: "Uint16",
                name: "upperSize"
            },
            {
                type: "Float32",
                name: "lineOffsetX"
            },
            {
                type: "Float32",
                name: "lineOffsetY"
            },
            {
                type: "Uint8",
                name: "writingMode"
            },
            {
                type: "Uint8",
                name: "placedOrientation"
            },
            {
                type: "Uint8",
                name: "hidden"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Int16",
                name: "associatedIconIndex"
            },
            {
                type: "Uint8",
                name: "flipState"
            }
        ]), na([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "placedIconSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            },
            {
                type: "Uint16",
                name: "key"
            },
            {
                type: "Uint16",
                name: "textBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "textBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numIconVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalIconVertices"
            },
            {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Float32",
                components: 2,
                name: "textOffset"
            },
            {
                type: "Float32",
                name: "collisionCircleDiameter"
            }
        ]), na([
            {
                type: "Float32",
                name: "offsetX"
            }
        ]), na([
            {
                type: "Int16",
                name: "x"
            },
            {
                type: "Int16",
                name: "y"
            }
        ]);
        var Wh = 24;
        const Jh = 128;
        function Qh(t1, e1) {
            const { expression: r  } = e1;
            if ("constant" === r.kind) return {
                kind: "constant",
                layoutSize: r.evaluate(new Us(t1 + 1))
            };
            if ("source" === r.kind) return {
                kind: "source"
            };
            {
                const { zoomStops: e1 , interpolationType: n  } = r;
                let i = 0;
                for(; i < e1.length && e1[i] <= t1;)i++;
                i = Math.max(0, i - 1);
                let s = i;
                for(; s < e1.length && e1[s] < t1 + 1;)s++;
                s = Math.min(e1.length - 1, s);
                const a = e1[i], o = e1[s];
                return "composite" === r.kind ? {
                    kind: "composite",
                    minZoom: a,
                    maxZoom: o,
                    interpolationType: n
                } : {
                    kind: "camera",
                    minZoom: a,
                    maxZoom: o,
                    minSize: r.evaluate(new Us(a)),
                    maxSize: r.evaluate(new Us(o)),
                    interpolationType: n
                };
            }
        }
        function tp(t1, { uSize: e1 , uSizeT: r  }, { lowerSize: n , upperSize: i  }) {
            return "source" === t1.kind ? n / Jh : "composite" === t1.kind ? Mr(n / Jh, i / Jh, r) : e1;
        }
        function ep(t1, e1) {
            let r = 0, n = 0;
            if ("constant" === t1.kind) n = t1.layoutSize;
            else if ("source" !== t1.kind) {
                const { interpolationType: i , minZoom: s , maxZoom: a  } = t1, o = i ? S(Kr.interpolationFactor(i, e1, s, a), 0, 1) : 0;
                "camera" === t1.kind ? n = Mr(t1.minSize, t1.maxSize, o) : r = o;
            }
            return {
                uSizeT: r,
                uSize: n
            };
        }
        var rp = Object.freeze({
            __proto__: null,
            getSizeData: Qh,
            evaluateSizeForFeature: tp,
            evaluateSizeForZoom: ep,
            SIZE_PACK_FACTOR: Jh
        });
        function np(t1, e1, r) {
            return t1.sections.forEach((t1)=>{
                t1.text = function(t1, e1, r) {
                    const n = e1.layout.get("text-transform").evaluate(r, {});
                    return "uppercase" === n ? t1 = t1.toLocaleUpperCase() : "lowercase" === n && (t1 = t1.toLocaleLowerCase()), js.applyArabicShaping && (t1 = js.applyArabicShaping(t1)), t1;
                }(t1.text, e1, r);
            }), t1;
        }
        const ip = {
            "!": "︕",
            "#": "＃",
            $: "＄",
            "%": "％",
            "&": "＆",
            "(": "︵",
            ")": "︶",
            "*": "＊",
            "+": "＋",
            ",": "︐",
            "-": "︲",
            ".": "・",
            "/": "／",
            ":": "︓",
            ";": "︔",
            "<": "︿",
            "=": "＝",
            ">": "﹀",
            "?": "︖",
            "@": "＠",
            "[": "﹇",
            "\\": "＼",
            "]": "﹈",
            "^": "＾",
            _: "︳",
            "`": "｀",
            "{": "︷",
            "|": "―",
            "}": "︸",
            "~": "～",
            "\xa2": "￠",
            "\xa3": "￡",
            "\xa5": "￥",
            "\xa6": "￤",
            "\xac": "￢",
            "\xaf": "￣",
            "–": "︲",
            "—": "︱",
            "‘": "﹃",
            "’": "﹄",
            "“": "﹁",
            "”": "﹂",
            "…": "︙",
            "‧": "・",
            "₩": "￦",
            "、": "︑",
            "。": "︒",
            "〈": "︿",
            "〉": "﹀",
            "《": "︽",
            "》": "︾",
            "「": "﹁",
            "」": "﹂",
            "『": "﹃",
            "』": "﹄",
            "【": "︻",
            "】": "︼",
            "〔": "︹",
            "〕": "︺",
            "〖": "︗",
            "〗": "︘",
            "！": "︕",
            "（": "︵",
            "）": "︶",
            "，": "︐",
            "－": "︲",
            "．": "・",
            "：": "︓",
            "；": "︔",
            "＜": "︿",
            "＞": "﹀",
            "？": "︖",
            "［": "﹇",
            "］": "﹈",
            "＿": "︳",
            "｛": "︷",
            "｜": "―",
            "｝": "︸",
            "｟": "︵",
            "｠": "︶",
            "｡": "︒",
            "｢": "﹁",
            "｣": "﹂"
        };
        function sp(t1) {
            return "︶" === t1 || "﹈" === t1 || "︸" === t1 || "﹄" === t1 || "﹂" === t1 || "︾" === t1 || "︼" === t1 || "︺" === t1 || "︘" === t1 || "﹀" === t1 || "︐" === t1 || "︓" === t1 || "︔" === t1 || "｀" === t1 || "￣" === t1 || "︑" === t1 || "︒" === t1;
        }
        function ap(t1) {
            return "︵" === t1 || "﹇" === t1 || "︷" === t1 || "﹃" === t1 || "﹁" === t1 || "︽" === t1 || "︻" === t1 || "︹" === t1 || "︗" === t1 || "︿" === t1;
        }
        var op = cp, lp = function(t1, e1, r, n, i) {
            var s, a, o = 8 * i - n - 1, l = (1 << o) - 1, u = l >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, f = t1[e1 + h];
            for(h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t1[e1 + h], h += p, c -= 8);
            for(a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t1[e1 + h], h += p, c -= 8);
            if (0 === s) s = 1 - u;
            else {
                if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);
                a += Math.pow(2, n), s -= u;
            }
            return (f ? -1 : 1) * a * Math.pow(2, s - n);
        }, up = function(t1, e1, r, n, i, s) {
            var a, o, l, u = 8 * s - i - 1, c = (1 << u) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : s - 1, d = n ? 1 : -1, y = e1 < 0 || 0 === e1 && 1 / e1 < 0 ? 1 : 0;
            for(e1 = Math.abs(e1), isNaN(e1) || e1 === 1 / 0 ? (o = isNaN(e1) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e1) / Math.LN2), e1 * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e1 += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e1 * l - 1) * Math.pow(2, i), a += h) : (o = e1 * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t1[r + f] = 255 & o, f += d, o /= 256, i -= 8);
            for(a = a << i | o, u += i; u > 0; t1[r + f] = 255 & a, f += d, a /= 256, u -= 8);
            t1[r + f - d] |= 128 * y;
        };
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ function cp(t1) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t1) ? t1 : new Uint8Array(t1 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        cp.Varint = 0, cp.Fixed64 = 1, cp.Bytes = 2, cp.Fixed32 = 5;
        var hp = 4294967296, pp = 1 / hp, fp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function dp(t1) {
            return t1.type === cp.Bytes ? t1.readVarint() + t1.pos : t1.pos + 1;
        }
        function yp(t1, e1, r) {
            return r ? 4294967296 * e1 + (t1 >>> 0) : 4294967296 * (e1 >>> 0) + (t1 >>> 0);
        }
        function mp(t1, e1, r) {
            var n = e1 <= 16383 ? 1 : e1 <= 2097151 ? 2 : e1 <= 268435455 ? 3 : Math.floor(Math.log(e1) / (7 * Math.LN2));
            r.realloc(n);
            for(var i = r.pos - 1; i >= t1; i--)r.buf[i + n] = r.buf[i];
        }
        function gp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeVarint(t1[r]);
        }
        function xp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSVarint(t1[r]);
        }
        function vp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFloat(t1[r]);
        }
        function bp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeDouble(t1[r]);
        }
        function wp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeBoolean(t1[r]);
        }
        function _p(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFixed32(t1[r]);
        }
        function Ap(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSFixed32(t1[r]);
        }
        function Sp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeFixed64(t1[r]);
        }
        function kp(t1, e1) {
            for(var r = 0; r < t1.length; r++)e1.writeSFixed64(t1[r]);
        }
        function Ip(t1, e1) {
            return (t1[e1] | t1[e1 + 1] << 8 | t1[e1 + 2] << 16) + 16777216 * t1[e1 + 3];
        }
        function Mp(t1, e1, r) {
            t1[r] = e1, t1[r + 1] = e1 >>> 8, t1[r + 2] = e1 >>> 16, t1[r + 3] = e1 >>> 24;
        }
        function Tp(t1, e1) {
            return (t1[e1] | t1[e1 + 1] << 8 | t1[e1 + 2] << 16) + (t1[e1 + 3] << 24);
        }
        function zp(t1, e1, r) {
            e1.glyphs = [], 1 === t1 && r.readMessage(Bp, e1);
        }
        function Bp(t1, e1, r) {
            if (3 === t1) {
                const { id: t1 , bitmap: n , width: i , height: s , left: a , top: o , advance: l  } = r.readMessage(Ep, {});
                e1.glyphs.push({
                    id: t1,
                    bitmap: new Ju({
                        width: i + 6,
                        height: s + 6
                    }, n),
                    metrics: {
                        width: i,
                        height: s,
                        left: a,
                        top: o,
                        advance: l
                    }
                });
            } else 4 === t1 ? e1.ascender = r.readSVarint() : 5 === t1 && (e1.descender = r.readSVarint());
        }
        function Ep(t1, e1, r) {
            1 === t1 ? e1.id = r.readVarint() : 2 === t1 ? e1.bitmap = r.readBytes() : 3 === t1 ? e1.width = r.readVarint() : 4 === t1 ? e1.height = r.readVarint() : 5 === t1 ? e1.left = r.readSVarint() : 6 === t1 ? e1.top = r.readSVarint() : 7 === t1 && (e1.advance = r.readVarint());
        }
        function Cp(t1) {
            let e1 = 0, r = 0;
            for (const n of t1)e1 += n.w * n.h, r = Math.max(r, n.w);
            t1.sort((t1, e1)=>e1.h - t1.h);
            const n = [
                {
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(e1 / .95)), r),
                    h: 1 / 0
                }
            ];
            let i = 0, s = 0;
            for (const e1 of t1)for(let t1 = n.length - 1; t1 >= 0; t1--){
                const r = n[t1];
                if (!(e1.w > r.w || e1.h > r.h)) {
                    if (e1.x = r.x, e1.y = r.y, s = Math.max(s, e1.y + e1.h), i = Math.max(i, e1.x + e1.w), e1.w === r.w && e1.h === r.h) {
                        const e1 = n.pop();
                        t1 < n.length && (n[t1] = e1);
                    } else e1.h === r.h ? (r.x += e1.w, r.w -= e1.w) : e1.w === r.w ? (r.y += e1.h, r.h -= e1.h) : (n.push({
                        x: r.x + e1.w,
                        y: r.y,
                        w: r.w - e1.w,
                        h: e1.h
                    }), r.y += e1.h, r.h -= e1.h);
                    break;
                }
            }
            return {
                w: i,
                h: s,
                fill: e1 / (i * s) || 0
            };
        }
        cp.prototype = {
            destroy: function() {
                this.buf = null;
            },
            readFields: function(t1, e1, r) {
                for(r = r || this.length; this.pos < r;){
                    var n = this.readVarint(), i = n >> 3, s = this.pos;
                    this.type = 7 & n, t1(i, e1, this), this.pos === s && this.skip(n);
                }
                return e1;
            },
            readMessage: function(t1, e1) {
                return this.readFields(t1, e1, this.readVarint() + this.pos);
            },
            readFixed32: function() {
                var t1 = Ip(this.buf, this.pos);
                return this.pos += 4, t1;
            },
            readSFixed32: function() {
                var t1 = Tp(this.buf, this.pos);
                return this.pos += 4, t1;
            },
            readFixed64: function() {
                var t1 = Ip(this.buf, this.pos) + Ip(this.buf, this.pos + 4) * hp;
                return this.pos += 8, t1;
            },
            readSFixed64: function() {
                var t1 = Ip(this.buf, this.pos) + Tp(this.buf, this.pos + 4) * hp;
                return this.pos += 8, t1;
            },
            readFloat: function() {
                var t1 = lp(this.buf, this.pos, !0, 23, 4);
                return this.pos += 4, t1;
            },
            readDouble: function() {
                var t1 = lp(this.buf, this.pos, !0, 52, 8);
                return this.pos += 8, t1;
            },
            readVarint: function(t1) {
                var e1, r, n = this.buf;
                return e1 = 127 & (r = n[this.pos++]), r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e1 : (e1 |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e1 : function(t1, e1, r) {
                    var n, i, s = r.buf;
                    if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return yp(t1, n, e1);
                    if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return yp(t1, n, e1);
                    if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return yp(t1, n, e1);
                    if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return yp(t1, n, e1);
                    if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return yp(t1, n, e1);
                    if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return yp(t1, n, e1);
                    throw new Error("Expected varint not more than 10 bytes");
                }(e1 |= (15 & (r = n[this.pos])) << 28, t1, this))));
            },
            readVarint64: function() {
                return this.readVarint(!0);
            },
            readSVarint: function() {
                var t1 = this.readVarint();
                return t1 % 2 == 1 ? (t1 + 1) / -2 : t1 / 2;
            },
            readBoolean: function() {
                return Boolean(this.readVarint());
            },
            readString: function() {
                var t1 = this.readVarint() + this.pos, e1 = this.pos;
                return this.pos = t1, t1 - e1 >= 12 && fp ? function(t1, e1, r) {
                    return fp.decode(t1.subarray(e1, r));
                }(this.buf, e1, t1) : function(t1, e1, r) {
                    for(var n = "", i = e1; i < r;){
                        var s, a, o, l = t1[i], u = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                        if (i + c > r) break;
                        1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t1[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t1[i + 2], 128 == (192 & (s = t1[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t1[i + 2], o = t1[i + 3], 128 == (192 & (s = t1[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;
                    }
                    return n;
                }(this.buf, e1, t1);
            },
            readBytes: function() {
                var t1 = this.readVarint() + this.pos, e1 = this.buf.subarray(this.pos, t1);
                return this.pos = t1, e1;
            },
            readPackedVarint: function(t1, e1) {
                if (this.type !== cp.Bytes) return t1.push(this.readVarint(e1));
                var r = dp(this);
                for(t1 = t1 || []; this.pos < r;)t1.push(this.readVarint(e1));
                return t1;
            },
            readPackedSVarint: function(t1) {
                if (this.type !== cp.Bytes) return t1.push(this.readSVarint());
                var e1 = dp(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSVarint());
                return t1;
            },
            readPackedBoolean: function(t1) {
                if (this.type !== cp.Bytes) return t1.push(this.readBoolean());
                var e1 = dp(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readBoolean());
                return t1;
            },
            readPackedFloat: function(t1) {
                if (this.type !== cp.Bytes) return t1.push(this.readFloat());
                var e1 = dp(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFloat());
                return t1;
            },
            readPackedDouble: function(t1) {
                if (this.type !== cp.Bytes) return t1.push(this.readDouble());
                var e1 = dp(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readDouble());
                return t1;
            },
            readPackedFixed32: function(t1) {
                if (this.type !== cp.Bytes) return t1.push(this.readFixed32());
                var e1 = dp(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFixed32());
                return t1;
            },
            readPackedSFixed32: function(t1) {
                if (this.type !== cp.Bytes) return t1.push(this.readSFixed32());
                var e1 = dp(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSFixed32());
                return t1;
            },
            readPackedFixed64: function(t1) {
                if (this.type !== cp.Bytes) return t1.push(this.readFixed64());
                var e1 = dp(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readFixed64());
                return t1;
            },
            readPackedSFixed64: function(t1) {
                if (this.type !== cp.Bytes) return t1.push(this.readSFixed64());
                var e1 = dp(this);
                for(t1 = t1 || []; this.pos < e1;)t1.push(this.readSFixed64());
                return t1;
            },
            skip: function(t1) {
                var e1 = 7 & t1;
                if (e1 === cp.Varint) for(; this.buf[this.pos++] > 127;);
                else if (e1 === cp.Bytes) this.pos = this.readVarint() + this.pos;
                else if (e1 === cp.Fixed32) this.pos += 4;
                else {
                    if (e1 !== cp.Fixed64) throw new Error("Unimplemented type: " + e1);
                    this.pos += 8;
                }
            },
            writeTag: function(t1, e1) {
                this.writeVarint(t1 << 3 | e1);
            },
            realloc: function(t1) {
                for(var e1 = this.length || 16; e1 < this.pos + t1;)e1 *= 2;
                if (e1 !== this.length) {
                    var r = new Uint8Array(e1);
                    r.set(this.buf), this.buf = r, this.length = e1;
                }
            },
            finish: function() {
                return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            },
            writeFixed32: function(t1) {
                this.realloc(4), Mp(this.buf, t1, this.pos), this.pos += 4;
            },
            writeSFixed32: function(t1) {
                this.realloc(4), Mp(this.buf, t1, this.pos), this.pos += 4;
            },
            writeFixed64: function(t1) {
                this.realloc(8), Mp(this.buf, -1 & t1, this.pos), Mp(this.buf, Math.floor(t1 * pp), this.pos + 4), this.pos += 8;
            },
            writeSFixed64: function(t1) {
                this.realloc(8), Mp(this.buf, -1 & t1, this.pos), Mp(this.buf, Math.floor(t1 * pp), this.pos + 4), this.pos += 8;
            },
            writeVarint: function(t1) {
                (t1 = +t1 || 0) > 268435455 || t1 < 0 ? function(t1, e1) {
                    var r, n;
                    if (t1 >= 0 ? (r = t1 % 4294967296 | 0, n = t1 / 4294967296 | 0) : (n = ~(-t1 / 4294967296), 4294967295 ^ (r = ~(-t1 % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t1 >= 0x10000000000000000 || t1 < -18446744073709552000) throw new Error("Given varint doesn't fit into 10 bytes");
                    e1.realloc(10), function(t1, e1, r) {
                        r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, r.buf[r.pos] = 127 & (t1 >>>= 7);
                    }(r, 0, e1), function(t1, e1) {
                        var r = (7 & t1) << 4;
                        e1.buf[e1.pos++] |= r | ((t1 >>>= 3) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e1.buf[e1.pos++] = 127 & t1)))));
                    }(n, e1);
                }(t1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t1 | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = t1 >>> 7 & 127))));
            },
            writeSVarint: function(t1) {
                this.writeVarint(t1 < 0 ? 2 * -t1 - 1 : 2 * t1);
            },
            writeBoolean: function(t1) {
                this.writeVarint(Boolean(t1));
            },
            writeString: function(t1) {
                t1 = String(t1), this.realloc(4 * t1.length), this.pos++;
                var e1 = this.pos;
                this.pos = function(t1, e1, r) {
                    for(var n, i, s = 0; s < e1.length; s++){
                        if ((n = e1.charCodeAt(s)) > 55295 && n < 57344) {
                            if (!i) {
                                n > 56319 || s + 1 === e1.length ? (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189) : i = n;
                                continue;
                            }
                            if (n < 56320) {
                                t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = n;
                                continue;
                            }
                            n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                        } else i && (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = null);
                        n < 128 ? t1[r++] = n : (n < 2048 ? t1[r++] = n >> 6 | 192 : (n < 65536 ? t1[r++] = n >> 12 | 224 : (t1[r++] = n >> 18 | 240, t1[r++] = n >> 12 & 63 | 128), t1[r++] = n >> 6 & 63 | 128), t1[r++] = 63 & n | 128);
                    }
                    return r;
                }(this.buf, t1, this.pos);
                var r = this.pos - e1;
                r >= 128 && mp(e1, r, this), this.pos = e1 - 1, this.writeVarint(r), this.pos += r;
            },
            writeFloat: function(t1) {
                this.realloc(4), up(this.buf, t1, this.pos, !0, 23, 4), this.pos += 4;
            },
            writeDouble: function(t1) {
                this.realloc(8), up(this.buf, t1, this.pos, !0, 52, 8), this.pos += 8;
            },
            writeBytes: function(t1) {
                var e1 = t1.length;
                this.writeVarint(e1), this.realloc(e1);
                for(var r = 0; r < e1; r++)this.buf[this.pos++] = t1[r];
            },
            writeRawMessage: function(t1, e1) {
                this.pos++;
                var r = this.pos;
                t1(e1, this);
                var n = this.pos - r;
                n >= 128 && mp(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
            },
            writeMessage: function(t1, e1, r) {
                this.writeTag(t1, cp.Bytes), this.writeRawMessage(e1, r);
            },
            writePackedVarint: function(t1, e1) {
                e1.length && this.writeMessage(t1, gp, e1);
            },
            writePackedSVarint: function(t1, e1) {
                e1.length && this.writeMessage(t1, xp, e1);
            },
            writePackedBoolean: function(t1, e1) {
                e1.length && this.writeMessage(t1, wp, e1);
            },
            writePackedFloat: function(t1, e1) {
                e1.length && this.writeMessage(t1, vp, e1);
            },
            writePackedDouble: function(t1, e1) {
                e1.length && this.writeMessage(t1, bp, e1);
            },
            writePackedFixed32: function(t1, e1) {
                e1.length && this.writeMessage(t1, _p, e1);
            },
            writePackedSFixed32: function(t1, e1) {
                e1.length && this.writeMessage(t1, Ap, e1);
            },
            writePackedFixed64: function(t1, e1) {
                e1.length && this.writeMessage(t1, Sp, e1);
            },
            writePackedSFixed64: function(t1, e1) {
                e1.length && this.writeMessage(t1, kp, e1);
            },
            writeBytesField: function(t1, e1) {
                this.writeTag(t1, cp.Bytes), this.writeBytes(e1);
            },
            writeFixed32Field: function(t1, e1) {
                this.writeTag(t1, cp.Fixed32), this.writeFixed32(e1);
            },
            writeSFixed32Field: function(t1, e1) {
                this.writeTag(t1, cp.Fixed32), this.writeSFixed32(e1);
            },
            writeFixed64Field: function(t1, e1) {
                this.writeTag(t1, cp.Fixed64), this.writeFixed64(e1);
            },
            writeSFixed64Field: function(t1, e1) {
                this.writeTag(t1, cp.Fixed64), this.writeSFixed64(e1);
            },
            writeVarintField: function(t1, e1) {
                this.writeTag(t1, cp.Varint), this.writeVarint(e1);
            },
            writeSVarintField: function(t1, e1) {
                this.writeTag(t1, cp.Varint), this.writeSVarint(e1);
            },
            writeStringField: function(t1, e1) {
                this.writeTag(t1, cp.Bytes), this.writeString(e1);
            },
            writeFloatField: function(t1, e1) {
                this.writeTag(t1, cp.Fixed32), this.writeFloat(e1);
            },
            writeDoubleField: function(t1, e1) {
                this.writeTag(t1, cp.Fixed64), this.writeDouble(e1);
            },
            writeBooleanField: function(t1, e1) {
                this.writeVarintField(t1, Boolean(e1));
            }
        };
        class Pp {
            constructor(t1, { pixelRatio: e1 , version: r , stretchX: n , stretchY: i , content: s  }){
                this.paddedRect = t1, this.pixelRatio = e1, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;
            }
            get tl() {
                return [
                    this.paddedRect.x + 1,
                    this.paddedRect.y + 1
                ];
            }
            get br() {
                return [
                    this.paddedRect.x + this.paddedRect.w - 1,
                    this.paddedRect.y + this.paddedRect.h - 1
                ];
            }
            get displaySize() {
                return [
                    (this.paddedRect.w - 2) / this.pixelRatio,
                    (this.paddedRect.h - 2) / this.pixelRatio
                ];
            }
        }
        class Dp {
            constructor(t1, e1){
                const r = {}, n = {};
                this.haveRenderCallbacks = [];
                const i = [];
                this.addImages(t1, r, i), this.addImages(e1, n, i);
                const { w: s , h: a  } = Cp(i), o = new Qu({
                    width: s || 1,
                    height: a || 1
                });
                for(const e1 in t1){
                    const n = t1[e1], i = r[e1].paddedRect;
                    Qu.copy(n.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: i.x + 1,
                        y: i.y + 1
                    }, n.data);
                }
                for(const t1 in e1){
                    const r = e1[t1], i = n[t1].paddedRect, s = i.x + 1, a = i.y + 1, l = r.data.width, u = r.data.height;
                    Qu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s,
                        y: a
                    }, r.data), Qu.copy(r.data, o, {
                        x: 0,
                        y: u - 1
                    }, {
                        x: s,
                        y: a - 1
                    }, {
                        width: l,
                        height: 1
                    }), Qu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s,
                        y: a + u
                    }, {
                        width: l,
                        height: 1
                    }), Qu.copy(r.data, o, {
                        x: l - 1,
                        y: 0
                    }, {
                        x: s - 1,
                        y: a
                    }, {
                        width: 1,
                        height: u
                    }), Qu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s + l,
                        y: a
                    }, {
                        width: 1,
                        height: u
                    });
                }
                this.image = o, this.iconPositions = r, this.patternPositions = n;
            }
            addImages(t1, e1, r) {
                for(const n in t1){
                    const i = t1[n], s = {
                        x: 0,
                        y: 0,
                        w: i.data.width + 2,
                        h: i.data.height + 2
                    };
                    r.push(s), e1[n] = new Pp(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);
                }
            }
            patchUpdatedImages(t1, e1) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e1)=>t1.hasImage(e1)), t1.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for(const r in t1.updatedImages)this.patchUpdatedImage(this.iconPositions[r], t1.getImage(r), e1), this.patchUpdatedImage(this.patternPositions[r], t1.getImage(r), e1);
            }
            patchUpdatedImage(t1, e1, r) {
                if (!t1 || !e1) return;
                if (t1.version === e1.version) return;
                t1.version = e1.version;
                const [n, i] = t1.tl;
                r.update(e1.data, void 0, {
                    x: n,
                    y: i
                });
            }
        }
        Oi(Pp, "ImagePosition"), Oi(Dp, "ImageAtlas");
        const Vp = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        };
        class Lp {
            constructor(){
                this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t1, e1) {
                const r = new Lp;
                return r.scale = t1 || 1, r.fontStack = e1, r;
            }
            static forImage(t1) {
                const e1 = new Lp;
                return e1.imageName = t1, e1;
            }
        }
        class Fp {
            constructor(){
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t1, e1) {
                const r = new Fp;
                for(let n = 0; n < t1.sections.length; n++){
                    const i = t1.sections[n];
                    i.image ? r.addImageSection(i) : r.addTextSection(i, e1);
                }
                return r;
            }
            length() {
                return this.text.length;
            }
            getSection(t1) {
                return this.sections[this.sectionIndex[t1]];
            }
            getSections() {
                return this.sections;
            }
            getSectionIndex(t1) {
                return this.sectionIndex[t1];
            }
            getCharCode(t1) {
                return this.text.charCodeAt(t1);
            }
            verticalizePunctuation(t1) {
                this.text = function(t1, e1) {
                    let r = "";
                    for(let n = 0; n < t1.length; n++){
                        const i = t1.charCodeAt(n + 1) || null, s = t1.charCodeAt(n - 1) || null;
                        r += !e1 && (i && Ss(i) && !ip[t1[n + 1]] || s && Ss(s) && !ip[t1[n - 1]]) || !ip[t1[n]] ? t1[n] : ip[t1[n]];
                    }
                    return r;
                }(this.text, t1);
            }
            trim() {
                let t1 = 0;
                for(let e1 = 0; e1 < this.text.length && jp[this.text.charCodeAt(e1)]; e1++)t1++;
                let e1 = this.text.length;
                for(let r = this.text.length - 1; r >= 0 && r >= t1 && jp[this.text.charCodeAt(r)]; r--)e1--;
                this.text = this.text.substring(t1, e1), this.sectionIndex = this.sectionIndex.slice(t1, e1);
            }
            substring(t1, e1) {
                const r = new Fp;
                return r.text = this.text.substring(t1, e1), r.sectionIndex = this.sectionIndex.slice(t1, e1), r.sections = this.sections, r;
            }
            toString() {
                return this.text;
            }
            getMaxScale() {
                return this.sectionIndex.reduce((t1, e1)=>Math.max(t1, this.sections[e1].scale), 0);
            }
            addTextSection(t1, e1) {
                this.text += t1.text, this.sections.push(Lp.forText(t1.scale, t1.fontStack || e1));
                const r = this.sections.length - 1;
                for(let e1 = 0; e1 < t1.text.length; ++e1)this.sectionIndex.push(r);
            }
            addImageSection(t1) {
                const e1 = t1.image ? t1.image.name : "";
                if (0 === e1.length) return void $("Can't add FormattedSection with an empty image.");
                const r = this.getNextImageSectionCharCode();
                r ? (this.text += String.fromCharCode(r), this.sections.push(Lp.forImage(e1)), this.sectionIndex.push(this.sections.length - 1)) : $("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }
        function Rp(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, d) {
            const y = Fp.fromFeature(t1, i);
            h === Vp.vertical && y.verticalizePunctuation(p);
            let m = [];
            const g = function(t1, e1, r, n, i, s) {
                if (!t1) return [];
                const a = [], o = function(t1, e1, r, n, i, s) {
                    let a = 0;
                    for(let r = 0; r < t1.length(); r++){
                        const o = t1.getSection(r);
                        a += $p(t1.getCharCode(r), o, n, i, e1, s);
                    }
                    return a / Math.max(1, Math.ceil(a / r));
                }(t1, e1, r, n, i, s), l = t1.text.indexOf("​") >= 0;
                let u = 0;
                for(let r = 0; r < t1.length(); r++){
                    const h = t1.getSection(r), p = t1.getCharCode(r);
                    if (jp[p] || (u += $p(p, h, n, i, e1, s)), r < t1.length() - 1) {
                        const e1 = !((c = p) < 11904 || !(ns(c) || rs(c) || ms(c) || fs(c) || os(c) || Hi(c) || is(c) || Qi(c) || ls(c) || us(c) || as(c) || vs(c) || ts(c) || Ji(c) || Wi(c) || ss(c) || es(c) || ys(c) || hs(c) || cs(c)));
                        (Up[p] || e1 || h.imageName) && a.push(Np(r + 1, u, o, a, qp(p, t1.getCharCode(r + 1), e1 && l), !1));
                    }
                }
                var c;
                return Gp(Np(t1.length(), u, o, a, 0, !0));
            }(y, u, s, e1, n, f), { processBidirectionalText: x , processStyledBidirectionalText: v  } = js;
            if (x && 1 === y.sections.length) {
                const t1 = x(y.toString(), g);
                for (const e1 of t1){
                    const t1 = new Fp;
                    t1.text = e1, t1.sections = y.sections;
                    for(let r = 0; r < e1.length; r++)t1.sectionIndex.push(0);
                    m.push(t1);
                }
            } else if (v) {
                const t1 = v(y.text, y.sectionIndex, g);
                for (const e1 of t1){
                    const t1 = new Fp;
                    t1.text = e1[0], t1.sectionIndex = e1[1], t1.sections = y.sections, m.push(t1);
                }
            } else m = function(t1, e1) {
                const r = [], n = t1.text;
                let i = 0;
                for (const n of e1)r.push(t1.substring(i, n)), i = n;
                return i < n.length && r.push(t1.substring(i, n.length)), r;
            }(y, g);
            const b = [], w = {
                positionedLines: b,
                text: y.toString(),
                top: c[1],
                bottom: c[1],
                left: c[0],
                right: c[0],
                writingMode: h,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            return function(t1, e1, r, n, i, s, a, o, l, u, c, h) {
                let p = 0, f = 0, d = 0;
                const y = "right" === o ? 1 : "left" === o ? 0 : .5;
                let m = !1;
                for (const t1 of i){
                    const r = t1.getSections();
                    for (const t1 of r){
                        if (t1.imageName) continue;
                        const r = e1[t1.fontStack];
                        if (r && (m = void 0 !== r.ascender && void 0 !== r.descender, !m)) break;
                    }
                    if (!m) break;
                }
                let g = 0;
                for (const a of i){
                    a.trim();
                    const i = a.getMaxScale(), o = (i - 1) * Wh, v = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t1.positionedLines[g] = v;
                    const b = v.positionedGlyphs;
                    let w = 0;
                    if (!a.length()) {
                        f += s, ++g;
                        continue;
                    }
                    let _ = 0, A = 0;
                    for(let s = 0; s < a.length(); s++){
                        const o = a.getSection(s), d = a.getSectionIndex(s), y = a.getCharCode(s);
                        let g = o.scale, v = null, S = null, k = null, I = Wh, M = 0;
                        const T = !(l === Vp.horizontal || !c && !As(y) || c && (jp[y] || (x = y, Zi(x) || Ki(x) || Yi(x) || ds(x) || xs(x))));
                        if (o.imageName) {
                            const e1 = n[o.imageName];
                            if (!e1) continue;
                            k = o.imageName, t1.iconsInText = t1.iconsInText || !0, S = e1.paddedRect;
                            const r = e1.displaySize;
                            g = g * Wh / h, v = {
                                width: r[0],
                                height: r[1],
                                left: 1,
                                top: -3,
                                advance: T ? r[1] : r[0],
                                localGlyph: !1
                            }, M = m ? -v.height * g : i * Wh - 17 - r[1] * g, I = v.advance;
                            const s = (T ? r[0] : r[1]) * g - Wh * i;
                            s > 0 && s > w && (w = s);
                        } else {
                            const t1 = r[o.fontStack];
                            if (!t1) continue;
                            t1[y] && (S = t1[y]);
                            const n = e1[o.fontStack];
                            if (!n) continue;
                            const s = n.glyphs[y];
                            if (!s) continue;
                            if (v = s.metrics, I = 8203 !== y ? Wh : 0, m) {
                                const t1 = void 0 !== n.ascender ? Math.abs(n.ascender) : 0, e1 = void 0 !== n.descender ? Math.abs(n.descender) : 0, r = (t1 + e1) * g;
                                _ < r && (_ = r, A = (t1 - e1) / 2 * g), M = -t1 * g;
                            } else M = (i - g) * Wh - 17;
                        }
                        T ? (t1.verticalizable = !0, b.push({
                            glyph: y,
                            imageName: k,
                            x: p,
                            y: f + M,
                            vertical: T,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: d,
                            metrics: v,
                            rect: S
                        }), p += I * g + u) : (b.push({
                            glyph: y,
                            imageName: k,
                            x: p,
                            y: f + M,
                            vertical: T,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: d,
                            metrics: v,
                            rect: S
                        }), p += v.advance * g + u);
                    }
                    0 !== b.length && (d = Math.max(p - u, d), m ? Zp(b, y, w, A, s * i / 2) : Zp(b, y, w, 0, s / 2)), p = 0;
                    const S = s * i + w;
                    v.lineOffset = Math.max(w, o), f += S, ++g;
                }
                var x;
                const v = f, { horizontalAlign: b , verticalAlign: w  } = Xp(a);
                (function(t1, e1, r, n, i, s) {
                    const a = (e1 - r) * i, o = -s * n;
                    for (const e1 of t1)for (const t1 of e1.positionedGlyphs)t1.x += a, t1.y += o;
                })(t1.positionedLines, y, b, w, d, v), t1.top += -w * v, t1.bottom = t1.top + v, t1.left += -b * d, t1.right = t1.left + d, t1.hasBaseline = m;
            }(w, e1, r, n, m, a, o, l, h, u, p, d), !function(t1) {
                for (const e1 of t1)if (0 !== e1.positionedGlyphs.length) return !1;
                return !0;
            }(b) && w;
        }
        const jp = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }, Up = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function $p(t1, e1, r, n, i, s) {
            if (e1.imageName) {
                const t1 = n[e1.imageName];
                return t1 ? t1.displaySize[0] * e1.scale * Wh / s + i : 0;
            }
            {
                const n = r[e1.fontStack], s = n && n.glyphs[t1];
                return s ? s.metrics.advance * e1.scale + i : 0;
            }
        }
        function Op(t1, e1, r, n) {
            const i = Math.pow(t1 - e1, 2);
            return n ? t1 < e1 ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }
        function qp(t1, e1, r) {
            let n = 0;
            return 10 === t1 && (n -= 1e4), r && (n += 150), 40 !== t1 && 65288 !== t1 || (n += 50), 41 !== e1 && 65289 !== e1 || (n += 50), n;
        }
        function Np(t1, e1, r, n, i, s) {
            let a = null, o = Op(e1, r, i, s);
            for (const t1 of n){
                const n = Op(e1 - t1.x, r, i, s) + t1.badness;
                n <= o && (a = t1, o = n);
            }
            return {
                index: t1,
                x: e1,
                priorBreak: a,
                badness: o
            };
        }
        function Gp(t1) {
            return t1 ? Gp(t1.priorBreak).concat(t1.index) : [];
        }
        function Xp(t1) {
            let e1 = .5, r = .5;
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    e1 = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    e1 = 0;
            }
            switch(t1){
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    r = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    r = 0;
            }
            return {
                horizontalAlign: e1,
                verticalAlign: r
            };
        }
        function Zp(t1, e1, r, n, i) {
            if (!(e1 || r || n || i)) return;
            const s = t1.length - 1, a = t1[s], o = (a.x + a.metrics.advance * a.scale) * e1;
            for(let e1 = 0; e1 <= s; e1++)t1[e1].x -= o, t1[e1].y += r + n + i;
        }
        function Kp(t1, e1, r) {
            const { horizontalAlign: n , verticalAlign: i  } = Xp(r), s = e1[0] - t1.displaySize[0] * n, a = e1[1] - t1.displaySize[1] * i;
            return {
                image: t1,
                top: a,
                bottom: a + t1.displaySize[1],
                left: s,
                right: s + t1.displaySize[0]
            };
        }
        function Yp(t1, e1, r, n, i, s) {
            const a = t1.image;
            let o;
            if (a.content) {
                const t1 = a.content, e1 = a.pixelRatio || 1;
                o = [
                    t1[0] / e1,
                    t1[1] / e1,
                    a.displaySize[0] - t1[2] / e1,
                    a.displaySize[1] - t1[3] / e1
                ];
            }
            const l = e1.left * s, u = e1.right * s;
            let c, h, p, f;
            "width" === r || "both" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]);
            const d = e1.top * s, y = e1.bottom * s;
            return "height" === r || "both" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {
                image: a,
                top: c,
                right: h,
                bottom: p,
                left: f,
                collisionPadding: o
            };
        }
        class Hp extends d {
            constructor(t1, e1, r, n, i){
                super(t1, e1), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
            }
            clone() {
                return new Hp(this.x, this.y, this.z, this.angle, this.segment);
            }
        }
        function Wp(t1, e1, r, n, i) {
            if (void 0 === e1.segment) return !0;
            let s = e1, a = e1.segment + 1, o = 0;
            for(; o > -r / 2;){
                if (a--, a < 0) return !1;
                o -= t1[a].dist(s), s = t1[a];
            }
            o += t1[a].dist(t1[a + 1]), a++;
            const l = [];
            let u = 0;
            for(; o < r / 2;){
                const e1 = t1[a], r = t1[a + 1];
                if (!r) return !1;
                let s = t1[a - 1].angleTo(e1) - e1.angleTo(r);
                for(s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
                    distance: o,
                    angleDelta: s
                }), u += s; o - l[0].distance > n;)u -= l.shift().angleDelta;
                if (u > i) return !1;
                a++, o += e1.dist(r);
            }
            return !0;
        }
        function Jp(t1) {
            let e1 = 0;
            for(let r = 0; r < t1.length - 1; r++)e1 += t1[r].dist(t1[r + 1]);
            return e1;
        }
        function Qp(t1, e1, r) {
            return t1 ? .6 * e1 * r : 0;
        }
        function tf(t1, e1) {
            return Math.max(t1 ? t1.right - t1.left : 0, e1 ? e1.right - e1.left : 0);
        }
        function ef(t1, e1, r, n, i, s) {
            const a = Qp(r, i, s), o = tf(r, n) * s;
            let l = 0;
            const u = Jp(t1) / 2;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1], s = n.dist(i);
                if (l + s > u) {
                    const c = (u - l) / s, h = Mr(n.x, i.x, c), p = Mr(n.y, i.y, c), f = new Hp(h, p, 0, i.angleTo(n), r);
                    return !a || Wp(t1, f, o, a, e1) ? f : void 0;
                }
                l += s;
            }
        }
        function rf(t1, e1, r, n, i, s, a, o, l) {
            const u = Qp(n, s, a), c = tf(n, i), h = c * a, p = 0 === t1[0].x || t1[0].x === l || 0 === t1[0].y || t1[0].y === l;
            return e1 - h < e1 / 4 && (e1 = h + e1 / 4), nf(t1, p ? e1 / 2 * o % e1 : (c / 2 + 2 * s) * a * o % e1, e1, u, r, h, p, !1, l);
        }
        function nf(t1, e1, r, n, i, s, a, o, l) {
            const u = s / 2, c = Jp(t1);
            let h = 0, p = e1 - r, f = [];
            for(let e1 = 0; e1 < t1.length - 1; e1++){
                const a = t1[e1], o = t1[e1 + 1], d = a.dist(o), y = o.angleTo(a);
                for(; p + r < h + d;){
                    p += r;
                    const m = (p - h) / d, g = Mr(a.x, o.x, m), x = Mr(a.y, o.y, m);
                    if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new Hp(g, x, 0, y, e1);
                        r._round(), n && !Wp(t1, r, s, n, i) || f.push(r);
                    }
                }
                h += d;
            }
            return o || f.length || a || (f = nf(t1, h / 2, r, n, i, s, a, !0, l)), f;
        }
        function sf(t1, e1, r, n, i) {
            const s = [];
            for(let a = 0; a < t1.length; a++){
                const o = t1[a];
                let l;
                for(let t1 = 0; t1 < o.length - 1; t1++){
                    let a = o[t1], u = o[t1 + 1];
                    a.x < e1 && u.x < e1 || (a.x < e1 ? a = new d(e1, a.y + (e1 - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x < e1 && (u = new d(e1, a.y + (e1 - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y < r && u.y < r || (a.y < r ? a = new d(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round() : u.y < r && (u = new d(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round()), a.x >= n && u.x >= n || (a.x >= n ? a = new d(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x >= n && (u = new d(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y >= i && u.y >= i || (a.y >= i ? a = new d(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round() : u.y >= i && (u = new d(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round()), l && a.equals(l[l.length - 1]) || (l = [
                        a
                    ], s.push(l)), l.push(u)))));
                }
            }
            return s;
        }
        Oi(Hp, "Anchor");
        const af = 1e20;
        function of(t1, e1, r, n, i, s, a, o, l) {
            for(let u = e1; u < e1 + n; u++)lf(t1, r * s + u, s, i, a, o, l);
            for(let u = r; u < r + i; u++)lf(t1, u * s + e1, 1, n, a, o, l);
        }
        function lf(t1, e1, r, n, i, s, a) {
            s[0] = 0, a[0] = -af, a[1] = af, i[0] = t1[e1];
            for(let o = 1, l = 0, u = 0; o < n; o++){
                i[o] = t1[e1 + o * r];
                const n = o * o;
                do {
                    const t1 = s[l];
                    u = (i[o] - i[t1] + n - t1 * t1) / (o - t1) / 2;
                }while (u <= a[l] && --l > -1);
                l++, s[l] = o, a[l] = u, a[l + 1] = af;
            }
            for(let o = 0, l = 0; o < n; o++){
                for(; a[l + 1] < o;)l++;
                const n = s[l], u = o - n;
                t1[e1 + o * r] = i[n] + u * u;
            }
        }
        const uf = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class cf {
            constructor(t1, e1, r){
                this.requestManager = t1, this.localGlyphMode = e1, this.localFontFamily = r, this.entries = {}, this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {}
                };
            }
            setURL(t1) {
                this.url = t1;
            }
            getGlyphs(t1, e1) {
                const r = [];
                for(const e1 in t1)for (const n of t1[e1])r.push({
                    stack: e1,
                    id: n
                });
                M(r, ({ stack: t1 , id: e1  }, r)=>{
                    let n = this.entries[t1];
                    n || (n = this.entries[t1] = {
                        glyphs: {},
                        requests: {},
                        ranges: {},
                        ascender: void 0,
                        descender: void 0
                    });
                    let i = n.glyphs[e1];
                    if (void 0 !== i) return void r(null, {
                        stack: t1,
                        id: e1,
                        glyph: i
                    });
                    if (i = this._tinySDF(n, t1, e1), i) return n.glyphs[e1] = i, void r(null, {
                        stack: t1,
                        id: e1,
                        glyph: i
                    });
                    const s = Math.floor(e1 / 256);
                    if (256 * s > 65535) return void r(new Error("glyphs > 65535 not supported"));
                    if (n.ranges[s]) return void r(null, {
                        stack: t1,
                        id: e1,
                        glyph: i
                    });
                    let a = n.requests[s];
                    a || (a = n.requests[s] = [], cf.loadGlyphRange(t1, s, this.url, this.requestManager, (t1, e1)=>{
                        if (e1) {
                            n.ascender = e1.ascender, n.descender = e1.descender;
                            for(const t1 in e1.glyphs)this._doesCharSupportLocalGlyph(+t1) || (n.glyphs[+t1] = e1.glyphs[+t1]);
                            n.ranges[s] = !0;
                        }
                        for (const r of a)r(t1, e1);
                        delete n.requests[s];
                    })), a.push((n, i)=>{
                        n ? r(n) : i && r(null, {
                            stack: t1,
                            id: e1,
                            glyph: i.glyphs[e1] || null
                        });
                    });
                }, (t1, r)=>{
                    if (t1) e1(t1);
                    else if (r) {
                        const t1 = {};
                        for (const { stack: e1 , id: n , glyph: i  } of r)void 0 === t1[e1] && (t1[e1] = {}), void 0 === t1[e1].glyphs && (t1[e1].glyphs = {}), t1[e1].glyphs[n] = i && {
                            id: i.id,
                            bitmap: i.bitmap.clone(),
                            metrics: i.metrics
                        }, t1[e1].ascender = this.entries[e1].ascender, t1[e1].descender = this.entries[e1].descender;
                        e1(null, t1);
                    }
                });
            }
            _doesCharSupportLocalGlyph(t1) {
                return this.localGlyphMode !== uf.none && (this.localGlyphMode === uf.all ? !!this.localFontFamily : !!this.localFontFamily && (us(t1) || ps(t1) || ts(t1) || es(t1) || Qi(t1)));
            }
            _tinySDF(t1, e1, r) {
                const n = this.localFontFamily;
                if (!n || !this._doesCharSupportLocalGlyph(r)) return;
                let i = t1.tinySDF;
                if (!i) {
                    let r = "400";
                    /bold/i.test(e1) ? r = "900" : /medium/i.test(e1) ? r = "500" : /light/i.test(e1) && (r = "200"), i = t1.tinySDF = new cf.TinySDF({
                        fontFamily: n,
                        fontWeight: r,
                        fontSize: 48,
                        buffer: 6,
                        radius: 16
                    }), i.fontWeight = r;
                }
                if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];
                const s = String.fromCharCode(r), { data: a , width: o , height: l , glyphWidth: u , glyphHeight: c , glyphLeft: h , glyphTop: p , glyphAdvance: f  } = i.draw(s);
                return this.localGlyphs[i.fontWeight][r] = {
                    id: r,
                    bitmap: new Ju({
                        width: o,
                        height: l
                    }, a),
                    metrics: {
                        width: u / 2,
                        height: c / 2,
                        left: h / 2,
                        top: p / 2 - 27,
                        advance: f / 2,
                        localGlyph: !0
                    }
                };
            }
        }
        function hf(t1, e1, r, n) {
            const i = [], s = t1.image, a = s.pixelRatio, o = s.paddedRect.w - 2, l = s.paddedRect.h - 2, u = t1.right - t1.left, c = t1.bottom - t1.top, h = s.stretchX || [
                [
                    0,
                    o
                ]
            ], p = s.stretchY || [
                [
                    0,
                    l
                ]
            ], f = (t1, e1)=>t1 + e1[1] - e1[0], y = h.reduce(f, 0), m = p.reduce(f, 0), g = o - y, x = l - m;
            let v = 0, b = y, w = 0, _ = m, A = 0, S = g, k = 0, I = x;
            if (s.content && n) {
                const t1 = s.content;
                v = pf(h, 0, t1[0]), w = pf(p, 0, t1[1]), b = pf(h, t1[0], t1[2]), _ = pf(p, t1[1], t1[3]), A = t1[0] - v, k = t1[1] - w, S = t1[2] - t1[0] - b, I = t1[3] - t1[1] - _;
            }
            const M = (n, i, o, l)=>{
                const h = df(n.stretch - v, b, u, t1.left), p = yf(n.fixed - A, S, n.stretch, y), f = df(i.stretch - w, _, c, t1.top), g = yf(i.fixed - k, I, i.stretch, m), x = df(o.stretch - v, b, u, t1.left), M = yf(o.fixed - A, S, o.stretch, y), T = df(l.stretch - w, _, c, t1.top), z = yf(l.fixed - k, I, l.stretch, m), B = new d(h, f), E = new d(x, f), C = new d(x, T), P = new d(h, T), D = new d(p / a, g / a), V = new d(M / a, z / a), L = e1 * Math.PI / 180;
                if (L) {
                    const t1 = Math.sin(L), e1 = Math.cos(L), r = [
                        e1,
                        -t1,
                        t1,
                        e1
                    ];
                    B._matMult(r), E._matMult(r), P._matMult(r), C._matMult(r);
                }
                const F = n.stretch + n.fixed, R = i.stretch + i.fixed;
                return {
                    tl: B,
                    tr: E,
                    bl: P,
                    br: C,
                    tex: {
                        x: s.paddedRect.x + 1 + F,
                        y: s.paddedRect.y + 1 + R,
                        w: o.stretch + o.fixed - F,
                        h: l.stretch + l.fixed - R
                    },
                    writingMode: void 0,
                    glyphOffset: [
                        0,
                        0
                    ],
                    sectionIndex: 0,
                    pixelOffsetTL: D,
                    pixelOffsetBR: V,
                    minFontScaleX: S / a / u,
                    minFontScaleY: I / a / c,
                    isSDF: r
                };
            };
            if (n && (s.stretchX || s.stretchY)) {
                const t1 = ff(h, g, y), e1 = ff(p, x, m);
                for(let r = 0; r < t1.length - 1; r++){
                    const n = t1[r], s = t1[r + 1];
                    for(let t1 = 0; t1 < e1.length - 1; t1++)i.push(M(n, e1[t1], s, e1[t1 + 1]));
                }
            } else i.push(M({
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: o + 1
            }, {
                fixed: 0,
                stretch: l + 1
            }));
            return i;
        }
        function pf(t1, e1, r) {
            let n = 0;
            for (const i of t1)n += Math.max(e1, Math.min(r, i[1])) - Math.max(e1, Math.min(r, i[0]));
            return n;
        }
        function ff(t1, e1, r) {
            const n = [
                {
                    fixed: -1,
                    stretch: 0
                }
            ];
            for (const [e1, r] of t1){
                const t1 = n[n.length - 1];
                n.push({
                    fixed: e1 - t1.stretch,
                    stretch: t1.stretch
                }), n.push({
                    fixed: e1 - t1.stretch,
                    stretch: t1.stretch + (r - e1)
                });
            }
            return n.push({
                fixed: e1 + 1,
                stretch: r
            }), n;
        }
        function df(t1, e1, r, n) {
            return t1 / e1 * r + n;
        }
        function yf(t1, e1, r, n) {
            return t1 - e1 * r / n;
        }
        function mf(t1, e1, r, n) {
            const i = e1 + t1.positionedLines[n].lineOffset;
            return 0 === n ? r + i / 2 : r + (i + (e1 + t1.positionedLines[n - 1].lineOffset)) / 2;
        }
        cf.loadGlyphRange = function(t1, e1, r, n, i) {
            const s = 256 * e1, a = s + 255, o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t1).replace("{range}", `${s}-${a}`), st.Glyphs);
            ut(o, (t1, e1)=>{
                if (t1) i(t1);
                else if (e1) {
                    const t1 = {}, r = function(t1) {
                        return new op(t1).readFields(zp, {});
                    }(e1);
                    for (const e1 of r.glyphs)t1[e1.id] = e1;
                    i(null, {
                        glyphs: t1,
                        ascender: r.ascender,
                        descender: r.descender
                    });
                }
            });
        }, cf.TinySDF = class {
            constructor({ fontSize: t1 = 24 , buffer: e1 = 3 , radius: r = 8 , cutoff: n = .25 , fontFamily: i = "sans-serif" , fontWeight: s = "normal" , fontStyle: a = "normal"  } = {}){
                this.buffer = e1, this.cutoff = n, this.radius = r;
                const o = this.size = t1 + 4 * e1, l = this._createCanvas(o), u = this.ctx = l.getContext("2d", {
                    willReadFrequently: !0
                });
                u.font = `${a} ${s} ${t1}px ${i}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);
            }
            _createCanvas(t1) {
                const e1 = document.createElement("canvas");
                return e1.width = e1.height = t1, e1;
            }
            draw(t1) {
                const { width: e1 , actualBoundingBoxAscent: r , actualBoundingBoxDescent: n , actualBoundingBoxLeft: i , actualBoundingBoxRight: s  } = this.ctx.measureText(t1), a = Math.ceil(r), o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))), l = Math.min(this.size - this.buffer, a + Math.ceil(n)), u = o + 2 * this.buffer, c = l + 2 * this.buffer, h = Math.max(u * c, 0), p = new Uint8ClampedArray(h), f = {
                    data: p,
                    width: u,
                    height: c,
                    glyphWidth: o,
                    glyphHeight: l,
                    glyphTop: a,
                    glyphLeft: 0,
                    glyphAdvance: e1
                };
                if (0 === o || 0 === l) return f;
                const { ctx: d , buffer: y , gridInner: m , gridOuter: g  } = this;
                d.clearRect(y, y, o, l), d.fillText(t1, y, y + a);
                const x = d.getImageData(y, y, o, l);
                g.fill(af, 0, h), m.fill(0, 0, h);
                for(let t1 = 0; t1 < l; t1++)for(let e1 = 0; e1 < o; e1++){
                    const r = x.data[4 * (t1 * o + e1) + 3] / 255;
                    if (0 === r) continue;
                    const n = (t1 + y) * u + e1 + y;
                    if (1 === r) g[n] = 0, m[n] = af;
                    else {
                        const t1 = .5 - r;
                        g[n] = t1 > 0 ? t1 * t1 : 0, m[n] = t1 < 0 ? t1 * t1 : 0;
                    }
                }
                of(g, 0, 0, u, c, u, this.f, this.v, this.z), of(m, y, y, o, l, u, this.f, this.v, this.z);
                for(let t1 = 0; t1 < h; t1++){
                    const e1 = Math.sqrt(g[t1]) - Math.sqrt(m[t1]);
                    p[t1] = Math.round(255 - 255 * (e1 / this.radius + this.cutoff));
                }
                return f;
            }
        };
        class gf {
            constructor(t1 = [], e1 = xf){
                if (this.data = t1, this.length = this.data.length, this.compare = e1, this.length > 0) for(let t1 = (this.length >> 1) - 1; t1 >= 0; t1--)this._down(t1);
            }
            push(t1) {
                this.data.push(t1), this.length++, this._up(this.length - 1);
            }
            pop() {
                if (0 === this.length) return;
                const t1 = this.data[0], e1 = this.data.pop();
                return this.length--, this.length > 0 && (this.data[0] = e1, this._down(0)), t1;
            }
            peek() {
                return this.data[0];
            }
            _up(t1) {
                const { data: e1 , compare: r  } = this, n = e1[t1];
                for(; t1 > 0;){
                    const i = t1 - 1 >> 1, s = e1[i];
                    if (r(n, s) >= 0) break;
                    e1[t1] = s, t1 = i;
                }
                e1[t1] = n;
            }
            _down(t1) {
                const { data: e1 , compare: r  } = this, n = this.length >> 1, i = e1[t1];
                for(; t1 < n;){
                    let n = 1 + (t1 << 1), s = e1[n];
                    const a = n + 1;
                    if (a < this.length && r(e1[a], s) < 0 && (n = a, s = e1[a]), r(s, i) >= 0) break;
                    e1[t1] = s, t1 = n;
                }
                e1[t1] = i;
            }
        }
        function xf(t1, e1) {
            return t1 < e1 ? -1 : t1 > e1 ? 1 : 0;
        }
        function vf(t1, e1 = 1, r = !1) {
            let n = 1 / 0, i = 1 / 0, s = -1 / 0, a = -1 / 0;
            const o = t1[0];
            for(let t1 = 0; t1 < o.length; t1++){
                const e1 = o[t1];
                (!t1 || e1.x < n) && (n = e1.x), (!t1 || e1.y < i) && (i = e1.y), (!t1 || e1.x > s) && (s = e1.x), (!t1 || e1.y > a) && (a = e1.y);
            }
            const l = Math.min(s - n, a - i);
            let u = l / 2;
            const c = new gf([], bf);
            if (0 === l) return new d(n, i);
            for(let e1 = n; e1 < s; e1 += l)for(let r = i; r < a; r += l)c.push(new wf(e1 + u, r + u, u, t1));
            let h = function(t1) {
                let e1 = 0, r = 0, n = 0;
                const i = t1[0];
                for(let t1 = 0, s = i.length, a = s - 1; t1 < s; a = t1++){
                    const s = i[t1], o = i[a], l = s.x * o.y - o.x * s.y;
                    r += (s.x + o.x) * l, n += (s.y + o.y) * l, e1 += 3 * l;
                }
                return new wf(r / e1, n / e1, 0, t1);
            }(t1), p = c.length;
            for(; c.length;){
                const n = c.pop();
                (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e1 || (u = n.h / 2, c.push(new wf(n.p.x - u, n.p.y - u, u, t1)), c.push(new wf(n.p.x + u, n.p.y - u, u, t1)), c.push(new wf(n.p.x - u, n.p.y + u, u, t1)), c.push(new wf(n.p.x + u, n.p.y + u, u, t1)), p += 4);
            }
            return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
        }
        function bf(t1, e1) {
            return e1.max - t1.max;
        }
        function wf(t1, e1, r, n) {
            this.p = new d(t1, e1), this.h = r, this.d = function(t1, e1) {
                let r = !1, n = 1 / 0;
                for(let i = 0; i < e1.length; i++){
                    const s = e1[i];
                    for(let e1 = 0, i = s.length, a = i - 1; e1 < i; a = e1++){
                        const i = s[e1], o = s[a];
                        i.y > t1.y != o.y > t1.y && t1.x < (o.x - i.x) * (t1.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Cu(t1, i, o));
                    }
                }
                return (r ? 1 : -1) * Math.sqrt(n);
            }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
        }
        const _f = Number.POSITIVE_INFINITY, Af = Math.sqrt(2);
        function Sf(t1, [e1, r]) {
            let n = 0, i = 0;
            if (r === _f) {
                e1 < 0 && (e1 = 0);
                const r = e1 / Af;
                switch(t1){
                    case "top-right":
                    case "top-left":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        i = 7 - r;
                        break;
                    case "bottom":
                        i = 7 - e1;
                        break;
                    case "top":
                        i = e1 - 7;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                        n = -r;
                        break;
                    case "top-left":
                    case "bottom-left":
                        n = r;
                        break;
                    case "left":
                        n = e1;
                        break;
                    case "right":
                        n = -e1;
                }
            } else {
                switch(e1 = Math.abs(e1), r = Math.abs(r), t1){
                    case "top-right":
                    case "top-left":
                    case "top":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        i = 7 - r;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        n = -e1;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        n = e1;
                }
            }
            return [
                n,
                i
            ];
        }
        function kf(t1, e1, r, n, i, s, a, o, l, u) {
            t1.createArrays(), t1.tilePixelRatio = ko / (512 * t1.overscaling), t1.compareText = {}, t1.iconsNeedLinear = !1;
            const c = t1.layers[0].layout, h = t1.layers[0]._unevaluatedLayout._values, p = {};
            if ("composite" === t1.textSizeData.kind) {
                const { minZoom: e1 , maxZoom: r  } = t1.textSizeData;
                p.compositeTextSizes = [
                    h["text-size"].possiblyEvaluate(new Us(e1), o),
                    h["text-size"].possiblyEvaluate(new Us(r), o)
                ];
            }
            if ("composite" === t1.iconSizeData.kind) {
                const { minZoom: e1 , maxZoom: r  } = t1.iconSizeData;
                p.compositeIconSizes = [
                    h["icon-size"].possiblyEvaluate(new Us(e1), o),
                    h["icon-size"].possiblyEvaluate(new Us(r), o)
                ];
            }
            p.layoutTextSize = h["text-size"].possiblyEvaluate(new Us(l + 1), o), p.layoutIconSize = h["icon-size"].possiblyEvaluate(new Us(l + 1), o), p.textMaxSize = h["text-size"].possiblyEvaluate(new Us(18), o);
            const f = "map" === c.get("text-rotation-alignment") && "point" !== c.get("symbol-placement"), d = c.get("text-size");
            for (const s of t1.features){
                const l = c.get("text-font").evaluate(s, {}, o).join(","), h = d.evaluate(s, {}, o), y = p.layoutTextSize.evaluate(s, {}, o), m = (p.layoutIconSize.evaluate(s, {}, o), {
                    horizontal: {},
                    vertical: void 0
                }), g = s.text;
                let x, v = [
                    0,
                    0
                ];
                if (g) {
                    const n = g.toString(), a = c.get("text-letter-spacing").evaluate(s, {}, o) * Wh, u = c.get("text-line-height").evaluate(s, {}, o) * Wh, p = ws(n) ? a : 0, d = c.get("text-anchor").evaluate(s, {}, o), x = c.get("text-variable-anchor");
                    if (!x) {
                        const t1 = c.get("text-radial-offset").evaluate(s, {}, o);
                        v = t1 ? Sf(d, [
                            t1 * Wh,
                            _f
                        ]) : c.get("text-offset").evaluate(s, {}, o).map((t1)=>t1 * Wh);
                    }
                    let b = f ? "center" : c.get("text-justify").evaluate(s, {}, o);
                    const w = "point" === c.get("symbol-placement"), _ = w ? c.get("text-max-width").evaluate(s, {}, o) * Wh : 1 / 0, A = (s)=>{
                        t1.allowVerticalPlacement && bs(n) && (m.vertical = Rp(g, e1, r, i, l, _, u, d, s, p, v, Vp.vertical, !0, y, h));
                    };
                    if (!f && x) {
                        const t1 = "auto" === b ? x.map((t1)=>If(t1)) : [
                            b
                        ];
                        let n = !1;
                        for(let s = 0; s < t1.length; s++){
                            const a = t1[s];
                            if (!m.horizontal[a]) {
                                if (n) m.horizontal[a] = m.horizontal[0];
                                else {
                                    const t1 = Rp(g, e1, r, i, l, _, u, "center", a, p, v, Vp.horizontal, !1, y, h);
                                    t1 && (m.horizontal[a] = t1, n = 1 === t1.positionedLines.length);
                                }
                            }
                        }
                        A("left");
                    } else {
                        if ("auto" === b && (b = If(d)), w || c.get("text-writing-mode").indexOf("horizontal") >= 0 || !bs(n)) {
                            const t1 = Rp(g, e1, r, i, l, _, u, d, b, p, v, Vp.horizontal, !1, y, h);
                            t1 && (m.horizontal[b] = t1);
                        }
                        A(w ? "left" : b);
                    }
                }
                let b = !1;
                if (s.icon && s.icon.name) {
                    const e1 = n[s.icon.name];
                    e1 && (x = Kp(i[s.icon.name], c.get("icon-offset").evaluate(s, {}, o), c.get("icon-anchor").evaluate(s, {}, o)), b = e1.sdf, void 0 === t1.sdfIcons ? t1.sdfIcons = e1.sdf : t1.sdfIcons !== e1.sdf && $("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e1.pixelRatio !== t1.pixelRatio || 0 !== c.get("icon-rotate").constantOr(1)) && (t1.iconsNeedLinear = !0));
                }
                const w = Bf(m.horizontal) || m.vertical;
                t1.iconsInText || (t1.iconsInText = !!w && w.iconsInText), (w || x) && Mf(t1, s, m, x, n, p, y, 0, v, b, a, o, u);
            }
            s && t1.generateCollisionDebugBuffers(l, t1.collisionBoxArray);
        }
        function If(t1) {
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left";
            }
            return "center";
        }
        function Mf(t1, e1, r, n, i, s, a, o, l, u, c, h, p) {
            let f = s.textMaxSize.evaluate(e1, {}, h);
            void 0 === f && (f = a);
            const d = t1.layers[0].layout, y = d.get("icon-offset").evaluate(e1, {}, h), m = Bf(r.horizontal) || r.vertical, g = "globe" === p.name, v = a / 24, b = t1.tilePixelRatio * f / 24, w = (z = t1.overscaling, t1.zoom > 18 && z > 2 && (z >>= 1), Math.max(ko / (512 * z), 1) * d.get("symbol-spacing")), _ = d.get("text-padding") * t1.tilePixelRatio, A = d.get("icon-padding") * t1.tilePixelRatio, S = x(d.get("text-max-angle")), k = "map" === d.get("text-rotation-alignment") && "point" !== d.get("symbol-placement"), I = "map" === d.get("icon-rotation-alignment") && "point" !== d.get("symbol-placement"), M = d.get("symbol-placement"), T = w / 2;
            var z;
            const B = d.get("icon-text-fit");
            let E;
            n && "none" !== B && (t1.allowVerticalPlacement && r.vertical && (E = Yp(n, r.vertical, B, d.get("icon-text-fit-padding"), y, v)), m && (n = Yp(n, m, B, d.get("icon-text-fit-padding"), y, v)));
            const C = (a, o, f)=>{
                if (o.x < 0 || o.x >= ko || o.y < 0 || o.y >= ko) return;
                let d = null;
                if (g) {
                    const { x: t1 , y: e1 , z: r  } = p.projectTilePoint(o.x, o.y, f);
                    d = {
                        anchor: new Hp(t1, e1, r, 0, void 0),
                        up: p.upVector(f, o.x, o.y)
                    };
                }
                !function(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S) {
                    const k = t1.addToLineVertexArray(e1, n);
                    let I, M, T, z, B, E, C, P = 0, D = 0, V = 0, L = 0, F = -1, R = -1;
                    const j = {};
                    let U = qa("");
                    const O = r ? r.anchor : e1;
                    let q = 0, N = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [q, N] = l.layout.get("text-offset").evaluate(b, {}, S).map((t1)=>t1 * Wh) : (q = l.layout.get("text-radial-offset").evaluate(b, {}, S) * Wh, N = _f), t1.allowVerticalPlacement && i.vertical) {
                        const t1 = i.vertical;
                        if (d) E = Cf(t1), o && (C = Cf(o));
                        else {
                            const r = l.layout.get("text-rotate").evaluate(b, {}, S) + 90;
                            T = Ef(u, O, e1, c, h, p, t1, f, r, y), o && (z = Ef(u, O, e1, c, h, p, o, g, r));
                        }
                    }
                    if (s) {
                        const n = l.layout.get("icon-rotate").evaluate(b, {}, S), i = "none" !== l.layout.get("icon-text-fit"), a = hf(s, n, _, i), f = o ? hf(o, n, _, i) : void 0;
                        M = Ef(u, O, e1, c, h, p, s, g, n), P = 4 * a.length;
                        const d = t1.iconSizeData;
                        let y = null;
                        "source" === d.kind ? (y = [
                            Jh * l.layout.get("icon-size").evaluate(b, {}, S)
                        ], y[0] > Tf && $(`${t1.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d.kind && (y = [
                            Jh * w.compositeIconSizes[0].evaluate(b, {}, S),
                            Jh * w.compositeIconSizes[1].evaluate(b, {}, S)
                        ], (y[0] > Tf || y[1] > Tf) && $(`${t1.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t1.addSymbols(t1.icon, a, y, v, x, b, !1, r, e1, k.lineStartIndex, k.lineLength, -1, A, S), F = t1.icon.placedSymbolArray.length - 1, f && (D = 4 * f.length, t1.addSymbols(t1.icon, f, y, v, x, b, Vp.vertical, r, e1, k.lineStartIndex, k.lineLength, -1, A, S), R = t1.icon.placedSymbolArray.length - 1);
                    }
                    for(const n in i.horizontal){
                        const s = i.horizontal[n];
                        I || (U = qa(s.text), d ? B = Cf(s) : I = Ef(u, O, e1, c, h, p, s, f, l.layout.get("text-rotate").evaluate(b, {}, S), y));
                        const o = 1 === s.positionedLines.length;
                        if (V += zf(t1, r, e1, s, a, l, d, b, y, k, i.vertical ? Vp.horizontal : Vp.horizontalOnly, o ? Object.keys(i.horizontal) : [
                            n
                        ], j, F, w, A, S), o) break;
                    }
                    i.vertical && (L += zf(t1, r, e1, i.vertical, a, l, d, b, y, k, Vp.vertical, [
                        "vertical"
                    ], j, R, w, A, S));
                    let G = -1;
                    const X = (t1, e1)=>t1 ? Math.max(t1, e1) : e1;
                    G = X(B, G), G = X(E, G), G = X(C, G);
                    const Z = G > -1 ? 1 : 0;
                    t1.glyphOffsetArray.length >= hd.MAX_GLYPHS && $("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t1.addToSortKeyRanges(t1.symbolInstances.length, b.sortKey), t1.symbolInstances.emplaceBack(O.x, O.y, O.z, e1.x, e1.y, j.right >= 0 ? j.right : -1, j.center >= 0 ? j.center : -1, j.left >= 0 ? j.left : -1, j.vertical >= 0 ? j.vertical : -1, F, R, U, void 0 !== I ? I : t1.collisionBoxArray.length, void 0 !== I ? I + 1 : t1.collisionBoxArray.length, void 0 !== T ? T : t1.collisionBoxArray.length, void 0 !== T ? T + 1 : t1.collisionBoxArray.length, void 0 !== M ? M : t1.collisionBoxArray.length, void 0 !== M ? M + 1 : t1.collisionBoxArray.length, z || t1.collisionBoxArray.length, z ? z + 1 : t1.collisionBoxArray.length, c, V, L, P, D, Z, 0, q, N, G);
                }(t1, o, d, a, r, n, i, E, t1.layers[0], t1.collisionBoxArray, e1.index, e1.sourceLayerIndex, t1.index, _, k, l, 0, A, I, y, e1, s, u, c, h);
            };
            if ("line" === M) for (const i of sf(e1.geometry, 0, 0, ko, ko)){
                const e1 = rf(i, w, S, r.vertical || m, n, 24, b, t1.overscaling, ko);
                for (const r of e1){
                    const e1 = m;
                    e1 && Pf(t1, e1.text, T, r) || C(i, r, h);
                }
            }
            else if ("line-center" === M) {
                for (const t1 of e1.geometry)if (t1.length > 1) {
                    const e1 = ef(t1, S, r.vertical || m, n, 24, b);
                    e1 && C(t1, e1, h);
                }
            } else if ("Polygon" === e1.type) for (const t1 of Lc(e1.geometry, 0)){
                const e1 = vf(t1, 16);
                C(t1[0], new Hp(e1.x, e1.y, 0, 0, void 0), h);
            }
            else if ("LineString" === e1.type) for (const t1 of e1.geometry)C(t1, new Hp(t1[0].x, t1[0].y, 0, 0, void 0), h);
            else if ("Point" === e1.type) for (const t1 of e1.geometry)for (const e1 of t1)C([
                e1
            ], new Hp(e1.x, e1.y, 0, 0, void 0), h);
        }
        const Tf = 32640;
        function zf(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f, y, m, g) {
            const x = function(t1, e1, r, n, i, s, a, o) {
                const l = [];
                if (0 === e1.positionedLines.length) return l;
                const u = n.layout.get("text-rotate").evaluate(s, {}) * Math.PI / 180, c = function(t1) {
                    const e1 = t1[0], r = t1[1], n = e1 * r;
                    return n > 0 ? [
                        e1,
                        -r
                    ] : n < 0 ? [
                        -e1,
                        r
                    ] : 0 === e1 ? [
                        r,
                        e1
                    ] : [
                        r,
                        -e1
                    ];
                }(r);
                let h = Math.abs(e1.top - e1.bottom);
                for (const t1 of e1.positionedLines)h -= t1.lineOffset;
                const p = e1.positionedLines.length, f = h / p;
                let y = e1.top - r[1];
                for(let t1 = 0; t1 < p; ++t1){
                    const n = e1.positionedLines[t1];
                    y = mf(e1, f, y, t1);
                    for (const t1 of n.positionedGlyphs){
                        if (!t1.rect) continue;
                        const n = t1.rect || {};
                        let s = 4, h = !0, p = 1, f = 0;
                        if (t1.imageName) {
                            const e1 = a[t1.imageName];
                            if (!e1) continue;
                            if (e1.sdf) {
                                $("SDF images are not supported in formatted text and will be ignored.");
                                continue;
                            }
                            h = !1, p = e1.pixelRatio, s = 1 / p;
                        }
                        const m = (i || o) && t1.vertical, g = t1.metrics.advance * t1.scale / 2, x = t1.metrics, v = t1.rect;
                        if (null === v) continue;
                        o && e1.verticalizable && (f = t1.imageName ? g - t1.metrics.width * t1.scale / 2 : 0);
                        const b = i ? [
                            t1.x + g,
                            t1.y
                        ] : [
                            0,
                            0
                        ];
                        let w = [
                            0,
                            0
                        ], _ = [
                            0,
                            0
                        ], A = !1;
                        i || (m ? (_ = [
                            t1.x + g + c[0],
                            t1.y + c[1] - f
                        ], A = !0) : w = [
                            t1.x + g + r[0],
                            t1.y + r[1] - f
                        ]);
                        const S = v.w * t1.scale / (p * (t1.localGlyph ? 2 : 1)), k = v.h * t1.scale / (p * (t1.localGlyph ? 2 : 1));
                        let I, M, T, z;
                        if (m) {
                            const e1 = t1.y - y, r = new d(-g, g - e1), n = -Math.PI / 2, i = new d(..._);
                            I = new d(-g + w[0], w[1]), I._rotateAround(n, r)._add(i), I.x += -e1 + g, I.y -= (x.left - s) * t1.scale;
                            const a = t1.imageName ? x.advance * t1.scale : Wh * t1.scale, o = String.fromCharCode(t1.glyph);
                            sp(o) ? I.x += (1 - s) * t1.scale : ap(o) ? I.x += a - x.height * t1.scale + (-s - 1) * t1.scale : I.x += t1.imageName || x.width + 2 * s === v.w && x.height + 2 * s === v.h ? (a - k) / 2 : (a - (x.height + 2 * s) * t1.scale) / 2, M = new d(I.x, I.y - S), T = new d(I.x + k, I.y), z = new d(I.x + k, I.y - S);
                        } else {
                            const e1 = (x.left - s) * t1.scale - g + w[0], r = (-x.top - s) * t1.scale + w[1], n = e1 + S, i = r + k;
                            I = new d(e1, r), M = new d(n, r), T = new d(e1, i), z = new d(n, i);
                        }
                        if (u) {
                            let t1;
                            t1 = i ? new d(0, 0) : A ? new d(c[0], c[1]) : new d(r[0], r[1]), I._rotateAround(u, t1), M._rotateAround(u, t1), T._rotateAround(u, t1), z._rotateAround(u, t1);
                        }
                        const B = new d(0, 0), E = new d(0, 0);
                        l.push({
                            tl: I,
                            tr: M,
                            bl: T,
                            br: z,
                            tex: n,
                            writingMode: e1.writingMode,
                            glyphOffset: b,
                            sectionIndex: t1.sectionIndex,
                            isSDF: h,
                            pixelOffsetTL: B,
                            pixelOffsetBR: E,
                            minFontScaleX: 0,
                            minFontScaleY: 0
                        });
                    }
                }
                return l;
            }(0, n, l, s, a, o, i, t1.allowVerticalPlacement), v = t1.textSizeData;
            let b = null;
            "source" === v.kind ? (b = [
                Jh * s.layout.get("text-size").evaluate(o, {}, g)
            ], b[0] > Tf && $(`${t1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === v.kind && (b = [
                Jh * y.compositeTextSizes[0].evaluate(o, {}, g),
                Jh * y.compositeTextSizes[1].evaluate(o, {}, g)
            ], (b[0] > Tf || b[1] > Tf) && $(`${t1.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t1.addSymbols(t1.text, x, b, l, a, o, c, e1, r, u.lineStartIndex, u.lineLength, f, m, g);
            for (const e1 of h)p[e1] = t1.text.placedSymbolArray.length - 1;
            return 4 * x.length;
        }
        function Bf(t1) {
            for(const e1 in t1)return t1[e1];
            return null;
        }
        function Ef(t1, e1, r, n, i, s, a, o, l, u) {
            let c = a.top, h = a.bottom, p = a.left, f = a.right;
            const y = a.collisionPadding;
            if (y && (p -= y[0], c -= y[1], f += y[2], h += y[3]), l) {
                const t1 = new d(p, c), e1 = new d(f, c), r = new d(p, h), n = new d(f, h), i = x(l);
                let s = new d(0, 0);
                u && (s = new d(u[0], u[1])), t1._rotateAround(i, s), e1._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t1.x, e1.x, r.x, n.x), f = Math.max(t1.x, e1.x, r.x, n.x), c = Math.min(t1.y, e1.y, r.y, n.y), h = Math.max(t1.y, e1.y, r.y, n.y);
            }
            return t1.emplaceBack(e1.x, e1.y, e1.z, r.x, r.y, p, c, f, h, o, n, i, s), t1.length - 1;
        }
        function Cf(t1) {
            t1.collisionPadding && (t1.top -= t1.collisionPadding[1], t1.bottom += t1.collisionPadding[3]);
            const e1 = t1.bottom - t1.top;
            return e1 > 0 ? Math.max(10, e1) : null;
        }
        function Pf(t1, e1, r, n) {
            const i = t1.compareText;
            if (e1 in i) {
                const t1 = i[e1];
                for(let e1 = t1.length - 1; e1 >= 0; e1--)if (n.dist(t1[e1]) < r) return !0;
            } else i[e1] = [];
            return i[e1].push(n), !1;
        }
        function Df(t1, e1) {
            const r = t1.fovAboveCenter, n = t1.elevation ? t1.elevation.getMinElevationBelowMSL() * e1 : 0, i = (t1._camera.position[2] * t1.worldSize - n) / Math.cos(t1._pitch), s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t1._pitch - r, .01)), a = Math.sin(t1._pitch) * s + i;
            return Math.min(1.01 * a, i * (1 / t1._horizonShift));
        }
        function Vf(t1, e1) {
            if (!e1.isReprojectedInTileSpace) return {
                scale: 1 << t1.z,
                x: t1.x,
                y: t1.y,
                x2: t1.x + 1,
                y2: t1.y + 1,
                projection: e1
            };
            const r = Math.pow(2, -t1.z), n = t1.x * r, i = (t1.x + 1) * r, s = t1.y * r, a = (t1.y + 1) * r, o = ou(n), l = ou(i), u = lu(s), c = lu(a), h = e1.project(o, u), p = e1.project(l, u), f = e1.project(l, c), d = e1.project(o, c);
            let y = Math.min(h.x, p.x, f.x, d.x), m = Math.min(h.y, p.y, f.y, d.y), g = Math.max(h.x, p.x, f.x, d.x), x = Math.max(h.y, p.y, f.y, d.y);
            const v = r / 16;
            function b(t1, r, n, i, s, a) {
                const o = (n + s) / 2, l = (i + a) / 2, u = e1.project(ou(o), lu(l)), c = Math.max(0, y - u.x, m - u.y, u.x - g, u.y - x);
                y = Math.min(y, u.x), g = Math.max(g, u.x), m = Math.min(m, u.y), x = Math.max(x, u.y), c > v && (b(t1, u, n, i, o, l), b(u, r, o, l, s, a));
            }
            b(h, p, n, s, i, s), b(p, f, i, s, i, a), b(f, d, i, a, n, a), b(d, h, n, a, n, s), y -= v, m -= v, g += v, x += v;
            const w = 1 / Math.max(g - y, x - m);
            return {
                scale: w,
                x: y * w,
                y: m * w,
                x2: g * w,
                y2: x * w,
                projection: e1
            };
        }
        const Lf = Eo(new Float32Array(16));
        class Ff {
            constructor(t1){
                this.spec = t1, this.name = t1.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [
                    "custom"
                ], this.center = [
                    0,
                    0
                ], this.range = [
                    3.5,
                    7
                ];
            }
            project(t1, e1) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                };
            }
            unproject(t1, e1) {
                return new ru(0, 0);
            }
            projectTilePoint(t1, e1, r) {
                return {
                    x: t1,
                    y: e1,
                    z: 0
                };
            }
            locationPoint(t1, e1, r = !0) {
                return t1._coordinatePoint(t1.locationCoordinate(e1), r);
            }
            pixelsPerMeter(t1, e1) {
                return au(1, t1) * e1;
            }
            pixelSpaceConversion(t1, e1, r) {
                return 1;
            }
            farthestPixelDistance(t1) {
                return Df(t1, t1.pixelsPerMeter);
            }
            pointCoordinate(t1, e1, r, n) {
                const i = t1.horizonLineFromTop(!1), s = new d(e1, Math.max(i, r));
                return t1.rayIntersectionCoordinate(t1.pointRayIntersection(s, n));
            }
            pointCoordinate3D(t1, e1, r) {
                const n = new d(e1, r);
                if (t1.elevation) return t1.elevation.pointCoordinate(n);
                {
                    const e1 = this.pointCoordinate(t1, n.x, n.y, 0);
                    return [
                        e1.x,
                        e1.y,
                        e1.z
                    ];
                }
            }
            isPointAboveHorizon(t1, e1) {
                if (t1.elevation) return !this.pointCoordinate3D(t1, e1.x, e1.y);
                const r = t1.horizonLineFromTop();
                return e1.y < r;
            }
            createInversionMatrix(t1, e1) {
                return Lf;
            }
            createTileMatrix(t1, e1, r) {
                let n, i, s;
                const a = r.canonical, o = Eo(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                    const l = Vf(a, this);
                    n = 1, i = l.x + r.wrap * l.scale, s = l.y, Vo(o, o, [
                        n / l.scale,
                        n / l.scale,
                        t1.pixelsPerMeter / e1
                    ]);
                } else n = e1 / t1.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;
                return Do(o, o, [
                    i,
                    s,
                    0
                ]), Vo(o, o, [
                    n / ko,
                    n / ko,
                    1
                ]), o;
            }
            upVector(t1, e1, r) {
                return [
                    0,
                    0,
                    1
                ];
            }
            upVectorScale(t1, e1, r) {
                return {
                    metersToTile: 1
                };
            }
        }
        class Rf extends Ff {
            constructor(t1){
                super(t1), this.range = [
                    4,
                    7
                ], this.center = t1.center || [
                    -96,
                    37.5
                ];
                const [e1, r] = this.parallels = t1.parallels || [
                    29.5,
                    45.5
                ], n = Math.sin(x(e1));
                this.n = (n + Math.sin(x(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t1, e1) {
                const { n: r , c: n , r0: i  } = this, s = x(t1 - this.center[0]), a = x(e1), o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;
                return {
                    x: o * Math.sin(s * r),
                    y: o * Math.cos(s * r) - i,
                    z: 0
                };
            }
            unproject(t1, e1) {
                const { n: r , c: n , r0: i  } = this, s = i + e1;
                let a = Math.atan2(t1, Math.abs(s)) * Math.sign(s);
                s * r < 0 && (a -= Math.PI * Math.sign(t1) * Math.sign(s));
                const o = x(this.center[0]) * r;
                a = I(a, -Math.PI - o, Math.PI - o);
                const l = S(v(a / r) + this.center[0], -180, 180), u = Math.asin(S((n - (t1 * t1 + s * s) * r * r) / (2 * r), -1, 1)), c = S(v(u), -cu, cu);
                return new ru(l, c);
            }
        }
        const jf = 1.340264, Uf = -0.081106, $f = 893e-6, Of = .003796, qf = Math.sqrt(3) / 2;
        class Nf extends Ff {
            project(t1, e1) {
                e1 = e1 / 180 * Math.PI, t1 = t1 / 180 * Math.PI;
                const r = Math.asin(qf * Math.sin(e1)), n = r * r, i = n * n * n;
                return {
                    x: .5 * (t1 * Math.cos(r) / (qf * (jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n))) / Math.PI + .5),
                    y: 1 - .5 * (r * (jf + Uf * n + i * ($f + Of * n)) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e1) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e1 = (2 * (1 - e1) - 1) * Math.PI, n = r * r, i = n * n * n;
                for(let t1, s, a, o = 0; o < 12 && (s = r * (jf + Uf * n + i * ($f + Of * n)) - e1, a = jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n), t1 = s / a, r = S(r - t1, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t1) < 1e-12)); ++o);
                const s = qf * t1 * (jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n)) / Math.cos(r), a = Math.asin(Math.sin(r) / qf), o = S(180 * s / Math.PI, -180, 180), l = S(180 * a / Math.PI, -cu, cu);
                return new ru(o, l);
            }
        }
        class Gf extends Ff {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e1) {
                return {
                    x: .5 + t1 / 360,
                    y: .5 - e1 / 360,
                    z: 0
                };
            }
            unproject(t1, e1) {
                const r = 360 * (t1 - .5), n = S(360 * (.5 - e1), -cu, cu);
                return new ru(r, n);
            }
        }
        const Xf = Math.PI / 2;
        function Zf(t1) {
            return Math.tan((Xf + t1) / 2);
        }
        class Kf extends Ff {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    30
                ];
                const [e1, r] = this.parallels = t1.parallels || [
                    30,
                    30
                ];
                let n = x(e1), i = x(r);
                this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);
                const s = Math.cos(n), a = Zf(n);
                this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Zf(i) / a), this.f = s * Math.pow(Zf(n), this.n) / this.n;
            }
            project(t1, e1) {
                e1 = x(e1), this.southernCenter && (e1 = -e1), t1 = x(t1 - this.center[0]);
                const r = 1e-6, { n: n , f: i  } = this;
                i > 0 ? e1 < -Xf + r && (e1 = -Xf + r) : e1 > Xf - r && (e1 = Xf - r);
                const s = i / Math.pow(Zf(e1), n);
                let a = s * Math.sin(n * t1), o = i - s * Math.cos(n * t1);
                return a = .5 * (a / Math.PI + .5), o = .5 * (o / Math.PI + .5), {
                    x: a,
                    y: this.southernCenter ? o : 1 - o,
                    z: 0
                };
            }
            unproject(t1, e1) {
                t1 = (2 * t1 - .5) * Math.PI, this.southernCenter && (e1 = 1 - e1), e1 = (2 * (1 - e1) - .5) * Math.PI;
                const { n: r , f: n  } = this, i = n - e1, s = Math.sign(i), a = Math.sign(r) * Math.sqrt(t1 * t1 + i * i);
                let o = Math.atan2(t1, Math.abs(i)) * s;
                i * r < 0 && (o -= Math.PI * Math.sign(t1) * s);
                const l = S(v(o / r) + this.center[0], -180, 180), u = S(v(2 * Math.atan(Math.pow(n / a, 1 / r)) - Xf), -cu, cu);
                return new ru(l, this.southernCenter ? -u : u);
            }
        }
        class Yf extends Ff {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
            }
            project(t1, e1) {
                return {
                    x: iu(t1),
                    y: su(e1),
                    z: 0
                };
            }
            unproject(t1, e1) {
                const r = ou(t1), n = lu(e1);
                return new ru(r, n);
            }
        }
        const Hf = x(cu);
        class Wf extends Ff {
            project(t1, e1) {
                const r = (e1 = x(e1)) * e1, n = r * r;
                return {
                    x: .5 * ((t1 = x(t1)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
                    y: 1 - .5 * (e1 * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e1) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e1 = (2 * (1 - e1) - 1) * Math.PI, n = 25, i = 0, s = r * r;
                do {
                    s = r * r;
                    const t1 = s * s;
                    i = (r * (1.007226 + s * (.015085 + t1 * (.028874 * s - .044475 - .005916 * t1))) - e1) / (1.007226 + s * (.045255 + t1 * (.259866 * s - .311325 - .005916 * 11 * t1))), r = S(r - i, -Hf, Hf);
                }while (Math.abs(i) > 1e-6 && --n > 0);
                s = r * r;
                const a = S(v(t1 / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180), o = v(r);
                return new ru(a, o);
            }
        }
        const Jf = x(cu);
        class Qf extends Ff {
            project(t1, e1) {
                e1 = x(e1), t1 = x(t1);
                const r = Math.cos(e1), n = 2 / Math.PI, i = Math.acos(r * Math.cos(t1 / 2)), s = Math.sin(i) / i, a = .5 * (t1 * n + 2 * r * Math.sin(t1 / 2) / s) || 0, o = .5 * (e1 + Math.sin(e1) / s) || 0;
                return {
                    x: .5 * (a / Math.PI + .5),
                    y: 1 - .5 * (o / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e1) {
                let r = t1 = (2 * t1 - .5) * Math.PI, n = e1 = (2 * (1 - e1) - 1) * Math.PI, i = 25;
                const s = 1e-6;
                let a = 0, o = 0;
                do {
                    const i = Math.cos(n), s = Math.sin(n), l = 2 * s * i, u = s * s, c = i * i, h = Math.cos(r / 2), p = Math.sin(r / 2), f = 2 * h * p, d = p * p, y = 1 - c * h * h, m = y ? 1 / y : 0, g = y ? Math.acos(i * h) * Math.sqrt(1 / y) : 0, x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t1, v = .5 * (g * s + n) - e1, b = .5 * m * (c * d + g * i * h * u) + 1 / Math.PI, w = m * (f * l / 4 - g * s * p), _ = .125 * m * (l * p - g * s * c * f), A = .5 * m * (u * h + g * d * i) + .5, k = w * _ - A * b;
                    a = (v * w - x * A) / k, o = (x * _ - v * b) / k, r = S(r - a, -Math.PI, Math.PI), n = S(n - o, -Jf, Jf);
                }while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);
                return new ru(v(r), v(n));
            }
        }
        class td extends Ff {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    0
                ], this.parallels = t1.parallels || [
                    0,
                    0
                ], this.cosPhi = Math.max(.01, Math.cos(x(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e1) {
                const { scale: r , cosPhi: n  } = this;
                return {
                    x: x(t1) * n * r + .5,
                    y: -Math.sin(x(e1)) / n * r + .5,
                    z: 0
                };
            }
            unproject(t1, e1) {
                const { scale: r , cosPhi: n  } = this, i = -(e1 - .5) / r, s = S(v((t1 - .5) / r) / n, -180, 180), a = Math.asin(S(i * n, -1, 1)), o = S(v(a), -cu, cu);
                return new ru(s, o);
            }
        }
        class ed extends Yf {
            constructor(t1){
                super(t1), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = [
                    "debug"
                ], this.range = [
                    3,
                    5
                ];
            }
            projectTilePoint(t1, e1, r) {
                const n = Ol(t1, e1, r);
                return el(n, n, Gl(Pl(r))), {
                    x: n[0],
                    y: n[1],
                    z: n[2]
                };
            }
            locationPoint(t1, e1) {
                const r = $l(e1.lat, e1.lng), n = Jo([], r), i = t1.elevation ? t1.elevation.getAtPointOrZero(t1.locationCoordinate(e1), t1._centerAltitude) : t1._centerAltitude;
                Wo(r, r, n, au(1, 0) * ko * i);
                const s = Eo(new Float64Array(16));
                return Po(s, t1.pixelMatrix, t1.globeMatrix), el(r, r, s), new d(r[0], r[1]);
            }
            pixelsPerMeter(t1, e1) {
                return au(1, 0) * e1;
            }
            pixelSpaceConversion(t1, e1, r) {
                const n = au(1, t1) * e1, i = Mr(au(1, 45) * e1, n, r);
                return this.pixelsPerMeter(t1, e1) / i;
            }
            createTileMatrix(t1, e1, r) {
                const n = Xl(Pl(r.canonical));
                return Po(new Float64Array(16), t1.globeMatrix, n);
            }
            createInversionMatrix(t1, e1) {
                const { center: r  } = t1, n = Gl(Pl(e1));
                return Fo(n, n, x(r.lng)), Lo(n, n, x(r.lat)), Vo(n, n, [
                    t1._pixelsPerMercatorPixel,
                    t1._pixelsPerMercatorPixel,
                    1
                ]), Float32Array.from(n);
            }
            pointCoordinate(t1, e1, r, n) {
                return Bl(t1, e1, r, !0) || new pu(0, 0);
            }
            pointCoordinate3D(t1, e1, r) {
                const n = this.pointCoordinate(t1, e1, r, 0);
                return [
                    n.x,
                    n.y,
                    n.z
                ];
            }
            isPointAboveHorizon(t1, e1) {
                return !Bl(t1, e1.x, e1.y, !1);
            }
            farthestPixelDistance(t1) {
                const e1 = function(t1, e1) {
                    const r = t1.cameraToCenterDistance, n = t1._centerAltitude * e1, i = t1._camera, s = t1._camera.forward(), a = Go([], Ho([], s, -r), [
                        0,
                        0,
                        n
                    ]), o = t1.worldSize / (2 * Math.PI), l = [
                        0,
                        0,
                        -o
                    ], u = t1.width / t1.height, c = Math.tan(t1.fovAboveCenter), h = Ho([], i.up(), c), p = Ho([], i.right(), c * u), f = Jo([], Go([], Go([], s, h), p)), d = [];
                    let y;
                    if (new vl(a, f).closestPointOnSphere(l, o, d)) {
                        const e1 = Go([], d, l), r = il([], e1, a);
                        y = Math.cos(t1.fovAboveCenter) * qo(r);
                    } else {
                        const t1 = il([], a, l), e1 = il([], l, a);
                        Jo(e1, e1);
                        const r = qo(t1) - o;
                        y = Math.sqrt(r * (r + 2 * o));
                        const n = Math.acos(y / (o + r)) - Math.acos(Qo(s, e1));
                        y *= Math.cos(n);
                    }
                    return 1.01 * y;
                }(t1, this.pixelsPerMeter(t1.center.lat, t1.worldSize)), r = Kl(t1.zoom);
                if (r > 0) {
                    const n = Df(t1, au(1, t1.center.lat) * t1.worldSize), i = t1.worldSize / (2 * Math.PI), s = Math.max(t1.width, t1.height) / t1.worldSize * Math.PI;
                    return Mr(e1, n + i * (1 - Math.cos(s)), Math.pow(r, 10));
                }
                return e1;
            }
            upVector(t1, e1, r) {
                return Ol(e1, r, t1, 1);
            }
            upVectorScale(t1) {
                return {
                    metersToTile: zl(ql(Pl(t1)))
                };
            }
        }
        function rd(t1) {
            const e1 = t1.parallels, r = !!e1 && Math.abs(e1[0] + e1[1]) < .01;
            switch(t1.name){
                case "mercator":
                    return new Yf(t1);
                case "equirectangular":
                    return new Gf(t1);
                case "naturalEarth":
                    return new Wf(t1);
                case "equalEarth":
                    return new Nf(t1);
                case "winkelTripel":
                    return new Qf(t1);
                case "albers":
                    return r ? new td(t1) : new Rf(t1);
                case "lambertConformalConic":
                    return r ? new td(t1) : new Kf(t1);
                case "globe":
                    return new ed(t1);
            }
            throw new Error(`Invalid projection name: ${t1.name}`);
        }
        const nd = ah.types, id = [
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }
        ];
        function sd(t1, e1, r, n, i, s, a, o, l, u, c, h, p) {
            const f = o ? Math.min(Tf, Math.round(o[0])) : 0, d = o ? Math.min(Tf, Math.round(o[1])) : 0;
            t1.emplaceBack(e1, r, Math.round(32 * n), Math.round(32 * i), s, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);
        }
        function ad(t1, e1, r, n, i, s, a) {
            t1.emplaceBack(e1, r, n, i, s, a);
        }
        function od(t1, e1, r, n, i) {
            t1.emplaceBack(e1, r, n, i), t1.emplaceBack(e1, r, n, i), t1.emplaceBack(e1, r, n, i), t1.emplaceBack(e1, r, n, i);
        }
        function ld(t1) {
            for (const e1 of t1.sections)if (Ms(e1.text)) return !0;
            return !1;
        }
        class ud {
            constructor(t1){
                this.layoutVertexArray = new fa, this.indexArray = new wa, this.programConfigurations = t1, this.segments = new So, this.dynamicLayoutVertexArray = new ua, this.opacityVertexArray = new ya, this.placedSymbolArray = new Pa, this.globeExtVertexArray = new da;
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t1, e1, r, n) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Nh.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray, e1), this.dynamicLayoutVertexBuffer = t1.createVertexBuffer(this.dynamicLayoutVertexArray, Xh.members, !0), this.opacityVertexBuffer = t1.createVertexBuffer(this.opacityVertexArray, id, !0), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, Gh.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t1));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
        }
        Oi(ud, "SymbolBuffers");
        class cd {
            constructor(t1, e1, r){
                this.layoutVertexArray = new t1, this.layoutAttributes = e1, this.indexArray = new r, this.segments = new So, this.collisionVertexArray = new va, this.collisionVertexArrayExt = new ba;
            }
            upload(t1) {
                this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t1.createVertexBuffer(this.collisionVertexArray, Zh.members, !0), this.collisionVertexBufferExt = t1.createVertexBuffer(this.collisionVertexArrayExt, Kh.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
        }
        Oi(cd, "CollisionBuffers");
        class hd {
            constructor(t1){
                this.collisionBoxArray = t1.collisionBoxArray, this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.id), this.index = t1.index, this.pixelRatio = t1.pixelRatio, this.sourceLayerIndex = t1.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Eo([]), this.placementViewportMatrix = Eo([]);
                const e1 = this.layers[0]._unevaluatedLayout._values;
                this.textSizeData = Qh(this.zoom, e1["text-size"]), this.iconSizeData = Qh(this.zoom, e1["icon-size"]);
                const r = this.layers[0].layout, n = r.get("symbol-sort-key"), i = r.get("symbol-z-order");
                this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map((t1)=>Vp[t1]), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.sourceID = t1.sourceID, this.projection = t1.projection;
            }
            createArrays() {
                this.text = new ud(new fo(this.layers, this.zoom, (t1)=>/^text/.test(t1))), this.icon = new ud(new fo(this.layers, this.zoom, (t1)=>/^icon/.test(t1))), this.glyphOffsetArray = new La, this.lineVertexArray = new Fa, this.symbolInstances = new Va;
            }
            calculateGlyphDependencies(t1, e1, r, n, i) {
                for(let r = 0; r < t1.length; r++)if (e1[t1.charCodeAt(r)] = !0, n && i) {
                    const n = ip[t1.charAt(r)];
                    n && (e1[n.charCodeAt(0)] = !0);
                }
            }
            populate(t1, e1, r, n) {
                const i = this.layers[0], s = i.layout, a = "globe" === this.projection.name, o = s.get("text-font"), l = s.get("text-field"), u = s.get("icon-image"), c = ("constant" !== l.value.kind || l.value.value instanceof Be && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== o.value.kind || o.value.value.length > 0), h = "constant" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0, p = s.get("symbol-sort-key");
                if (this.features = [], !c && !h) return;
                const f = e1.iconDependencies, d = e1.glyphDependencies, y = e1.availableImages, m = new Us(this.zoom);
                for (const { feature: e1 , id: l , index: u , sourceLayerIndex: g  } of t1){
                    const t1 = i._featureFilter.needGeometry, x = wu(e1, t1);
                    if (!i._featureFilter.filter(m, x, r)) continue;
                    if (t1 || (x.geometry = bu(e1, r, n)), a && 1 !== e1.type && r.z <= 5) {
                        const t1 = x.geometry, e1 = .98078528056, n = (t1, n)=>Qo(Ol(t1.x, t1.y, r, 1), Ol(n.x, n.y, r, 1)) < e1;
                        for(let e1 = 0; e1 < t1.length; e1++)t1[e1] = mu(t1[e1], n);
                    }
                    let v, b;
                    if (c) {
                        const t1 = i.getValueAndResolveTokens("text-field", x, r, y), e1 = Be.factory(t1);
                        ld(e1) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === Fs() || this.hasRTLText && js.isParsed()) && (v = np(e1, i, x));
                    }
                    if (h) {
                        const t1 = i.getValueAndResolveTokens("icon-image", x, r, y);
                        b = t1 instanceof Ee ? t1 : Ee.fromString(t1);
                    }
                    if (!v && !b) continue;
                    const w = this.sortFeaturesByKey ? p.evaluate(x, {}, r) : void 0;
                    if (this.features.push({
                        id: l,
                        text: v,
                        icon: b,
                        index: u,
                        sourceLayerIndex: g,
                        geometry: x.geometry,
                        properties: e1.properties,
                        type: nd[e1.type],
                        sortKey: w
                    }), b && (f[b.name] = !0), v) {
                        const t1 = o.evaluate(x, {}, r).join(","), e1 = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Vp.vertical) >= 0;
                        for (const r of v.sections)if (r.image) f[r.image.name] = !0;
                        else {
                            const n = bs(v.toString()), i = r.fontStack || t1, s = d[i] = d[i] || {};
                            this.calculateGlyphDependencies(r.text, s, e1, this.allowVerticalPlacement, n);
                        }
                    }
                }
                "line" === s.get("symbol-placement") && (this.features = function(t1) {
                    const e1 = {}, r = {}, n = [];
                    let i = 0;
                    function s(e1) {
                        n.push(t1[e1]), i++;
                    }
                    function a(t1, e1, i) {
                        const s = r[t1];
                        return delete r[t1], r[e1] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;
                    }
                    function o(t1, r, i) {
                        const s = e1[r];
                        return delete e1[r], e1[t1] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;
                    }
                    function l(t1, e1, r) {
                        const n = r ? e1[0][e1[0].length - 1] : e1[0][0];
                        return `${t1}:${n.x}:${n.y}`;
                    }
                    for(let u = 0; u < t1.length; u++){
                        const c = t1[u], h = c.geometry, p = c.text ? c.text.toString() : null;
                        if (!p) {
                            s(u);
                            continue;
                        }
                        const f = l(p, h), d = l(p, h, !0);
                        if (f in r && d in e1 && r[f] !== e1[d]) {
                            const t1 = o(f, d, h), i = a(f, d, n[t1].geometry);
                            delete e1[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t1].geometry = null;
                        } else f in r ? a(f, d, h) : d in e1 ? o(f, d, h) : (s(u), e1[f] = i - 1, r[d] = i - 1);
                    }
                    return n.filter((t1)=>t1.geometry);
                }(this.features)), this.sortFeaturesByKey && this.features.sort((t1, e1)=>t1.sortKey - e1.sortKey);
            }
            update(t1, e1, r, n) {
                this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t1, e1, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(t1, e1, this.layers, r, n));
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t1) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t1), this.iconCollisionBox.upload(t1)), this.text.upload(t1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = rd(this.projection)), this.projectionInstance;
            }
            destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t1, e1) {
                const r = this.lineVertexArray.length;
                if (void 0 !== t1.segment) for (const { x: t1 , y: r  } of e1)this.lineVertexArray.emplaceBack(t1, r);
                return {
                    lineStartIndex: r,
                    lineLength: this.lineVertexArray.length - r
                };
            }
            addSymbols(t1, e1, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d = t1.indexArray, y = t1.layoutVertexArray, m = t1.globeExtVertexArray, g = t1.segments.prepareSegment(4 * e1.length, y, d, this.canOverlap ? s.sortKey : void 0), x = this.glyphOffsetArray.length, v = g.vertexLength, b = this.allowVerticalPlacement && a === Vp.vertical ? Math.PI / 2 : 0, w = s.text && s.text.sections;
                for(let n = 0; n < e1.length; n++){
                    const { tl: i , tr: a , bl: u , br: c , tex: h , pixelOffsetTL: x , pixelOffsetBR: v , minFontScaleX: _ , minFontScaleY: A , glyphOffset: S , isSDF: k , sectionIndex: I  } = e1[n], M = g.vertexLength, T = S[1];
                    if (sd(y, l.x, l.y, i.x, T + i.y, h.x, h.y, r, k, x.x, x.y, _, A), sd(y, l.x, l.y, a.x, T + a.y, h.x + h.w, h.y, r, k, v.x, x.y, _, A), sd(y, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, k, x.x, v.y, _, A), sd(y, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, k, v.x, v.y, _, A), o) {
                        const { x: e1 , y: r , z: n  } = o.anchor, [i, s, a] = o.up;
                        ad(m, e1, r, n, i, s, a), ad(m, e1, r, n, i, s, a), ad(m, e1, r, n, i, s, a), ad(m, e1, r, n, i, s, a), od(t1.dynamicLayoutVertexArray, e1, r, n, b);
                    } else od(t1.dynamicLayoutVertexArray, l.x, l.y, l.z, b);
                    d.emplaceBack(M, M + 1, M + 2), d.emplaceBack(M + 1, M + 2, M + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S[0]), n !== e1.length - 1 && I === e1[n + 1].sectionIndex || t1.programConfigurations.populatePaintArrays(y.length, s, s.index, {}, p, f, w && w[I]);
                }
                const _ = o ? o.anchor : l;
                t1.placedSymbolArray.emplaceBack(_.x, _.y, _.z, l.x, l.y, x, this.glyphOffsetArray.length - x, v, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);
            }
            _commitLayoutVertex(t1, e1, r, n, i, s, a) {
                t1.emplaceBack(e1, r, n, i, s, Math.round(a.x), Math.round(a.y));
            }
            _addCollisionDebugVertices(t1, e1, r, n, i, s, a) {
                const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), l = o.vertexLength, u = a.tileAnchorX, c = a.tileAnchorY;
                for(let t1 = 0; t1 < 4; t1++)r.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                r.collisionVertexArrayExt.emplaceBack(e1, -t1.padding, -t1.padding), r.collisionVertexArrayExt.emplaceBack(e1, t1.padding, -t1.padding), r.collisionVertexArrayExt.emplaceBack(e1, t1.padding, t1.padding), r.collisionVertexArrayExt.emplaceBack(e1, -t1.padding, t1.padding), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t1.x1, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t1.x2, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t1.x2, t1.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t1.x1, t1.y2)), o.vertexLength += 4;
                const h = r.indexArray;
                h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t1, e1, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceTextSize(t1, s, e1, a);
                    this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            _addIconDebugCollisionBoxes(t1, e1, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceIconSize(t1, e1, s.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            generateCollisionDebugBuffers(t1, e1) {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new cd(ga, Yh.members, Ma), this.iconCollisionBox = new cd(ga, Yh.members, Ma);
                const r = ep(this.iconSizeData, t1), n = ep(this.textSizeData, t1);
                for(let i = 0; i < this.symbolInstances.length; i++){
                    const s = this.symbolInstances.get(i);
                    this._addTextDebugCollisionBoxes(n, t1, e1, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t1, e1, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t1, e1, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t1, e1, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
                }
            }
            getSymbolInstanceTextSize(t1, e1, r, n) {
                const i = this.text.placedSymbolArray.get(e1.rightJustifiedTextSymbolIndex >= 0 ? e1.rightJustifiedTextSymbolIndex : e1.centerJustifiedTextSymbolIndex >= 0 ? e1.centerJustifiedTextSymbolIndex : e1.leftJustifiedTextSymbolIndex >= 0 ? e1.leftJustifiedTextSymbolIndex : e1.verticalPlacedTextSymbolIndex >= 0 ? e1.verticalPlacedTextSymbolIndex : n), s = tp(this.textSizeData, t1, i) / Wh;
                return this.tilePixelRatio * s;
            }
            getSymbolInstanceIconSize(t1, e1, r) {
                const n = this.icon.placedSymbolArray.get(r), i = tp(this.iconSizeData, t1, n);
                return this.tilePixelRatio * i;
            }
            _commitDebugCollisionVertexUpdate(t1, e1, r) {
                t1.emplaceBack(e1, -r, -r), t1.emplaceBack(e1, r, -r), t1.emplaceBack(e1, r, r), t1.emplaceBack(e1, -r, r);
            }
            _updateTextDebugCollisionBoxes(t1, e1, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceTextSize(t1, s, e1, a);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);
                }
            }
            _updateIconDebugCollisionBoxes(t1, e1, r, n, i, s) {
                for(let a = n; a < i; a++){
                    const n = r.get(a), i = this.getSymbolInstanceIconSize(t1, e1, s);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);
                }
            }
            updateCollisionDebugBuffers(t1, e1) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const r = ep(this.iconSizeData, t1), n = ep(this.textSizeData, t1);
                for(let i = 0; i < this.symbolInstances.length; i++){
                    const s = this.symbolInstances.get(i);
                    this._updateTextDebugCollisionBoxes(n, t1, e1, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t1, e1, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t1, e1, s.iconBoxStartIndex, s.iconBoxEndIndex, s.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r, t1, e1, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s.placedIconSymbolIndex);
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t1, e1, r, n, i, s, a, o, l) {
                const u = {};
                if (e1 < r) {
                    const { x1: r , y1: n , x2: i , y2: s , padding: a , projectedAnchorX: o , projectedAnchorY: l , projectedAnchorZ: c , tileAnchorX: h , tileAnchorY: p , featureIndex: f  } = t1.get(e1);
                    u.textBox = {
                        x1: r,
                        y1: n,
                        x2: i,
                        y2: s,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.textFeatureIndex = f;
                }
                if (n < i) {
                    const { x1: e1 , y1: r , x2: i , y2: s , padding: a , projectedAnchorX: o , projectedAnchorY: l , projectedAnchorZ: c , tileAnchorX: h , tileAnchorY: p , featureIndex: f  } = t1.get(n);
                    u.verticalTextBox = {
                        x1: e1,
                        y1: r,
                        x2: i,
                        y2: s,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalTextFeatureIndex = f;
                }
                if (s < a) {
                    const { x1: e1 , y1: r , x2: n , y2: i , padding: a , projectedAnchorX: o , projectedAnchorY: l , projectedAnchorZ: c , tileAnchorX: h , tileAnchorY: p , featureIndex: f  } = t1.get(s);
                    u.iconBox = {
                        x1: e1,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: a,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.iconFeatureIndex = f;
                }
                if (o < l) {
                    const { x1: e1 , y1: r , x2: n , y2: i , padding: s , projectedAnchorX: a , projectedAnchorY: l , projectedAnchorZ: c , tileAnchorX: h , tileAnchorY: p , featureIndex: f  } = t1.get(o);
                    u.verticalIconBox = {
                        x1: e1,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: s,
                        projectedAnchorX: a,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalIconFeatureIndex = f;
                }
                return u;
            }
            deserializeCollisionBoxes(t1) {
                this.collisionArrays = [];
                for(let e1 = 0; e1 < this.symbolInstances.length; e1++){
                    const r = this.symbolInstances.get(e1);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t1, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0;
            }
            hasIconData() {
                return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t1, e1) {
                const r = t1.placedSymbolArray.get(e1), n = r.vertexStartIndex + 4 * r.numGlyphs;
                for(let e1 = r.vertexStartIndex; e1 < n; e1 += 4)t1.indexArray.emplaceBack(e1, e1 + 1, e1 + 2), t1.indexArray.emplaceBack(e1 + 1, e1 + 2, e1 + 3);
            }
            getSortedSymbolIndexes(t1) {
                if (this.sortedAngle === t1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                const e1 = Math.sin(t1), r = Math.cos(t1), n = [], i = [], s = [];
                for(let t1 = 0; t1 < this.symbolInstances.length; ++t1){
                    s.push(t1);
                    const a = this.symbolInstances.get(t1);
                    n.push(0 | Math.round(e1 * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);
                }
                return s.sort((t1, e1)=>n[t1] - n[e1] || i[e1] - i[t1]), s;
            }
            addToSortKeyRanges(t1, e1) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r && r.sortKey === e1 ? r.symbolInstanceEnd = t1 + 1 : this.sortKeyRanges.push({
                    sortKey: e1,
                    symbolInstanceStart: t1,
                    symbolInstanceEnd: t1 + 1
                });
            }
            sortFeatures(t1) {
                if (this.sortFeaturesByY && this.sortedAngle !== t1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t1), this.sortedAngle = t1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const t1 of this.symbolInstanceIndexes){
                        const e1 = this.symbolInstances.get(t1);
                        this.featureSortOrder.push(e1.featureIndex);
                        const { rightJustifiedTextSymbolIndex: r , centerJustifiedTextSymbolIndex: n , leftJustifiedTextSymbolIndex: i , verticalPlacedTextSymbolIndex: s , placedIconSymbolIndex: a , verticalPlacedIconSymbolIndex: o  } = e1;
                        r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }
        Oi(hd, "SymbolBucket", {
            omit: [
                "layers",
                "collisionBoxArray",
                "features",
                "compareText"
            ]
        }), hd.MAX_GLYPHS = 65535, hd.addDynamicAttributes = od;
        const pd = new Js({
            "symbol-placement": new Ys(Ht.layout_symbol["symbol-placement"]),
            "symbol-spacing": new Ys(Ht.layout_symbol["symbol-spacing"]),
            "symbol-avoid-edges": new Ys(Ht.layout_symbol["symbol-avoid-edges"]),
            "symbol-sort-key": new Hs(Ht.layout_symbol["symbol-sort-key"]),
            "symbol-z-order": new Ys(Ht.layout_symbol["symbol-z-order"]),
            "icon-allow-overlap": new Ys(Ht.layout_symbol["icon-allow-overlap"]),
            "icon-ignore-placement": new Ys(Ht.layout_symbol["icon-ignore-placement"]),
            "icon-optional": new Ys(Ht.layout_symbol["icon-optional"]),
            "icon-rotation-alignment": new Ys(Ht.layout_symbol["icon-rotation-alignment"]),
            "icon-size": new Hs(Ht.layout_symbol["icon-size"]),
            "icon-text-fit": new Ys(Ht.layout_symbol["icon-text-fit"]),
            "icon-text-fit-padding": new Ys(Ht.layout_symbol["icon-text-fit-padding"]),
            "icon-image": new Hs(Ht.layout_symbol["icon-image"]),
            "icon-rotate": new Hs(Ht.layout_symbol["icon-rotate"]),
            "icon-padding": new Ys(Ht.layout_symbol["icon-padding"]),
            "icon-keep-upright": new Ys(Ht.layout_symbol["icon-keep-upright"]),
            "icon-offset": new Hs(Ht.layout_symbol["icon-offset"]),
            "icon-anchor": new Hs(Ht.layout_symbol["icon-anchor"]),
            "icon-pitch-alignment": new Ys(Ht.layout_symbol["icon-pitch-alignment"]),
            "text-pitch-alignment": new Ys(Ht.layout_symbol["text-pitch-alignment"]),
            "text-rotation-alignment": new Ys(Ht.layout_symbol["text-rotation-alignment"]),
            "text-field": new Hs(Ht.layout_symbol["text-field"]),
            "text-font": new Hs(Ht.layout_symbol["text-font"]),
            "text-size": new Hs(Ht.layout_symbol["text-size"]),
            "text-max-width": new Hs(Ht.layout_symbol["text-max-width"]),
            "text-line-height": new Hs(Ht.layout_symbol["text-line-height"]),
            "text-letter-spacing": new Hs(Ht.layout_symbol["text-letter-spacing"]),
            "text-justify": new Hs(Ht.layout_symbol["text-justify"]),
            "text-radial-offset": new Hs(Ht.layout_symbol["text-radial-offset"]),
            "text-variable-anchor": new Ys(Ht.layout_symbol["text-variable-anchor"]),
            "text-anchor": new Hs(Ht.layout_symbol["text-anchor"]),
            "text-max-angle": new Ys(Ht.layout_symbol["text-max-angle"]),
            "text-writing-mode": new Ys(Ht.layout_symbol["text-writing-mode"]),
            "text-rotate": new Hs(Ht.layout_symbol["text-rotate"]),
            "text-padding": new Ys(Ht.layout_symbol["text-padding"]),
            "text-keep-upright": new Ys(Ht.layout_symbol["text-keep-upright"]),
            "text-transform": new Hs(Ht.layout_symbol["text-transform"]),
            "text-offset": new Hs(Ht.layout_symbol["text-offset"]),
            "text-allow-overlap": new Ys(Ht.layout_symbol["text-allow-overlap"]),
            "text-ignore-placement": new Ys(Ht.layout_symbol["text-ignore-placement"]),
            "text-optional": new Ys(Ht.layout_symbol["text-optional"])
        });
        var fd = {
            paint: new Js({
                "icon-opacity": new Hs(Ht.paint_symbol["icon-opacity"]),
                "icon-color": new Hs(Ht.paint_symbol["icon-color"]),
                "icon-halo-color": new Hs(Ht.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new Hs(Ht.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new Hs(Ht.paint_symbol["icon-halo-blur"]),
                "icon-translate": new Ys(Ht.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new Ys(Ht.paint_symbol["icon-translate-anchor"]),
                "text-opacity": new Hs(Ht.paint_symbol["text-opacity"]),
                "text-color": new Hs(Ht.paint_symbol["text-color"], {
                    runtimeType: le,
                    getOverride: (t1)=>t1.textColor,
                    hasOverride: (t1)=>!!t1.textColor
                }),
                "text-halo-color": new Hs(Ht.paint_symbol["text-halo-color"]),
                "text-halo-width": new Hs(Ht.paint_symbol["text-halo-width"]),
                "text-halo-blur": new Hs(Ht.paint_symbol["text-halo-blur"]),
                "text-translate": new Ys(Ht.paint_symbol["text-translate"]),
                "text-translate-anchor": new Ys(Ht.paint_symbol["text-translate-anchor"])
            }),
            layout: pd
        };
        class dd {
            constructor(t1){
                this.type = t1.property.overrides ? t1.property.overrides.runtimeType : ie, this.defaultValue = t1;
            }
            evaluate(t1) {
                if (t1.formattedSection) {
                    const e1 = this.defaultValue.property.overrides;
                    if (e1 && e1.hasOverride(t1.formattedSection)) return e1.getOverride(t1.formattedSection);
                }
                return t1.feature && t1.featureState ? this.defaultValue.evaluate(t1.feature, t1.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t1) {
                this.defaultValue.isConstant() || t1(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return null;
            }
        }
        Oi(dd, "FormatSectionOverride", {
            omit: [
                "defaultValue"
            ]
        });
        class yd extends wo {
            constructor(t1){
                super(t1, fd);
            }
            recalculate(t1, e1) {
                super.recalculate(t1, e1), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const r = this.layout.get("text-writing-mode");
                if (r) {
                    const t1 = [];
                    for (const e1 of r)t1.indexOf(e1) < 0 && t1.push(e1);
                    this.layout._values["text-writing-mode"] = t1;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? [
                    "horizontal"
                ] : [
                    "horizontal",
                    "vertical"
                ];
                this._setPaintOverrides();
            }
            getValueAndResolveTokens(t1, e1, r, n) {
                const i = this.layout.get(t1).evaluate(e1, {}, r, n), s = this._unevaluatedLayout._values[t1];
                return s.isDataDriven() || Nn(s.value) || !i ? i : function(t1, e1) {
                    return e1.replace(/{([^{}]+)}/g, (e1, r)=>r in t1 ? String(t1[r]) : "");
                }(e1.properties, i);
            }
            createBucket(t1) {
                return new hd(t1);
            }
            queryRadius() {
                return 0;
            }
            queryIntersectsFeature() {
                return !1;
            }
            _setPaintOverrides() {
                for (const t1 of fd.paint.overridableProperties){
                    if (!yd.hasPaintOverride(this.layout, t1)) continue;
                    const e1 = this.paint.get(t1), r = new dd(e1), n = new qn(r, e1.property.specification);
                    let i = null;
                    i = "constant" === e1.value.kind || "source" === e1.value.kind ? new Xn("source", n) : new Zn("composite", n, e1.value.zoomStops, e1.value._interpolationType), this.paint._values[t1] = new Zs(e1.property, i, e1.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t1, e1, r) {
                return !(!this.layout || e1.isDataDriven() || r.isDataDriven()) && yd.hasPaintOverride(this.layout, t1);
            }
            static hasPaintOverride(t1, e1) {
                const r = t1.get("text-field"), n = fd.paint.properties[e1];
                let i = !1;
                const s = (t1)=>{
                    for (const e1 of t1)if (n.overrides && n.overrides.hasOverride(e1)) return void (i = !0);
                };
                if ("constant" === r.value.kind && r.value.value instanceof Be) s(r.value.value.sections);
                else if ("source" === r.value.kind) {
                    const t1 = (e1)=>{
                        i || (e1 instanceof Fe && De(e1.value) === pe ? s(e1.value.sections) : e1 instanceof Oe ? s(e1.sections) : e1.eachChild(t1));
                    }, e1 = r.value;
                    e1._styleExpression && t1(e1._styleExpression.expression);
                }
                return i;
            }
            getProgramConfiguration(t1) {
                return new po(this, t1);
            }
        }
        var md = {
            paint: new Js({
                "background-color": new Ys(Ht.paint_background["background-color"]),
                "background-pattern": new Ys(Ht.paint_background["background-pattern"]),
                "background-opacity": new Ys(Ht.paint_background["background-opacity"])
            })
        }, gd = {
            paint: new Js({
                "raster-opacity": new Ys(Ht.paint_raster["raster-opacity"]),
                "raster-hue-rotate": new Ys(Ht.paint_raster["raster-hue-rotate"]),
                "raster-brightness-min": new Ys(Ht.paint_raster["raster-brightness-min"]),
                "raster-brightness-max": new Ys(Ht.paint_raster["raster-brightness-max"]),
                "raster-saturation": new Ys(Ht.paint_raster["raster-saturation"]),
                "raster-contrast": new Ys(Ht.paint_raster["raster-contrast"]),
                "raster-resampling": new Ys(Ht.paint_raster["raster-resampling"]),
                "raster-fade-duration": new Ys(Ht.paint_raster["raster-fade-duration"])
            })
        };
        class xd extends wo {
            constructor(t1){
                super(t1, {}), this.implementation = t1;
            }
            is3D() {
                return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
            }
            isLayerDraped() {
                return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
                return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1;
            }
            serialize() {}
            onAdd(t1) {
                this.implementation.onAdd && this.implementation.onAdd(t1, t1.painter.context.gl);
            }
            onRemove(t1) {
                this.implementation.onRemove && this.implementation.onRemove(t1, t1.painter.context.gl);
            }
        }
        var vd = {
            paint: new Js({
                "sky-type": new Ys(Ht.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new Ys(Ht.paint_sky["sky-atmosphere-sun"]),
                "sky-atmosphere-sun-intensity": new Ys(Ht.paint_sky["sky-atmosphere-sun-intensity"]),
                "sky-gradient-center": new Ys(Ht.paint_sky["sky-gradient-center"]),
                "sky-gradient-radius": new Ys(Ht.paint_sky["sky-gradient-radius"]),
                "sky-gradient": new Ws(Ht.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new Ys(Ht.paint_sky["sky-atmosphere-halo-color"]),
                "sky-atmosphere-color": new Ys(Ht.paint_sky["sky-atmosphere-color"]),
                "sky-opacity": new Ys(Ht.paint_sky["sky-opacity"])
            })
        };
        function bd(t1, e1, r) {
            const n = [
                0,
                0,
                1
            ], i = hl([]);
            return fl(i, i, r ? -x(t1) + Math.PI : x(t1)), pl(i, i, -x(e1)), rl(n, n, i), Jo(n, n);
        }
        const wd = {
            circle: class extends wo {
                constructor(t1){
                    super(t1, Ou);
                }
                createBucket(t1) {
                    return new Su(t1);
                }
                queryRadius(t1) {
                    const e1 = t1;
                    return Fu("circle-radius", this, e1) + Fu("circle-stroke-width", this, e1) + Ru(this.paint.get("circle-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, s, a, o) {
                    const l = Uu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), u = this.paint.get("circle-radius").evaluate(e1, r) + this.paint.get("circle-stroke-width").evaluate(e1, r);
                    return qu(t1, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
                }
                getProgramIds() {
                    return [
                        "circle"
                    ];
                }
                getProgramConfiguration(t1) {
                    return new po(this, t1);
                }
            },
            heatmap: class extends wo {
                createBucket(t1) {
                    return new Ku(t1);
                }
                constructor(t1){
                    super(t1, tc), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "heatmap-color" === t1 && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = ec({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }
                queryRadius(t1) {
                    return Fu("heatmap-radius", this, t1);
                }
                queryIntersectsFeature(t1, e1, r, n, i, s, a, o) {
                    const l = this.paint.get("heatmap-radius").evaluate(e1, r);
                    return qu(t1, n, s, a, o, !0, !0, new d(0, 0), l);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "heatmap",
                        "heatmapTexture"
                    ];
                }
                getProgramConfiguration(t1) {
                    return new po(this, t1);
                }
            },
            hillshade: class extends wo {
                constructor(t1){
                    super(t1, rc);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "hillshade",
                        "hillshadePrepare"
                    ];
                }
            },
            fill: class extends wo {
                constructor(t1){
                    super(t1, Oc);
                }
                getProgramIds() {
                    const t1 = this.paint.get("fill-pattern"), e1 = t1 && t1.constantOr(1), r = [
                        e1 ? "fillPattern" : "fill"
                    ];
                    return this.paint.get("fill-antialias") && r.push(e1 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
                }
                getProgramConfiguration(t1) {
                    return new po(this, t1);
                }
                recalculate(t1, e1) {
                    super.recalculate(t1, e1);
                    const r = this.paint._values["fill-outline-color"];
                    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t1) {
                    return new Uc(t1);
                }
                queryRadius() {
                    return Ru(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, s) {
                    return !t1.queryGeometry.isAboveHorizon && Mu(ju(t1.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), n);
                }
                isTileClipped() {
                    return !0;
                }
            },
            "fill-extrusion": class extends wo {
                constructor(t1){
                    super(t1, Ah);
                }
                createBucket(t1) {
                    return new fh(t1);
                }
                queryRadius() {
                    return Ru(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                    return !0;
                }
                getProgramIds() {
                    return [
                        this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"
                    ];
                }
                getProgramConfiguration(t1) {
                    return new po(this, t1);
                }
                queryIntersectsFeature(t1, e1, r, n, i, s, a, o, l) {
                    const u = Uu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), c = this.paint.get("fill-extrusion-height").evaluate(e1, r), h = this.paint.get("fill-extrusion-base").evaluate(e1, r), p = [
                        0,
                        0
                    ], f = o && s.elevation, y = s.elevation ? s.elevation.exaggeration() : 1, m = t1.tile.getBucket(this);
                    if (f && m instanceof fh) {
                        const t1 = m.centroidVertexArray, e1 = l + 1;
                        e1 < t1.length && (p[0] = t1.geta_centroid_pos0(e1), p[1] = t1.geta_centroid_pos1(e1));
                    }
                    if (0 === p[0] && 1 === p[1]) return !1;
                    "globe" === s.projection.name && (n = wh([
                        n
                    ], [
                        new d(0, 0),
                        new d(ko, ko)
                    ], t1.tileID.canonical).map((t1)=>t1.polygon).flat());
                    const g = f ? o : null, [x, v] = function(t1, e1, r, n, i, s, a, o, l, u, c) {
                        return "globe" === t1.projection.name ? function(t1, e1, r, n, i, s, a, o, l, u, c) {
                            const h = [], p = [], f = t1.projection.upVectorScale(c, t1.center.lat, t1.worldSize).metersToTile, d = [
                                0,
                                0,
                                0,
                                1
                            ], y = [
                                0,
                                0,
                                0,
                                1
                            ], m = (t1, e1, r, n)=>{
                                t1[0] = e1, t1[1] = r, t1[2] = n, t1[3] = 1;
                            }, g = bh();
                            r > 0 && (r += g), n += g;
                            for (const g of e1){
                                const e1 = [], x = [];
                                for (const h of g){
                                    const p = h.x + i.x, g = h.y + i.y, v = t1.projection.projectTilePoint(p, g, c), b = t1.projection.upVector(c, h.x, h.y);
                                    let w = r, _ = n;
                                    if (a) {
                                        const t1 = Ch(p, g, r, n, a, o, l, u);
                                        w += t1.base, _ += t1.top;
                                    }
                                    0 !== r ? m(d, v.x + b[0] * f * w, v.y + b[1] * f * w, v.z + b[2] * f * w) : m(d, v.x, v.y, v.z), m(y, v.x + b[0] * f * _, v.y + b[1] * f * _, v.z + b[2] * f * _), el(d, d, s), el(y, y, s), e1.push(new zh(d[0], d[1], d[2])), x.push(new zh(y[0], y[1], y[2]));
                                }
                                h.push(e1), p.push(x);
                            }
                            return [
                                h,
                                p
                            ];
                        }(t1, e1, r, n, i, s, a, o, l, u, c) : a ? function(t1, e1, r, n, i, s, a, o, l) {
                            const u = [], c = [], h = [
                                0,
                                0,
                                0,
                                1
                            ];
                            for (const p of t1){
                                const t1 = [], f = [];
                                for (const u of p){
                                    const c = u.x + n.x, p = u.y + n.y, d = Ch(c, p, e1, r, s, a, o, l);
                                    h[0] = c, h[1] = p, h[2] = d.base, h[3] = 1, ul(h, h, i), h[3] = Math.max(h[3], 1e-5);
                                    const y = new zh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                                    h[0] = c, h[1] = p, h[2] = d.top, h[3] = 1, ul(h, h, i), h[3] = Math.max(h[3], 1e-5);
                                    const m = new zh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                                    t1.push(y), f.push(m);
                                }
                                u.push(t1), c.push(f);
                            }
                            return [
                                u,
                                c
                            ];
                        }(e1, r, n, i, s, a, o, l, u) : function(t1, e1, r, n, i) {
                            const s = [], a = [], o = i[8] * e1, l = i[9] * e1, u = i[10] * e1, c = i[11] * e1, h = i[8] * r, p = i[9] * r, f = i[10] * r, d = i[11] * r;
                            for (const e1 of t1){
                                const t1 = [], r = [];
                                for (const s of e1){
                                    const e1 = s.x + n.x, a = s.y + n.y, y = i[0] * e1 + i[4] * a + i[12], m = i[1] * e1 + i[5] * a + i[13], g = i[2] * e1 + i[6] * a + i[14], x = i[3] * e1 + i[7] * a + i[15], v = y + o, b = m + l, w = g + u, _ = Math.max(x + c, 1e-5), A = y + h, S = m + p, k = g + f, I = Math.max(x + d, 1e-5);
                                    t1.push(new zh(v / _, b / _, w / _)), r.push(new zh(A / I, S / I, k / I));
                                }
                                s.push(t1), a.push(r);
                            }
                            return [
                                s,
                                a
                            ];
                        }(e1, r, n, i, s);
                    }(s, n, h, c, u, a, g, p, y, s.center.lat, t1.tileID.canonical), b = t1.queryGeometry;
                    return function(t1, e1, r) {
                        let n = 1 / 0;
                        Mu(r, e1) && (n = Eh(r, e1[0]));
                        for(let i = 0; i < e1.length; i++){
                            const s = e1[i], a = t1[i];
                            for(let t1 = 0; t1 < s.length - 1; t1++){
                                const e1 = s[t1], i = [
                                    e1,
                                    s[t1 + 1],
                                    a[t1 + 1],
                                    a[t1],
                                    e1
                                ];
                                ku(r, i) && (n = Math.min(n, Eh(r, i)));
                            }
                        }
                        return n !== 1 / 0 && n;
                    }(x, v, b.isPointQuery() ? b.screenBounds : b.screenGeometry);
                }
            },
            line: class extends wo {
                constructor(t1){
                    super(t1, $h), this.gradientVersion = 0;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    if ("line-gradient" === t1) {
                        const t1 = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = t1._styleExpression && t1._styleExpression.expression instanceof Ir, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }
                widthExpression() {
                    return this._transitionablePaint._values["line-width"].value.expression;
                }
                recalculate(t1, e1) {
                    super.recalculate(t1, e1), this.paint._values["line-floorwidth"] = Oh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t1);
                }
                createBucket(t1) {
                    return new jh(t1);
                }
                getProgramIds() {
                    return [
                        this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"
                    ];
                }
                getProgramConfiguration(t1) {
                    return new po(this, t1);
                }
                queryRadius(t1) {
                    const e1 = t1, r = qh(Fu("line-width", this, e1), Fu("line-gap-width", this, e1)), n = Fu("line-offset", this, e1);
                    return r / 2 + Math.abs(n) + Ru(this.paint.get("line-translate"));
                }
                queryIntersectsFeature(t1, e1, r, n, i, s) {
                    if (t1.queryGeometry.isAboveHorizon) return !1;
                    const a = ju(t1.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, t1.pixelToTileUnitsFactor), o = t1.pixelToTileUnitsFactor / 2 * qh(this.paint.get("line-width").evaluate(e1, r), this.paint.get("line-gap-width").evaluate(e1, r)), l = this.paint.get("line-offset").evaluate(e1, r);
                    return l && (n = function(t1, e1) {
                        const r = [], n = new d(0, 0);
                        for(let i = 0; i < t1.length; i++){
                            const s = t1[i], a = [];
                            for(let t1 = 0; t1 < s.length; t1++){
                                const r = s[t1 - 1], i = s[t1], o = s[t1 + 1], l = 0 === t1 ? n : i.sub(r)._unit()._perp(), u = t1 === s.length - 1 ? n : o.sub(i)._unit()._perp(), c = l._add(u)._unit();
                                c._mult(1 / (c.x * u.x + c.y * u.y)), a.push(c._mult(e1)._add(i));
                            }
                            r.push(a);
                        }
                        return r;
                    }(n, l * t1.pixelToTileUnitsFactor)), function(t1, e1, r) {
                        for(let n = 0; n < e1.length; n++){
                            const i = e1[n];
                            if (t1.length >= 3) {
                                for(let e1 = 0; e1 < i.length; e1++)if (Du(t1, i[e1])) return !0;
                            }
                            if (Tu(t1, i, r)) return !0;
                        }
                        return !1;
                    }(a, n, o);
                }
                isTileClipped() {
                    return !0;
                }
            },
            symbol: yd,
            background: class extends wo {
                constructor(t1){
                    super(t1, md);
                }
                getProgramIds() {
                    return [
                        this.paint.get("background-pattern") ? "backgroundPattern" : "background"
                    ];
                }
            },
            raster: class extends wo {
                constructor(t1){
                    super(t1, gd);
                }
                getProgramIds() {
                    return [
                        "raster"
                    ];
                }
            },
            sky: class extends wo {
                constructor(t1){
                    super(t1, vd), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "sky-gradient" === t1 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t1 && "sky-atmosphere-halo-color" !== t1 && "sky-atmosphere-color" !== t1 && "sky-atmosphere-sun-intensity" !== t1 || (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                    this.colorRamp = ec({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                needsSkyboxCapture(t1) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e1 = t1.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e1.azimuthal || this._lightPosition.polar !== e1.polar;
                    }
                    return !1;
                }
                getCenter(t1, e1) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r = this.paint.get("sky-atmosphere-sun"), n = !r, i = t1.style.light, s = i.properties.get("position");
                        return n && "viewport" === i.properties.get("anchor") && $("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? bd(s.azimuthal, 90 - s.polar, e1) : bd(r[0], 90 - r[1], e1);
                    }
                    const r = this.paint.get("sky-gradient-center");
                    return bd(r[0], 90 - r[1], e1);
                }
                is3D() {
                    return !1;
                }
                isSky() {
                    return !0;
                }
                markSkyboxValid(t1) {
                    this._skyboxInvalidated = !1, this._lightPosition = t1.style.light.properties.get("position");
                }
                hasOffscreenPass() {
                    return !0;
                }
                getProgramIds() {
                    const t1 = this.paint.get("sky-type");
                    return "atmosphere" === t1 ? [
                        "skyboxCapture",
                        "skybox"
                    ] : "gradient" === t1 ? [
                        "skyboxGradient"
                    ] : null;
                }
            }
        };
        class _d {
            constructor(t1, e1, r, n){
                this.context = t1, this.format = r, this.texture = t1.gl.createTexture(), this.update(e1, n);
            }
            update(t1, r, n) {
                const { width: i , height: s  } = t1, { context: a  } = this, { gl: o  } = a, { HTMLImageElement: l , HTMLCanvasElement: u , HTMLVideoElement: c , ImageData: h , ImageBitmap: p  } = e1;
                if (o.bindTexture(o.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!r || !1 !== r.premultiply)), n || this.size && this.size[0] === i && this.size[1] === s) {
                    const { x: e1 , y: r  } = n || {
                        x: 0,
                        y: 0
                    };
                    t1 instanceof l || t1 instanceof u || t1 instanceof c || t1 instanceof h || p && t1 instanceof p ? o.texSubImage2D(o.TEXTURE_2D, 0, e1, r, o.RGBA, o.UNSIGNED_BYTE, t1) : o.texSubImage2D(o.TEXTURE_2D, 0, e1, r, i, s, o.RGBA, o.UNSIGNED_BYTE, t1.data);
                } else this.size = [
                    i,
                    s
                ], t1 instanceof l || t1 instanceof u || t1 instanceof c || t1 instanceof h || p && t1 instanceof p ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, t1) : o.texImage2D(o.TEXTURE_2D, 0, this.format, i, s, 0, this.format, o.UNSIGNED_BYTE, t1.data);
                this.useMipmap = Boolean(r && r.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o.generateMipmap(o.TEXTURE_2D);
            }
            bind(t1, e1) {
                const { context: r  } = this, { gl: n  } = r;
                n.bindTexture(n.TEXTURE_2D, this.texture), t1 !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t1 === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t1), this.filter = t1), e1 !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e1), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e1), this.wrap = e1);
            }
            isSizePowerOfTwo() {
                return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
                const { gl: t1  } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }
        class Ad {
            constructor(t1){
                this._callback = t1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = ()=>{
                    this._triggered = !1, this._callback();
                });
            }
            trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                    this._triggered = !1, this._callback();
                }, 0));
            }
            remove() {
                this._channel = void 0, this._callback = ()=>{};
            }
        }
        class Sd {
            constructor(){
                this.tasks = {}, this.taskQueue = [], V([
                    "process"
                ], this), this.invoker = new Ad(this.process), this.nextId = 0;
            }
            add(t1, e1) {
                const r = this.nextId++, n = function({ type: t1 , isSymbolTile: e1 , zoom: r  }) {
                    return r = r || 0, "message" === t1 ? 0 : "maybePrepare" !== t1 || e1 ? "parseTile" !== t1 || e1 ? "parseTile" === t1 && e1 ? 300 - r : "maybePrepare" === t1 && e1 ? 400 - r : 500 : 200 - r : 100 - r;
                }(e1);
                if (0 === n) {
                    N();
                    t1();
                    return {
                        cancel: ()=>{}
                    };
                }
                return this.tasks[r] = {
                    fn: t1,
                    metadata: e1,
                    priority: n,
                    id: r
                }, this.taskQueue.push(r), this.invoker.trigger(), {
                    cancel: ()=>{
                        delete this.tasks[r];
                    }
                };
            }
            process() {
                N();
                {
                    if (this.taskQueue = this.taskQueue.filter((t1)=>!!this.tasks[t1]), !this.taskQueue.length) return;
                    const t1 = this.pick();
                    if (null === t1) return;
                    const e1 = this.tasks[t1];
                    if (delete this.tasks[t1], this.taskQueue.length && this.invoker.trigger(), !e1) return;
                    e1.fn();
                }
            }
            pick() {
                let t1 = null, e1 = 1 / 0;
                for(let r = 0; r < this.taskQueue.length; r++){
                    const n = this.tasks[this.taskQueue[r]];
                    n.priority < e1 && (e1 = n.priority, t1 = r);
                }
                if (null === t1) return null;
                const r = this.taskQueue[t1];
                return this.taskQueue.splice(t1, 1), r;
            }
            remove() {
                this.invoker.remove();
            }
        }
        class kd {
            constructor(t1){
                this._stringToNumber = {}, this._numberToString = [];
                for(let e1 = 0; e1 < t1.length; e1++){
                    const r = t1[e1];
                    this._stringToNumber[r] = e1, this._numberToString[e1] = r;
                }
            }
            encode(t1) {
                return this._stringToNumber[t1];
            }
            decode(t1) {
                return this._numberToString[t1];
            }
        }
        const Id = [
            "tile",
            "layer",
            "source",
            "sourceLayer",
            "state"
        ];
        class Md {
            constructor(t1, e1, r, n, i){
                this.type = "Feature", this._vectorTileFeature = t1, this._z = e1, this._x = r, this._y = n, this.properties = t1.properties, this.id = i;
            }
            get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t1) {
                this._geometry = t1;
            }
            toJSON() {
                const t1 = {
                    type: "Feature",
                    geometry: this.geometry,
                    properties: this.properties
                };
                void 0 !== this.id && (t1.id = this.id);
                for (const e1 of Id)void 0 !== this[e1] && (t1[e1] = this[e1]);
                return t1;
            }
        }
        const Td = 32, zd = 33, Bd = new Uint16Array(8184);
        for(let t1 = 0; t1 < 2046; t1++){
            let e1 = t1 + 2, r = 0, n = 0, i = 0, s = 0, a = 0, o = 0;
            for(1 & e1 ? i = s = a = Td : r = n = o = Td; (e1 >>= 1) > 1;){
                const t1 = r + i >> 1, l = n + s >> 1;
                1 & e1 ? (i = r, s = n, r = a, n = o) : (r = i, n = s, i = a, s = o), a = t1, o = l;
            }
            const l = 4 * t1;
            Bd[l + 0] = r, Bd[l + 1] = n, Bd[l + 2] = i, Bd[l + 3] = s;
        }
        const Ed = new Uint16Array(2178), Cd = new Uint8Array(1089), Pd = new Uint16Array(1089);
        function Dd(t1) {
            return 0 === t1 ? -0.03125 : 32 === t1 ? .03125 : 0;
        }
        var Vd = na([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            },
            {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }
        ]);
        const Ld = {
            type: 2,
            extent: ko,
            loadGeometry: ()=>[
                    [
                        new d(0, 0),
                        new d(8193, 0),
                        new d(8193, 8193),
                        new d(0, 8193),
                        new d(0, 0)
                    ]
                ]
        };
        class Fd {
            constructor(t1, e1, r, n, i){
                this.tileID = t1, this.uid = E(), this.uses = 0, this.tileSize = e1, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, this.expiredRequestCount = 0, this.state = "loading", n && n.transform && (this.projection = n.transform.projection);
            }
            registerFadeDuration(t1) {
                const e1 = t1 + this.timeAdded;
                e1 < Nt.now() || this.fadeEndTime && e1 < this.fadeEndTime || (this.fadeEndTime = e1);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = Vf(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t1, e1, r) {
                if (this.unloadVectorData(), this.state = "loaded", t1) {
                    t1.featureIndex && (this.latestFeatureIndex = t1.featureIndex, t1.rawTileData ? (this.latestRawTileData = t1.rawTileData, this.latestFeatureIndex.rawTileData = t1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t1.collisionBoxArray, this.buckets = function(t1, e1) {
                        const r = {};
                        if (!e1) return r;
                        for (const n of t1){
                            const t1 = n.layerIds.map((t1)=>e1.getLayer(t1)).filter(Boolean);
                            if (0 !== t1.length) {
                                n.layers = t1, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map((e1)=>t1.filter((t1)=>t1.id === e1)[0]));
                                for (const e1 of t1)r[e1.id] = n;
                            }
                        }
                        return r;
                    }(t1.buckets, e1.style), this.hasSymbolBuckets = !1;
                    for(const t1 in this.buckets){
                        const e1 = this.buckets[t1];
                        if (e1 instanceof hd) {
                            if (this.hasSymbolBuckets = !0, !r) break;
                            e1.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets) for(const t1 in this.buckets){
                        const e1 = this.buckets[t1];
                        if (e1 instanceof hd && e1.hasRTLText) {
                            this.hasRTLText = !0, js.isLoading() || js.isLoaded() || "deferred" !== Fs() || Rs();
                            break;
                        }
                    }
                    this.queryPadding = 0;
                    for(const t1 in this.buckets){
                        const r = this.buckets[t1];
                        this.queryPadding = Math.max(this.queryPadding, e1.style.getLayer(t1).queryRadius(r));
                    }
                    t1.imageAtlas && (this.imageAtlas = t1.imageAtlas), t1.glyphAtlasImage && (this.glyphAtlasImage = t1.glyphAtlasImage), t1.lineAtlas && (this.lineAtlas = t1.lineAtlas);
                } else this.collisionBoxArray = new Ea;
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for(const t1 in this.buckets)this.buckets[t1].destroy();
                    this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                }
            }
            getBucket(t1) {
                return this.buckets[t1.id];
            }
            upload(t1) {
                for(const e1 in this.buckets){
                    const r = this.buckets[e1];
                    r.uploadPending() && r.upload(t1);
                }
                const e1 = t1.gl;
                this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new _d(t1, this.imageAtlas.image, e1.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new _d(t1, this.glyphAtlasImage, e1.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new _d(t1, this.lineAtlas.image, e1.ALPHA), this.lineAtlas.uploaded = !0);
            }
            prepare(t1) {
                this.imageAtlas && this.imageAtlas.patchUpdatedImages(t1, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t1, e1, r, n, i, s, a, o) {
                return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                    tileResult: n,
                    pixelPosMatrix: a,
                    transform: s,
                    params: i,
                    tileTransform: this.tileTransform
                }, t1, e1, r) : {};
            }
            querySourceFeatures(t1, e1) {
                const r = this.latestFeatureIndex;
                if (!r || !r.rawTileData) return;
                const n = r.loadVTLayers(), i = e1 ? e1.sourceLayer : "", s = n._geojsonTileLayer || n[i];
                if (!s) return;
                const a = ai(e1 && e1.filter), { z: o , x: l , y: u  } = this.tileID.canonical, c = {
                    z: o,
                    x: l,
                    y: u
                };
                for(let e1 = 0; e1 < s.length; e1++){
                    const n = s.feature(e1);
                    if (a.needGeometry) {
                        const t1 = wu(n, !0);
                        if (!a.filter(new Us(this.tileID.overscaledZ), t1, this.tileID.canonical)) continue;
                    } else if (!a.filter(new Us(this.tileID.overscaledZ), n)) continue;
                    const h = r.getId(n, i), p = new Md(n, o, l, u, h);
                    p.tile = c, t1.push(p);
                }
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(t1) {
                const e1 = this.expirationTime;
                if (t1.cacheControl) {
                    const e1 = G(t1.cacheControl);
                    e1["max-age"] && (this.expirationTime = Date.now() + 1e3 * e1["max-age"]);
                } else t1.expires && (this.expirationTime = new Date(t1.expires).getTime());
                if (this.expirationTime) {
                    const t1 = Date.now();
                    let r = !1;
                    if (this.expirationTime > t1) r = !1;
                    else if (e1) {
                        if (this.expirationTime < e1) r = !0;
                        else {
                            const n = this.expirationTime - e1;
                            n ? this.expirationTime = t1 + Math.max(n, 3e4) : r = !0;
                        }
                    } else r = !0;
                    r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t1, e1) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t1).length || !e1) return;
                const r = this.latestFeatureIndex.loadVTLayers(), n = e1.style.listImages();
                for(const i in this.buckets){
                    if (!e1.style.hasLayer(i)) continue;
                    const s = this.buckets[i], a = s.layers[0].sourceLayer || "_geojsonTileLayer", o = r[a], l = t1[a];
                    if (!o || !l || 0 === Object.keys(l).length) continue;
                    if (s.update(l, o, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), s instanceof jh || s instanceof Uc) {
                        const t1 = e1.style._getSourceCache(s.layers[0].source);
                        e1._terrain && e1._terrain.enabled && t1 && s.programConfigurations.needsUpload && e1._terrain._clearRenderCacheForTile(t1.id, this.tileID);
                    }
                    const u = e1 && e1.style && e1.style.getLayer(i);
                    u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(s)));
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Nt.now();
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t1) {
                this.symbolFadeHoldUntil = Nt.now() + t1;
            }
            setTexture(t1, e1) {
                const r = e1.context, n = r.gl;
                this.texture = this.texture || e1.getTileTexture(t1.width), this.texture ? this.texture.update(t1, {
                    useMipmap: !0
                }) : (this.texture = new _d(r, t1, n.RGBA, {
                    useMipmap: !0
                }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, r.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r.extTextureFilterAnisotropicMax));
            }
            setDependencies(t1, e1) {
                const r = {};
                for (const t1 of e1)r[t1] = !0;
                this.dependencies[t1] = r;
            }
            hasDependency(t1, e1) {
                for (const r of t1){
                    const t1 = this.dependencies[r];
                    if (t1) {
                        for (const r of e1)if (t1[r]) return !0;
                    }
                }
                return !1;
            }
            clearQueryDebugViz() {}
            _makeDebugTileBoundsBuffers(t1, e1) {
                if (!e1 || "mercator" === e1.name || this._tileDebugBuffer) return;
                const r = bu(Ld, this.tileID.canonical, this.tileTransform)[0], n = new sa, i = new Ta;
                for(let t1 = 0; t1 < r.length; t1++){
                    const { x: e1 , y: s  } = r[t1];
                    n.emplaceBack(e1, s), i.emplaceBack(t1);
                }
                i.emplaceBack(0), this._tileDebugIndexBuffer = t1.createIndexBuffer(i), this._tileDebugBuffer = t1.createVertexBuffer(n, xl.members), this._tileDebugSegments = So.simpleSegment(0, 0, n.length, i.length);
            }
            _makeTileBoundsBuffers(t1, e1) {
                if (this._tileBoundsBuffer || !e1 || "mercator" === e1.name) return;
                const r = bu(Ld, this.tileID.canonical, this.tileTransform)[0];
                let n, i;
                if (this.isRaster) {
                    const t1 = function(t1, e1) {
                        const r = Vf(t1, e1), n = Math.pow(2, t1.z);
                        for(let i = 0; i < zd; i++)for(let s = 0; s < zd; s++){
                            const a = ou((t1.x + (s + Dd(s)) / Td) / n), o = lu((t1.y + (i + Dd(i)) / Td) / n), l = e1.project(a, o), u = i * zd + s;
                            Ed[2 * u + 0] = Math.round((l.x * r.scale - r.x) * ko), Ed[2 * u + 1] = Math.round((l.y * r.scale - r.y) * ko);
                        }
                        Cd.fill(0), Pd.fill(0);
                        for(let t1 = 2045; t1 >= 0; t1--){
                            const e1 = 4 * t1, r = Bd[e1 + 0], n = Bd[e1 + 1], i = Bd[e1 + 2], s = Bd[e1 + 3], a = r + i >> 1, o = n + s >> 1, l = a + o - n, u = o + r - a, c = n * zd + r, h = s * zd + i, p = o * zd + a, f = Math.hypot((Ed[2 * c + 0] + Ed[2 * h + 0]) / 2 - Ed[2 * p + 0], (Ed[2 * c + 1] + Ed[2 * h + 1]) / 2 - Ed[2 * p + 1]) >= 16;
                            if (Cd[p] = Cd[p] || (f ? 1 : 0), t1 < 1022) {
                                const t1 = (n + u >> 1) * zd + (r + l >> 1), e1 = (s + u >> 1) * zd + (i + l >> 1);
                                Cd[p] = Cd[p] || Cd[t1] || Cd[e1];
                            }
                        }
                        const i = new oa, s = new wa;
                        let a = 0;
                        function o(t1, e1) {
                            const r = e1 * zd + t1;
                            return 0 === Pd[r] && (i.emplaceBack(Ed[2 * r + 0], Ed[2 * r + 1], t1 * ko / Td, e1 * ko / Td), Pd[r] = ++a), Pd[r] - 1;
                        }
                        function l(t1, e1, r, n, i, a) {
                            const u = t1 + r >> 1, c = e1 + n >> 1;
                            if (Math.abs(t1 - i) + Math.abs(e1 - a) > 1 && Cd[c * zd + u]) l(i, a, t1, e1, u, c), l(r, n, i, a, u, c);
                            else {
                                const l = o(t1, e1), u = o(r, n), c = o(i, a);
                                s.emplaceBack(l, u, c);
                            }
                        }
                        return l(0, 0, Td, Td, Td, 0), l(Td, Td, 0, 0, 0, Td), {
                            vertices: i,
                            indices: s
                        };
                    }(this.tileID.canonical, e1);
                    n = t1.vertices, i = t1.indices;
                } else {
                    n = new oa, i = new wa;
                    for (const { x: t1 , y: e1  } of r)n.emplaceBack(t1, e1, 0, 0);
                    const t1 = sc(n.int16, void 0, 4);
                    for(let e1 = 0; e1 < t1.length; e1 += 3)i.emplaceBack(t1[e1], t1[e1 + 1], t1[e1 + 2]);
                }
                this._tileBoundsBuffer = t1.createVertexBuffer(n, Vd.members), this._tileBoundsIndexBuffer = t1.createIndexBuffer(i), this._tileBoundsSegments = So.simpleSegment(0, 0, n.length, i.length);
            }
            _makeGlobeTileDebugBuffers(t1, e1) {
                const r = e1.projection;
                if (!r || "globe" !== r.name || e1.freezeTileCoverage) return;
                const n = this.tileID.canonical, i = Gl(Vl(n, e1)), s = Kl(e1.zoom);
                let a;
                s > 0 && (a = Co(new Float64Array(16), e1.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t1, n, e1, i, a, s), this._makeGlobeTileDebugTextBuffer(t1, n, e1, i, a, s);
            }
            _globePoint(t1, e1, r, n, i, s, a) {
                let o = Ol(t1, e1, r);
                if (s) {
                    const i = 1 << r.z, l = iu(n.center.lng), u = su(n.center.lat), c = (r.x + .5) / i - l;
                    let h = 0;
                    c > .5 ? h = -1 : c < -0.5 && (h = 1);
                    let p = (t1 / ko + r.x) / i + h, f = (e1 / ko + r.y) / i;
                    p = (p - l) * n._pixelsPerMercatorPixel + l, f = (f - u) * n._pixelsPerMercatorPixel + u;
                    const d = [
                        p * n.worldSize,
                        f * n.worldSize,
                        0
                    ];
                    el(d, d, s), o = Dl(o, d, a);
                }
                return el(o, o, i);
            }
            _makeGlobeTileDebugBorderBuffer(t1, e1, r, n, i, s) {
                const a = new sa, o = new Ta, l = new aa, u = (t1, u, c, h, p)=>{
                    const f = (c - t1) / (p - 1), d = (h - u) / (p - 1), y = a.length;
                    for(let c = 0; c < p; c++){
                        const h = t1 + c * f, p = u + c * d;
                        a.emplaceBack(h, p);
                        const m = this._globePoint(h, p, e1, r, n, i, s);
                        l.emplaceBack(m[0], m[1], m[2]), o.emplaceBack(y + c);
                    }
                }, c = ko;
                u(0, 0, c, 0, 16), u(c, 0, c, c, 16), u(c, c, 0, c, 16), u(0, c, 0, 0, 16), this._tileDebugIndexBuffer = t1.createIndexBuffer(o), this._tileDebugBuffer = t1.createVertexBuffer(a, xl.members), this._globeTileDebugBorderBuffer = t1.createVertexBuffer(l, gl.members), this._tileDebugSegments = So.simpleSegment(0, 0, a.length, o.length);
            }
            _makeGlobeTileDebugTextBuffer(t1, e1, r, n, i, s) {
                const a = new sa, o = new wa, l = new aa, u = 25;
                o.reserve(32), a.reserve(u), l.reserve(u);
                const c = (t1, e1)=>u * t1 + e1;
                for(let t1 = 0; t1 < u; t1++){
                    const o = 2048 * t1;
                    for(let t1 = 0; t1 < u; t1++){
                        const u = 2048 * t1;
                        a.emplaceBack(u, o);
                        const c = this._globePoint(u, o, e1, r, n, i, s);
                        l.emplaceBack(c[0], c[1], c[2]);
                    }
                }
                for(let t1 = 0; t1 < 4; t1++)for(let e1 = 0; e1 < 4; e1++){
                    const r = c(t1, e1), n = c(t1, e1 + 1), i = c(t1 + 1, e1), s = c(t1 + 1, e1 + 1);
                    o.emplaceBack(r, n, i), o.emplaceBack(i, n, s);
                }
                this._tileDebugTextIndexBuffer = t1.createIndexBuffer(o), this._tileDebugTextBuffer = t1.createVertexBuffer(a, xl.members), this._globeTileDebugTextBuffer = t1.createVertexBuffer(l, gl.members), this._tileDebugTextSegments = So.simpleSegment(0, 0, u, 32);
            }
        }
        class Rd {
            constructor(){
                this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t1, e1, r) {
                const n = String(e1);
                if (this.stateChanges[t1] = this.stateChanges[t1] || {}, this.stateChanges[t1][n] = this.stateChanges[t1][n] || {}, z(this.stateChanges[t1][n], r), null === this.deletedStates[t1]) {
                    this.deletedStates[t1] = {};
                    for(const e1 in this.state[t1])e1 !== n && (this.deletedStates[t1][e1] = null);
                } else if (this.deletedStates[t1] && null === this.deletedStates[t1][n]) {
                    this.deletedStates[t1][n] = {};
                    for(const e1 in this.state[t1][n])r[e1] || (this.deletedStates[t1][n][e1] = null);
                } else for(const e1 in r)this.deletedStates[t1] && this.deletedStates[t1][n] && null === this.deletedStates[t1][n][e1] && delete this.deletedStates[t1][n][e1];
            }
            removeFeatureState(t1, e1, r) {
                if (null === this.deletedStates[t1]) return;
                const n = String(e1);
                if (this.deletedStates[t1] = this.deletedStates[t1] || {}, r && void 0 !== e1) null !== this.deletedStates[t1][n] && (this.deletedStates[t1][n] = this.deletedStates[t1][n] || {}, this.deletedStates[t1][n][r] = null);
                else if (void 0 !== e1) {
                    if (this.stateChanges[t1] && this.stateChanges[t1][n]) for(r in this.deletedStates[t1][n] = {}, this.stateChanges[t1][n])this.deletedStates[t1][n][r] = null;
                    else this.deletedStates[t1][n] = null;
                } else this.deletedStates[t1] = null;
            }
            getState(t1, e1) {
                const r = String(e1), n = z({}, (this.state[t1] || {})[r], (this.stateChanges[t1] || {})[r]);
                if (null === this.deletedStates[t1]) return {};
                if (this.deletedStates[t1]) {
                    const r = this.deletedStates[t1][e1];
                    if (null === r) return {};
                    for(const t1 in r)delete n[t1];
                }
                return n;
            }
            initializeTileState(t1, e1) {
                t1.setFeatureState(this.state, e1);
            }
            coalesceChanges(t1, e1) {
                const r = {};
                for(const t1 in this.stateChanges){
                    this.state[t1] = this.state[t1] || {};
                    const e1 = {};
                    for(const r in this.stateChanges[t1])this.state[t1][r] || (this.state[t1][r] = {}), z(this.state[t1][r], this.stateChanges[t1][r]), e1[r] = this.state[t1][r];
                    r[t1] = e1;
                }
                for(const t1 in this.deletedStates){
                    this.state[t1] = this.state[t1] || {};
                    const e1 = {};
                    if (null === this.deletedStates[t1]) for(const r in this.state[t1])e1[r] = {}, this.state[t1][r] = {};
                    else for(const r in this.deletedStates[t1]){
                        if (null === this.deletedStates[t1][r]) this.state[t1][r] = {};
                        else if (this.state[t1][r]) for (const e1 of Object.keys(this.deletedStates[t1][r]))delete this.state[t1][r][e1];
                        e1[r] = this.state[t1][r];
                    }
                    r[t1] = r[t1] || {}, z(r[t1], e1);
                }
                if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for(const n in t1)t1[n].setFeatureState(r, e1);
            }
        }
        class jd {
            constructor(t1){
                this.size = t1, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t1, e1) {
                const r = this.toIdx(t1, e1);
                return {
                    min: this.minimums[r],
                    max: this.maximums[r]
                };
            }
            isLeaf(t1, e1) {
                return this.leaves[this.toIdx(t1, e1)];
            }
            toIdx(t1, e1) {
                return e1 * this.size + t1;
            }
        }
        function Ud(t1, e1, r, n) {
            let i = 0, s = Number.MAX_VALUE;
            for(let a = 0; a < 3; a++)if (Math.abs(n[a]) < 1e-15) {
                if (r[a] < t1[a] || r[a] > e1[a]) return null;
            } else {
                const o = 1 / n[a];
                let l = (t1[a] - r[a]) * o, u = (e1[a] - r[a]) * o;
                if (l > u) {
                    const t1 = l;
                    l = u, u = t1;
                }
                if (l > i && (i = l), u < s && (s = u), i > s) return null;
            }
            return i;
        }
        function $d(t1, e1, r, n, i, s, a, o, l, u, c) {
            const h = n - t1, p = i - e1, f = s - r, d = a - t1, y = o - e1, m = l - r, g = c[1] * m - c[2] * y, x = c[2] * d - c[0] * m, v = c[0] * y - c[1] * d, b = h * g + p * x + f * v;
            if (Math.abs(b) < 1e-15) return null;
            const w = 1 / b, _ = u[0] - t1, A = u[1] - e1, S = u[2] - r, k = (_ * g + A * x + S * v) * w;
            if (k < 0 || k > 1) return null;
            const I = A * f - S * p, M = S * h - _ * f, T = _ * p - A * h, z = (c[0] * I + c[1] * M + c[2] * T) * w;
            return z < 0 || k + z > 1 ? null : (d * I + y * M + m * T) * w;
        }
        function Od(t1, e1, r) {
            return (t1 - e1) / (r - e1);
        }
        function qd(t1, e1, r, n, i, s, a, o, l) {
            const u = 1 << r, c = s - n, h = a - i, p = (t1 + 1) / u * c + n, f = (e1 + 0) / u * h + i, d = (e1 + 1) / u * h + i;
            o[0] = (t1 + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;
        }
        class Nd {
            constructor(t1){
                if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t1, this._siblingOffset = [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ], !this.dem) return;
                const e1 = function(t1) {
                    const e1 = Math.ceil(Math.log2(t1.dim / 8)), r = [];
                    let n = Math.ceil(Math.pow(2, e1));
                    const i = 1 / n, s = (t1, e1, r, n, i)=>{
                        const s = n ? 1 : 0, a = (t1 + 1) * r - s, o = e1 * r, l = (e1 + 1) * r - s;
                        i[0] = t1 * r, i[1] = o, i[2] = a, i[3] = l;
                    };
                    let a = new jd(n);
                    const o = [];
                    for(let e1 = 0; e1 < n * n; e1++){
                        s(e1 % n, Math.floor(e1 / n), i, !1, o);
                        const r = Xd(o[0], o[1], t1), l = Xd(o[2], o[1], t1), u = Xd(o[2], o[3], t1), c = Xd(o[0], o[3], t1);
                        a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);
                    }
                    for(r.push(a), n /= 2; n >= 1; n /= 2){
                        const t1 = r[r.length - 1];
                        a = new jd(n);
                        for(let e1 = 0; e1 < n * n; e1++){
                            s(e1 % n, Math.floor(e1 / n), 2, !0, o);
                            const r = t1.getElevation(o[0], o[1]), i = t1.getElevation(o[2], o[1]), l = t1.getElevation(o[2], o[3]), u = t1.getElevation(o[0], o[3]), c = t1.isLeaf(o[0], o[1]), h = t1.isLeaf(o[2], o[1]), p = t1.isLeaf(o[2], o[3]), f = t1.isLeaf(o[0], o[3]), d = Math.min(r.min, i.min, l.min, u.min), y = Math.max(r.max, i.max, l.max, u.max), m = c && h && p && f;
                            a.maximums.push(y), a.minimums.push(d), a.leaves.push(y - d <= 5 && m ? 1 : 0);
                        }
                        r.push(a);
                    }
                    return r;
                }(this.dem), r = e1.length - 1, n = e1[r];
                this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e1, 0, 0, r, 0);
            }
            raycastRoot(t1, e1, r, n, i, s, a = 1) {
                return Ud([
                    t1,
                    e1,
                    -100
                ], [
                    r,
                    n,
                    this.maximums[0] * a
                ], i, s);
            }
            raycast(t1, e1, r, n, i, s, a = 1) {
                if (!this.nodeCount) return null;
                const o = this.raycastRoot(t1, e1, r, n, i, s, a);
                if (null == o) return null;
                const l = [], u = [], c = [], h = [], p = [
                    {
                        idx: 0,
                        t: o,
                        nodex: 0,
                        nodey: 0,
                        depth: 0
                    }
                ];
                for(; p.length > 0;){
                    const { idx: o , t: f , nodex: d , nodey: y , depth: m  } = p.pop();
                    if (this.leaves[o]) {
                        qd(d, y, m, t1, e1, r, n, c, h);
                        const o = 1 << m, l = (d + 0) / o, u = (d + 1) / o, p = (y + 0) / o, g = (y + 1) / o, x = Xd(l, p, this.dem) * a, v = Xd(u, p, this.dem) * a, b = Xd(u, g, this.dem) * a, w = Xd(l, g, this.dem) * a, _ = $d(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s), A = $d(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s), S = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);
                        if (S !== Number.MAX_VALUE) return S;
                        {
                            const t1 = Wo([], i, s, f);
                            if (Gd(x, v, w, b, Od(t1[0], c[0], h[0]), Od(t1[1], c[1], h[1])) >= t1[2]) return f;
                        }
                        continue;
                    }
                    let g = 0;
                    for(let p = 0; p < this._siblingOffset.length; p++){
                        qd((d << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t1, e1, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;
                        const f = Ud(c, h, i, s);
                        if (null != f) {
                            const t1 = f;
                            l[p] = t1;
                            let e1 = !1;
                            for(let r = 0; r < g && !e1; r++)t1 >= l[u[r]] && (u.splice(r, 0, p), e1 = !0);
                            e1 || (u[g] = p), g++;
                        }
                    }
                    for(let t1 = 0; t1 < g; t1++){
                        const e1 = u[t1];
                        p.push({
                            idx: this.childOffsets[o] + e1,
                            t: l[e1],
                            nodex: (d << 1) + this._siblingOffset[e1][0],
                            nodey: (y << 1) + this._siblingOffset[e1][1],
                            depth: m + 1
                        });
                    }
                }
                return null;
            }
            _addNode(t1, e1, r) {
                return this.minimums.push(t1), this.maximums.push(e1), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t1, e1, r, n, i) {
                if (1 === t1[n].isLeaf(e1, r)) return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const s = n - 1, a = t1[s];
                let o = 0, l = 0;
                for(let t1 = 0; t1 < this._siblingOffset.length; t1++){
                    const n = 2 * e1 + this._siblingOffset[t1][0], i = 2 * r + this._siblingOffset[t1][1], s = a.getElevation(n, i), u = a.isLeaf(n, i), c = this._addNode(s.min, s.max, u);
                    u && (o |= 1 << t1), l || (l = c);
                }
                for(let n = 0; n < this._siblingOffset.length; n++)o & 1 << n || this._construct(t1, 2 * e1 + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
            }
        }
        function Gd(t1, e1, r, n, i, s) {
            return Mr(Mr(t1, r, s), Mr(e1, n, s), i);
        }
        function Xd(t1, e1, r) {
            const n = r.dim, i = S(t1 * n - .5, 0, n - 1), s = S(e1 * n - .5, 0, n - 1), a = Math.floor(i), o = Math.floor(s), l = Math.min(a + 1, n - 1), u = Math.min(o + 1, n - 1);
            return Gd(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);
        }
        const Zd = {
            mapbox: [
                6553.6,
                25.6,
                .1,
                1e4
            ],
            terrarium: [
                256,
                1,
                1 / 256,
                32768
            ]
        };
        class Kd {
            get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t1, e1, r, n = !1, i = !1){
                if (this.uid = t1, e1.height !== e1.width) throw new RangeError("DEM tiles must be square");
                if (r && "mapbox" !== r && "terrarium" !== r) return $(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e1.height;
                const s = this.dim = e1.height - 2, a = new Uint32Array(e1.data.buffer);
                if (this.pixels = new Uint8Array(e1.data.buffer), this.encoding = r || "mapbox", this.borderReady = n, !n) {
                    for(let t1 = 0; t1 < s; t1++)a[this._idx(-1, t1)] = a[this._idx(0, t1)], a[this._idx(s, t1)] = a[this._idx(s - 1, t1)], a[this._idx(t1, -1)] = a[this._idx(t1, 0)], a[this._idx(t1, s)] = a[this._idx(t1, s - 1)];
                    a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(s, -1)] = a[this._idx(s - 1, 0)], a[this._idx(-1, s)] = a[this._idx(0, s - 1)], a[this._idx(s, s)] = a[this._idx(s - 1, s - 1)], i && this._buildQuadTree();
                }
            }
            _buildQuadTree() {
                this._tree = new Nd(this);
            }
            get(t1, e1, r = !1) {
                r && (t1 = S(t1, -1, this.dim), e1 = S(e1, -1, this.dim));
                const n = 4 * this._idx(t1, e1);
                return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2]);
            }
            static getUnpackVector(t1) {
                return Zd[t1];
            }
            get unpackVector() {
                return Zd[this.encoding];
            }
            _idx(t1, e1) {
                if (t1 < -1 || t1 >= this.dim + 1 || e1 < -1 || e1 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                return (e1 + 1) * this.stride + (t1 + 1);
            }
            _unpackMapbox(t1, e1, r) {
                return (256 * t1 * 256 + 256 * e1 + r) / 10 - 1e4;
            }
            _unpackTerrarium(t1, e1, r) {
                return 256 * t1 + e1 + r / 256 - 32768;
            }
            static pack(t1, e1) {
                const r = [
                    0,
                    0,
                    0,
                    0
                ], n = Kd.getUnpackVector(e1);
                let i = Math.floor((t1 + n[3]) / n[2]);
                return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
            }
            getPixels() {
                return new Qu({
                    width: this.stride,
                    height: this.stride
                }, this.pixels);
            }
            backfillBorder(t1, e1, r) {
                if (this.dim !== t1.dim) throw new Error("dem dimension mismatch");
                let n = e1 * this.dim, i = e1 * this.dim + this.dim, s = r * this.dim, a = r * this.dim + this.dim;
                switch(e1){
                    case -1:
                        n = i - 1;
                        break;
                    case 1:
                        i = n + 1;
                }
                switch(r){
                    case -1:
                        s = a - 1;
                        break;
                    case 1:
                        a = s + 1;
                }
                const o = -e1 * this.dim, l = -r * this.dim;
                for(let e1 = s; e1 < a; e1++)for(let r = n; r < i; r++){
                    const n = 4 * this._idx(r, e1), i = 4 * this._idx(r + o, e1 + l);
                    this.pixels[n + 0] = t1.pixels[i + 0], this.pixels[n + 1] = t1.pixels[i + 1], this.pixels[n + 2] = t1.pixels[i + 2], this.pixels[n + 3] = t1.pixels[i + 3];
                }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }
        Oi(Kd, "DEMData"), Oi(Nd, "DemMinMaxQuadTree", {
            omit: [
                "dem"
            ]
        });
        class Yd {
            constructor(t1, e1){
                this.max = t1, this.onRemove = e1, this.reset();
            }
            reset() {
                for(const t1 in this.data)for (const e1 of this.data[t1])e1.timeout && clearTimeout(e1.timeout), this.onRemove(e1.value);
                return this.data = {}, this.order = [], this;
            }
            add(t1, e1, r) {
                const n = t1.wrapped().key;
                void 0 === this.data[n] && (this.data[n] = []);
                const i = {
                    value: e1,
                    timeout: void 0
                };
                if (void 0 !== r && (i.timeout = setTimeout(()=>{
                    this.remove(t1, i);
                }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) {
                    const t1 = this._getAndRemoveByKey(this.order[0]);
                    t1 && this.onRemove(t1);
                }
                return this;
            }
            has(t1) {
                return t1.wrapped().key in this.data;
            }
            getAndRemove(t1) {
                return this.has(t1) ? this._getAndRemoveByKey(t1.wrapped().key) : null;
            }
            _getAndRemoveByKey(t1) {
                const e1 = this.data[t1].shift();
                return e1.timeout && clearTimeout(e1.timeout), 0 === this.data[t1].length && delete this.data[t1], this.order.splice(this.order.indexOf(t1), 1), e1.value;
            }
            getByKey(t1) {
                const e1 = this.data[t1];
                return e1 ? e1[0].value : null;
            }
            get(t1) {
                return this.has(t1) ? this.data[t1.wrapped().key][0].value : null;
            }
            remove(t1, e1) {
                if (!this.has(t1)) return this;
                const r = t1.wrapped().key, n = void 0 === e1 ? 0 : this.data[r].indexOf(e1), i = this.data[r][n];
                return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this;
            }
            setMaxSize(t1) {
                for(this.max = t1; this.order.length > this.max;){
                    const t1 = this._getAndRemoveByKey(this.order[0]);
                    t1 && this.onRemove(t1);
                }
                return this;
            }
            filter(t1) {
                const e1 = [];
                for(const r in this.data)for (const n of this.data[r])t1(n.value) || e1.push(n);
                for (const t1 of e1)this.remove(t1.value.tileID, t1);
            }
        }
        class Hd {
            constructor(t1, e1, r){
                this.func = t1, this.mask = e1, this.range = r;
            }
        }
        Hd.ReadOnly = !1, Hd.ReadWrite = !0, Hd.disabled = new Hd(519, Hd.ReadOnly, [
            0,
            1
        ]);
        const Wd = 7680;
        class Jd {
            constructor(t1, e1, r, n, i, s){
                this.test = t1, this.ref = e1, this.mask = r, this.fail = n, this.depthFail = i, this.pass = s;
            }
        }
        Jd.disabled = new Jd({
            func: 519,
            mask: 0
        }, 0, 0, Wd, Wd, Wd);
        class Qd {
            constructor(t1, e1, r){
                this.blendFunction = t1, this.blendColor = e1, this.mask = r;
            }
        }
        Qd.Replace = [
            1,
            0
        ], Qd.disabled = new Qd(Qd.Replace, Me.transparent, [
            !1,
            !1,
            !1,
            !1
        ]), Qd.unblended = new Qd(Qd.Replace, Me.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Qd.alphaBlended = new Qd([
            1,
            771
        ], Me.transparent, [
            !0,
            !0,
            !0,
            !0
        ]);
        const ty = 1029, ey = 2305;
        class ry {
            constructor(t1, e1, r){
                this.enable = t1, this.mode = e1, this.frontFace = r;
            }
        }
        ry.disabled = new ry(!1, ty, ey), ry.backCCW = new ry(!0, ty, ey), ry.backCW = new ry(!0, ty, 2304), ry.frontCW = new ry(!0, 1028, 2304), ry.frontCCW = new ry(!0, 1028, ey);
        class ny extends Yt {
            constructor(t1, e1, r){
                super(), this.id = t1, this._onlySymbols = r, e1.on("data", (t1)=>{
                    "source" === t1.dataType && "metadata" === t1.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === t1.dataType && "content" === t1.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
                }), e1.on("error", ()=>{
                    this._sourceErrored = !0;
                }), this._source = e1, this._tiles = {}, this._cache = new Yd(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e1.minTileCacheSize, this._maxTileCacheSize = e1.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Rd, this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(t1) {
                this.map = t1, this._minTileCacheSize = void 0 === this._minTileCacheSize && t1 ? t1._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t1 ? t1._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for(const t1 in this._tiles){
                    const e1 = this._tiles[t1];
                    if ("loaded" !== e1.state && "errored" !== e1.state) return !1;
                }
                return !0;
            }
            getSource() {
                return this._source;
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused) return;
                const t1 = this._shouldReloadOnResume;
                this._paused = !1, this._shouldReloadOnResume = !1, t1 && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(t1, e1) {
                return t1.isSymbolTile = this._onlySymbols, this._source.loadTile(t1, e1);
            }
            _unloadTile(t1) {
                if (this._source.unloadTile) return this._source.unloadTile(t1, ()=>{});
            }
            _abortTile(t1) {
                if (this._source.abortTile) return this._source.abortTile(t1, ()=>{});
            }
            serialize() {
                return this._source.serialize();
            }
            prepare(t1) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for(const e1 in this._tiles){
                    const r = this._tiles[e1];
                    r.upload(t1), r.prepare(this.map.style.imageManager);
                }
            }
            getIds() {
                return T(this._tiles).map((t1)=>t1.tileID).sort(iy).map((t1)=>t1.key);
            }
            getRenderableIds(t1) {
                const e1 = [];
                for(const r in this._tiles)this._isIdRenderable(+r, t1) && e1.push(this._tiles[r]);
                return t1 ? e1.sort((t1, e1)=>{
                    const r = t1.tileID, n = e1.tileID, i = new d(r.canonical.x, r.canonical.y)._rotate(this.transform.angle), s = new d(n.canonical.x, n.canonical.y)._rotate(this.transform.angle);
                    return r.overscaledZ - n.overscaledZ || s.y - i.y || s.x - i.x;
                }).map((t1)=>t1.tileID.key) : e1.map((t1)=>t1.tileID).sort(iy).map((t1)=>t1.key);
            }
            hasRenderableParent(t1) {
                const e1 = this.findLoadedParent(t1, 0);
                return !!e1 && this._isIdRenderable(e1.tileID.key);
            }
            _isIdRenderable(t1, e1) {
                return this._tiles[t1] && this._tiles[t1].hasData() && !this._coveredTiles[t1] && (e1 || !this._tiles[t1].holdingForFade());
            }
            reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for(const t1 in this._tiles)"errored" !== this._tiles[t1].state && this._reloadTile(+t1, "reloading");
                }
            }
            _reloadTile(t1, e1) {
                const r = this._tiles[t1];
                r && ("loading" !== r.state && (r.state = e1), this._loadTile(r, this._tileLoaded.bind(this, r, t1, e1)));
            }
            _tileLoaded(t1, e1, r, n) {
                if (n) {
                    if (t1.state = "errored", 404 !== n.status) this._source.fire(new Kt(n, {
                        tile: t1
                    }));
                    else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const t1 = this.map.painter.terrain;
                        this.update(this.transform, t1.getScaledDemTileSize(), !0), t1.resetTileLookupCache(this.id);
                    } else this.update(this.transform);
                } else t1.timeAdded = Nt.now(), "expired" === r && (t1.refreshedUponExpiration = !0), this._setTileReloadTimer(e1, t1), "raster-dem" === this._source.type && t1.dem && this._backfillDEM(t1), this._state.initializeTileState(t1, this.map ? this.map.painter : null), this._source.fire(new Zt("data", {
                    dataType: "source",
                    tile: t1,
                    coord: t1.tileID,
                    sourceCacheId: this.id
                }));
            }
            _backfillDEM(t1) {
                const e1 = this.getRenderableIds();
                for(let n = 0; n < e1.length; n++){
                    const i = e1[n];
                    if (t1.neighboringTiles && t1.neighboringTiles[i]) {
                        const e1 = this.getTileByID(i);
                        r(t1, e1), r(e1, t1);
                    }
                }
                function r(t1, e1) {
                    if (!t1.dem || t1.dem.borderReady) return;
                    t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0;
                    let r = e1.tileID.canonical.x - t1.tileID.canonical.x;
                    const n = e1.tileID.canonical.y - t1.tileID.canonical.y, i = Math.pow(2, t1.tileID.canonical.z), s = e1.tileID.key;
                    0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), e1.dem && t1.dem && (t1.dem.backfillBorder(e1.dem, r, n), t1.neighboringTiles && t1.neighboringTiles[s] && (t1.neighboringTiles[s].backfilled = !0)));
                }
            }
            getTile(t1) {
                return this.getTileByID(t1.key);
            }
            getTileByID(t1) {
                return this._tiles[t1];
            }
            _retainLoadedChildren(t1, e1, r, n) {
                for(const i in this._tiles){
                    let s = this._tiles[i];
                    if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e1 || s.tileID.overscaledZ > r) continue;
                    let a = s.tileID;
                    for(; s && s.tileID.overscaledZ > e1 + 1;){
                        const t1 = s.tileID.scaledTo(s.tileID.overscaledZ - 1);
                        s = this._tiles[t1.key], s && s.hasData() && (a = t1);
                    }
                    let o = a;
                    for(; o.overscaledZ > e1;)if (o = o.scaledTo(o.overscaledZ - 1), t1[o.key]) {
                        n[a.key] = a;
                        break;
                    }
                }
            }
            findLoadedParent(t1, e1) {
                if (t1.key in this._loadedParentTiles) {
                    const r = this._loadedParentTiles[t1.key];
                    return r && r.tileID.overscaledZ >= e1 ? r : null;
                }
                for(let r = t1.overscaledZ - 1; r >= e1; r--){
                    const e1 = t1.scaledTo(r), n = this._getLoadedTile(e1);
                    if (n) return n;
                }
            }
            _getLoadedTile(t1) {
                const e1 = this._tiles[t1.key];
                return e1 && e1.hasData() ? e1 : this._cache.getByKey(this._source.reparseOverscaled ? t1.wrapped().key : t1.canonical.key);
            }
            updateCacheSize(t1, e1) {
                e1 = e1 || this._source.tileSize;
                const r = Math.ceil(t1.width / e1) + 1, n = Math.ceil(t1.height / e1) + 1, i = Math.floor(r * n * 5), s = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i, a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;
                this._cache.setMaxSize(a);
            }
            handleWrapJump(t1) {
                const e1 = Math.round((t1 - (void 0 === this._prevLng ? t1 : this._prevLng)) / 360);
                if (this._prevLng = t1, e1) {
                    const t1 = {};
                    for(const r in this._tiles){
                        const n = this._tiles[r];
                        n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e1), t1[n.tileID.key] = n;
                    }
                    this._tiles = t1;
                    for(const t1 in this._timers)clearTimeout(this._timers[t1]), delete this._timers[t1];
                    for(const t1 in this._tiles)this._setTileReloadTimer(+t1, this._tiles[t1]);
                }
            }
            update(t1, e1, r) {
                if (this.transform = t1, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
                if (this.usedForTerrain && !r) return;
                let n;
                this.updateCacheSize(t1, e1), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n = t1.getVisibleUnwrappedCoordinates(this._source.tileID).map((t1)=>new Mh(t1.canonical.z, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y)) : (n = t1.coveringTiles({
                    tileSize: e1 || this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom && !r,
                    reparseOverscaled: this._source.reparseOverscaled,
                    isTerrainDEM: this.usedForTerrain
                }), this._source.hasTile && (n = n.filter((t1)=>this._source.hasTile(t1)))) : n = [];
                const i = this._updateRetainedTiles(n);
                if (sy(this._source.type) && 0 !== n.length) {
                    const t1 = {}, e1 = {}, r = Object.keys(i);
                    for (const n of r){
                        const r = i[n], s = this._tiles[n];
                        if (!s || s.fadeEndTime && s.fadeEndTime <= Nt.now()) continue;
                        const a = this.findLoadedParent(r, Math.max(r.overscaledZ - ny.maxOverzooming, this._source.minzoom));
                        a && (this._addTile(a.tileID), t1[a.tileID.key] = a.tileID), e1[n] = r;
                    }
                    const s = n[n.length - 1].overscaledZ;
                    for(const t1 in this._tiles){
                        const r = this._tiles[t1];
                        if (i[t1] || !r.hasData()) continue;
                        let n = r.tileID;
                        for(; n.overscaledZ > s;){
                            n = n.scaledTo(n.overscaledZ - 1);
                            const s = this._tiles[n.key];
                            if (s && s.hasData() && e1[n.key]) {
                                i[t1] = r.tileID;
                                break;
                            }
                        }
                    }
                    for(const e1 in t1)i[e1] || (this._coveredTiles[e1] = !0, i[e1] = t1[e1]);
                }
                for(const t1 in i)this._tiles[t1].clearFadeHold();
                const s = function(t1, e1) {
                    const r = [];
                    for(const n in t1)n in e1 || r.push(n);
                    return r;
                }(this._tiles, i);
                for (const t1 of s){
                    const e1 = this._tiles[t1];
                    e1.hasSymbolBuckets && !e1.holdingForFade() ? e1.setHoldDuration(this.map._fadeDuration) : e1.hasSymbolBuckets && !e1.symbolFadeFinished() || this._removeTile(+t1);
                }
                this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
                for(const t1 in this._tiles)this._tiles[t1].holdingForFade() && this._removeTile(+t1);
            }
            _updateRetainedTiles(t1) {
                const e1 = {};
                if (0 === t1.length) return e1;
                const r = {}, n = t1.reduce((t1, e1)=>Math.min(t1, e1.overscaledZ), 1 / 0), i = t1[0].overscaledZ, s = Math.max(i - ny.maxOverzooming, this._source.minzoom), a = Math.max(i + ny.maxUnderzooming, this._source.minzoom), o = {};
                for (const r of t1){
                    const t1 = this._addTile(r);
                    e1[r.key] = r, t1.hasData() || n < this._source.maxzoom && (o[r.key] = r);
                }
                this._retainLoadedChildren(o, n, a, e1);
                for (const n of t1){
                    let t1 = this._tiles[n.key];
                    if (t1.hasData()) continue;
                    if (n.canonical.z >= this._source.maxzoom) {
                        const t1 = n.children(this._source.maxzoom)[0], r = this.getTile(t1);
                        if (r && r.hasData()) {
                            e1[t1.key] = t1;
                            continue;
                        }
                    } else {
                        const t1 = n.children(this._source.maxzoom);
                        if (e1[t1[0].key] && e1[t1[1].key] && e1[t1[2].key] && e1[t1[3].key]) continue;
                    }
                    let i = t1.wasRequested();
                    for(let a = n.overscaledZ - 1; a >= s; --a){
                        const s = n.scaledTo(a);
                        if (r[s.key]) break;
                        if (r[s.key] = !0, t1 = this.getTile(s), !t1 && i && (t1 = this._addTile(s)), t1 && (e1[s.key] = s, i = t1.wasRequested(), t1.hasData())) break;
                    }
                }
                return e1;
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for(const t1 in this._tiles){
                    const e1 = [];
                    let r, n = this._tiles[t1].tileID;
                    for(; n.overscaledZ > 0;){
                        if (n.key in this._loadedParentTiles) {
                            r = this._loadedParentTiles[n.key];
                            break;
                        }
                        e1.push(n.key);
                        const t1 = n.scaledTo(n.overscaledZ - 1);
                        if (r = this._getLoadedTile(t1), r) break;
                        n = t1;
                    }
                    for (const t1 of e1)this._loadedParentTiles[t1] = r;
                }
            }
            _addTile(t1) {
                let e1 = this._tiles[t1.key];
                if (e1) return e1;
                e1 = this._cache.getAndRemove(t1), e1 && (this._setTileReloadTimer(t1.key, e1), e1.tileID = t1, this._state.initializeTileState(e1, this.map ? this.map.painter : null), this._cacheTimers[t1.key] && (clearTimeout(this._cacheTimers[t1.key]), delete this._cacheTimers[t1.key], this._setTileReloadTimer(t1.key, e1)));
                const r = Boolean(e1);
                if (!r) {
                    const r = this.map ? this.map.painter : null;
                    e1 = new Fd(t1, this._source.tileSize * t1.overscaleFactor(), this.transform.tileZoom, r, this._isRaster), this._loadTile(e1, this._tileLoaded.bind(this, e1, t1.key, e1.state));
                }
                return e1 ? (e1.uses++, this._tiles[t1.key] = e1, r || this._source.fire(new Zt("dataloading", {
                    tile: e1,
                    coord: e1.tileID,
                    dataType: "source"
                })), e1) : null;
            }
            _setTileReloadTimer(t1, e1) {
                t1 in this._timers && (clearTimeout(this._timers[t1]), delete this._timers[t1]);
                const r = e1.getExpiryTimeout();
                r && (this._timers[t1] = setTimeout(()=>{
                    this._reloadTile(t1, "expired"), delete this._timers[t1];
                }, r));
            }
            _removeTile(t1) {
                const e1 = this._tiles[t1];
                e1 && (e1.uses--, delete this._tiles[t1], this._timers[t1] && (clearTimeout(this._timers[t1]), delete this._timers[t1]), e1.uses > 0 || (e1.hasData() && "reloading" !== e1.state ? this._cache.add(e1.tileID, e1, e1.getExpiryTimeout()) : (e1.aborted = !0, this._abortTile(e1), this._unloadTile(e1))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;
                for(const t1 in this._tiles)this._removeTile(+t1);
                this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t1, e1, r) {
                const n = [], i = this.transform;
                if (!i) return n;
                const s = "globe" === i.projection.name, a = iu(i.center.lng);
                for(const o in this._tiles){
                    const l = this._tiles[o];
                    if (r && l.clearQueryDebugViz(), l.holdingForFade()) continue;
                    let u;
                    if (s) {
                        const t1 = l.tileID.canonical;
                        if (0 === t1.z) {
                            const e1 = [
                                Math.abs(S(a, ...ay(t1, -1)) - a),
                                Math.abs(S(a, ...ay(t1, 1)) - a)
                            ];
                            u = [
                                0,
                                2 * e1.indexOf(Math.min(...e1)) - 1
                            ];
                        } else {
                            const e1 = [
                                Math.abs(S(a, ...ay(t1, -1)) - a),
                                Math.abs(S(a, ...ay(t1, 0)) - a),
                                Math.abs(S(a, ...ay(t1, 1)) - a)
                            ];
                            u = [
                                e1.indexOf(Math.min(...e1)) - 1
                            ];
                        }
                    } else u = [
                        0
                    ];
                    for (const r of u){
                        const s = t1.containsTile(l, i, e1, r);
                        s && n.push(s);
                    }
                }
                return n;
            }
            getVisibleCoordinates(t1) {
                const e1 = this.getRenderableIds(t1).map((t1)=>this._tiles[t1].tileID);
                for (const t1 of e1)t1.projMatrix = this.transform.calculateProjMatrix(t1.toUnwrapped());
                return e1;
            }
            hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (sy(this._source.type)) for(const t1 in this._tiles){
                    const e1 = this._tiles[t1];
                    if (void 0 !== e1.fadeEndTime && e1.fadeEndTime >= Nt.now()) return !0;
                }
                return !1;
            }
            setFeatureState(t1, e1, r) {
                this._state.updateState(t1 = t1 || "_geojsonTileLayer", e1, r);
            }
            removeFeatureState(t1, e1, r) {
                this._state.removeFeatureState(t1 = t1 || "_geojsonTileLayer", e1, r);
            }
            getFeatureState(t1, e1) {
                return this._state.getState(t1 = t1 || "_geojsonTileLayer", e1);
            }
            setDependencies(t1, e1, r) {
                const n = this._tiles[t1];
                n && n.setDependencies(e1, r);
            }
            reloadTilesForDependencies(t1, e1) {
                for(const r in this._tiles)this._tiles[r].hasDependency(t1, e1) && this._reloadTile(+r, "reloading");
                this._cache.filter((r)=>!r.hasDependency(t1, e1));
            }
            _preloadTiles(t1, e1) {
                const r = new Map, n = Array.isArray(t1) ? t1 : [
                    t1
                ], i = this.map.painter.terrain, s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;
                for (const t1 of n){
                    const e1 = t1.coveringTiles({
                        tileSize: s,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    });
                    for (const t1 of e1)r.set(t1.key, t1);
                    this.usedForTerrain && t1.updateElevation(!1);
                }
                M(Array.from(r.values()), (t1, e1)=>{
                    const r = new Fd(t1, this._source.tileSize * t1.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
                    this._loadTile(r, (t1)=>{
                        "raster-dem" === this._source.type && r.dem && this._backfillDEM(r), e1(t1, r);
                    });
                }, e1);
            }
        }
        function iy(t1, e1) {
            const r = Math.abs(2 * t1.wrap) - +(t1.wrap < 0), n = Math.abs(2 * e1.wrap) - +(e1.wrap < 0);
            return t1.overscaledZ - e1.overscaledZ || n - r || e1.canonical.y - t1.canonical.y || e1.canonical.x - t1.canonical.x;
        }
        function sy(t1) {
            return "raster" === t1 || "image" === t1 || "video" === t1 || "custom" === t1;
        }
        function ay(t1, e1) {
            const r = 1 << t1.z;
            return [
                t1.x / r + e1,
                (t1.x + 1) / r + e1
            ];
        }
        ny.maxOverzooming = 10, ny.maxUnderzooming = 3;
        class oy {
            constructor(t1, e1, r){
                this._demTile = t1, this._dem = this._demTile.dem, this._scale = e1, this._offset = r;
            }
            static create(t1, e1, r) {
                const n = r || t1.findDEMTileFor(e1);
                if (!n || !n.dem) return;
                const i = n.dem, s = n.tileID, a = 1 << e1.canonical.z - s.canonical.z;
                return new oy(n, n.tileSize / ko / a, [
                    (e1.canonical.x / a - s.canonical.x) * i.dim,
                    (e1.canonical.y / a - s.canonical.y) * i.dim
                ]);
            }
            tileCoordToPixel(t1, e1) {
                const r = e1 * this._scale + this._offset[1], n = Math.floor(t1 * this._scale + this._offset[0]), i = Math.floor(r);
                return new d(n, i);
            }
            getElevationAt(t1, e1, r, n) {
                const i = t1 * this._scale + this._offset[0], s = e1 * this._scale + this._offset[1], a = Math.floor(i), o = Math.floor(s), l = this._dem;
                return n = !!n, r ? Mr(Mr(l.get(a, o, n), l.get(a, o + 1, n), s - o), Mr(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);
            }
            getElevationAtPixel(t1, e1, r) {
                return this._dem.get(t1, e1, !!r);
            }
            getMeterToDEM(t1) {
                return (1 << this._demTile.tileID.canonical.z) * au(1, t1) * this._dem.stride;
            }
        }
        class ly {
            constructor(t1, e1){
                this.tileID = t1, this.x = t1.canonical.x, this.y = t1.canonical.y, this.z = t1.canonical.z, this.grid = new ji(ko, 16, 0), this.featureIndexArray = new ja, this.promoteId = e1;
            }
            insert(t1, e1, r, n, i, s = 0) {
                const a = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i, s);
                const o = this.grid;
                for(let t1 = 0; t1 < e1.length; t1++){
                    const r = e1[t1], n = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
                    for(let t1 = 0; t1 < r.length; t1++){
                        const e1 = r[t1];
                        n[0] = Math.min(n[0], e1.x), n[1] = Math.min(n[1], e1.y), n[2] = Math.max(n[2], e1.x), n[3] = Math.max(n[3], e1.y);
                    }
                    n[0] < ko && n[1] < ko && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new sh(new op(this.rawTileData)).layers, this.sourceLayerCoder = new kd(this.vtLayers ? Object.keys(this.vtLayers).sort() : [
                        "_geojsonTileLayer"
                    ]), this.vtFeatures = {};
                    for(const t1 in this.vtLayers)this.vtFeatures[t1] = [];
                }
                return this.vtLayers;
            }
            query(t1, e1, r, n) {
                this.loadVTLayers();
                const i = t1.params || {}, s = ai(i.filter), a = t1.tileResult, o = t1.transform, l = a.bufferedTilespaceBounds, u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t1, e1, r, n)=>Vu(a.bufferedTilespaceGeometry, t1, e1, r, n));
                u.sort(cy);
                let c = null;
                o.elevation && u.length > 0 && (c = oy.create(o.elevation, this.tileID));
                const h = {};
                let p;
                for(let o = 0; o < u.length; o++){
                    const l = u[o];
                    if (l === p) continue;
                    p = l;
                    const f = this.featureIndexArray.get(l);
                    let d = null;
                    this.loadMatchingFeature(h, f, s, i.layers, i.availableImages, e1, r, n, (e1, r, n, i = 0)=>(d || (d = bu(e1, this.tileID.canonical, t1.tileTransform)), r.queryIntersectsFeature(a, e1, n, d, this.z, t1.transform, t1.pixelPosMatrix, c, i)));
                }
                return h;
            }
            loadMatchingFeature(t1, e1, r, n, i, s, a, o, l) {
                const { featureIndex: u , bucketIndex: c , sourceLayerIndex: h , layoutVertexArrayOffset: p  } = e1, f = this.bucketLayerIDs[c];
                if (n && !function(t1, e1) {
                    for(let r = 0; r < t1.length; r++)if (e1.indexOf(t1[r]) >= 0) return !0;
                    return !1;
                }(n, f)) return;
                const d = this.sourceLayerCoder.decode(h), y = this.vtLayers[d].feature(u);
                if (r.needGeometry) {
                    const t1 = wu(y, !0);
                    if (!r.filter(new Us(this.tileID.overscaledZ), t1, this.tileID.canonical)) return;
                } else if (!r.filter(new Us(this.tileID.overscaledZ), y)) return;
                const m = this.getId(y, d);
                for(let e1 = 0; e1 < f.length; e1++){
                    const r = f[e1];
                    if (n && n.indexOf(r) < 0) continue;
                    const c = s[r];
                    if (!c) continue;
                    let h = {};
                    void 0 !== m && o && (h = o.getState(c.sourceLayer || "_geojsonTileLayer", m));
                    const d = z({}, a[r]);
                    d.paint = uy(d.paint, c.paint, y, h, i), d.layout = uy(d.layout, c.layout, y, h, i);
                    const g = !l || l(y, c, h, p);
                    if (!g) continue;
                    const x = new Md(y, this.z, this.x, this.y, m);
                    x.layer = d;
                    let v = t1[r];
                    void 0 === v && (v = t1[r] = []), v.push({
                        featureIndex: u,
                        feature: x,
                        intersectionZ: g
                    });
                }
            }
            lookupSymbolFeatures(t1, e1, r, n, i, s, a, o) {
                const l = {};
                this.loadVTLayers();
                const u = ai(i);
                for (const i of t1)this.loadMatchingFeature(l, {
                    bucketIndex: r,
                    sourceLayerIndex: n,
                    featureIndex: i,
                    layoutVertexArrayOffset: 0
                }, u, s, a, o, e1);
                return l;
            }
            loadFeature(t1) {
                const { featureIndex: e1 , sourceLayerIndex: r  } = t1;
                this.loadVTLayers();
                const n = this.sourceLayerCoder.decode(r), i = this.vtFeatures[n];
                if (i[e1]) return i[e1];
                const s = this.vtLayers[n].feature(e1);
                return i[e1] = s, s;
            }
            hasLayer(t1) {
                for (const e1 of this.bucketLayerIDs)for (const r of e1)if (t1 === r) return !0;
                return !1;
            }
            getId(t1, e1) {
                let r = t1.id;
                if (this.promoteId) {
                    const n = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e1];
                    null != n && (r = t1.properties[n]), "boolean" == typeof r && (r = Number(r));
                }
                return r;
            }
        }
        function uy(t1, e1, r, n, i) {
            return F(t1, (t1, s)=>{
                const a = e1 instanceof Ks ? e1.get(s) : null;
                return a && a.evaluate ? a.evaluate(r, n, i) : a;
            });
        }
        function cy(t1, e1) {
            return e1 - t1;
        }
        Oi(ly, "FeatureIndex", {
            omit: [
                "rawTileData",
                "sourceLayerCoder"
            ]
        });
        class hy {
            constructor(t1, e1){
                this.width = t1, this.height = e1, this.nextRow = 0, this.image = new Ju({
                    width: t1,
                    height: e1
                }), this.positions = {}, this.uploaded = !1;
            }
            getDash(t1, e1) {
                const r = this.getKey(t1, e1);
                return this.positions[r];
            }
            trim() {
                const t1 = this.width, e1 = this.height = P(this.nextRow);
                this.image.resize({
                    width: t1,
                    height: e1
                });
            }
            getKey(t1, e1) {
                return t1.join(",") + e1;
            }
            getDashRanges(t1, e1, r) {
                const n = [];
                let i = t1.length % 2 == 1 ? -t1[t1.length - 1] * r : 0, s = t1[0] * r, a = !0;
                n.push({
                    left: i,
                    right: s,
                    isDash: a,
                    zeroLength: 0 === t1[0]
                });
                let o = t1[0];
                for(let e1 = 1; e1 < t1.length; e1++){
                    a = !a;
                    const l = t1[e1];
                    i = o * r, o += l, s = o * r, n.push({
                        left: i,
                        right: s,
                        isDash: a,
                        zeroLength: 0 === l
                    });
                }
                return n;
            }
            addRoundDash(t1, e1, r) {
                const n = e1 / 2;
                for(let e1 = -r; e1 <= r; e1++){
                    const i = this.width * (this.nextRow + r + e1);
                    let s = 0, a = t1[s];
                    for(let o = 0; o < this.width; o++){
                        o / a.right > 1 && (a = t1[++s]);
                        const l = Math.abs(o - a.left), u = Math.abs(o - a.right), c = Math.min(l, u);
                        let h;
                        const p = e1 / r * (n + 1);
                        if (a.isDash) {
                            const t1 = n - Math.abs(p);
                            h = Math.sqrt(c * c + t1 * t1);
                        } else h = n - Math.sqrt(c * c + p * p);
                        this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
                    }
                }
            }
            addRegularDash(t1, e1) {
                for(let e1 = t1.length - 1; e1 >= 0; --e1){
                    const r = t1[e1], n = t1[e1 + 1];
                    r.zeroLength ? t1.splice(e1, 1) : n && n.isDash === r.isDash && (n.left = r.left, t1.splice(e1, 1));
                }
                const r = t1[0], n = t1[t1.length - 1];
                r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);
                const i = this.width * this.nextRow;
                let s = 0, a = t1[s];
                for(let r = 0; r < this.width; r++){
                    r / a.right > 1 && (a = t1[++s]);
                    const n = Math.abs(r - a.left), o = Math.abs(r - a.right), l = Math.min(n, o);
                    this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e1 + 128));
                }
            }
            addDash(t1, e1) {
                const r = this.getKey(t1, e1);
                if (this.positions[r]) return this.positions[r];
                const n = "round" === e1, i = n ? 7 : 0, s = 2 * i + 1;
                if (this.nextRow + s > this.height) return $("LineAtlas out of space"), null;
                0 === t1.length && t1.push(1);
                let a = 0;
                for(let e1 = 0; e1 < t1.length; e1++)t1[e1] < 0 && ($("Negative value is found in line dasharray, replacing values with 0"), t1[e1] = 0), a += t1[e1];
                if (0 !== a) {
                    const r = this.width / a, s = this.getDashRanges(t1, this.width, r);
                    n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e1 ? .5 * r : 0);
                }
                const o = this.nextRow + i;
                this.nextRow += s;
                const l = {
                    tl: [
                        o,
                        i
                    ],
                    br: [
                        a,
                        0
                    ]
                };
                return this.positions[r] = l, l;
            }
        }
        Oi(hy, "LineAtlas");
        class py {
            constructor(t1){
                const e1 = {}, r = [];
                for(const n in t1){
                    const i = t1[n], s = e1[n] = {};
                    for(const t1 in i.glyphs){
                        const e1 = i.glyphs[+t1];
                        if (!e1 || 0 === e1.bitmap.width || 0 === e1.bitmap.height) continue;
                        const n = e1.metrics.localGlyph ? 2 : 1, a = {
                            x: 0,
                            y: 0,
                            w: e1.bitmap.width + 2 * n,
                            h: e1.bitmap.height + 2 * n
                        };
                        r.push(a), s[t1] = a;
                    }
                }
                const { w: n , h: i  } = Cp(r), s = new Ju({
                    width: n || 1,
                    height: i || 1
                });
                for(const r in t1){
                    const n = t1[r];
                    for(const t1 in n.glyphs){
                        const i = n.glyphs[+t1];
                        if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height) continue;
                        const a = e1[r][t1], o = i.metrics.localGlyph ? 2 : 1;
                        Ju.copy(i.bitmap, s, {
                            x: 0,
                            y: 0
                        }, {
                            x: a.x + o,
                            y: a.y + o
                        }, i.bitmap);
                    }
                }
                this.image = s, this.positions = e1;
            }
        }
        Oi(py, "GlyphAtlas");
        class fy {
            constructor(t1){
                this.tileID = new Mh(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t1.showCollisionBoxes, this.collectResourceTiming = !!t1.collectResourceTiming, this.returnDependencies = !!t1.returnDependencies, this.promoteId = t1.promoteId, this.enableTerrain = !!t1.enableTerrain, this.isSymbolTile = t1.isSymbolTile, this.tileTransform = Vf(t1.tileID.canonical, t1.projection), this.projection = t1.projection;
            }
            parse(t1, e1, r, n, i) {
                this.status = "parsing", this.data = t1, this.collisionBoxArray = new Ea;
                const s = new kd(Object.keys(t1.layers).sort()), a = new ly(this.tileID, this.promoteId);
                a.bucketLayerIDs = [];
                const o = {}, l = new hy(256, 256), u = {
                    featureIndex: a,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: l,
                    availableImages: r
                }, c = e1.familiesBySource[this.source];
                for(const e1 in c){
                    const n = t1.layers[e1];
                    if (!n) continue;
                    let i = !1, l = !1;
                    for (const t1 of c[e1])"symbol" === t1[0].type ? i = !0 : l = !0;
                    if (!0 === this.isSymbolTile && !i) continue;
                    if (!1 === this.isSymbolTile && !l) continue;
                    1 === n.version && $(`Vector tile source "${this.source}" layer "${e1}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const h = s.encode(e1), p = [];
                    for(let t1 = 0; t1 < n.length; t1++){
                        const r = n.feature(t1), i = a.getId(r, e1);
                        p.push({
                            feature: r,
                            id: i,
                            index: t1,
                            sourceLayerIndex: h
                        });
                    }
                    for (const t1 of c[e1]){
                        const e1 = t1[0];
                        void 0 !== this.isSymbolTile && "symbol" === e1.type !== this.isSymbolTile || e1.minzoom && this.zoom < Math.floor(e1.minzoom) || e1.maxzoom && this.zoom >= e1.maxzoom || "none" !== e1.visibility && (dy(t1, this.zoom, r), (o[e1.id] = e1.createBucket({
                            index: a.bucketLayerIDs.length,
                            layers: t1,
                            zoom: this.zoom,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: h,
                            sourceID: this.source,
                            enableTerrain: this.enableTerrain,
                            projection: this.projection.spec,
                            availableImages: r
                        })).populate(p, u, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(t1.map((t1)=>t1.id)));
                    }
                }
                let h, p, f, d;
                l.trim();
                const y = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom
                }, m = F(u.glyphDependencies, (t1)=>Object.keys(t1).map(Number));
                Object.keys(m).length ? n.send("getGlyphs", {
                    uid: this.uid,
                    stacks: m
                }, (t1, e1)=>{
                    h || (h = t1, p = e1, v.call(this));
                }, void 0, !1, y) : p = {};
                const g = Object.keys(u.iconDependencies);
                g.length ? n.send("getImages", {
                    icons: g,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                }, (t1, e1)=>{
                    h || (h = t1, f = e1, v.call(this));
                }, void 0, !1, y) : f = {};
                const x = Object.keys(u.patternDependencies);
                function v() {
                    if (h) return i(h);
                    if (p && f && d) {
                        const t1 = new py(p), e1 = new Dp(f, d);
                        for(const n in o){
                            const i = o[n];
                            i instanceof hd ? (dy(i.layers, this.zoom, r), kf(i, p, t1.positions, f, e1.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i.hasPattern && (i instanceof jh || i instanceof Uc || i instanceof fh) && (dy(i.layers, this.zoom, r), i.addFeatures(u, this.tileID.canonical, e1.patternPositions, r, this.tileTransform));
                        }
                        this.status = "done", i(null, {
                            buckets: T(o).filter((t1)=>!t1.isEmpty()),
                            featureIndex: a,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: t1.image,
                            lineAtlas: l,
                            imageAtlas: e1,
                            glyphMap: this.returnDependencies ? p : null,
                            iconMap: this.returnDependencies ? f : null,
                            glyphPositions: this.returnDependencies ? t1.positions : null
                        });
                    }
                }
                x.length ? n.send("getImages", {
                    icons: x,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                }, (t1, e1)=>{
                    h || (h = t1, d = e1, v.call(this));
                }, void 0, !1, y) : d = {}, v.call(this);
            }
        }
        function dy(t1, e1, r) {
            const n = new Us(e1);
            for (const e1 of t1)e1.recalculate(n, r);
        }
        class yy {
            constructor(t1){
                this.entries = {}, this.scheduler = t1;
            }
            request(t1, e1, r, n) {
                const i = this.entries[t1] = this.entries[t1] || {
                    callbacks: []
                };
                if (i.result) {
                    const [t1, r] = i.result;
                    return this.scheduler ? this.scheduler.add(()=>{
                        n(t1, r);
                    }, e1) : n(t1, r), ()=>{};
                }
                return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n)=>{
                    i.result = [
                        r,
                        n
                    ];
                    for (const t1 of i.callbacks)this.scheduler ? this.scheduler.add(()=>{
                        t1(r, n);
                    }, e1) : t1(r, n);
                    setTimeout(()=>delete this.entries[t1], 3e3);
                })), ()=>{
                    i.result || (i.callbacks = i.callbacks.filter((t1)=>t1 !== n), i.callbacks.length || (i.cancel(), delete this.entries[t1]));
                };
            }
        }
        function my(t1, e1, r) {
            const n = JSON.stringify(t1.request);
            return t1.data && (this.deduped.entries[n] = {
                result: [
                    null,
                    t1.data
                ]
            }), this.deduped.request(n, {
                type: "parseTile",
                isSymbolTile: t1.isSymbolTile,
                zoom: t1.tileZoom
            }, (e1)=>{
                const n = ut(t1.request, (t1, n, i, s)=>{
                    t1 ? e1(t1) : n && e1(null, {
                        vectorTile: r ? void 0 : new sh(new op(n)),
                        rawData: n,
                        cacheControl: i,
                        expires: s
                    });
                });
                return ()=>{
                    n.cancel(), e1();
                };
            }, e1);
        }
        t1.ARRAY_TYPE = To, t1.AUTH_ERR_MSG = yt, t1.Aabb = _l, t1.Actor = class {
            constructor(t1, r, n){
                this.target = t1, this.parent = r, this.mapId = n, this.callbacks = {}, this.cancelCallbacks = {}, V([
                    "receive"
                ], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = N() ? t1 : e1, this.scheduler = new Sd;
            }
            send(t1, e1, r, n, i = !1, s) {
                const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                r && (r.metadata = s, this.callbacks[a] = r);
                const o = Z(this.globalScope) ? void 0 : [];
                return this.target.postMessage({
                    id: a,
                    type: t1,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: Gi(e1, o)
                }, o), {
                    cancel: ()=>{
                        r && delete this.callbacks[a], this.target.postMessage({
                            id: a,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                };
            }
            receive(t1) {
                const e1 = t1.data, r = e1.id;
                if (r && (!e1.targetMapId || this.mapId === e1.targetMapId)) {
                    if ("<cancel>" === e1.type) {
                        const t1 = this.cancelCallbacks[r];
                        delete this.cancelCallbacks[r], t1 && t1.cancel();
                    } else if (e1.mustQueue || N()) {
                        const t1 = this.callbacks[r];
                        this.cancelCallbacks[r] = this.scheduler.add(()=>this.processTask(r, e1), t1 && t1.metadata || {
                            type: "message"
                        });
                    } else this.processTask(r, e1);
                }
            }
            processTask(t1, e1) {
                if ("<response>" === e1.type) {
                    const r = this.callbacks[t1];
                    delete this.callbacks[t1], r && (e1.error ? r(Xi(e1.error)) : r(null, Xi(e1.data)));
                } else {
                    const r = Z(this.globalScope) ? void 0 : [], n = e1.hasCallback ? (e1, n)=>{
                        delete this.cancelCallbacks[t1], this.target.postMessage({
                            id: t1,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e1 ? Gi(e1) : null,
                            data: Gi(n, r)
                        }, r);
                    } : (t1)=>{}, i = Xi(e1.data);
                    if (this.parent[e1.type]) this.parent[e1.type](e1.sourceMapId, i, n);
                    else if (this.parent.getWorkerSource) {
                        const t1 = e1.type.split(".");
                        this.parent.getWorkerSource(e1.sourceMapId, t1[0], i.source)[t1[1]](i, n);
                    } else n(new Error(`Could not find function ${e1.type}`));
                }
            }
            remove() {
                this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }, t1.CanonicalTileID = kh, t1.Color = Me, t1.ColorMode = Qd, t1.CullFaceMode = ry, t1.DEMData = Kd, t1.DataConstantProperty = Ys, t1.DedupedRequest = yy, t1.DepthMode = Hd, t1.EXTENT = ko, t1.Elevation = class {
            isDataAvailableAtPoint(t1) {
                const e1 = this._source();
                if (this.isUsingMockSource() || !e1 || t1.y < 0 || t1.y > 1) return !1;
                const r = e1.getSource().maxzoom, n = 1 << r, i = Math.floor(t1.x), s = Math.floor((t1.x - i) * n), a = Math.floor(t1.y * n), o = this.findDEMTileFor(new Mh(r, i, r, s, a));
                return !(!o || !o.dem);
            }
            getAtPointOrZero(t1, e1 = 0) {
                return this.getAtPoint(t1, e1) || 0;
            }
            getAtPoint(t1, e1, r = !0) {
                if (this.isUsingMockSource()) return null;
                null == e1 && (e1 = null);
                const n = this._source();
                if (!n) return e1;
                if (t1.y < 0 || t1.y > 1) return e1;
                const i = n.getSource().maxzoom, s = 1 << i, a = Math.floor(t1.x), o = t1.x - a, l = new Mh(i, a, i, Math.floor(o * s), Math.floor(t1.y * s)), u = this.findDEMTileFor(l);
                if (!u || !u.dem) return e1;
                const c = u.dem, h = 1 << u.tileID.canonical.z, p = (o * h - u.tileID.canonical.x) * c.dim, f = (t1.y * h - u.tileID.canonical.y) * c.dim, d = Math.floor(p), y = Math.floor(f);
                return (r ? this.exaggeration() : 1) * Mr(Mr(c.get(d, y), c.get(d, y + 1), f - y), Mr(c.get(d + 1, y), c.get(d + 1, y + 1), f - y), p - d);
            }
            getAtTileOffset(t1, e1, r) {
                const n = 1 << t1.canonical.z;
                return this.getAtPointOrZero(new pu(t1.wrap + (t1.canonical.x + e1 / ko) / n, (t1.canonical.y + r / ko) / n));
            }
            getAtTileOffsetFunc(t1, e1, r, n) {
                return (i)=>{
                    const s = this.getAtTileOffset(t1, i.x, i.y), a = n.upVector(t1.canonical, i.x, i.y);
                    return Ho(a, a, s * n.upVectorScale(t1.canonical, e1, r).metersToTile), a;
                };
            }
            getForTilePoints(t1, e1, r, n) {
                if (this.isUsingMockSource()) return !1;
                const i = oy.create(this, t1, n);
                return !!i && (e1.forEach((t1)=>{
                    t1[2] = this.exaggeration() * i.getElevationAt(t1[0], t1[1], r);
                }), !0);
            }
            getMinMaxForTile(t1) {
                if (this.isUsingMockSource()) return null;
                const e1 = this.findDEMTileFor(t1);
                if (!e1 || !e1.dem) return null;
                const r = e1.dem.tree, n = e1.tileID, i = 1 << t1.canonical.z - n.canonical.z;
                let s = t1.canonical.x / i - n.canonical.x, a = t1.canonical.y / i - n.canonical.y, o = 0;
                for(let e1 = 0; e1 < t1.canonical.z - n.canonical.z && !r.leaves[o]; e1++){
                    s *= 2, a *= 2;
                    const t1 = 2 * Math.floor(a) + Math.floor(s);
                    o = r.childOffsets[o] + t1, s %= 1, a %= 1;
                }
                return {
                    min: this.exaggeration() * r.minimums[o],
                    max: this.exaggeration() * r.maximums[o]
                };
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
            }
            raycast(t1, e1, r) {
                throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t1) {
                throw new Error("Pure virtual method called.");
            }
            _source() {
                throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.");
            }
            exaggeration() {
                throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t1) {
                throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
            }
        }, t1.ErrorEvent = Kt, t1.EvaluationParameters = Us, t1.Event = Zt, t1.Evented = Yt, t1.FillExtrusionBucket = fh, t1.Frustum = wl, t1.FrustumCorners = bl, t1.GLOBE_RADIUS = Al, t1.GLOBE_SCALE_MATCH_LATITUDE = 45, t1.GLOBE_ZOOM_THRESHOLD_MAX = 6, t1.GLOBE_ZOOM_THRESHOLD_MIN = 5, t1.GlobeSharedBuffers = class {
            constructor(t1){
                this._createGrid(t1), this._createPoles(t1);
            }
            destroy() {
                this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
                for (const t1 of this._poleSegments)t1.destroy();
                for (const t1 of this._gridSegments)t1.withSkirts.destroy(), t1.withoutSkirts.destroy();
                if (this._wireframeIndexBuffer) {
                    this._wireframeIndexBuffer.destroy();
                    for (const t1 of this._wireframeSegments)t1.destroy();
                }
            }
            _fillGridMeshWithLods(t1, e1) {
                const r = new sa, n = new wa, i = [], s = t1 + 1 + 2, a = e1[0] + 1, o = e1[0] + 1 + (1 + e1.length), l = (t1, e1, r)=>{
                    let n = t1 === s - 1 ? t1 - 2 : 0 === t1 ? t1 : t1 - 1;
                    return n += r ? 24575 : 0, [
                        n,
                        e1
                    ];
                };
                for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, 0, !0));
                for(let t1 = 0; t1 < a; ++t1)for(let e1 = 0; e1 < s; ++e1)r.emplaceBack(...l(e1, t1, (0 === e1 || e1 === s - 1) && !0));
                for(let t1 = 0; t1 < e1.length; ++t1){
                    const n = e1[t1];
                    for(let t1 = 0; t1 < s; ++t1)r.emplaceBack(...l(t1, n, !0));
                }
                for(let t1 = 0; t1 < e1.length; ++t1){
                    const a = n.length, l = e1[t1] + 1 + 2, u = new wa;
                    for(let r = 0; r < l - 1; r++){
                        const i = r === l - 2, a = i ? s * (o - e1.length + t1 - r) : s;
                        for(let t1 = 0; t1 < s - 1; t1++){
                            const e1 = r * s + t1;
                            0 === r || i || 0 === t1 || t1 === s - 2 ? (u.emplaceBack(e1 + 1, e1, e1 + a), u.emplaceBack(e1 + a, e1 + a + 1, e1 + 1)) : (n.emplaceBack(e1 + 1, e1, e1 + a), n.emplaceBack(e1 + a, e1 + a + 1, e1 + 1));
                        }
                    }
                    const c = So.simpleSegment(0, a, r.length, n.length - a);
                    for(let t1 = 0; t1 < u.uint16.length; t1 += 3)n.emplaceBack(u.uint16[t1], u.uint16[t1 + 1], u.uint16[t1 + 2]);
                    const h = So.simpleSegment(0, a, r.length, n.length - a);
                    i.push({
                        withoutSkirts: c,
                        withSkirts: h
                    });
                }
                return {
                    vertices: r,
                    indices: n,
                    segments: i
                };
            }
            _createGrid(t1) {
                const e1 = this._fillGridMeshWithLods(Sl, kl);
                this._gridSegments = e1.segments, this._gridBuffer = t1.createVertexBuffer(e1.vertices, xl.members), this._gridIndexBuffer = t1.createIndexBuffer(e1.indices, !0);
            }
            _createPoles(t1) {
                const e1 = new wa;
                for(let t1 = 0; t1 <= Sl; t1++)e1.emplaceBack(0, t1 + 1, t1 + 2);
                this._poleIndexBuffer = t1.createIndexBuffer(e1, !0);
                const r = new ka, n = new ka;
                this._poleSegments = [];
                for(let t1 = 0, e1 = 0; t1 < 5; t1++){
                    const i = 360 / (1 << t1);
                    r.emplaceBack(0, -Al, 0, .5, 0), n.emplaceBack(0, -Al, 0, .5, 1);
                    for(let t1 = 0; t1 <= Sl; t1++){
                        const e1 = t1 / Sl, s = Mr(0, i, e1), [a, o, l] = Ul(Jl, Ql, s, Al);
                        r.emplaceBack(a, o, l, e1, 0), n.emplaceBack(a, o, l, e1, 1);
                    }
                    this._poleSegments.push(So.simpleSegment(e1, 0, 66, 64)), e1 += 66;
                }
                this._poleNorthVertexBuffer = t1.createVertexBuffer(r, ml, !1), this._poleSouthVertexBuffer = t1.createVertexBuffer(n, ml, !1);
            }
            getGridBuffers(t1, e1) {
                return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    e1 ? this._gridSegments[t1].withSkirts : this._gridSegments[t1].withoutSkirts
                ];
            }
            getPoleBuffers(t1) {
                return [
                    this._poleNorthVertexBuffer,
                    this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[t1]
                ];
            }
            getWirefameBuffers(t1, e1) {
                if (!this._wireframeSegments) {
                    const e1 = new Ma, r = Sl, n = r + 1 + 2, i = 1;
                    this._wireframeSegments = [];
                    for(let t1 = 0, s = 0; t1 < kl.length; t1++){
                        const a = kl[t1];
                        for(let t1 = i; t1 < a + i; t1++)for(let s = i; s < r + i; s++){
                            const r = t1 * n + s;
                            e1.emplaceBack(r, r + 1), e1.emplaceBack(r, r + n), e1.emplaceBack(r, r + n + 1);
                        }
                        const o = a * r * 3;
                        this._wireframeSegments.push(So.simpleSegment(0, s, (a + 1) * n, o)), s += o;
                    }
                    this._wireframeIndexBuffer = t1.createIndexBuffer(e1);
                }
                return [
                    this._gridBuffer,
                    this._wireframeIndexBuffer,
                    this._wireframeSegments[e1]
                ];
            }
        }, t1.GlyphManager = cf, t1.ImagePosition = Pp, t1.LivePerformanceUtils = Lt, t1.LngLat = ru, t1.LngLatBounds = Io, t1.LocalGlyphMode = uf, t1.MAX_MERCATOR_LATITUDE = cu, t1.MercatorCoordinate = pu, t1.ONE_EM = Wh, t1.OverscaledTileID = Mh, t1.PerformanceMarkers = Vt, t1.Properties = Js, t1.RGBAImage = Qu, t1.Ray = vl, t1.RequestManager = class {
            constructor(t1, e1, r){
                this._transformRequestFn = t1, this._customAccessToken = e1, this._silenceAuthErrors = !!r, this._createSkuToken();
            }
            _createSkuToken() {
                const t1 = function() {
                    let t1 = "";
                    for(let e1 = 0; e1 < 10; e1++)t1 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: [
                            "1",
                            h,
                            t1
                        ].join(""),
                        tokenExpiresAt: Date.now() + 432e5
                    };
                }();
                this._skuToken = t1.token, this._skuTokenExpiresAt = t1.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(t1, e1) {
                return this._transformRequestFn && this._transformRequestFn(t1, e1) || {
                    url: t1
                };
            }
            normalizeStyleURL(t1, e1) {
                if (!mt(t1)) return t1;
                const r = _t(t1);
                return r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e1);
            }
            normalizeGlyphsURL(t1, e1) {
                if (!mt(t1)) return t1;
                const r = _t(t1);
                return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e1);
            }
            normalizeSourceURL(t1, e1, r, n) {
                if (!mt(t1)) return t1;
                const i = _t(t1);
                return i.path = `/v4/${i.authority}.json`, i.params.push("secure"), r && i.params.push(`language=${r}`), n && i.params.push(`worldview=${n}`), this._makeAPIURL(i, this._customAccessToken || e1);
            }
            normalizeSpriteURL(t1, e1, r, n) {
                const i = _t(t1);
                return mt(t1) ? (i.path = `/styles/v1${i.path}/sprite${e1}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e1}${r}`, At(i));
            }
            normalizeTileURL(t1, e1, r) {
                if (this._isSkuTokenExpired() && this._createSkuToken(), t1 && !mt(t1)) return t1;
                const n = _t(t1);
                n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e1 || r && "raster" !== n.authority && 512 === r ? "@2x" : ""}${s.supported ? ".webp" : "$1"}`), "raster" === n.authority ? n.path = `/${i.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\/v4\//, "/"), n.path = `/${i.TILE_URL_VERSION}${n.path}`);
                const a = this._customAccessToken || function(t1) {
                    for (const e1 of t1){
                        const t1 = e1.match(/^access_token=(.*)$/);
                        if (t1) return t1[1];
                    }
                    return null;
                }(n.params) || i.ACCESS_TOKEN;
                return i.REQUIRE_ACCESS_TOKEN && a && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, a);
            }
            canonicalizeTileURL(t1, e1) {
                const r = _t(t1);
                if (!r.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r.path.match(/\.[\w]+$/)) return t1;
                let n = "mapbox://";
                r.path.match(/^\/raster\/v1\//) ? n += `raster/${r.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n += `tiles/${r.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`;
                let s = r.params;
                return e1 && (s = s.filter((t1)=>!t1.match(/^access_token=/))), s.length && (n += `?${s.join("&")}`), n;
            }
            canonicalizeTileset(t1, e1) {
                const r = !!e1 && mt(e1), n = [];
                for (const e1 of t1.tiles || [])gt(e1) ? n.push(this.canonicalizeTileURL(e1, r)) : n.push(e1);
                return n;
            }
            _makeAPIURL(t1, e1) {
                const r = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n = _t(i.API_URL);
                if (t1.protocol = n.protocol, t1.authority = n.authority, "http" === t1.protocol) {
                    const e1 = t1.params.indexOf("secure");
                    e1 >= 0 && t1.params.splice(e1, 1);
                }
                if ("/" !== n.path && (t1.path = `${n.path}${t1.path}`), !i.REQUIRE_ACCESS_TOKEN) return At(t1);
                if (e1 = e1 || i.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!e1) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);
                    if ("s" === e1[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);
                }
                return t1.params = t1.params.filter((t1)=>-1 === t1.indexOf("access_token")), t1.params.push(`access_token=${e1 || ""}`), At(t1);
            }
        }, t1.ResourceType = st, t1.SegmentVector = So, t1.SourceCache = ny, t1.StencilMode = Jd, t1.StructArrayLayout1ui2 = Ta, t1.StructArrayLayout2f1f2i16 = xa, t1.StructArrayLayout2i4 = sa, t1.StructArrayLayout2ui4 = Ma, t1.StructArrayLayout3f12 = ba, t1.StructArrayLayout3ui6 = wa, t1.StructArrayLayout4i8 = oa, t1.StructArrayLayout5f20 = ka, t1.Texture = _d, t1.Tile = Fd, t1.Transitionable = qs, t1.Uniform1f = to, t1.Uniform1i = class extends Qa {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
            }
        }, t1.Uniform2f = class extends Qa {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0
                ];
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }, t1.Uniform3f = class extends Qa {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0
                ];
            }
            set(t1, e1, r) {
                this.fetchUniformLocation(t1, e1) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }, t1.Uniform4f = eo, t1.UniformColor = ro, t1.UniformMatrix2f = class extends Qa {
            constructor(t1){
                super(t1), this.current = so;
            }
            set(t1, e1, r) {
                if (this.fetchUniformLocation(t1, e1)) {
                    for(let t1 = 0; t1 < 4; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.UniformMatrix3f = class extends Qa {
            constructor(t1){
                super(t1), this.current = io;
            }
            set(t1, e1, r) {
                if (this.fetchUniformLocation(t1, e1)) {
                    for(let t1 = 0; t1 < 9; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.UniformMatrix4f = class extends Qa {
            constructor(t1){
                super(t1), this.current = no;
            }
            set(t1, e1, r) {
                if (this.fetchUniformLocation(t1, e1)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
                    for(let t1 = 1; t1 < 16; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.UnwrappedTileID = Ih, t1.ValidationError = Wn, t1.VectorTileFeature = ah, t1.VectorTileWorkerSource = class extends Yt {
            constructor(t1, e1, r, n, i){
                super(), this.actor = t1, this.layerIndex = e1, this.availableImages = r, this.loadVectorData = i || my, this.loading = {}, this.loaded = {}, this.deduped = new yy(t1.scheduler), this.isSpriteLoaded = n, this.scheduler = t1.scheduler;
            }
            loadTile(t1, e1) {
                const r = t1.uid, n = t1 && t1.request, i = n && n.collectResourceTiming, s = this.loading[r] = new fy(t1);
                s.abort = this.loadVectorData(t1, (a, o)=>{
                    const l = !this.loading[r];
                    if (delete this.loading[r], l || a || !o) return s.status = "done", l || (this.loaded[r] = s), e1(a);
                    const u = o.rawData, c = {};
                    o.expires && (c.expires = o.expires), o.cacheControl && (c.cacheControl = o.cacheControl), s.vectorTile = o.vectorTile || new sh(new op(u));
                    const h = ()=>{
                        s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, (t1, r)=>{
                            if (t1 || !r) return e1(t1);
                            const s = {};
                            if (i) {
                                const t1 = jt(n);
                                t1.length > 0 && (s.resourceTiming = JSON.parse(JSON.stringify(t1)));
                            }
                            e1(null, z({
                                rawTileData: u.slice(0)
                            }, r, c, s));
                        });
                    };
                    this.isSpriteLoaded ? h() : this.once("isSpriteLoaded", ()=>{
                        this.scheduler ? this.scheduler.add(h, {
                            type: "parseTile",
                            isSymbolTile: t1.isSymbolTile,
                            zoom: t1.tileZoom
                        }) : h();
                    }), this.loaded = this.loaded || {}, this.loaded[r] = s;
                });
            }
            reloadTile(t1, e1) {
                const r = this.loaded, n = t1.uid, i = this;
                if (r && r[n]) {
                    const s = r[n];
                    s.showCollisionBoxes = t1.showCollisionBoxes, s.enableTerrain = !!t1.enableTerrain, s.projection = t1.projection, s.tileTransform = Vf(t1.tileID.canonical, t1.projection);
                    const a = (t1, r)=>{
                        const n = s.reloadCallback;
                        n && (delete s.reloadCallback, s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), e1(t1, r);
                    };
                    "parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());
                }
            }
            abortTile(t1, e1) {
                const r = t1.uid, n = this.loading[r];
                n && (n.abort && n.abort(), delete this.loading[r]), e1();
            }
            removeTile(t1, e1) {
                const r = this.loaded, n = t1.uid;
                r && r[n] && delete r[n], e1();
            }
        }, t1.WritingMode = Vp, t1.ZoomDependentExpression = Zn, t1.add = Go, t1.addDynamicAttributes = od, t1.adjoint = function(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = e1[3], a = e1[4], o = e1[5], l = e1[6], u = e1[7], c = e1[8];
            return t1[0] = a * c - o * u, t1[1] = i * u - n * c, t1[2] = n * o - i * a, t1[3] = o * l - s * c, t1[4] = r * c - i * l, t1[5] = i * s - r * o, t1[6] = s * u - a * l, t1[7] = n * l - r * u, t1[8] = r * a - n * s, t1;
        }, t1.asyncAll = M, t1.bezier = _, t1.bindAll = V, t1.boundsAttributes = Vd, t1.bufferConvexPolygon = function(t1, e1) {
            const r = [];
            for(let n = 0; n < t1.length; n++){
                const i = I(n - 1, -1, t1.length - 1), s = I(n + 1, -1, t1.length - 1), a = t1[n], o = t1[s], l = t1[i].sub(a).unit(), u = o.sub(a).unit(), c = u.angleWithSep(l.x, l.y), h = l.add(u).unit().mult(-1 * e1 / Math.sin(c / 2));
                r.push(a.add(h));
            }
            return r;
        }, t1.cacheEntryPossiblyAdded = function(t1) {
            it++, it > tt && (t1.getActor().send("enforceCacheSizeLimit", Q), it = 0);
        }, t1.calculateGlobeLabelMatrix = function(t1, e1) {
            const { x: r , y: n  } = t1.point, i = Zl(r, n, t1.worldSize / t1._pixelsPerMercatorPixel, 0, 0);
            return Po(i, i, Xl(Pl(e1)));
        }, t1.calculateGlobeMatrix = function(t1) {
            const { x: e1 , y: r  } = t1.point, { lng: n , lat: i  } = t1._center;
            return Zl(e1, r, t1.worldSize, n, i);
        }, t1.calculateGlobeMercatorMatrix = function(t1) {
            const e1 = t1.pixelsPerMeter, r = e1 / au(1, t1.center.lat), n = Eo(new Float64Array(16));
            return Do(n, n, [
                t1.point.x,
                t1.point.y,
                0
            ]), Vo(n, n, [
                r,
                r,
                e1
            ]), Float32Array.from(n);
        }, t1.circumferenceAtLatitude = nu, t1.clamp = S, t1.clearTileCache = function(t1) {
            if (!et()) return;
            const r = e1.caches.delete(H);
            t1 && r.catch(t1).then(()=>t1());
        }, t1.clipLine = sf, t1.clone = function(t1) {
            var e1 = new To(16);
            return e1[0] = t1[0], e1[1] = t1[1], e1[2] = t1[2], e1[3] = t1[3], e1[4] = t1[4], e1[5] = t1[5], e1[6] = t1[6], e1[7] = t1[7], e1[8] = t1[8], e1[9] = t1[9], e1[10] = t1[10], e1[11] = t1[11], e1[12] = t1[12], e1[13] = t1[13], e1[14] = t1[14], e1[15] = t1[15], e1;
        }, t1.clone$1 = j, t1.collisionCircleLayout = Hh, t1.config = i, t1.conjugate = function(t1, e1) {
            return t1[0] = -e1[0], t1[1] = -e1[1], t1[2] = -e1[2], t1[3] = e1[3], t1;
        }, t1.create = function() {
            var t1 = new To(16);
            return To != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0), t1[0] = 1, t1[5] = 1, t1[10] = 1, t1[15] = 1, t1;
        }, t1.create$1 = zo, t1.createExpression = Gn, t1.createLayout = na, t1.createStyleLayer = function(t1) {
            return "custom" === t1.type ? new xd(t1) : new wd[t1.type](t1);
        }, t1.cross = tl, t1.degToRad = x, t1.distance = function(t1, e1) {
            return Math.hypot(e1[0] - t1[0], e1[1] - t1[1], e1[2] - t1[2]);
        }, t1.div = function(t1, e1, r) {
            return t1[0] = e1[0] / r[0], t1[1] = e1[1] / r[1], t1[2] = e1[2] / r[2], t1;
        }, t1.dot = Qo, t1.earthRadius = tu, t1.ease = A, t1.easeCubicInOut = w, t1.ecefToLatLng = function([t1, e1, r]) {
            const n = Math.hypot(t1, e1, r), i = Math.atan2(t1, r), s = .5 * Math.PI - Math.acos(-e1 / n);
            return new ru(v(i), v(s));
        }, t1.emitValidationErrors = Ri, t1.endsWith = L, t1.enforceCacheSizeLimit = function(t1) {
            rt(), W && W.then((e1)=>{
                e1.keys().then((r)=>{
                    for(let n = 0; n < r.length - t1; n++)e1.delete(r[n]);
                });
            });
        }, t1.evaluateSizeForFeature = tp, t1.evaluateSizeForZoom = ep, t1.evaluateVariableOffset = Sf, t1.evented = Ls, t1.exactEquals = function(t1, e1) {
            return t1[0] === e1[0] && t1[1] === e1[1] && t1[2] === e1[2] && t1[3] === e1[3];
        }, t1.exactEquals$1 = function(t1, e1) {
            return t1[0] === e1[0] && t1[1] === e1[1] && t1[2] === e1[2];
        }, t1.exported = Nt, t1.exported$1 = s, t1.extend = z, t1.extend$1 = Wt, t1.fillExtrusionHeightLift = bh, t1.filterObject = R, t1.fromMat4 = function(t1, e1) {
            return t1[0] = e1[0], t1[1] = e1[1], t1[2] = e1[2], t1[3] = e1[4], t1[4] = e1[5], t1[5] = e1[6], t1[6] = e1[8], t1[7] = e1[9], t1[8] = e1[10], t1;
        }, t1.fromQuat = function(t1, e1) {
            var r = e1[0], n = e1[1], i = e1[2], s = e1[3], a = r + r, o = n + n, l = i + i, u = r * a, c = n * a, h = n * o, p = i * a, f = i * o, d = i * l, y = s * a, m = s * o, g = s * l;
            return t1[0] = 1 - h - d, t1[1] = c + g, t1[2] = p - m, t1[3] = 0, t1[4] = c - g, t1[5] = 1 - u - d, t1[6] = f + y, t1[7] = 0, t1[8] = p + m, t1[9] = f - y, t1[10] = 1 - u - h, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
        }, t1.fromRotation = function(t1, e1) {
            var r = Math.sin(e1), n = Math.cos(e1);
            return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = -r, t1[4] = n, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
        }, t1.fromScaling = Ro, t1.furthestTileCorner = function(t1) {
            const e1 = Math.round((t1 + 45 + 360) % 360 / 90) % 4;
            return b[e1];
        }, t1.getAABBPointSquareDist = function(t1, e1, r) {
            let n = 0;
            for(let i = 0; i < 2; ++i){
                const s = r ? r[i] : 0;
                t1[i] > s && (n += (t1[i] - s) * (t1[i] - s)), e1[i] < s && (n += (s - e1[i]) * (s - e1[i]));
            }
            return n;
        }, t1.getAnchorAlignment = Xp, t1.getAnchorJustification = If, t1.getBounds = function(t1) {
            let e1 = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
            for (const s of t1)e1 = Math.min(e1, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
            return {
                min: new d(e1, r),
                max: new d(n, i)
            };
        }, t1.getColumn = Y, t1.getGridMatrix = function(t1, e1, r, n) {
            const i = e1.getNorth(), s = e1.getSouth(), a = e1.getWest(), o = e1.getEast(), l = 1 << t1.z, u = o - a, c = i - s, h = u / Sl, p = -c / kl[r], f = [
                0,
                h,
                0,
                p,
                0,
                0,
                i,
                a,
                0
            ];
            if (t1.z > 0) {
                const t1 = 180 / n;
                Bo(f, f, [
                    t1 / u + 1,
                    0,
                    0,
                    0,
                    t1 / c + 1,
                    0,
                    -0.5 * t1 / h,
                    .5 * t1 / p,
                    1
                ]);
            }
            return f[2] = l, f[5] = t1.x, f[8] = t1.y, f;
        }, t1.getImage = dt, t1.getJSON = function(t1, e1) {
            return lt(z(t1, {
                type: "json"
            }), e1);
        }, t1.getLatitudinalLod = function(t1) {
            const e1 = cu - 5;
            t1 = S(t1, -e1, e1) / e1 * 90;
            const r = Math.pow(Math.abs(Math.sin(x(t1))), 3);
            return Math.round(r * (kl.length - 1));
        }, t1.getMapSessionAPI = Pt, t1.getPerformanceMeasurement = jt, t1.getProjection = rd, t1.getRTLTextPluginStatus = Fs, t1.getReferrer = ot, t1.getTilePoint = function(t1, { x: e1 , y: r  }, n = 0) {
            return new d(((e1 - n) * t1.scale - t1.x) * ko, (r * t1.scale - t1.y) * ko);
        }, t1.getTileVec3 = function(t1, e1, r = 0) {
            return No(((e1.x - r) * t1.scale - t1.x) * ko, (e1.y * t1.scale - t1.y) * ko, uu(e1.z, e1.y));
        }, t1.getVideo = function(t1, r) {
            const n = e1.document.createElement("video");
            n.muted = !0, n.onloadstart = function() {
                r(null, n);
            };
            for(let r = 0; r < t1.length; r++){
                const i = e1.document.createElement("source");
                ct(t1[r]) || (n.crossOrigin = "Anonymous"), i.src = t1[r], n.appendChild(i);
            }
            return {
                cancel: ()=>{}
            };
        }, t1.globeCenterToScreenPoint = function(t1) {
            const e1 = [
                0,
                0,
                0
            ], r = Eo(new Float64Array(16));
            return Po(r, t1.pixelMatrix, t1.globeMatrix), el(e1, e1, r), new d(e1[0], e1[1]);
        }, t1.globeDenormalizeECEF = Xl, t1.globeECEFOrigin = function(t1, e1) {
            const r = [
                0,
                0,
                0
            ];
            return el(r, r, Gl(Pl(e1.canonical))), el(r, r, t1), r;
        }, t1.globeMetersToEcef = zl, t1.globeNormalizeECEF = Gl, t1.globePixelsToTileUnits = function(t1, e1) {
            return ko / (512 * Math.pow(2, t1)) * ql(Pl(e1));
        }, t1.globePoleMatrixForTile = function(t1, e1, r) {
            const n = Eo(new Float64Array(16)), i = (e1 / (1 << t1) - .5) * Math.PI * 2;
            return Fo(n, r.globeMatrix, i), Float32Array.from(n);
        }, t1.globeTileBounds = Pl, t1.globeTiltAtLngLat = Yl, t1.globeToMercatorTransition = Kl, t1.globeUseCustomAntiAliasing = function(t1, e1, r) {
            const n = Kl(r.zoom), i = t1.style.map._antialias, s = !!e1.extStandardDerivatives, a = e1.extStandardDerivativesForceOff || t1.terrain && t1.terrain.exaggeration() > 0;
            return 0 === n && !i && !a && s;
        }, t1.identity = Eo, t1.identity$1 = hl, t1.invert = Co, t1.isFullscreen = function() {
            return !!e1.document.fullscreenElement || !!e1.document.webkitFullscreenElement;
        }, t1.isLngLatBehindGlobe = Hl, t1.isMapAuthenticated = function(t1) {
            return Dt.has(t1);
        }, t1.isMapboxURL = mt, t1.isSafariWithAntialiasingBug = function(t1) {
            const e1 = t1.navigator ? t1.navigator.userAgent : null;
            return !!Z(t1) && e1 && (e1.match("Version/15.4") || e1.match("Version/15.5") || e1.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t1.latFromMercatorY = lu, t1.latLngToECEF = $l, t1.len = al, t1.length = qo, t1.length$1 = function(t1) {
            return Math.hypot(t1[0], t1[1], t1[2], t1[3]);
        }, t1.lngFromMercatorX = ou, t1.loadVectorTile = my, t1.makeRequest = lt, t1.mapValue = function(t1, e1, r, n, i) {
            return S((t1 - e1) / (r - e1) * (i - n) + n, n, i);
        }, t1.mercatorScale = hu, t1.mercatorXfromLng = iu, t1.mercatorYfromLat = su, t1.mercatorZfromAltitude = au, t1.mul = Uo, t1.mul$1 = sl, t1.multiply = Po, t1.multiply$1 = Bo, t1.multiply$2 = Zo, t1.nextPowerOfTwo = P, t1.normalize = Jo, t1.normalize$1 = dl, t1.normalize$2 = ll, t1.number = Mr, t1.ortho = function(t1, e1, r, n, i, s, a) {
            var o = 1 / (e1 - r), l = 1 / (n - i), u = 1 / (s - a);
            return t1[0] = -2 * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 2 * u, t1[11] = 0, t1[12] = (e1 + r) * o, t1[13] = (i + n) * l, t1[14] = (a + s) * u, t1[15] = 1, t1;
        }, t1.pbf = op, t1.perspective = function(t1, e1, r, n, i) {
            var s, a = 1 / Math.tan(e1 / 2);
            return t1[0] = a / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = a, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0 ? (t1[10] = (i + n) * (s = 1 / (n - i)), t1[14] = 2 * i * n * s) : (t1[10] = -1, t1[14] = -2 * n), t1;
        }, t1.pick = function(t1, e1) {
            const r = {};
            for(let n = 0; n < e1.length; n++){
                const i = e1[n];
                i in t1 && (r[i] = t1[i]);
            }
            return r;
        }, t1.plugin = js, t1.pointGeometry = d, t1.polesInViewport = function(t1) {
            const e1 = Eo(new Float64Array(16));
            Po(e1, t1.pixelMatrix, t1.globeMatrix);
            const r = [
                0,
                Il,
                0
            ], n = [
                0,
                Ml,
                0
            ];
            return el(r, r, e1), el(n, n, e1), [
                r[0] > 0 && r[0] <= t1.width && r[1] > 0 && r[1] <= t1.height && !Hl(t1, new ru(t1.center.lat, 90)),
                n[0] > 0 && n[0] <= t1.width && n[1] > 0 && n[1] <= t1.height && !Hl(t1, new ru(t1.center.lat, -90))
            ];
        }, t1.polygonContainsPoint = Du, t1.polygonIntersectsBox = Vu, t1.polygonIntersectsPolygon = ku, t1.polygonizeBounds = function(t1, e1, r = 0, n = !0) {
            const i = new d(r, r), s = t1.sub(i), a = e1.add(i), o = [
                s,
                new d(a.x, s.y),
                a,
                new d(s.x, a.y)
            ];
            return n && o.push(s.clone()), o;
        }, t1.posAttributes = xl, t1.postMapLoadEvent = zt, t1.postPerformanceEvent = Et, t1.postTurnstileEvent = Mt, t1.potpack = Cp, t1.prevPowerOfTwo = function(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t1) / Math.LN2));
        }, t1.radToDeg = v, t1.refProperties = [
            "type",
            "source",
            "source-layer",
            "minzoom",
            "maxzoom",
            "filter",
            "layout"
        ], t1.registerForPluginStateChange = function(t1) {
            return t1({
                pluginStatus: Cs,
                pluginURL: Ps
            }), Ls.on("pluginStateChange", t1), t1;
        }, t1.removeAuthState = function(t1) {
            Dt.delete(t1);
        }, t1.renderColorRamp = ec, t1.resample = du, t1.rotateX = Lo, t1.rotateX$1 = pl, t1.rotateY = Fo, t1.rotateY$1 = fl, t1.rotateZ = function(t1, e1, r) {
            var n = Math.sin(r), i = Math.cos(r), s = e1[0], a = e1[1], o = e1[2], l = e1[3], u = e1[4], c = e1[5], h = e1[6], p = e1[7];
            return e1 !== t1 && (t1[8] = e1[8], t1[9] = e1[9], t1[10] = e1[10], t1[11] = e1[11], t1[12] = e1[12], t1[13] = e1[13], t1[14] = e1[14], t1[15] = e1[15]), t1[0] = s * i + u * n, t1[1] = a * i + c * n, t1[2] = o * i + h * n, t1[3] = l * i + p * n, t1[4] = u * i - s * n, t1[5] = c * i - a * n, t1[6] = h * i - o * n, t1[7] = p * i - l * n, t1;
        }, t1.rotateZ$1 = function(t1, e1, r) {
            r *= .5;
            var n = e1[0], i = e1[1], s = e1[2], a = e1[3], o = Math.sin(r), l = Math.cos(r);
            return t1[0] = n * l + i * o, t1[1] = i * l - n * o, t1[2] = s * l + a * o, t1[3] = a * l - s * o, t1;
        }, t1.scale = Vo, t1.scale$1 = ol, t1.scale$2 = Ho, t1.scaleAndAdd = Wo, t1.set = function(t1, e1, r, n) {
            return t1[0] = e1, t1[1] = r, t1[2] = n, t1;
        }, t1.setCacheLimits = function(t1, e1) {
            Q = t1, tt = e1;
        }, t1.setColumn = function(t1, e1, r) {
            t1[4 * e1 + 0] = r[0], t1[4 * e1 + 1] = r[1], t1[4 * e1 + 2] = r[2], t1[4 * e1 + 3] = r[3];
        }, t1.setRTLTextPlugin = function(t1, e1, r = !1) {
            if (Cs === Ts || Cs === zs || Cs === Bs) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Ps = Nt.resolveURL(t1), Cs = Ts, Es = e1, Vs(), r || Rs();
        }, t1.smoothstep = k, t1.spec = Ht, t1.squaredLength = function(t1) {
            var e1 = t1[0], r = t1[1], n = t1[2];
            return e1 * e1 + r * r + n * n;
        }, t1.storeAuthState = function(t1, e1) {
            e1 ? Dt.add(t1) : Dt.delete(t1);
        }, t1.sub = il, t1.subtract = Xo, t1.symbolSize = rp, t1.tileAABB = function(t1, e1, r, n, i, s, a, o, l) {
            if ("globe" === l.name) return Fl(t1, e1, new kh(r, n, i));
            const u = Vf({
                z: r,
                x: n,
                y: i
            }, l);
            return new _l([
                (s + u.x / u.scale) * e1,
                e1 * (u.y / u.scale),
                a
            ], [
                (s + u.x2 / u.scale) * e1,
                e1 * (u.y2 / u.scale),
                o
            ]);
        }, t1.tileCornersToBounds = Rl, t1.tileTransform = Vf, t1.transformMat3 = function(t1, e1, r) {
            var n = e1[0], i = e1[1], s = e1[2];
            return t1[0] = n * r[0] + i * r[3] + s * r[6], t1[1] = n * r[1] + i * r[4] + s * r[7], t1[2] = n * r[2] + i * r[5] + s * r[8], t1;
        }, t1.transformMat4 = el, t1.transformMat4$1 = ul, t1.transformQuat = rl, t1.transitionTileAABBinECEF = Vl, t1.translate = Do, t1.transpose = function(t1, e1) {
            if (t1 === e1) {
                var r = e1[1], n = e1[2], i = e1[5];
                t1[1] = e1[3], t1[2] = e1[6], t1[3] = r, t1[5] = e1[7], t1[6] = n, t1[7] = i;
            } else t1[0] = e1[0], t1[1] = e1[3], t1[2] = e1[6], t1[3] = e1[1], t1[4] = e1[4], t1[5] = e1[7], t1[6] = e1[2], t1[7] = e1[5], t1[8] = e1[8];
            return t1;
        }, t1.triggerPluginCompletionEvent = Ds, t1.uniqueId = E, t1.updateGlobeVertexNormal = function(t1, e1, r, n, i) {
            const s = 5 * e1 + 2;
            t1.float32[s + 0] = r, t1.float32[s + 1] = n, t1.float32[s + 2] = i;
        }, t1.validateCustomStyleLayer = function(t1) {
            const e1 = [], r = t1.id;
            return void 0 === r && e1.push({
                message: `layers.${r}: missing required property "id"`
            }), void 0 === t1.render && e1.push({
                message: `layers.${r}: missing required method "render"`
            }), t1.renderingMode && "2d" !== t1.renderingMode && "3d" !== t1.renderingMode && e1.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
            }), e1;
        }, t1.validateFilter = (t1)=>Fi(xi(t1)), t1.validateFog = (t1)=>Fi(Bi(t1)), t1.validateLayer = (t1)=>Fi(Ai(t1)), t1.validateLight = (t1)=>Fi(Ti(t1)), t1.validateSource = (t1)=>Fi(Ii(t1)), t1.validateStyle = Di, t1.validateTerrain = (t1)=>Fi(zi(t1)), t1.values = T, t1.vectorTile = Zc, t1.version = r, t1.warnOnce = $, t1.window = e1, t1.wrap = I;
    });
    define([
        "./shared"
    ], function(e1) {
        "use strict";
        function t1(e1) {
            if ("number" == typeof e1 || "boolean" == typeof e1 || "string" == typeof e1 || null == e1) return JSON.stringify(e1);
            if (Array.isArray(e1)) {
                let r = "[";
                for (const o of e1)r += `${t1(o)},`;
                return `${r}]`;
            }
            let r = "{";
            for (const o of Object.keys(e1).sort())r += `${o}:${t1(e1[o])},`;
            return `${r}}`;
        }
        function r(r) {
            let o = "";
            for (const n of e1.refProperties)o += `/${t1(r[n])}`;
            return o;
        }
        class o {
            constructor(e1){
                this.keyCache = {}, e1 && this.replace(e1);
            }
            replace(e1) {
                this._layerConfigs = {}, this._layers = {}, this.update(e1, []);
            }
            update(t1, o) {
                for (const r of t1)this._layerConfigs[r.id] = r, (this._layers[r.id] = e1.createStyleLayer(r)).compileFilter(), this.keyCache[r.id] && delete this.keyCache[r.id];
                for (const e1 of o)delete this.keyCache[e1], delete this._layerConfigs[e1], delete this._layers[e1];
                this.familiesBySource = {};
                const n = function(e1, t1) {
                    const o = {};
                    for(let n = 0; n < e1.length; n++){
                        const i = t1 && t1[e1[n].id] || r(e1[n]);
                        t1 && (t1[e1[n].id] = i);
                        let s = o[i];
                        s || (s = o[i] = []), s.push(e1[n]);
                    }
                    const n = [];
                    for(const e1 in o)n.push(o[e1]);
                    return n;
                }(e1.values(this._layerConfigs), this.keyCache);
                for (const e1 of n){
                    const t1 = e1.map((e1)=>this._layers[e1.id]), r = t1[0];
                    if ("none" === r.visibility) continue;
                    const o = r.source || "";
                    let n = this.familiesBySource[o];
                    n || (n = this.familiesBySource[o] = {});
                    const i = r.sourceLayer || "_geojsonTileLayer";
                    let s = n[i];
                    s || (s = n[i] = []), s.push(t1);
                }
            }
        }
        class n {
            loadTile(t1, r) {
                const { uid: o , encoding: n , rawImageData: i , padding: s , buildQuadTree: a  } = t1, l = e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap ? this.getImageData(i, s) : i;
                r(null, new e1.DEMData(o, l, n, s < 1, a));
            }
            getImageData(e1, t1) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e1.width, e1.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })), this.offscreenCanvas.width = e1.width, this.offscreenCanvas.height = e1.height, this.offscreenCanvasContext.drawImage(e1, 0, 0, e1.width, e1.height);
                const r = this.offscreenCanvasContext.getImageData(-t1, -t1, e1.width + 2 * t1, e1.height + 2 * t1);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r;
            }
        }
        var i = function e1(t1, r) {
            var o, n = t1 && t1.type;
            if ("FeatureCollection" === n) for(o = 0; o < t1.features.length; o++)e1(t1.features[o], r);
            else if ("GeometryCollection" === n) for(o = 0; o < t1.geometries.length; o++)e1(t1.geometries[o], r);
            else if ("Feature" === n) e1(t1.geometry, r);
            else if ("Polygon" === n) s(t1.coordinates, r);
            else if ("MultiPolygon" === n) for(o = 0; o < t1.coordinates.length; o++)s(t1.coordinates[o], r);
            return t1;
        };
        function s(e1, t1) {
            if (0 !== e1.length) {
                a(e1[0], t1);
                for(var r = 1; r < e1.length; r++)a(e1[r], !t1);
            }
        }
        function a(e1, t1) {
            for(var r = 0, o = 0, n = 0, i = e1.length, s = i - 1; n < i; s = n++){
                var a = (e1[n][0] - e1[s][0]) * (e1[s][1] + e1[n][1]), l = r + a;
                o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r, r = l;
            }
            r + o >= 0 != !!t1 && e1.reverse();
        }
        const l = e1.VectorTileFeature.prototype.toGeoJSON;
        class u {
            constructor(t1){
                this._feature = t1, this.extent = e1.EXTENT, this.type = t1.type, this.properties = t1.tags, "id" in t1 && !isNaN(t1.id) && (this.id = parseInt(t1.id, 10));
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const t1 = [];
                    for (const r of this._feature.geometry)t1.push([
                        new e1.pointGeometry(r[0], r[1])
                    ]);
                    return t1;
                }
                {
                    const t1 = [];
                    for (const r of this._feature.geometry){
                        const o = [];
                        for (const t1 of r)o.push(new e1.pointGeometry(t1[0], t1[1]));
                        t1.push(o);
                    }
                    return t1;
                }
            }
            toGeoJSON(e1, t1, r) {
                return l.call(this, e1, t1, r);
            }
        }
        class h {
            constructor(t1){
                this.layers = {
                    _geojsonTileLayer: this
                }, this.name = "_geojsonTileLayer", this.extent = e1.EXTENT, this.length = t1.length, this._features = t1;
            }
            feature(e1) {
                return new u(this._features[e1]);
            }
        }
        var c = {}, f = {
            get exports () {
                return c;
            },
            set exports (e){
                c = e;
            }
        }, p = e1.pointGeometry, g = e1.vectorTile.VectorTileFeature, d = m;
        function m(e1, t1) {
            this.options = t1 || {}, this.features = e1, this.length = e1.length;
        }
        function y(e1, t1) {
            this.id = "number" == typeof e1.id ? e1.id : void 0, this.type = e1.type, this.rawGeometry = 1 === e1.type ? [
                e1.geometry
            ] : e1.geometry, this.properties = e1.tags, this.extent = t1 || 4096;
        }
        m.prototype.feature = function(e1) {
            return new y(this.features[e1], this.options.extent);
        }, y.prototype.loadGeometry = function() {
            var e1 = this.rawGeometry;
            this.geometry = [];
            for(var t1 = 0; t1 < e1.length; t1++){
                for(var r = e1[t1], o = [], n = 0; n < r.length; n++)o.push(new p(r[n][0], r[n][1]));
                this.geometry.push(o);
            }
            return this.geometry;
        }, y.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for(var e1 = this.geometry, t1 = 1 / 0, r = -1 / 0, o = 1 / 0, n = -1 / 0, i = 0; i < e1.length; i++)for(var s = e1[i], a = 0; a < s.length; a++){
                var l = s[a];
                t1 = Math.min(t1, l.x), r = Math.max(r, l.x), o = Math.min(o, l.y), n = Math.max(n, l.y);
            }
            return [
                t1,
                o,
                r,
                n
            ];
        }, y.prototype.toGeoJSON = g.prototype.toGeoJSON;
        var v = e1.pbf, x = d;
        function w(e1) {
            var t1 = new v;
            return function(e1, t1) {
                for(var r in e1.layers)t1.writeMessage(3, S, e1.layers[r]);
            }(e1, t1), t1.finish();
        }
        function S(e1, t1) {
            var r;
            t1.writeVarintField(15, e1.version || 1), t1.writeStringField(1, e1.name || ""), t1.writeVarintField(5, e1.extent || 4096);
            var o = {
                keys: [],
                values: [],
                keycache: {},
                valuecache: {}
            };
            for(r = 0; r < e1.length; r++)o.feature = e1.feature(r), t1.writeMessage(2, M, o);
            var n = o.keys;
            for(r = 0; r < n.length; r++)t1.writeStringField(3, n[r]);
            var i = o.values;
            for(r = 0; r < i.length; r++)t1.writeMessage(4, T, i[r]);
        }
        function M(e1, t1) {
            var r = e1.feature;
            void 0 !== r.id && t1.writeVarintField(1, r.id), t1.writeMessage(2, P, e1), t1.writeVarintField(3, r.type), t1.writeMessage(4, I, r);
        }
        function P(e1, t1) {
            var r = e1.feature, o = e1.keys, n = e1.values, i = e1.keycache, s = e1.valuecache;
            for(var a in r.properties){
                var l = r.properties[a], u = i[a];
                if (null !== l) {
                    void 0 === u && (o.push(a), i[a] = u = o.length - 1), t1.writeVarint(u);
                    var h = typeof l;
                    "string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));
                    var c = h + ":" + l, f = s[c];
                    void 0 === f && (n.push(l), s[c] = f = n.length - 1), t1.writeVarint(f);
                }
            }
        }
        function b(e1, t1) {
            return (t1 << 3) + (7 & e1);
        }
        function k(e1) {
            return e1 << 1 ^ e1 >> 31;
        }
        function I(e1, t1) {
            for(var r = e1.loadGeometry(), o = e1.type, n = 0, i = 0, s = r.length, a = 0; a < s; a++){
                var l = r[a], u = 1;
                1 === o && (u = l.length), t1.writeVarint(b(1, u));
                for(var h = 3 === o ? l.length - 1 : l.length, c = 0; c < h; c++){
                    1 === c && 1 !== o && t1.writeVarint(b(2, h - 1));
                    var f = l[c].x - n, p = l[c].y - i;
                    t1.writeVarint(k(f)), t1.writeVarint(k(p)), n += f, i += p;
                }
                3 === o && t1.writeVarint(b(7, 1));
            }
        }
        function T(e1, t1) {
            var r = typeof e1;
            "string" === r ? t1.writeStringField(1, e1) : "boolean" === r ? t1.writeBooleanField(7, e1) : "number" === r && (e1 % 1 != 0 ? t1.writeDoubleField(3, e1) : e1 < 0 ? t1.writeSVarintField(6, e1) : t1.writeVarintField(5, e1));
        }
        function _(e1, t1, r, o, n, i) {
            if (n - o <= r) return;
            const s = o + n >> 1;
            L(e1, t1, s, o, n, i % 2), _(e1, t1, r, o, s - 1, i + 1), _(e1, t1, r, s + 1, n, i + 1);
        }
        function L(e1, t1, r, o, n, i) {
            for(; n > o;){
                if (n - o > 600) {
                    const s = n - o + 1, a = r - o + 1, l = Math.log(s), u = .5 * Math.exp(2 * l / 3), h = .5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1);
                    L(e1, t1, r, Math.max(o, Math.floor(r - a * u / s + h)), Math.min(n, Math.floor(r + (s - a) * u / s + h)), i);
                }
                const s = t1[2 * r + i];
                let a = o, l = n;
                for(C(e1, t1, o, r), t1[2 * n + i] > s && C(e1, t1, o, n); a < l;){
                    for(C(e1, t1, a, l), a++, l--; t1[2 * a + i] < s;)a++;
                    for(; t1[2 * l + i] > s;)l--;
                }
                t1[2 * o + i] === s ? C(e1, t1, o, l) : (l++, C(e1, t1, l, n)), l <= r && (o = l + 1), r <= l && (n = l - 1);
            }
        }
        function C(e1, t1, r, o) {
            O(e1, r, o), O(t1, 2 * r, 2 * o), O(t1, 2 * r + 1, 2 * o + 1);
        }
        function O(e1, t1, r) {
            const o = e1[t1];
            e1[t1] = e1[r], e1[r] = o;
        }
        function z(e1, t1, r, o) {
            const n = e1 - r, i = t1 - o;
            return n * n + i * i;
        }
        f.exports = w, c.fromVectorTileJs = w, c.fromGeojsonVt = function(e1, t1) {
            t1 = t1 || {};
            var r = {};
            for(var o in e1)r[o] = new x(e1[o].features, t1), r[o].name = o, r[o].version = t1.version, r[o].extent = t1.extent;
            return w({
                layers: r
            });
        }, c.GeoJSONWrapper = x;
        const E = (e1)=>e1[0], F = (e1)=>e1[1];
        class N {
            constructor(e1, t1 = E, r = F, o = 64, n = Float64Array){
                this.nodeSize = o, this.points = e1;
                const i = e1.length < 65536 ? Uint16Array : Uint32Array, s = this.ids = new i(e1.length), a = this.coords = new n(2 * e1.length);
                for(let o = 0; o < e1.length; o++)s[o] = o, a[2 * o] = t1(e1[o]), a[2 * o + 1] = r(e1[o]);
                _(s, a, o, 0, s.length - 1, 0);
            }
            range(e1, t1, r, o) {
                return function(e1, t1, r, o, n, i, s) {
                    const a = [
                        0,
                        e1.length - 1,
                        0
                    ], l = [];
                    let u, h;
                    for(; a.length;){
                        const c = a.pop(), f = a.pop(), p = a.pop();
                        if (f - p <= s) {
                            for(let s = p; s <= f; s++)u = t1[2 * s], h = t1[2 * s + 1], u >= r && u <= n && h >= o && h <= i && l.push(e1[s]);
                            continue;
                        }
                        const g = Math.floor((p + f) / 2);
                        u = t1[2 * g], h = t1[2 * g + 1], u >= r && u <= n && h >= o && h <= i && l.push(e1[g]);
                        const d = (c + 1) % 2;
                        (0 === c ? r <= u : o <= h) && (a.push(p), a.push(g - 1), a.push(d)), (0 === c ? n >= u : i >= h) && (a.push(g + 1), a.push(f), a.push(d));
                    }
                    return l;
                }(this.ids, this.coords, e1, t1, r, o, this.nodeSize);
            }
            within(e1, t1, r) {
                return function(e1, t1, r, o, n, i) {
                    const s = [
                        0,
                        e1.length - 1,
                        0
                    ], a = [], l = n * n;
                    for(; s.length;){
                        const u = s.pop(), h = s.pop(), c = s.pop();
                        if (h - c <= i) {
                            for(let n = c; n <= h; n++)z(t1[2 * n], t1[2 * n + 1], r, o) <= l && a.push(e1[n]);
                            continue;
                        }
                        const f = Math.floor((c + h) / 2), p = t1[2 * f], g = t1[2 * f + 1];
                        z(p, g, r, o) <= l && a.push(e1[f]);
                        const d = (u + 1) % 2;
                        (0 === u ? r - n <= p : o - n <= g) && (s.push(c), s.push(f - 1), s.push(d)), (0 === u ? r + n >= p : o + n >= g) && (s.push(f + 1), s.push(h), s.push(d));
                    }
                    return a;
                }(this.ids, this.coords, e1, t1, r, this.nodeSize);
            }
        }
        const j = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (e1)=>e1
        }, Z = Math.fround || (G = new Float32Array(1), (e1)=>(G[0] = +e1, G[0]));
        var G;
        class J {
            constructor(e1){
                this.options = B(Object.create(j), e1), this.trees = new Array(this.options.maxZoom + 1);
            }
            load(e1) {
                const { log: t1 , minZoom: r , maxZoom: o , nodeSize: n  } = this.options;
                t1 && console.time("total time");
                const i = `prepare ${e1.length} points`;
                t1 && console.time(i), this.points = e1;
                let s = [];
                for(let t1 = 0; t1 < e1.length; t1++)e1[t1].geometry && s.push(Y(e1[t1], t1));
                this.trees[o + 1] = new N(s, R, q, n, Float32Array), t1 && console.timeEnd(i);
                for(let e1 = o; e1 >= r; e1--){
                    const r = +Date.now();
                    s = this._cluster(s, e1), this.trees[e1] = new N(s, R, q, n, Float32Array), t1 && console.log("z%d: %d clusters in %dms", e1, s.length, +Date.now() - r);
                }
                return t1 && console.timeEnd("total time"), this;
            }
            getClusters(e1, t1) {
                let r = ((e1[0] + 180) % 360 + 360) % 360 - 180;
                const o = Math.max(-90, Math.min(90, e1[1]));
                let n = 180 === e1[2] ? 180 : ((e1[2] + 180) % 360 + 360) % 360 - 180;
                const i = Math.max(-90, Math.min(90, e1[3]));
                if (e1[2] - e1[0] >= 360) r = -180, n = 180;
                else if (r > n) {
                    const e1 = this.getClusters([
                        r,
                        o,
                        180,
                        i
                    ], t1), s = this.getClusters([
                        -180,
                        o,
                        n,
                        i
                    ], t1);
                    return e1.concat(s);
                }
                const s = this.trees[this._limitZoom(t1)], a = s.range(A(r), D(i), A(n), D(o)), l = [];
                for (const e1 of a){
                    const t1 = s.points[e1];
                    l.push(t1.numPoints ? X(t1) : this.points[t1.index]);
                }
                return l;
            }
            getChildren(e1) {
                const t1 = this._getOriginId(e1), r = this._getOriginZoom(e1), o = "No cluster with the specified id.", n = this.trees[r];
                if (!n) throw new Error(o);
                const i = n.points[t1];
                if (!i) throw new Error(o);
                const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), a = n.within(i.x, i.y, s), l = [];
                for (const t1 of a){
                    const r = n.points[t1];
                    r.parentId === e1 && l.push(r.numPoints ? X(r) : this.points[r.index]);
                }
                if (0 === l.length) throw new Error(o);
                return l;
            }
            getLeaves(e1, t1, r) {
                const o = [];
                return this._appendLeaves(o, e1, t1 = t1 || 10, r = r || 0, 0), o;
            }
            getTile(e1, t1, r) {
                const o = this.trees[this._limitZoom(e1)], n = Math.pow(2, e1), { extent: i , radius: s  } = this.options, a = s / i, l = (r - a) / n, u = (r + 1 + a) / n, h = {
                    features: []
                };
                return this._addTileFeatures(o.range((t1 - a) / n, l, (t1 + 1 + a) / n, u), o.points, t1, r, n, h), 0 === t1 && this._addTileFeatures(o.range(1 - a / n, l, 1, u), o.points, n, r, n, h), t1 === n - 1 && this._addTileFeatures(o.range(0, l, a / n, u), o.points, -1, r, n, h), h.features.length ? h : null;
            }
            getClusterExpansionZoom(e1) {
                let t1 = this._getOriginZoom(e1) - 1;
                for(; t1 <= this.options.maxZoom;){
                    const r = this.getChildren(e1);
                    if (t1++, 1 !== r.length) break;
                    e1 = r[0].properties.cluster_id;
                }
                return t1;
            }
            _appendLeaves(e1, t1, r, o, n) {
                const i = this.getChildren(t1);
                for (const t1 of i){
                    const i = t1.properties;
                    if (i && i.cluster ? n + i.point_count <= o ? n += i.point_count : n = this._appendLeaves(e1, i.cluster_id, r, o, n) : n < o ? n++ : e1.push(t1), e1.length === r) break;
                }
                return n;
            }
            _addTileFeatures(e1, t1, r, o, n, i) {
                for (const s of e1){
                    const e1 = t1[s], a = e1.numPoints;
                    let l, u, h;
                    if (a) l = V(e1), u = e1.x, h = e1.y;
                    else {
                        const t1 = this.points[e1.index];
                        l = t1.properties, u = A(t1.geometry.coordinates[0]), h = D(t1.geometry.coordinates[1]);
                    }
                    const c = {
                        type: 1,
                        geometry: [
                            [
                                Math.round(this.options.extent * (u * n - r)),
                                Math.round(this.options.extent * (h * n - o))
                            ]
                        ],
                        tags: l
                    };
                    let f;
                    a ? f = e1.id : this.options.generateId ? f = e1.index : this.points[e1.index].id && (f = this.points[e1.index].id), void 0 !== f && (c.id = f), i.features.push(c);
                }
            }
            _limitZoom(e1) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e1), this.options.maxZoom + 1));
            }
            _cluster(e1, t1) {
                const r = [], { radius: o , extent: n , reduce: i , minPoints: s  } = this.options, a = o / (n * Math.pow(2, t1));
                for(let o = 0; o < e1.length; o++){
                    const n = e1[o];
                    if (n.zoom <= t1) continue;
                    n.zoom = t1;
                    const l = this.trees[t1 + 1], u = l.within(n.x, n.y, a), h = n.numPoints || 1;
                    let c = h;
                    for (const e1 of u){
                        const r = l.points[e1];
                        r.zoom > t1 && (c += r.numPoints || 1);
                    }
                    if (c > h && c >= s) {
                        let e1 = n.x * h, s = n.y * h, a = i && h > 1 ? this._map(n, !0) : null;
                        const f = (o << 5) + (t1 + 1) + this.points.length;
                        for (const r of u){
                            const o = l.points[r];
                            if (o.zoom <= t1) continue;
                            o.zoom = t1;
                            const u = o.numPoints || 1;
                            e1 += o.x * u, s += o.y * u, o.parentId = f, i && (a || (a = this._map(n, !0)), i(a, this._map(o)));
                        }
                        n.parentId = f, r.push(W(e1 / c, s / c, f, c, a));
                    } else if (r.push(n), c > 1) for (const e1 of u){
                        const o = l.points[e1];
                        o.zoom <= t1 || (o.zoom = t1, r.push(o));
                    }
                }
                return r;
            }
            _getOriginId(e1) {
                return e1 - this.points.length >> 5;
            }
            _getOriginZoom(e1) {
                return (e1 - this.points.length) % 32;
            }
            _map(e1, t1) {
                if (e1.numPoints) return t1 ? B({}, e1.properties) : e1.properties;
                const r = this.points[e1.index].properties, o = this.options.map(r);
                return t1 && o === r ? B({}, o) : o;
            }
        }
        function W(e1, t1, r, o, n) {
            return {
                x: Z(e1),
                y: Z(t1),
                zoom: 1 / 0,
                id: r,
                parentId: -1,
                numPoints: o,
                properties: n
            };
        }
        function Y(e1, t1) {
            const [r, o] = e1.geometry.coordinates;
            return {
                x: Z(A(r)),
                y: Z(D(o)),
                zoom: 1 / 0,
                index: t1,
                parentId: -1
            };
        }
        function X(e1) {
            var t1;
            return {
                type: "Feature",
                id: e1.id,
                properties: V(e1),
                geometry: {
                    type: "Point",
                    coordinates: [
                        (t1 = e1.x, 360 * (t1 - .5)),
                        $(e1.y)
                    ]
                }
            };
        }
        function V(e1) {
            const t1 = e1.numPoints, r = t1 >= 1e4 ? `${Math.round(t1 / 1e3)}k` : t1 >= 1e3 ? Math.round(t1 / 100) / 10 + "k" : t1;
            return B(B({}, e1.properties), {
                cluster: !0,
                cluster_id: e1.id,
                point_count: t1,
                point_count_abbreviated: r
            });
        }
        function A(e1) {
            return e1 / 360 + .5;
        }
        function D(e1) {
            const t1 = Math.sin(e1 * Math.PI / 180), r = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return r < 0 ? 0 : r > 1 ? 1 : r;
        }
        function $(e1) {
            const t1 = (180 - 360 * e1) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t1)) / Math.PI - 90;
        }
        function B(e1, t1) {
            for(const r in t1)e1[r] = t1[r];
            return e1;
        }
        function R(e1) {
            return e1.x;
        }
        function q(e1) {
            return e1.y;
        }
        function U(e1, t1, r, o) {
            for(var n, i = o, s = r - t1 >> 1, a = r - t1, l = e1[t1], u = e1[t1 + 1], h = e1[r], c = e1[r + 1], f = t1 + 3; f < r; f += 3){
                var p = Q(e1[f], e1[f + 1], l, u, h, c);
                if (p > i) n = f, i = p;
                else if (p === i) {
                    var g = Math.abs(f - s);
                    g < a && (n = f, a = g);
                }
            }
            i > o && (n - t1 > 3 && U(e1, t1, n, o), e1[n + 2] = i, r - n > 3 && U(e1, n, r, o));
        }
        function Q(e1, t1, r, o, n, i) {
            var s = n - r, a = i - o;
            if (0 !== s || 0 !== a) {
                var l = ((e1 - r) * s + (t1 - o) * a) / (s * s + a * a);
                l > 1 ? (r = n, o = i) : l > 0 && (r += s * l, o += a * l);
            }
            return (s = e1 - r) * s + (a = t1 - o) * a;
        }
        function H(e1, t1, r, o) {
            var n = {
                id: void 0 === e1 ? null : e1,
                type: t1,
                geometry: r,
                tags: o,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            return function(e1) {
                var t1 = e1.geometry, r = e1.type;
                if ("Point" === r || "MultiPoint" === r || "LineString" === r) K(e1, t1);
                else if ("Polygon" === r || "MultiLineString" === r) for(var o = 0; o < t1.length; o++)K(e1, t1[o]);
                else if ("MultiPolygon" === r) for(o = 0; o < t1.length; o++)for(var n = 0; n < t1[o].length; n++)K(e1, t1[o][n]);
            }(n), n;
        }
        function K(e1, t1) {
            for(var r = 0; r < t1.length; r += 3)e1.minX = Math.min(e1.minX, t1[r]), e1.minY = Math.min(e1.minY, t1[r + 1]), e1.maxX = Math.max(e1.maxX, t1[r]), e1.maxY = Math.max(e1.maxY, t1[r + 1]);
        }
        function ee(e1, t1, r, o) {
            if (t1.geometry) {
                var n = t1.geometry.coordinates, i = t1.geometry.type, s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2), a = [], l = t1.id;
                if (r.promoteId ? l = t1.properties[r.promoteId] : r.generateId && (l = o || 0), "Point" === i) te(n, a);
                else if ("MultiPoint" === i) for(var u = 0; u < n.length; u++)te(n[u], a);
                else if ("LineString" === i) re(n, a, s, !1);
                else if ("MultiLineString" === i) {
                    if (r.lineMetrics) {
                        for(u = 0; u < n.length; u++)re(n[u], a = [], s, !1), e1.push(H(l, "LineString", a, t1.properties));
                        return;
                    }
                    oe(n, a, s, !1);
                } else if ("Polygon" === i) oe(n, a, s, !0);
                else {
                    if ("MultiPolygon" !== i) {
                        if ("GeometryCollection" === i) {
                            for(u = 0; u < t1.geometry.geometries.length; u++)ee(e1, {
                                id: l,
                                geometry: t1.geometry.geometries[u],
                                properties: t1.properties
                            }, r, o);
                            return;
                        }
                        throw new Error("Input data is not a valid GeoJSON object.");
                    }
                    for(u = 0; u < n.length; u++){
                        var h = [];
                        oe(n[u], h, s, !0), a.push(h);
                    }
                }
                e1.push(H(l, i, a, t1.properties));
            }
        }
        function te(e1, t1) {
            t1.push(ne(e1[0])), t1.push(ie(e1[1])), t1.push(0);
        }
        function re(e1, t1, r, o) {
            for(var n, i, s = 0, a = 0; a < e1.length; a++){
                var l = ne(e1[a][0]), u = ie(e1[a][1]);
                t1.push(l), t1.push(u), t1.push(0), a > 0 && (s += o ? (n * u - l * i) / 2 : Math.sqrt(Math.pow(l - n, 2) + Math.pow(u - i, 2))), n = l, i = u;
            }
            var h = t1.length - 3;
            t1[2] = 1, U(t1, 0, h, r), t1[h + 2] = 1, t1.size = Math.abs(s), t1.start = 0, t1.end = t1.size;
        }
        function oe(e1, t1, r, o) {
            for(var n = 0; n < e1.length; n++){
                var i = [];
                re(e1[n], i, r, o), t1.push(i);
            }
        }
        function ne(e1) {
            return e1 / 360 + .5;
        }
        function ie(e1) {
            var t1 = Math.sin(e1 * Math.PI / 180), r = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return r < 0 ? 0 : r > 1 ? 1 : r;
        }
        function se(e1, t1, r, o, n, i, s, a) {
            if (o /= t1, i >= (r /= t1) && s < o) return e1;
            if (s < r || i >= o) return null;
            for(var l = [], u = 0; u < e1.length; u++){
                var h = e1[u], c = h.geometry, f = h.type, p = 0 === n ? h.minX : h.minY, g = 0 === n ? h.maxX : h.maxY;
                if (p >= r && g < o) l.push(h);
                else if (!(g < r || p >= o)) {
                    var d = [];
                    if ("Point" === f || "MultiPoint" === f) ae(c, d, r, o, n);
                    else if ("LineString" === f) le(c, d, r, o, n, !1, a.lineMetrics);
                    else if ("MultiLineString" === f) he(c, d, r, o, n, !1);
                    else if ("Polygon" === f) he(c, d, r, o, n, !0);
                    else if ("MultiPolygon" === f) for(var m = 0; m < c.length; m++){
                        var y = [];
                        he(c[m], y, r, o, n, !0), y.length && d.push(y);
                    }
                    if (d.length) {
                        if (a.lineMetrics && "LineString" === f) {
                            for(m = 0; m < d.length; m++)l.push(H(h.id, f, d[m], h.tags));
                            continue;
                        }
                        "LineString" !== f && "MultiLineString" !== f || (1 === d.length ? (f = "LineString", d = d[0]) : f = "MultiLineString"), "Point" !== f && "MultiPoint" !== f || (f = 3 === d.length ? "Point" : "MultiPoint"), l.push(H(h.id, f, d, h.tags));
                    }
                }
            }
            return l.length ? l : null;
        }
        function ae(e1, t1, r, o, n) {
            for(var i = 0; i < e1.length; i += 3){
                var s = e1[i + n];
                s >= r && s <= o && (t1.push(e1[i]), t1.push(e1[i + 1]), t1.push(e1[i + 2]));
            }
        }
        function le(e1, t1, r, o, n, i, s) {
            for(var a, l, u = ue(e1), h = 0 === n ? fe : pe, c = e1.start, f = 0; f < e1.length - 3; f += 3){
                var p = e1[f], g = e1[f + 1], d = e1[f + 2], m = e1[f + 3], y = e1[f + 4], v = 0 === n ? p : g, x = 0 === n ? m : y, w = !1;
                s && (a = Math.sqrt(Math.pow(p - m, 2) + Math.pow(g - y, 2))), v < r ? x > r && (l = h(u, p, g, m, y, r), s && (u.start = c + a * l)) : v > o ? x < o && (l = h(u, p, g, m, y, o), s && (u.start = c + a * l)) : ce(u, p, g, d), x < r && v >= r && (l = h(u, p, g, m, y, r), w = !0), x > o && v <= o && (l = h(u, p, g, m, y, o), w = !0), !i && w && (s && (u.end = c + a * l), t1.push(u), u = ue(e1)), s && (c += a);
            }
            var S = e1.length - 3;
            p = e1[S], g = e1[S + 1], d = e1[S + 2], (v = 0 === n ? p : g) >= r && v <= o && ce(u, p, g, d), S = u.length - 3, i && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && ce(u, u[0], u[1], u[2]), u.length && t1.push(u);
        }
        function ue(e1) {
            var t1 = [];
            return t1.size = e1.size, t1.start = e1.start, t1.end = e1.end, t1;
        }
        function he(e1, t1, r, o, n, i) {
            for(var s = 0; s < e1.length; s++)le(e1[s], t1, r, o, n, i, !1);
        }
        function ce(e1, t1, r, o) {
            e1.push(t1), e1.push(r), e1.push(o);
        }
        function fe(e1, t1, r, o, n, i) {
            var s = (i - t1) / (o - t1);
            return e1.push(i), e1.push(r + (n - r) * s), e1.push(1), s;
        }
        function pe(e1, t1, r, o, n, i) {
            var s = (i - r) / (n - r);
            return e1.push(t1 + (o - t1) * s), e1.push(i), e1.push(1), s;
        }
        function ge(e1, t1) {
            for(var r = [], o = 0; o < e1.length; o++){
                var n, i = e1[o], s = i.type;
                if ("Point" === s || "MultiPoint" === s || "LineString" === s) n = de(i.geometry, t1);
                else if ("MultiLineString" === s || "Polygon" === s) {
                    n = [];
                    for(var a = 0; a < i.geometry.length; a++)n.push(de(i.geometry[a], t1));
                } else if ("MultiPolygon" === s) for(n = [], a = 0; a < i.geometry.length; a++){
                    for(var l = [], u = 0; u < i.geometry[a].length; u++)l.push(de(i.geometry[a][u], t1));
                    n.push(l);
                }
                r.push(H(i.id, s, n, i.tags));
            }
            return r;
        }
        function de(e1, t1) {
            var r = [];
            r.size = e1.size, void 0 !== e1.start && (r.start = e1.start, r.end = e1.end);
            for(var o = 0; o < e1.length; o += 3)r.push(e1[o] + t1, e1[o + 1], e1[o + 2]);
            return r;
        }
        function me(e1, t1) {
            if (e1.transformed) return e1;
            var r, o, n, i = 1 << e1.z, s = e1.x, a = e1.y;
            for(r = 0; r < e1.features.length; r++){
                var l = e1.features[r], u = l.geometry, h = l.type;
                if (l.geometry = [], 1 === h) for(o = 0; o < u.length; o += 2)l.geometry.push(ye(u[o], u[o + 1], t1, i, s, a));
                else for(o = 0; o < u.length; o++){
                    var c = [];
                    for(n = 0; n < u[o].length; n += 2)c.push(ye(u[o][n], u[o][n + 1], t1, i, s, a));
                    l.geometry.push(c);
                }
            }
            return e1.transformed = !0, e1;
        }
        function ye(e1, t1, r, o, n, i) {
            return [
                Math.round(r * (e1 * o - n)),
                Math.round(r * (t1 * o - i))
            ];
        }
        function ve(e1, t1, r, o, n) {
            for(var i = t1 === n.maxZoom ? 0 : n.tolerance / ((1 << t1) * n.extent), s = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: 0,
                source: null,
                x: r,
                y: o,
                z: t1,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            }, a = 0; a < e1.length; a++){
                s.numFeatures++, xe(s, e1[a], i, n);
                var l = e1[a].minX, u = e1[a].minY, h = e1[a].maxX, c = e1[a].maxY;
                l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);
            }
            return s;
        }
        function xe(e1, t1, r, o) {
            var n = t1.geometry, i = t1.type, s = [];
            if ("Point" === i || "MultiPoint" === i) for(var a = 0; a < n.length; a += 3)s.push(n[a]), s.push(n[a + 1]), e1.numPoints++, e1.numSimplified++;
            else if ("LineString" === i) we(s, n, e1, r, !1, !1);
            else if ("MultiLineString" === i || "Polygon" === i) for(a = 0; a < n.length; a++)we(s, n[a], e1, r, "Polygon" === i, 0 === a);
            else if ("MultiPolygon" === i) for(var l = 0; l < n.length; l++){
                var u = n[l];
                for(a = 0; a < u.length; a++)we(s, u[a], e1, r, !0, 0 === a);
            }
            if (s.length) {
                var h = t1.tags || null;
                if ("LineString" === i && o.lineMetrics) {
                    for(var c in h = {}, t1.tags)h[c] = t1.tags[c];
                    h.mapbox_clip_start = n.start / n.size, h.mapbox_clip_end = n.end / n.size;
                }
                var f = {
                    geometry: s,
                    type: "Polygon" === i || "MultiPolygon" === i ? 3 : "LineString" === i || "MultiLineString" === i ? 2 : 1,
                    tags: h
                };
                null !== t1.id && (f.id = t1.id), e1.features.push(f);
            }
        }
        function we(e1, t1, r, o, n, i) {
            var s = o * o;
            if (o > 0 && t1.size < (n ? s : o)) r.numPoints += t1.length / 3;
            else {
                for(var a = [], l = 0; l < t1.length; l += 3)(0 === o || t1[l + 2] > s) && (r.numSimplified++, a.push(t1[l]), a.push(t1[l + 1])), r.numPoints++;
                n && function(e1, t1) {
                    for(var r = 0, o = 0, n = e1.length, i = n - 2; o < n; i = o, o += 2)r += (e1[o] - e1[i]) * (e1[o + 1] + e1[i + 1]);
                    if (r > 0 === t1) for(o = 0, n = e1.length; o < n / 2; o += 2){
                        var s = e1[o], a = e1[o + 1];
                        e1[o] = e1[n - 2 - o], e1[o + 1] = e1[n - 1 - o], e1[n - 2 - o] = s, e1[n - 1 - o] = a;
                    }
                }(a, i), e1.push(a);
            }
        }
        function Se(e1, t1) {
            var r = (t1 = this.options = function(e1, t1) {
                for(var r in t1)e1[r] = t1[r];
                return e1;
            }(Object.create(this.options), t1)).debug;
            if (r && console.time("preprocess data"), t1.maxZoom < 0 || t1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t1.promoteId && t1.generateId) throw new Error("promoteId and generateId cannot be used together.");
            var o = function(e1, t1) {
                var r = [];
                if ("FeatureCollection" === e1.type) for(var o = 0; o < e1.features.length; o++)ee(r, e1.features[o], t1, o);
                else ee(r, "Feature" === e1.type ? e1 : {
                    geometry: e1
                }, t1);
                return r;
            }(e1, t1);
            this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t1.indexMaxZoom, t1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o = function(e1, t1) {
                var r = t1.buffer / t1.extent, o = e1, n = se(e1, 1, -1 - r, r, 0, -1, 2, t1), i = se(e1, 1, 1 - r, 2 + r, 0, -1, 2, t1);
                return (n || i) && (o = se(e1, 1, -r, 1 + r, 0, -1, 2, t1) || [], n && (o = ge(n, 1).concat(o)), i && (o = o.concat(ge(i, -1)))), o;
            }(o, t1), o.length && this.splitTile(o, 0, 0, 0), r && (o.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function Me(e1, t1, r) {
            return 32 * ((1 << e1) * r + t1) + e1;
        }
        function Pe(e1, t1) {
            const r = e1.tileID.canonical;
            if (!this._geoJSONIndex) return t1(null, null);
            const o = this._geoJSONIndex.getTile(r.z, r.x, r.y);
            if (!o) return t1(null, null);
            const n = new h(o.features);
            let i = c(n);
            0 === i.byteOffset && i.byteLength === i.buffer.byteLength || (i = new Uint8Array(i)), t1(null, {
                vectorTile: n,
                rawData: i.buffer
            });
        }
        Se.prototype.options = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        }, Se.prototype.splitTile = function(e1, t1, r, o, n, i, s) {
            for(var a = [
                e1,
                t1,
                r,
                o
            ], l = this.options, u = l.debug; a.length;){
                o = a.pop(), r = a.pop(), t1 = a.pop(), e1 = a.pop();
                var h = 1 << t1, c = Me(t1, r, o), f = this.tiles[c];
                if (!f && (u > 1 && console.time("creation"), f = this.tiles[c] = ve(e1, t1, r, o, l), this.tileCoords.push({
                    z: t1,
                    x: r,
                    y: o
                }), u)) {
                    u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t1, r, o, f.numFeatures, f.numPoints, f.numSimplified), console.timeEnd("creation"));
                    var p = "z" + t1;
                    this.stats[p] = (this.stats[p] || 0) + 1, this.total++;
                }
                if (f.source = e1, n) {
                    if (t1 === l.maxZoom || t1 === n) continue;
                    var g = 1 << n - t1;
                    if (r !== Math.floor(i / g) || o !== Math.floor(s / g)) continue;
                } else if (t1 === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints) continue;
                if (f.source = null, 0 !== e1.length) {
                    u > 1 && console.time("clipping");
                    var d, m, y, v, x, w, S = .5 * l.buffer / l.extent, M = .5 - S, P = .5 + S, b = 1 + S;
                    d = m = y = v = null, x = se(e1, h, r - S, r + P, 0, f.minX, f.maxX, l), w = se(e1, h, r + M, r + b, 0, f.minX, f.maxX, l), e1 = null, x && (d = se(x, h, o - S, o + P, 1, f.minY, f.maxY, l), m = se(x, h, o + M, o + b, 1, f.minY, f.maxY, l), x = null), w && (y = se(w, h, o - S, o + P, 1, f.minY, f.maxY, l), v = se(w, h, o + M, o + b, 1, f.minY, f.maxY, l), w = null), u > 1 && console.timeEnd("clipping"), a.push(d || [], t1 + 1, 2 * r, 2 * o), a.push(m || [], t1 + 1, 2 * r, 2 * o + 1), a.push(y || [], t1 + 1, 2 * r + 1, 2 * o), a.push(v || [], t1 + 1, 2 * r + 1, 2 * o + 1);
                }
            }
        }, Se.prototype.getTile = function(e1, t1, r) {
            var o = this.options, n = o.extent, i = o.debug;
            if (e1 < 0 || e1 > 24) return null;
            var s = 1 << e1, a = Me(e1, t1 = (t1 % s + s) % s, r);
            if (this.tiles[a]) return me(this.tiles[a], n);
            i > 1 && console.log("drilling down to z%d-%d-%d", e1, t1, r);
            for(var l, u = e1, h = t1, c = r; !l && u > 0;)u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[Me(u, h, c)];
            return l && l.source ? (i > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), i > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, e1, t1, r), i > 1 && console.timeEnd("drilling down"), this.tiles[a] ? me(this.tiles[a], n) : null) : null;
        };
        class be extends e1.VectorTileWorkerSource {
            constructor(e1, t1, r, o, n){
                super(e1, t1, r, o, Pe), n && (this.loadGeoJSON = n);
            }
            loadData(t1, r) {
                const o = t1 && t1.request, n = o && o.collectResourceTiming;
                this.loadGeoJSON(t1, (s, a)=>{
                    if (s || !a) return r(s);
                    if ("object" != typeof a) return r(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    {
                        i(a, !0);
                        try {
                            if (t1.filter) {
                                const r = e1.createExpression(t1.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === r.result) throw new Error(r.value.map((e1)=>`${e1.key}: ${e1.message}`).join(", "));
                                const o = a.features.filter((e1)=>r.value.evaluate({
                                        zoom: 0
                                    }, e1));
                                a = {
                                    type: "FeatureCollection",
                                    features: o
                                };
                            }
                            this._geoJSONIndex = t1.cluster ? new J(function({ superclusterOptions: t1 , clusterProperties: r  }) {
                                if (!r || !t1) return t1;
                                const o = {}, n = {}, i = {
                                    accumulated: null,
                                    zoom: 0
                                }, s = {
                                    properties: null
                                }, a = Object.keys(r);
                                for (const t1 of a){
                                    const [i, s] = r[t1], a = e1.createExpression(s), l = e1.createExpression("string" == typeof i ? [
                                        i,
                                        [
                                            "accumulated"
                                        ],
                                        [
                                            "get",
                                            t1
                                        ]
                                    ] : i);
                                    o[t1] = a.value, n[t1] = l.value;
                                }
                                return t1.map = (e1)=>{
                                    s.properties = e1;
                                    const t1 = {};
                                    for (const e1 of a)t1[e1] = o[e1].evaluate(i, s);
                                    return t1;
                                }, t1.reduce = (e1, t1)=>{
                                    s.properties = t1;
                                    for (const t1 of a)i.accumulated = e1[t1], e1[t1] = n[t1].evaluate(i, s);
                                }, t1;
                            }(t1)).load(a.features) : function(e1, t1) {
                                return new Se(e1, t1);
                            }(a, t1.geojsonVtOptions);
                        } catch (s) {
                            return r(s);
                        }
                        this.loaded = {};
                        const l = {};
                        if (n) {
                            const r = e1.getPerformanceMeasurement(o);
                            r && (l.resourceTiming = {}, l.resourceTiming[t1.source] = JSON.parse(JSON.stringify(r)));
                        }
                        r(null, l);
                    }
                });
            }
            reloadTile(e1, t1) {
                const r = this.loaded;
                return r && r[e1.uid] ? super.reloadTile(e1, t1) : this.loadTile(e1, t1);
            }
            loadGeoJSON(t1, r) {
                if (t1.request) e1.getJSON(t1.request, r);
                else {
                    if ("string" != typeof t1.data) return r(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    try {
                        return r(null, JSON.parse(t1.data));
                    } catch (e1) {
                        return r(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    }
                }
            }
            getClusterExpansionZoom(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getClusterExpansionZoom(e1.clusterId));
                } catch (e1) {
                    t1(e1);
                }
            }
            getClusterChildren(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getChildren(e1.clusterId));
                } catch (e1) {
                    t1(e1);
                }
            }
            getClusterLeaves(e1, t1) {
                try {
                    t1(null, this._geoJSONIndex.getLeaves(e1.clusterId, e1.limit, e1.offset));
                } catch (e1) {
                    t1(e1);
                }
            }
        }
        class ke {
            constructor(t1){
                this.self = t1, this.actor = new e1.Actor(t1, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e1.getProjection({
                    name: "mercator"
                }), this.workerSourceTypes = {
                    vector: e1.VectorTileWorkerSource,
                    geojson: be
                }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e1, t1)=>{
                    if (this.workerSourceTypes[e1]) throw new Error(`Worker source with name "${e1}" already registered.`);
                    this.workerSourceTypes[e1] = t1;
                }, this.self.registerRTLTextPlugin = (t1)=>{
                    if (e1.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
                    e1.plugin.applyArabicShaping = t1.applyArabicShaping, e1.plugin.processBidirectionalText = t1.processBidirectionalText, e1.plugin.processStyledBidirectionalText = t1.processStyledBidirectionalText;
                };
            }
            clearCaches(e1, t1, r) {
                delete this.layerIndexes[e1], delete this.availableImages[e1], delete this.workerSources[e1], delete this.demWorkerSources[e1], r();
            }
            checkIfReady(e1, t1, r) {
                r();
            }
            setReferrer(e1, t1) {
                this.referrer = t1;
            }
            spriteLoaded(t1, r) {
                this.isSpriteLoaded[t1] = r;
                for(const o in this.workerSources[t1]){
                    const n = this.workerSources[t1][o];
                    for(const t1 in n)n[t1] instanceof e1.VectorTileWorkerSource && (n[t1].isSpriteLoaded = r, n[t1].fire(new e1.Event("isSpriteLoaded")));
                }
            }
            setImages(e1, t1, r) {
                this.availableImages[e1] = t1;
                for(const r in this.workerSources[e1]){
                    const o = this.workerSources[e1][r];
                    for(const e1 in o)o[e1].availableImages = t1;
                }
                r();
            }
            enableTerrain(e1, t1, r) {
                this.terrain = t1, r();
            }
            setProjection(t1, r) {
                this.projections[t1] = e1.getProjection(r);
            }
            setLayers(e1, t1, r) {
                this.getLayerIndex(e1).replace(t1), r();
            }
            updateLayers(e1, t1, r) {
                this.getLayerIndex(e1).update(t1.layers, t1.removedIds), r();
            }
            loadTile(t1, r, o) {
                const n = this.enableTerrain ? e1.extend({
                    enableTerrain: this.terrain
                }, r) : r;
                n.projection = this.projections[t1] || this.defaultProjection, this.getWorkerSource(t1, r.type, r.source).loadTile(n, o);
            }
            loadDEMTile(t1, r, o) {
                const n = this.enableTerrain ? e1.extend({
                    buildQuadTree: this.terrain
                }, r) : r;
                this.getDEMWorkerSource(t1, r.source).loadTile(n, o);
            }
            reloadTile(t1, r, o) {
                const n = this.enableTerrain ? e1.extend({
                    enableTerrain: this.terrain
                }, r) : r;
                n.projection = this.projections[t1] || this.defaultProjection, this.getWorkerSource(t1, r.type, r.source).reloadTile(n, o);
            }
            abortTile(e1, t1, r) {
                this.getWorkerSource(e1, t1.type, t1.source).abortTile(t1, r);
            }
            removeTile(e1, t1, r) {
                this.getWorkerSource(e1, t1.type, t1.source).removeTile(t1, r);
            }
            removeSource(e1, t1, r) {
                if (!this.workerSources[e1] || !this.workerSources[e1][t1.type] || !this.workerSources[e1][t1.type][t1.source]) return;
                const o = this.workerSources[e1][t1.type][t1.source];
                delete this.workerSources[e1][t1.type][t1.source], void 0 !== o.removeSource ? o.removeSource(t1, r) : r();
            }
            loadWorkerSource(e1, t1, r) {
                try {
                    this.self.importScripts(t1.url), r();
                } catch (e1) {
                    r(e1.toString());
                }
            }
            syncRTLPluginState(t1, r, o) {
                try {
                    e1.plugin.setState(r);
                    const t1 = e1.plugin.getPluginURL();
                    if (e1.plugin.isLoaded() && !e1.plugin.isParsed() && null != t1) {
                        this.self.importScripts(t1);
                        const r = e1.plugin.isParsed();
                        o(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t1}`), r);
                    }
                } catch (e1) {
                    o(e1.toString());
                }
            }
            getAvailableImages(e1) {
                let t1 = this.availableImages[e1];
                return t1 || (t1 = []), t1;
            }
            getLayerIndex(e1) {
                let t1 = this.layerIndexes[e1];
                return t1 || (t1 = this.layerIndexes[e1] = new o), t1;
            }
            getWorkerSource(e1, t1, r) {
                if (this.workerSources[e1] || (this.workerSources[e1] = {}), this.workerSources[e1][t1] || (this.workerSources[e1][t1] = {}), !this.workerSources[e1][t1][r]) {
                    const o = {
                        send: (t1, r, o, n, i, s)=>{
                            this.actor.send(t1, r, o, e1, i, s);
                        },
                        scheduler: this.actor.scheduler
                    };
                    this.workerSources[e1][t1][r] = new this.workerSourceTypes[t1](o, this.getLayerIndex(e1), this.getAvailableImages(e1), this.isSpriteLoaded[e1]);
                }
                return this.workerSources[e1][t1][r];
            }
            getDEMWorkerSource(e1, t1) {
                return this.demWorkerSources[e1] || (this.demWorkerSources[e1] = {}), this.demWorkerSources[e1][t1] || (this.demWorkerSources[e1][t1] = new n), this.demWorkerSources[e1][t1];
            }
            enforceCacheSizeLimit(t1, r) {
                e1.enforceCacheSizeLimit(r);
            }
            getWorkerPerformanceMetrics(e1, t1, r) {
                r(void 0, void 0);
            }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new ke(self)), ke;
    });
    define([
        "./shared"
    ], function(e1) {
        "use strict";
        function t1(e1, i) {
            if (Array.isArray(e1)) {
                if (!Array.isArray(i) || e1.length !== i.length) return !1;
                for(let o = 0; o < e1.length; o++)if (!t1(e1[o], i[o])) return !1;
                return !0;
            }
            if ("object" == typeof e1 && null !== e1 && null !== i) {
                if ("object" != typeof i) return !1;
                if (Object.keys(e1).length !== Object.keys(i).length) return !1;
                for(const o in e1)if (!t1(e1[o], i[o])) return !1;
                return !0;
            }
            return e1 === i;
        }
        var i = o;
        function o(e1) {
            return !function(e1) {
                var t1;
                return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
                    if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
                    var e1, t1, i = new Blob([
                        ""
                    ], {
                        type: "text/javascript"
                    }), o = URL.createObjectURL(i);
                    try {
                        t1 = new Worker(o), e1 = !0;
                    } catch (t1) {
                        e1 = !1;
                    }
                    return t1 && t1.terminate(), URL.revokeObjectURL(o), e1;
                }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
                    var e1 = document.createElement("canvas");
                    e1.width = e1.height = 1;
                    var t1 = e1.getContext("2d");
                    if (!t1) return !1;
                    var i = t1.getImageData(0, 0, 1, 1);
                    return i && i.width === e1.width;
                }() ? (void 0 === r[t1 = e1 && e1.failIfMajorPerformanceCaveat] && (r[t1] = function(e1) {
                    var t1, i = function(e1) {
                        var t1 = document.createElement("canvas"), i = Object.create(o.webGLContextAttributes);
                        return i.failIfMajorPerformanceCaveat = e1, t1.getContext("webgl", i) || t1.getContext("experimental-webgl", i);
                    }(e1);
                    if (!i) return !1;
                    try {
                        t1 = i.createShader(i.VERTEX_SHADER);
                    } catch (e1) {
                        return !1;
                    }
                    return !(!t1 || i.isContextLost()) && (i.shaderSource(t1, "void main() {}"), i.compileShader(t1), !0 === i.getShaderParameter(t1, i.COMPILE_STATUS));
                }(t1)), r[t1] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            }(e1);
        }
        var r = {};
        function n(t1, i, o) {
            const r = e1.window.document.createElement(t1);
            return void 0 !== i && (r.className = i), o && o.appendChild(r), r;
        }
        function s(t1, i, o) {
            const r = e1.window.document.createElementNS("http://www.w3.org/2000/svg", t1);
            for (const e1 of Object.keys(i))r.setAttributeNS(null, e1, i[e1]);
            return o && o.appendChild(r), r;
        }
        o.webGLContextAttributes = {
            antialias: !1,
            alpha: !0,
            stencil: !0,
            depth: !0
        };
        const a = e1.window.document && e1.window.document.documentElement.style, l = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
        let c;
        function h() {
            a && l && (c = a[l], a[l] = "none");
        }
        function u() {
            a && l && (a[l] = c);
        }
        function _(t1) {
            t1.preventDefault(), t1.stopPropagation(), e1.window.removeEventListener("click", _, !0);
        }
        function d() {
            e1.window.addEventListener("click", _, !0), e1.window.setTimeout(()=>{
                e1.window.removeEventListener("click", _, !0);
            }, 0);
        }
        function p(e1, t1) {
            const i = e1.getBoundingClientRect();
            return g(e1, i, t1);
        }
        function m(e1, t1) {
            const i = e1.getBoundingClientRect(), o = [];
            for(let r = 0; r < t1.length; r++)o.push(g(e1, i, t1[r]));
            return o;
        }
        function f(t1) {
            return void 0 !== e1.window.InstallTrigger && 2 === t1.button && t1.ctrlKey && e1.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t1.button;
        }
        function g(t1, i, o) {
            const r = t1.offsetWidth === i.width ? 1 : t1.offsetWidth / i.width;
            return new e1.pointGeometry((o.clientX - i.left) * r, (o.clientY - i.top) * r);
        }
        function v(e1, t1) {
            var i = t1[0], o = t1[1], r = t1[2], n = t1[3], s = i * n - r * o;
            return s ? (e1[0] = n * (s = 1 / s), e1[1] = -o * s, e1[2] = -r * s, e1[3] = i * s, e1) : null;
        }
        function x(e1) {
            const { userImage: t1  } = e1;
            return !!(t1 && t1.render && t1.render()) && (e1.data.replace(new Uint8Array(t1.data.buffer)), !0);
        }
        class y extends e1.Evented {
            constructor(){
                super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e1.RGBAImage({
                    width: 1,
                    height: 1
                }), this.dirty = !0;
            }
            isLoaded() {
                return this.loaded;
            }
            setLoaded(e1) {
                if (this.loaded !== e1 && (this.loaded = e1, e1)) {
                    for (const { ids: e1 , callback: t1  } of this.requestors)this._notify(e1, t1);
                    this.requestors = [];
                }
            }
            hasImage(e1) {
                return !!this.getImage(e1);
            }
            getImage(e1) {
                return this.images[e1];
            }
            addImage(e1, t1) {
                this._validate(e1, t1) && (this.images[e1] = t1);
            }
            _validate(t1, i) {
                let o = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t1}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t1}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t1}" has invalid "content" value`))), o = !1), o;
            }
            _validateStretch(e1, t1) {
                if (!e1) return !0;
                let i = 0;
                for (const o of e1){
                    if (o[0] < i || o[1] < o[0] || t1 < o[1]) return !1;
                    i = o[1];
                }
                return !0;
            }
            _validateContent(e1, t1) {
                return !(e1 && (4 !== e1.length || e1[0] < 0 || t1.data.width < e1[0] || e1[1] < 0 || t1.data.height < e1[1] || e1[2] < 0 || t1.data.width < e1[2] || e1[3] < 0 || t1.data.height < e1[3] || e1[2] < e1[0] || e1[3] < e1[1]));
            }
            updateImage(e1, t1) {
                t1.version = this.images[e1].version + 1, this.images[e1] = t1, this.updatedImages[e1] = !0;
            }
            removeImage(e1) {
                const t1 = this.images[e1];
                delete this.images[e1], delete this.patterns[e1], t1.userImage && t1.userImage.onRemove && t1.userImage.onRemove();
            }
            listImages() {
                return Object.keys(this.images);
            }
            getImages(e1, t1) {
                let i = !0;
                if (!this.isLoaded()) for (const t1 of e1)this.images[t1] || (i = !1);
                this.isLoaded() || i ? this._notify(e1, t1) : this.requestors.push({
                    ids: e1,
                    callback: t1
                });
            }
            _notify(t1, i) {
                const o = {};
                for (const i of t1){
                    this.images[i] || this.fire(new e1.Event("styleimagemissing", {
                        id: i
                    }));
                    const t1 = this.images[i];
                    t1 ? o[i] = {
                        data: t1.data.clone(),
                        pixelRatio: t1.pixelRatio,
                        sdf: t1.sdf,
                        version: t1.version,
                        stretchX: t1.stretchX,
                        stretchY: t1.stretchY,
                        content: t1.content,
                        hasRenderCallback: Boolean(t1.userImage && t1.userImage.render)
                    } : e1.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                }
                i(null, o);
            }
            getPixelSize() {
                const { width: e1 , height: t1  } = this.atlasImage;
                return {
                    width: e1,
                    height: t1
                };
            }
            getPattern(t1) {
                const i = this.patterns[t1], o = this.getImage(t1);
                if (!o) return null;
                if (i && i.position.version === o.version) return i.position;
                if (i) i.position.version = o.version;
                else {
                    const i = {
                        w: o.data.width + 2,
                        h: o.data.height + 2,
                        x: 0,
                        y: 0
                    }, r = new e1.ImagePosition(i, o);
                    this.patterns[t1] = {
                        bin: i,
                        position: r
                    };
                }
                return this._updatePatternAtlas(), this.patterns[t1].position;
            }
            bind(t1) {
                const i = t1.gl;
                this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e1.Texture(t1, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
                const t1 = [];
                for(const e1 in this.patterns)t1.push(this.patterns[e1].bin);
                const { w: i , h: o  } = e1.potpack(t1), r = this.atlasImage;
                r.resize({
                    width: i || 1,
                    height: o || 1
                });
                for(const t1 in this.patterns){
                    const { bin: i  } = this.patterns[t1], o = i.x + 1, n = i.y + 1, s = this.images[t1].data, a = s.width, l = s.height;
                    e1.RGBAImage.copy(s, r, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: n
                    }, {
                        width: a,
                        height: l
                    }), e1.RGBAImage.copy(s, r, {
                        x: 0,
                        y: l - 1
                    }, {
                        x: o,
                        y: n - 1
                    }, {
                        width: a,
                        height: 1
                    }), e1.RGBAImage.copy(s, r, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: n + l
                    }, {
                        width: a,
                        height: 1
                    }), e1.RGBAImage.copy(s, r, {
                        x: a - 1,
                        y: 0
                    }, {
                        x: o - 1,
                        y: n
                    }, {
                        width: 1,
                        height: l
                    }), e1.RGBAImage.copy(s, r, {
                        x: 0,
                        y: 0
                    }, {
                        x: o + a,
                        y: n
                    }, {
                        width: 1,
                        height: l
                    });
                }
                this.dirty = !0;
            }
            beginFrame() {
                this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e1) {
                for (const t1 of e1){
                    if (this.callbackDispatchedThisFrame[t1]) continue;
                    this.callbackDispatchedThisFrame[t1] = !0;
                    const e1 = this.images[t1];
                    x(e1) && this.updateImage(t1, e1);
                }
            }
        }
        const b = new e1.Properties({
            anchor: new e1.DataConstantProperty(e1.spec.light.anchor),
            position: new class {
                constructor(){
                    this.specification = e1.spec.light.position;
                }
                possiblyEvaluate(t1, i) {
                    return function([t1, i, o]) {
                        const r = e1.degToRad(i + 90), n = e1.degToRad(o);
                        return {
                            x: t1 * Math.cos(r) * Math.sin(n),
                            y: t1 * Math.sin(r) * Math.sin(n),
                            z: t1 * Math.cos(n),
                            azimuthal: i,
                            polar: o
                        };
                    }(t1.expression.evaluate(i));
                }
                interpolate(t1, i, o) {
                    return {
                        x: e1.number(t1.x, i.x, o),
                        y: e1.number(t1.y, i.y, o),
                        z: e1.number(t1.z, i.z, o),
                        azimuthal: e1.number(t1.azimuthal, i.azimuthal, o),
                        polar: e1.number(t1.polar, i.polar, o)
                    };
                }
            },
            color: new e1.DataConstantProperty(e1.spec.light.color),
            intensity: new e1.DataConstantProperty(e1.spec.light.intensity)
        }), w = "-transition";
        class T extends e1.Evented {
            constructor(t1){
                super(), this._transitionable = new e1.Transitionable(b), this.setLight(t1), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize();
            }
            setLight(t1, i = {}) {
                if (!this._validate(e1.validateLight, t1, i)) for(const i in t1){
                    const o = t1[i];
                    e1.endsWith(i, w) ? this._transitionable.setTransition(i.slice(0, -w.length), o) : this._transitionable.setValue(i, o);
                }
            }
            updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(e1, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && e1.emitValidationErrors(this, t1.call(e1.validateStyle, e1.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e1.spec
                })));
            }
        }
        const E = new e1.Properties({
            source: new e1.DataConstantProperty(e1.spec.terrain.source),
            exaggeration: new e1.DataConstantProperty(e1.spec.terrain.exaggeration)
        }), C = "-transition";
        class M extends e1.Evented {
            constructor(t1, i){
                super(), this._transitionable = new e1.Transitionable(E), this.set(t1), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1) {
                for(const i in t1){
                    const o = t1[i];
                    e1.endsWith(i, C) ? this._transitionable.setTransition(i.slice(0, -C.length), o) : this._transitionable.setValue(i, o);
                }
            }
            updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(e1, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
            }
        }
        function I(t1, i, o, r) {
            const n = e1.smoothstep(45, 65, o), [s, a] = S(t1, r), l = e1.length(i);
            let c = 1 - Math.min(1, Math.exp((l - s) / (a - s) * -6));
            return c *= c * c, c = Math.min(1, 1.00747 * c), c * n * t1.alpha;
        }
        function S(e1, t1) {
            const i = .5 / Math.tan(.5 * t1);
            return [
                e1.range[0] + i,
                e1.range[1] + i
            ];
        }
        const D = new e1.Properties({
            range: new e1.DataConstantProperty(e1.spec.fog.range),
            color: new e1.DataConstantProperty(e1.spec.fog.color),
            "high-color": new e1.DataConstantProperty(e1.spec.fog["high-color"]),
            "space-color": new e1.DataConstantProperty(e1.spec.fog["space-color"]),
            "horizon-blend": new e1.DataConstantProperty(e1.spec.fog["horizon-blend"]),
            "star-intensity": new e1.DataConstantProperty(e1.spec.fog["star-intensity"])
        }), L = "-transition";
        class A extends e1.Evented {
            constructor(t1, i){
                super(), this._transitionable = new e1.Transitionable(D), this.set(t1), this._transitioning = this._transitionable.untransitioned(), this._transform = i;
            }
            get state() {
                const t1 = this._transform, i = "globe" === t1.projection.name, o = e1.globeToMercatorTransition(t1.zoom), r = this.properties.get("range"), n = [
                    .5,
                    3
                ];
                return {
                    range: i ? [
                        e1.number(n[0], r[0], o),
                        e1.number(n[1], r[1], o)
                    ] : r,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i = {}) {
                if (!this._validate(e1.validateFog, t1, i)) {
                    for (const i of Object.keys(e1.spec.fog))t1 && void 0 === t1[i] && (t1[i] = e1.spec.fog[i].default);
                    for(const i in t1){
                        const o = t1[i];
                        e1.endsWith(i, L) ? this._transitionable.setTransition(i.slice(0, -L.length), o) : this._transitionable.setValue(i, o);
                    }
                }
            }
            getOpacity(t1) {
                if (!this._transform.projection.supportsFog) return 0;
                const i = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : e1.smoothstep(45, 65, t1)) * i.a;
            }
            getOpacityAtLatLng(t1, i) {
                return this._transform.projection.supportsFog ? function(t1, i, o) {
                    const r = e1.MercatorCoordinate.fromLngLat(i), n = o.elevation ? o.elevation.getAtPointOrZero(r) : 0, s = [
                        r.x,
                        r.y,
                        n
                    ];
                    return e1.transformMat4(s, s, o.mercatorFogMatrix), I(t1, s, o.pitch, o._fov);
                }(this.state, t1, i) : 0;
            }
            getFovAdjustedRange(e1) {
                return this._transform.projection.supportsFog ? S(this.state, e1) : [
                    0,
                    1
                ];
            }
            updateTransitions(e1) {
                this._transitioning = this._transitionable.transitioned(e1, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e1) {
                this.properties = this._transitioning.possiblyEvaluate(e1);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && e1.emitValidationErrors(this, t1.call(e1.validateStyle, e1.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e1.spec
                })));
            }
        }
        class z {
            constructor(t1, i){
                this.workerPool = t1, this.actors = [], this.currentActor = 0, this.id = e1.uniqueId();
                const o = this.workerPool.acquire(this.id);
                for(let e1 = 0; e1 < o.length; e1++){
                    const t1 = new z.Actor(o[e1], i, this.id);
                    t1.name = `Worker ${e1}`, this.actors.push(t1);
                }
                this.ready = !1, this.broadcast("checkIfReady", null, ()=>{
                    this.ready = !0;
                });
            }
            broadcast(t1, i, o) {
                e1.asyncAll(this.actors, (e1, o)=>{
                    e1.send(t1, i, o);
                }, o = o || function() {});
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
                this.actors.forEach((e1)=>{
                    e1.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }
        function P(t1, i, o) {
            return i * (e1.EXTENT / (t1.tileSize * Math.pow(2, o - t1.tileID.overscaledZ)));
        }
        z.Actor = e1.Actor;
        class R {
            constructor(e1, t1, i, o){
                this.screenBounds = e1, this.cameraPoint = t1, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);
            }
            static createFromScreenPoints(t1, i) {
                let o, r;
                if (t1 instanceof e1.pointGeometry || "number" == typeof t1[0]) {
                    const n = e1.pointGeometry.convert(t1);
                    o = [
                        n
                    ], r = i.isPointAboveHorizon(n);
                } else {
                    const n = e1.pointGeometry.convert(t1[0]), s = e1.pointGeometry.convert(t1[1]);
                    o = [
                        n,
                        s
                    ], r = e1.polygonizeBounds(n, s).every((e1)=>i.isPointAboveHorizon(e1));
                }
                return new R(o, i.getCameraPoint(), r, i);
            }
            isPointQuery() {
                return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t1) {
                return e1.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t1);
            }
            bufferedCameraGeometry(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e1.pointGeometry(1, 1)) : this.screenBounds[1], r = e1.polygonizeBounds(i, o, 0, !1);
                return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e1.bufferConvexPolygon(r, t1);
            }
            bufferedCameraGeometryGlobe(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e1.pointGeometry(1, 1)) : this.screenBounds[1], r = e1.polygonizeBounds(i, o, t1), n = this.cameraPoint.clone();
                switch(3 * ((n.y > i.y) + (n.y > o.y)) + ((n.x > i.x) + (n.x > o.x))){
                    case 0:
                        r[0] = n, r[4] = n.clone();
                        break;
                    case 1:
                        r.splice(1, 0, n);
                        break;
                    case 2:
                        r[1] = n;
                        break;
                    case 3:
                        r.splice(4, 0, n);
                        break;
                    case 5:
                        r.splice(2, 0, n);
                        break;
                    case 6:
                        r[3] = n;
                        break;
                    case 7:
                        r.splice(3, 0, n);
                        break;
                    case 8:
                        r[2] = n;
                }
                return r;
            }
            containsTile(t1, i, o, r = 0) {
                const n = t1.queryPadding / i._pixelsPerMercatorPixel + 1, s = o ? this._bufferedCameraMercator(n, i) : this._bufferedScreenMercator(n, i);
                let a = t1.tileID.wrap + (s.unwrapped ? r : 0);
                const l = s.polygon.map((i)=>e1.getTilePoint(t1.tileTransform, i, a));
                if (!e1.polygonIntersectsBox(l, 0, 0, e1.EXTENT, e1.EXTENT)) return;
                a = t1.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);
                const c = this.screenGeometryMercator.polygon.map((i)=>e1.getTileVec3(t1.tileTransform, i, a)), h = c.map((t1)=>new e1.pointGeometry(t1[0], t1[1])), u = i.getFreeCameraOptions().position || new e1.MercatorCoordinate(0, 0, 0), _ = e1.getTileVec3(t1.tileTransform, u, a), d = c.map((t1)=>{
                    const i = e1.sub(t1, t1, _);
                    return e1.normalize(i, i), new e1.Ray(_, i);
                }), p = P(t1, 1, i.zoom) * i._pixelsPerMercatorPixel;
                var m;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: h,
                    tilespaceRays: d,
                    bufferedTilespaceGeometry: l,
                    bufferedTilespaceBounds: (m = e1.getBounds(l), m.min.x = e1.clamp(m.min.x, 0, e1.EXTENT), m.min.y = e1.clamp(m.min.y, 0, e1.EXTENT), m.max.x = e1.clamp(m.max.x, 0, e1.EXTENT), m.max.y = e1.clamp(m.max.y, 0, e1.EXTENT), m),
                    tile: t1,
                    tileID: t1.tileID,
                    pixelToTileUnitsFactor: p
                };
            }
            _bufferedScreenMercator(e1, t1) {
                const i = k(e1);
                if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e1), t1) : {
                        polygon: this.bufferedScreenGeometry(e1).map((e1)=>t1.pointCoordinate3D(e1)),
                        unwrapped: !0
                    }, this._screenRaycastCache[i] = o, o;
                }
            }
            _bufferedCameraMercator(e1, t1) {
                const i = k(e1);
                if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e1), t1) : {
                        polygon: this.bufferedCameraGeometry(e1).map((e1)=>t1.pointCoordinate3D(e1)),
                        unwrapped: !0
                    }, this._cameraRaycastCache[i] = o, o;
                }
            }
            _projectAndResample(t1, i) {
                const o = function(t1, i) {
                    const o = e1.multiply([], i.pixelMatrix, i.globeMatrix), r = [
                        0,
                        -e1.GLOBE_RADIUS,
                        0,
                        1
                    ], n = [
                        0,
                        e1.GLOBE_RADIUS,
                        0,
                        1
                    ], s = [
                        0,
                        0,
                        0,
                        1
                    ];
                    e1.transformMat4$1(r, r, o), e1.transformMat4$1(n, n, o), e1.transformMat4$1(s, s, o);
                    const a = new e1.pointGeometry(r[0] / r[3], r[1] / r[3]), l = new e1.pointGeometry(n[0] / n[3], n[1] / n[3]), c = e1.polygonContainsPoint(t1, a) && r[3] < s[3], h = e1.polygonContainsPoint(t1, l) && n[3] < s[3];
                    if (!c && !h) return null;
                    const u = function(e1, t1, i) {
                        for(let o = 1; o < e1.length; o++){
                            const r = B(t1.pointCoordinate3D(e1[o - 1]).x), n = B(t1.pointCoordinate3D(e1[o]).x);
                            if (i < 0) {
                                if (r < n) return {
                                    idx: o,
                                    t: -r / (n - 1 - r)
                                };
                            } else if (n < r) return {
                                idx: o,
                                t: (1 - r) / (n + 1 - r)
                            };
                        }
                        return null;
                    }(t1, i, c ? -1 : 1);
                    if (!u) return null;
                    const { idx: _ , t: d  } = u;
                    let p = _ > 1 ? O(t1.slice(0, _), i) : [], m = _ < t1.length ? O(t1.slice(_), i) : [];
                    p = p.map((t1)=>new e1.pointGeometry(B(t1.x), t1.y)), m = m.map((t1)=>new e1.pointGeometry(B(t1.x), t1.y));
                    const f = [
                        ...p
                    ];
                    0 === f.length && f.push(m[m.length - 1]);
                    const g = e1.number(f[f.length - 1].y, (0 === m.length ? p[0] : m[0]).y, d);
                    let v;
                    return v = c ? [
                        new e1.pointGeometry(0, g),
                        new e1.pointGeometry(0, 0),
                        new e1.pointGeometry(1, 0),
                        new e1.pointGeometry(1, g)
                    ] : [
                        new e1.pointGeometry(1, g),
                        new e1.pointGeometry(1, 1),
                        new e1.pointGeometry(0, 1),
                        new e1.pointGeometry(0, g)
                    ], f.push(...v), 0 === m.length ? f.push(p[0]) : f.push(...m), {
                        polygon: f.map((t1)=>new e1.MercatorCoordinate(t1.x, t1.y)),
                        unwrapped: !1
                    };
                }(t1, i);
                if (o) return o;
                const r = function(t1, i) {
                    let o = !1, r = -1 / 0, n = 0;
                    for(let e1 = 0; e1 < t1.length - 1; e1++)t1[e1].x > r && (r = t1[e1].x, n = e1);
                    for(let e1 = 0; e1 < t1.length - 1; e1++){
                        const i = (n + e1) % (t1.length - 1), r = t1[i], s = t1[i + 1];
                        Math.abs(r.x - s.x) > .5 && (r.x < s.x ? (r.x += 1, 0 === i && (t1[t1.length - 1].x += 1)) : (s.x += 1, i + 1 === t1.length - 1 && (t1[0].x += 1)), o = !0);
                    }
                    const s = e1.mercatorXfromLng(i.center.lng);
                    return o && s < Math.abs(s - 1) && t1.forEach((e1)=>{
                        e1.x -= 1;
                    }), {
                        polygon: t1,
                        unwrapped: o
                    };
                }(O(t1, i).map((t1)=>new e1.pointGeometry(B(t1.x), t1.y)), i);
                return {
                    polygon: r.polygon.map((t1)=>new e1.MercatorCoordinate(t1.x, t1.y)),
                    unwrapped: r.unwrapped
                };
            }
        }
        function O(t1, i) {
            return e1.resample(t1, (e1)=>{
                const t1 = i.pointCoordinate3D(e1);
                e1.x = t1.x, e1.y = t1.y;
            }, 1 / 256);
        }
        function B(e1) {
            return e1 < 0 ? 1 + e1 % 1 : e1 % 1;
        }
        function k(e1) {
            return 100 * e1 | 0;
        }
        function F(t1, i, o, r, n) {
            const s = function(o, r) {
                if (o) return n(o);
                if (r) {
                    t1.url && r.tiles && t1.tiles && delete t1.tiles;
                    const o = e1.pick(e1.extend(r, t1), [
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "mapbox_logo",
                        "bounds",
                        "scheme",
                        "tileSize",
                        "encoding"
                    ]);
                    r.vector_layers && (o.vectorLayers = r.vector_layers, o.vectorLayerIds = o.vectorLayers.map((e1)=>e1.id)), o.tiles = i.canonicalizeTileset(o, t1.url), n(null, o);
                }
            };
            return t1.url ? e1.getJSON(i.transformRequest(i.normalizeSourceURL(t1.url, null, o, r), e1.ResourceType.Source), s) : e1.exported.frame(()=>s(null, t1));
        }
        class U {
            constructor(t1, i, o){
                this.bounds = e1.LngLatBounds.convert(this.validateBounds(t1)), this.minzoom = i || 0, this.maxzoom = o || 24;
            }
            validateBounds(e1) {
                return Array.isArray(e1) && 4 === e1.length ? [
                    Math.max(-180, e1[0]),
                    Math.max(-90, e1[1]),
                    Math.min(180, e1[2]),
                    Math.min(90, e1[3])
                ] : [
                    -180,
                    -90,
                    180,
                    90
                ];
            }
            contains(t1) {
                const i = Math.pow(2, t1.z), o = Math.floor(e1.mercatorXfromLng(this.bounds.getWest()) * i), r = Math.floor(e1.mercatorYfromLat(this.bounds.getNorth()) * i), n = Math.ceil(e1.mercatorXfromLng(this.bounds.getEast()) * i), s = Math.ceil(e1.mercatorYfromLat(this.bounds.getSouth()) * i);
                return t1.x >= o && t1.x < n && t1.y >= r && t1.y < s;
            }
        }
        class N {
            constructor(e1, t1, i){
                this.context = e1;
                const o = e1.gl;
                this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e1.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || t1.destroy();
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e1) {
                const t1 = this.context.gl;
                this.context.unbindVAO(), this.bind(), t1.bufferSubData(t1.ELEMENT_ARRAY_BUFFER, 0, e1.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        const G = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class j {
            constructor(e1, t1, i, o){
                this.length = t1.length, this.attributes = i, this.itemSize = t1.bytesPerElement, this.dynamicDraw = o, this.context = e1;
                const r = e1.gl;
                this.buffer = r.createBuffer(), e1.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || t1.destroy();
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e1) {
                const t1 = this.context.gl;
                this.bind(), t1.bufferSubData(t1.ARRAY_BUFFER, 0, e1.arrayBuffer);
            }
            enableAttributes(e1, t1) {
                for(let i = 0; i < this.attributes.length; i++){
                    const o = t1.attributes[this.attributes[i].name];
                    void 0 !== o && e1.enableVertexAttribArray(o);
                }
            }
            setVertexAttribPointers(e1, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const r = this.attributes[o], n = t1.attributes[r.name];
                    void 0 !== n && e1.vertexAttribPointer(n, r.components, e1[G[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        class Z {
            constructor(e1){
                this.gl = e1.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }
            get() {
                return this.current;
            }
            set(e1) {}
            getDefault() {
                return this.default;
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class V extends Z {
            getDefault() {
                return e1.Color.transparent;
            }
            set(e1) {
                const t1 = this.current;
                (e1.r !== t1.r || e1.g !== t1.g || e1.b !== t1.b || e1.a !== t1.a || this.dirty) && (this.gl.clearColor(e1.r, e1.g, e1.b, e1.a), this.current = e1, this.dirty = !1);
            }
        }
        class W extends Z {
            getDefault() {
                return 1;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.clearDepth(e1), this.current = e1, this.dirty = !1);
            }
        }
        class X extends Z {
            getDefault() {
                return 0;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.clearStencil(e1), this.current = e1, this.dirty = !1);
            }
        }
        class q extends Z {
            getDefault() {
                return [
                    !0,
                    !0,
                    !0,
                    !0
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || e1[2] !== t1[2] || e1[3] !== t1[3] || this.dirty) && (this.gl.colorMask(e1[0], e1[1], e1[2], e1[3]), this.current = e1, this.dirty = !1);
            }
        }
        class $ extends Z {
            getDefault() {
                return !0;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.depthMask(e1), this.current = e1, this.dirty = !1);
            }
        }
        class H extends Z {
            getDefault() {
                return 255;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.stencilMask(e1), this.current = e1, this.dirty = !1);
            }
        }
        class Y extends Z {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                };
            }
            set(e1) {
                const t1 = this.current;
                (e1.func !== t1.func || e1.ref !== t1.ref || e1.mask !== t1.mask || this.dirty) && (this.gl.stencilFunc(e1.func, e1.ref, e1.mask), this.current = e1, this.dirty = !1);
            }
        }
        class K extends Z {
            getDefault() {
                const e1 = this.gl;
                return [
                    e1.KEEP,
                    e1.KEEP,
                    e1.KEEP
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || e1[2] !== t1[2] || this.dirty) && (this.gl.stencilOp(e1[0], e1[1], e1[2]), this.current = e1, this.dirty = !1);
            }
        }
        class J extends Z {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                e1 ? t1.enable(t1.STENCIL_TEST) : t1.disable(t1.STENCIL_TEST), this.current = e1, this.dirty = !1;
            }
        }
        class Q extends Z {
            getDefault() {
                return [
                    0,
                    1
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || this.dirty) && (this.gl.depthRange(e1[0], e1[1]), this.current = e1, this.dirty = !1);
            }
        }
        class ee extends Z {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                e1 ? t1.enable(t1.DEPTH_TEST) : t1.disable(t1.DEPTH_TEST), this.current = e1, this.dirty = !1;
            }
        }
        class te extends Z {
            getDefault() {
                return this.gl.LESS;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.depthFunc(e1), this.current = e1, this.dirty = !1);
            }
        }
        class ie extends Z {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                e1 ? t1.enable(t1.BLEND) : t1.disable(t1.BLEND), this.current = e1, this.dirty = !1;
            }
        }
        class oe extends Z {
            getDefault() {
                const e1 = this.gl;
                return [
                    e1.ONE,
                    e1.ZERO
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || this.dirty) && (this.gl.blendFunc(e1[0], e1[1]), this.current = e1, this.dirty = !1);
            }
        }
        class re extends Z {
            getDefault() {
                return e1.Color.transparent;
            }
            set(e1) {
                const t1 = this.current;
                (e1.r !== t1.r || e1.g !== t1.g || e1.b !== t1.b || e1.a !== t1.a || this.dirty) && (this.gl.blendColor(e1.r, e1.g, e1.b, e1.a), this.current = e1, this.dirty = !1);
            }
        }
        class ne extends Z {
            getDefault() {
                return this.gl.FUNC_ADD;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.blendEquation(e1), this.current = e1, this.dirty = !1);
            }
        }
        class se extends Z {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                e1 ? t1.enable(t1.CULL_FACE) : t1.disable(t1.CULL_FACE), this.current = e1, this.dirty = !1;
            }
        }
        class ae extends Z {
            getDefault() {
                return this.gl.BACK;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.cullFace(e1), this.current = e1, this.dirty = !1);
            }
        }
        class le extends Z {
            getDefault() {
                return this.gl.CCW;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.frontFace(e1), this.current = e1, this.dirty = !1);
            }
        }
        class ce extends Z {
            getDefault() {
                return null;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.useProgram(e1), this.current = e1, this.dirty = !1);
            }
        }
        class he extends Z {
            getDefault() {
                return this.gl.TEXTURE0;
            }
            set(e1) {
                (e1 !== this.current || this.dirty) && (this.gl.activeTexture(e1), this.current = e1, this.dirty = !1);
            }
        }
        class ue extends Z {
            getDefault() {
                const e1 = this.gl;
                return [
                    0,
                    0,
                    e1.drawingBufferWidth,
                    e1.drawingBufferHeight
                ];
            }
            set(e1) {
                const t1 = this.current;
                (e1[0] !== t1[0] || e1[1] !== t1[1] || e1[2] !== t1[2] || e1[3] !== t1[3] || this.dirty) && (this.gl.viewport(e1[0], e1[1], e1[2], e1[3]), this.current = e1, this.dirty = !1);
            }
        }
        class _e extends Z {
            getDefault() {
                return null;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindFramebuffer(t1.FRAMEBUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class de extends Z {
            getDefault() {
                return null;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindRenderbuffer(t1.RENDERBUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class pe extends Z {
            getDefault() {
                return null;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindTexture(t1.TEXTURE_2D, e1), this.current = e1, this.dirty = !1;
            }
        }
        class me extends Z {
            getDefault() {
                return null;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindBuffer(t1.ARRAY_BUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class fe extends Z {
            getDefault() {
                return null;
            }
            set(e1) {
                const t1 = this.gl;
                t1.bindBuffer(t1.ELEMENT_ARRAY_BUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class ge extends Z {
            constructor(e1){
                super(e1), this.vao = e1.extVertexArrayObject;
            }
            getDefault() {
                return null;
            }
            set(e1) {
                this.vao && (e1 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e1), this.current = e1, this.dirty = !1);
            }
        }
        class ve extends Z {
            getDefault() {
                return 4;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_ALIGNMENT, e1), this.current = e1, this.dirty = !1;
            }
        }
        class xe extends Z {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e1), this.current = e1, this.dirty = !1;
            }
        }
        class ye extends Z {
            getDefault() {
                return !1;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_FLIP_Y_WEBGL, e1), this.current = e1, this.dirty = !1;
            }
        }
        class be extends Z {
            constructor(e1, t1){
                super(e1), this.context = e1, this.parent = t1;
            }
            getDefault() {
                return null;
            }
        }
        class we extends be {
            setDirty() {
                this.dirty = !0;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, t1.COLOR_ATTACHMENT0, t1.TEXTURE_2D, e1, 0), this.current = e1, this.dirty = !1;
            }
        }
        class Te extends be {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e1) {
                if (e1 === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferRenderbuffer(t1.FRAMEBUFFER, this.attachment(), t1.RENDERBUFFER, e1), this.current = e1, this.dirty = !1;
            }
        }
        class Ee extends Te {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
        }
        class Ce {
            constructor(e1, t1, i, o){
                this.context = e1, this.width = t1, this.height = i;
                const r = this.framebuffer = e1.gl.createFramebuffer();
                this.colorAttachment = new we(e1, r), o && (this.depthAttachment = new Te(e1, r));
            }
            destroy() {
                const e1 = this.context.gl, t1 = this.colorAttachment.get();
                if (t1 && e1.deleteTexture(t1), this.depthAttachment) {
                    const t1 = this.depthAttachment.get();
                    t1 && e1.deleteRenderbuffer(t1);
                }
                e1.deleteFramebuffer(this.framebuffer);
            }
        }
        class Me {
            constructor(e1, t1 = !1){
                if (this.gl = e1, this.isWebGL2 = t1, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t1) {
                    const t1 = e1;
                    this.extVertexArrayObject = {
                        createVertexArrayOES: t1.createVertexArray.bind(e1),
                        deleteVertexArrayOES: t1.deleteVertexArray.bind(e1),
                        bindVertexArrayOES: t1.bindVertexArray.bind(e1)
                    };
                }
                this.clearColor = new V(this), this.clearDepth = new W(this), this.clearStencil = new X(this), this.colorMask = new q(this), this.depthMask = new $(this), this.stencilMask = new H(this), this.stencilFunc = new Y(this), this.stencilOp = new K(this), this.stencilTest = new J(this), this.depthRange = new Q(this), this.depthTest = new ee(this), this.depthFunc = new te(this), this.blend = new ie(this), this.blendFunc = new oe(this), this.blendColor = new re(this), this.blendEquation = new ne(this), this.cullFace = new se(this), this.cullFaceSide = new ae(this), this.frontFace = new le(this), this.program = new ce(this), this.activeTexture = new he(this), this.viewport = new ue(this), this.bindFramebuffer = new _e(this), this.bindRenderbuffer = new de(this), this.bindTexture = new pe(this), this.bindVertexBuffer = new me(this), this.bindElementBuffer = new fe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ge(this), this.pixelStoreUnpack = new ve(this), this.pixelStoreUnpackPremultiplyAlpha = new xe(this), this.pixelStoreUnpackFlipY = new ye(this), this.extTextureFilterAnisotropic = e1.getExtension("EXT_texture_filter_anisotropic") || e1.getExtension("MOZ_EXT_texture_filter_anisotropic") || e1.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e1.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extStandardDerivativesForceOff = !1, this.extDebugRendererInfo = e1.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e1.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e1.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t1 || (this.extTextureHalfFloat = e1.getExtension("OES_texture_half_float")), (t1 || this.extTextureHalfFloat && e1.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e1.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t1 || e1.getExtension("OES_standard_derivatives"), this.extTimerQuery = e1.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e1.getParameter(e1.MAX_TEXTURE_SIZE);
            }
            setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(e1, t1) {
                return new N(this, e1, t1);
            }
            createVertexBuffer(e1, t1, i) {
                return new j(this, e1, t1, i);
            }
            createRenderbuffer(e1, t1, i) {
                const o = this.gl, r = o.createRenderbuffer();
                return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e1, t1, i), this.bindRenderbuffer.set(null), r;
            }
            createFramebuffer(e1, t1, i) {
                return new Ce(this, e1, t1, i);
            }
            clear({ color: e1 , depth: t1 , stencil: i  }) {
                const o = this.gl;
                let r = 0;
                e1 && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e1), this.colorMask.set([
                    !0,
                    !0,
                    !0,
                    !0
                ])), void 0 !== t1 && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([
                    0,
                    1
                ]), this.clearDepth.set(t1), this.depthMask.set(!0)), void 0 !== i && (r |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), o.clear(r);
            }
            setCullFace(e1) {
                !1 === e1.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e1.mode), this.frontFace.set(e1.frontFace));
            }
            setDepthMode(e1) {
                e1.func !== this.gl.ALWAYS || e1.mask ? (this.depthTest.set(!0), this.depthFunc.set(e1.func), this.depthMask.set(e1.mask), this.depthRange.set(e1.range)) : this.depthTest.set(!1);
            }
            setStencilMode(e1) {
                e1.test.func !== this.gl.ALWAYS || e1.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e1.mask), this.stencilOp.set([
                    e1.fail,
                    e1.depthFail,
                    e1.pass
                ]), this.stencilFunc.set({
                    func: e1.test.func,
                    ref: e1.ref,
                    mask: e1.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(i) {
                t1(i.blendFunction, e1.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(i.blendFunction), this.blendColor.set(i.blendColor)), this.colorMask.set(i.mask);
            }
            unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
        }
        class Ie extends e1.Evented {
            constructor(t1, i, o, r){
                if (super(), this.id = t1, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e1.extend(this, e1.pick(i, [
                    "url",
                    "scheme",
                    "tileSize",
                    "promoteId"
                ])), this._options = e1.extend({
                    type: "vector"
                }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e1.DedupedRequest;
            }
            load(t1) {
                this._loaded = !1, this.fire(new e1.Event("dataloading", {
                    dataType: "source"
                }));
                const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map._worldview;
                this._tileJSONRequest = F(this._options, this.map._requestManager, i, o, (r, n)=>{
                    this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e1.ErrorEvent(r))) : n && (e1.extend(this, n), n.bounds && (this.tileBounds = new U(n.bounds, this.minzoom, this.maxzoom)), e1.postTurnstileEvent(n.tiles, this.map._requestManager._customAccessToken), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(r);
                });
            }
            loaded() {
                return this._loaded;
            }
            hasTile(e1) {
                return !this.tileBounds || this.tileBounds.contains(e1.canonical);
            }
            onAdd(e1) {
                this.map = e1, this.load();
            }
            reload() {
                this.cancelTileJSONRequest(), this.load(()=>this.map.style._clearSource(this.id));
            }
            setTiles(e1) {
                return this._options.tiles = e1, this.reload(), this;
            }
            setUrl(e1) {
                return this.url = e1, this._options.url = e1, this.reload(), this;
            }
            onRemove() {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e1.extend({}, this._options);
            }
            loadTile(t1, i) {
                const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme)), r = {
                    request: this.map._requestManager.transformRequest(o, e1.ResourceType.Tile),
                    data: void 0,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    tileZoom: t1.tileZoom,
                    zoom: t1.tileID.overscaledZ,
                    tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    pixelRatio: e1.exported.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: t1.isSymbolTile
                };
                if (r.request.collectResourceTiming = this._collectResourceTiming, t1.actor && "expired" !== t1.state) "loading" === t1.state ? t1.reloadCallback = i : t1.request = t1.actor.send("reloadTile", r, n.bind(this));
                else if (t1.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t1.request = t1.actor.send("loadTile", r, n.bind(this), void 0, !0);
                else {
                    const i = e1.loadVectorTile.call({
                        deduped: this._deduped
                    }, r, (e1, i)=>{
                        e1 || !i ? n.call(this, e1) : (r.data = {
                            cacheControl: i.cacheControl,
                            expires: i.expires,
                            rawData: i.rawData.slice(0)
                        }, t1.actor && t1.actor.send("loadTile", r, n.bind(this), void 0, !0));
                    }, !0);
                    t1.request = {
                        cancel: i
                    };
                }
                function n(o, r) {
                    return delete t1.request, t1.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t1.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t1.setExpiryData(r), t1.loadVectorData(r, this.map.painter), e1.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (t1.reloadCallback && (this.loadTile(t1, t1.reloadCallback), t1.reloadCallback = null)));
                }
            }
            abortTile(e1) {
                e1.request && (e1.request.cancel(), delete e1.request), e1.actor && e1.actor.send("abortTile", {
                    uid: e1.uid,
                    type: this.type,
                    source: this.id
                });
            }
            unloadTile(e1) {
                e1.unloadVectorData(), e1.actor && e1.actor.send("removeTile", {
                    uid: e1.uid,
                    type: this.type,
                    source: this.id
                });
            }
            hasTransition() {
                return !1;
            }
            afterUpdate() {
                this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        class Se extends e1.Evented {
            constructor(t1, i, o, r){
                super(), this.id = t1, this.dispatcher = o, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e1.extend({
                    type: "raster"
                }, i), e1.extend(this, e1.pick(i, [
                    "url",
                    "scheme",
                    "tileSize"
                ]));
            }
            load(t1) {
                this._loaded = !1, this.fire(new e1.Event("dataloading", {
                    dataType: "source"
                })), this._tileJSONRequest = F(this._options, this.map._requestManager, null, null, (i, o)=>{
                    this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e1.ErrorEvent(i)) : o && (e1.extend(this, o), o.bounds && (this.tileBounds = new U(o.bounds, this.minzoom, this.maxzoom)), e1.postTurnstileEvent(o.tiles), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(i);
                });
            }
            loaded() {
                return this._loaded;
            }
            onAdd(e1) {
                this.map = e1, this.load();
            }
            reload() {
                this.cancelTileJSONRequest(), this.load(()=>this.map.style._clearSource(this.id));
            }
            setTiles(e1) {
                return this._options.tiles = e1, this.reload(), this;
            }
            setUrl(e1) {
                return this.url = e1, this._options.url = e1, this.reload(), this;
            }
            onRemove() {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e1.extend({}, this._options);
            }
            hasTile(e1) {
                return !this.tileBounds || this.tileBounds.contains(e1.canonical);
            }
            loadTile(t1, i) {
                const o = e1.exported.devicePixelRatio >= 2, r = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);
                t1.request = e1.getImage(this.map._requestManager.transformRequest(r, e1.ResourceType.Tile), (o, r, n, s)=>(delete t1.request, t1.aborted ? (t1.state = "unloaded", i(null)) : o ? (t1.state = "errored", i(o)) : r ? (this.map._refreshExpiredTiles && t1.setExpiryData({
                        cacheControl: n,
                        expires: s
                    }), t1.setTexture(r, this.map.painter), t1.state = "loaded", e1.cacheEntryPossiblyAdded(this.dispatcher), void i(null)) : i(null)));
            }
            static loadTileData(e1, t1, i) {
                e1.setTexture(t1, i);
            }
            static unloadTileData(e1, t1) {
                e1.texture && t1.saveTileTexture(e1.texture);
            }
            abortTile(e1, t1) {
                e1.request && (e1.request.cancel(), delete e1.request), t1();
            }
            unloadTile(e1, t1) {
                e1.texture && this.map.painter.saveTileTexture(e1.texture), t1();
            }
            hasTransition() {
                return !1;
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        let De;
        function Le(t1, i, o, r, n, s, a, l) {
            const c = [
                t1,
                o,
                n,
                i,
                r,
                s,
                1,
                1,
                1
            ], h = [
                a,
                l,
                1
            ], u = e1.adjoint([], c), [_, d, p] = e1.transformMat3(h, h, e1.transpose(u, u));
            return e1.multiply$1(c, [
                _,
                0,
                0,
                0,
                d,
                0,
                0,
                0,
                p
            ], c);
        }
        class Ae extends e1.Evented {
            constructor(e1, t1, i, o){
                super(), this.id = e1, this.dispatcher = i, this.coordinates = t1.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = t1, this._dirty = !1;
            }
            load(t1, i) {
                this._loaded = i || !1, this.fire(new e1.Event("dataloading", {
                    dataType: "source"
                })), this.url = this.options.url, this._imageRequest = e1.getImage(this.map._requestManager.transformRequest(this.url, e1.ResourceType.Image), (i, o)=>{
                    if (this._imageRequest = null, this._loaded = !0, i) this.fire(new e1.ErrorEvent(i));
                    else if (o) {
                        const { HTMLImageElement: i  } = e1.window;
                        this.image = o instanceof i ? e1.exported.getImageData(o) : o, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t1 && (this.coordinates = t1), this._finishLoading();
                    }
                });
            }
            loaded() {
                return this._loaded;
            }
            updateImage(e1) {
                return this.image && e1.url ? (this._imageRequest && e1.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e1.url, this.load(e1.coordinates, this._loaded), this) : this;
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new e1.Event("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(e1) {
                this.map = e1, this.load();
            }
            onRemove() {
                this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
            }
            setCoordinates(t1) {
                this.coordinates = t1, this._boundsArray = void 0;
                const i = t1.map(e1.MercatorCoordinate.fromLngLat);
                return this.tileID = function(t1) {
                    let i = 1 / 0, o = 1 / 0, r = -1 / 0, n = -1 / 0;
                    for (const e1 of t1)i = Math.min(i, e1.x), o = Math.min(o, e1.y), r = Math.max(r, e1.x), n = Math.max(n, e1.y);
                    const s = Math.max(r - i, n - o), a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)), l = Math.pow(2, a);
                    return new e1.CanonicalTileID(a, Math.floor((i + r) / 2 * l), Math.floor((o + n) / 2 * l));
                }(i), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e1.Event("data", {
                    dataType: "source",
                    sourceDataType: "content"
                })), this;
            }
            _clear() {
                this._boundsArray = void 0;
            }
            _prepareData(t1) {
                for(const e1 in this.tiles){
                    const t1 = this.tiles[e1];
                    "loaded" !== t1.state && (t1.state = "loaded", t1.texture = this.texture);
                }
                if (this._boundsArray) return;
                const i = e1.tileTransform(this.tileID, this.map.transform.projection), [o, r, n, s] = this.coordinates.map((t1)=>{
                    const o = i.projection.project(t1[0], t1[1]);
                    return e1.getTilePoint(i, o)._round();
                });
                this.perspectiveTransform = function(t1, i, o, r, n, s, a, l, c, h) {
                    const u = Le(0, 0, t1, 0, 0, i, t1, i), _ = Le(o, r, n, s, a, l, c, h);
                    return e1.multiply$1(_, e1.adjoint(u, u), _), [
                        _[6] / _[8] * t1 / e1.EXTENT,
                        _[7] / _[8] * i / e1.EXTENT
                    ];
                }(this.width, this.height, o.x, o.y, r.x, r.y, s.x, s.y, n.x, n.y);
                const a = this._boundsArray = new e1.StructArrayLayout4i8;
                a.emplaceBack(o.x, o.y, 0, 0), a.emplaceBack(r.x, r.y, e1.EXTENT, 0), a.emplaceBack(s.x, s.y, 0, e1.EXTENT), a.emplaceBack(n.x, n.y, e1.EXTENT, e1.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t1.createVertexBuffer(a, e1.boundsAttributes.members), this.boundsSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image) return;
                const t1 = this.map.painter.context, i = t1.gl;
                this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e1.Texture(t1, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this._dirty = !1), this._prepareData(t1);
            }
            loadTile(e1, t1) {
                this.tileID && this.tileID.equals(e1.tileID.canonical) ? (this.tiles[String(e1.tileID.wrap)] = e1, e1.buckets = {}, t1(null)) : (e1.state = "errored", t1(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return !1;
            }
        }
        const ze = {
            vector: Ie,
            raster: Se,
            "raster-dem": class extends Se {
                constructor(t1, i, o, r){
                    super(t1, i, o, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e1.extend({
                        type: "raster-dem"
                    }, i), this.encoding = i.encoding || "mapbox";
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function r(e1, o) {
                        e1 && (t1.state = "errored", i(e1)), o && (t1.dem = o, t1.dem.onDeserialize(), t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0, t1.state = "loaded", i(null));
                    }
                    t1.request = e1.getImage(this.map._requestManager.transformRequest(o, e1.ResourceType.Tile), (function(o, n, s, a) {
                        if (delete t1.request, t1.aborted) t1.state = "unloaded", i(null);
                        else if (o) t1.state = "errored", i(o);
                        else if (n) {
                            this.map._refreshExpiredTiles && t1.setExpiryData({
                                cacheControl: s,
                                expires: a
                            });
                            const i = e1.window.ImageBitmap && n instanceof e1.window.ImageBitmap && (null == De && (De = e1.window.OffscreenCanvas && new e1.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e1.window.createImageBitmap), De), o = 1 - (n.width - e1.prevPowerOfTwo(n.width)) / 2;
                            o < 1 || t1.neighboringTiles || (t1.neighboringTiles = this._getNeighboringTiles(t1.tileID));
                            const l = i ? n : e1.exported.getImageData(n, o), c = {
                                uid: t1.uid,
                                coord: t1.tileID,
                                source: this.id,
                                rawImageData: l,
                                encoding: this.encoding,
                                padding: o
                            };
                            t1.actor && "expired" !== t1.state || (t1.actor = this.dispatcher.getActor(), t1.actor.send("loadDEMTile", c, r.bind(this), void 0, !0));
                        }
                    }).bind(this));
                }
                _getNeighboringTiles(t1) {
                    const i = t1.canonical, o = Math.pow(2, i.z), r = (i.x - 1 + o) % o, n = 0 === i.x ? t1.wrap - 1 : t1.wrap, s = (i.x + 1 + o) % o, a = i.x + 1 === o ? t1.wrap + 1 : t1.wrap, l = {};
                    return l[new e1.OverscaledTileID(t1.overscaledZ, n, i.z, r, i.y).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, a, i.z, s, i.y).key] = {
                        backfilled: !1
                    }, i.y > 0 && (l[new e1.OverscaledTileID(t1.overscaledZ, n, i.z, r, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, t1.wrap, i.z, i.x, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, a, i.z, s, i.y - 1).key] = {
                        backfilled: !1
                    }), i.y + 1 < o && (l[new e1.OverscaledTileID(t1.overscaledZ, n, i.z, r, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, t1.wrap, i.z, i.x, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e1.OverscaledTileID(t1.overscaledZ, a, i.z, s, i.y + 1).key] = {
                        backfilled: !1
                    }), l;
                }
                unloadTile(e1) {
                    e1.demTexture && this.map.painter.saveTileTexture(e1.demTexture), e1.fbo && (e1.fbo.destroy(), delete e1.fbo), e1.dem && delete e1.dem, delete e1.neighboringTiles, e1.state = "unloaded";
                }
            },
            geojson: class extends e1.Evented {
                constructor(t1, i, o, r){
                    super(), this.id = t1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e1.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
                    const n = e1.EXTENT / this.tileSize;
                    this.workerOptions = e1.extend({
                        source: this.id,
                        cluster: i.cluster || !1,
                        geojsonVtOptions: {
                            buffer: (void 0 !== i.buffer ? i.buffer : 128) * n,
                            tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * n,
                            extent: e1.EXTENT,
                            maxZoom: this.maxzoom,
                            lineMetrics: i.lineMetrics || !1,
                            generateId: i.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, i.clusterMinPoints || 2),
                            extent: e1.EXTENT,
                            radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n,
                            log: !1,
                            generateId: i.generateId || !1
                        },
                        clusterProperties: i.clusterProperties,
                        filter: i.filter
                    }, i.workerOptions);
                }
                onAdd(e1) {
                    this.map = e1, this.setData(this._data);
                }
                setData(e1) {
                    return this._data = e1, this._updateWorkerData(), this;
                }
                getClusterExpansionZoom(e1, t1) {
                    return this.actor.send("geojson.getClusterExpansionZoom", {
                        clusterId: e1,
                        source: this.id
                    }, t1), this;
                }
                getClusterChildren(e1, t1) {
                    return this.actor.send("geojson.getClusterChildren", {
                        clusterId: e1,
                        source: this.id
                    }, t1), this;
                }
                getClusterLeaves(e1, t1, i, o) {
                    return this.actor.send("geojson.getClusterLeaves", {
                        source: this.id,
                        clusterId: e1,
                        limit: t1,
                        offset: i
                    }, o), this;
                }
                _updateWorkerData() {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(new e1.Event("dataloading", {
                        dataType: "source"
                    })), this._loaded = !1;
                    const t1 = e1.extend({}, this.workerOptions), i = this._data;
                    "string" == typeof i ? (t1.request = this.map._requestManager.transformRequest(e1.exported.resolveURL(i), e1.ResourceType.Source), t1.request.collectResourceTiming = this._collectResourceTiming) : t1.data = JSON.stringify(i), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t1, (t1, i)=>{
                        if (this._loaded = !0, this._pendingLoad = null, t1) this.fire(new e1.ErrorEvent(t1));
                        else {
                            const t1 = {
                                dataType: "source",
                                sourceDataType: this._metadataFired ? "content" : "metadata"
                            };
                            this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (t1.resourceTiming = i.resourceTiming[this.id]), this.fire(new e1.Event("data", t1)), this._metadataFired = !0;
                        }
                        this._coalesce && (this._updateWorkerData(), this._coalesce = !1);
                    });
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t1, i) {
                    const o = t1.actor ? "reloadTile" : "loadTile";
                    t1.actor = this.actor, t1.request = this.actor.send(o, {
                        type: this.type,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        maxZoom: this.maxzoom,
                        tileSize: this.tileSize,
                        source: this.id,
                        pixelRatio: e1.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId
                    }, (e1, r)=>(delete t1.request, t1.unloadVectorData(), t1.aborted ? i(null) : e1 ? i(e1) : (t1.loadVectorData(r, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
                }
                abortTile(e1) {
                    e1.request && (e1.request.cancel(), delete e1.request), e1.aborted = !0;
                }
                unloadTile(e1) {
                    e1.unloadVectorData(), this.actor.send("removeTile", {
                        uid: e1.uid,
                        type: this.type,
                        source: this.id
                    });
                }
                onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel();
                }
                serialize() {
                    return e1.extend({}, this._options, {
                        type: this.type,
                        data: this._data
                    });
                }
                hasTransition() {
                    return !1;
                }
            },
            video: class extends Ae {
                constructor(e1, t1, i, o){
                    super(e1, t1, i, o), this.roundZoom = !0, this.type = "video", this.options = t1;
                }
                load() {
                    this._loaded = !1;
                    const t1 = this.options;
                    this.urls = [];
                    for (const i of t1.urls)this.urls.push(this.map._requestManager.transformRequest(i, e1.ResourceType.Source).url);
                    e1.getVideo(this.urls, (t1, i)=>{
                        this._loaded = !0, t1 ? this.fire(new e1.ErrorEvent(t1)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", ()=>{
                            this.map.triggerRepaint();
                        }), this.map && this.video.play(), this._finishLoading());
                    });
                }
                pause() {
                    this.video && this.video.pause();
                }
                play() {
                    this.video && this.video.play();
                }
                seek(t1) {
                    if (this.video) {
                        const i = this.video.seekable;
                        t1 < i.start(0) || t1 > i.end(0) ? this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t1;
                    }
                }
                getVideo() {
                    return this.video;
                }
                onAdd(e1) {
                    this.map || (this.map = e1, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                    const t1 = this.map.painter.context, i = t1.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e1.Texture(t1, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t1);
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this.video && !this.video.paused;
                }
            },
            image: Ae,
            canvas: class extends Ae {
                constructor(t1, i, o, r){
                    super(t1, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((e1)=>!Array.isArray(e1) || 2 !== e1.length || e1.some((e1)=>"number" != typeof e1)) || this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof e1.window.HTMLCanvasElement || this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t1}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
                }
                load() {
                    this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e1.window.HTMLCanvasElement ? this.options.canvas : e1.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e1.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0, this.map.triggerRepaint();
                    }, this.pause = function() {
                        this._playing && (this.prepare(), this._playing = !1);
                    }, this._finishLoading());
                }
                getCanvas() {
                    return this.canvas;
                }
                onAdd(e1) {
                    this.map = e1, this.load(), this.canvas && this.animate && this.play();
                }
                onRemove() {
                    this.pause();
                }
                prepare() {
                    let t1 = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width, t1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t1 = !0), this._hasInvalidDimensions()) return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const i = this.map.painter.context;
                    this.texture ? (t1 || this._playing) && this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new e1.Texture(i, this.canvas, i.gl.RGBA, {
                        premultiply: !0
                    }), this._prepareData(i);
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this._playing;
                }
                _hasInvalidDimensions() {
                    for (const e1 of [
                        this.canvas.width,
                        this.canvas.height
                    ])if (isNaN(e1) || e1 <= 0) return !0;
                    return !1;
                }
            },
            custom: class extends e1.Evented {
                constructor(t1, i, o, r){
                    super(), this.id = t1, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e1.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e1.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new U(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e1.extend(this, e1.pick(i, [
                        "dataType",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution",
                        "minTileCacheSize",
                        "maxTileCacheSize"
                    ]));
                }
                serialize() {
                    return e1.pick(this, [
                        "type",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution"
                    ]);
                }
                load() {
                    this._loaded = !0, this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
                loaded() {
                    return this._loaded;
                }
                onAdd(t1) {
                    this._map = t1, this._loaded = !1, this.fire(new e1.Event("dataloading", {
                        dataType: "source"
                    })), this._implementation.onAdd && this._implementation.onAdd(t1), this.load();
                }
                onRemove(e1) {
                    this._implementation.onRemove && this._implementation.onRemove(e1);
                }
                hasTile(e1) {
                    if (this._implementation.hasTile) {
                        const { x: t1 , y: i , z: o  } = e1.canonical;
                        return this._implementation.hasTile({
                            x: t1,
                            y: i,
                            z: o
                        });
                    }
                    return !this.tileBounds || this.tileBounds.contains(e1.canonical);
                }
                loadTile(t1, i) {
                    const { x: o , y: r , z: n  } = t1.tileID.canonical, s = new e1.window.AbortController;
                    t1.request = Promise.resolve(this._implementation.loadTile({
                        x: o,
                        y: r,
                        z: n
                    }, {
                        signal: s.signal
                    })).then((function(o) {
                        return delete t1.request, t1.aborted ? (t1.state = "unloaded", i(null)) : void 0 === o ? (t1.state = "errored", i(null)) : null === o ? (this.loadTileData(t1, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }), t1.state = "loaded", i(null)) : function(t1) {
                            return t1 instanceof e1.window.ImageData || t1 instanceof e1.window.HTMLCanvasElement || t1 instanceof e1.window.ImageBitmap || t1 instanceof e1.window.HTMLImageElement;
                        }(o) ? (this.loadTileData(t1, o), t1.state = "loaded", void i(null)) : (t1.state = "errored", i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                    }).bind(this)).catch((e1)=>{
                        20 !== e1.code && (t1.state = "errored", i(e1));
                    }), t1.request.cancel = ()=>s.abort();
                }
                loadTileData(e1, t1) {
                    Se.loadTileData(e1, t1, this._map.painter);
                }
                unloadTileData(e1) {
                    Se.unloadTileData(e1, this._map.painter);
                }
                unloadTile(e1, t1) {
                    if (this.unloadTileData(e1), this._implementation.unloadTile) {
                        const { x: t1 , y: i , z: o  } = e1.tileID.canonical;
                        this._implementation.unloadTile({
                            x: t1,
                            y: i,
                            z: o
                        });
                    }
                    t1();
                }
                abortTile(e1, t1) {
                    e1.request && e1.request.cancel && (e1.request.cancel(), delete e1.request), t1();
                }
                hasTransition() {
                    return !1;
                }
                _coveringTiles() {
                    return this._map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((e1)=>({
                            x: e1.canonical.x,
                            y: e1.canonical.y,
                            z: e1.canonical.z
                        }));
                }
                _clearTiles() {
                    this._map.style._clearSource(this.id);
                }
                _update() {
                    this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
            }
        }, Pe = function(t1, i, o, r) {
            const n = new ze[i.type](t1, i, o, r);
            if (n.id !== t1) throw new Error(`Expected Source id to be ${t1} instead of ${n.id}`);
            return e1.bindAll([
                "load",
                "abort",
                "unload",
                "serialize",
                "prepare"
            ], n), n;
        };
        function Re(t1, i) {
            const o = e1.identity([]);
            return e1.scale(o, o, [
                .5 * t1.width,
                .5 * -t1.height,
                1
            ]), e1.translate(o, o, [
                1,
                -1,
                0
            ]), e1.multiply(o, o, t1.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
        }
        function Oe(e1, t1, i, o, r, n, s, a = !1) {
            const l = e1.tilesIn(o, s, a);
            l.sort(ke);
            const c = [];
            for (const o of l)c.push({
                wrappedTileID: o.tile.tileID.wrapped().key,
                queryResults: o.tile.queryRenderedFeatures(t1, i, e1._state, o, r, n, Re(e1.transform, o.tile.tileID), a)
            });
            const h = function(e1) {
                const t1 = {}, i = {};
                for (const o of e1){
                    const e1 = o.queryResults, r = o.wrappedTileID, n = i[r] = i[r] || {};
                    for(const i in e1){
                        const o = e1[i], r = n[i] = n[i] || {}, s = t1[i] = t1[i] || [];
                        for (const e1 of o)r[e1.featureIndex] || (r[e1.featureIndex] = !0, s.push(e1));
                    }
                }
                return t1;
            }(c);
            for(const t1 in h)h[t1].forEach((t1)=>{
                const i = t1.feature, o = i.layer;
                o && "background" !== o.type && "sky" !== o.type && (i.source = o.source, o["source-layer"] && (i.sourceLayer = o["source-layer"]), i.state = void 0 !== i.id ? e1.getFeatureState(o["source-layer"], i.id) : {});
            });
            return h;
        }
        function Be(e1, t1) {
            const i = e1.getRenderableIds().map((t1)=>e1.getTileByID(t1)), o = [], r = {};
            for(let e1 = 0; e1 < i.length; e1++){
                const n = i[e1], s = n.tileID.canonical.key;
                r[s] || (r[s] = !0, n.querySourceFeatures(o, t1));
            }
            return o;
        }
        function ke(e1, t1) {
            const i = e1.tileID, o = t1.tileID;
            return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
        }
        function Fe() {
            return null != fn.workerClass ? new fn.workerClass : new e1.window.Worker(fn.workerUrl);
        }
        const Ue = "mapboxgl_preloaded_worker_pool";
        class Ne {
            constructor(){
                this.active = {};
            }
            acquire(e1) {
                if (!this.workers) for(this.workers = []; this.workers.length < Ne.workerCount;)this.workers.push(new Fe);
                return this.active[e1] = !0, this.workers.slice();
            }
            release(e1) {
                delete this.active[e1], 0 === this.numActive() && (this.workers.forEach((e1)=>{
                    e1.terminate();
                }), this.workers = null);
            }
            isPreloaded() {
                return !!this.active[Ue];
            }
            numActive() {
                return Object.keys(this.active).length;
            }
        }
        let Ge;
        function je() {
            return Ge || (Ge = new Ne), Ge;
        }
        function Ze(t1, i) {
            const o = {};
            for(const e1 in t1)"ref" !== e1 && (o[e1] = t1[e1]);
            return e1.refProperties.forEach((e1)=>{
                e1 in i && (o[e1] = i[e1]);
            }), o;
        }
        function Ve(e1) {
            e1 = e1.slice();
            const t1 = Object.create(null);
            for(let i = 0; i < e1.length; i++)t1[e1[i].id] = e1[i];
            for(let i = 0; i < e1.length; i++)"ref" in e1[i] && (e1[i] = Ze(e1[i], t1[e1[i].ref]));
            return e1;
        }
        Ne.workerCount = 2;
        const We = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setProjection: "setProjection"
        };
        function Xe(e1, t1, i) {
            i.push({
                command: We.addSource,
                args: [
                    e1,
                    t1[e1]
                ]
            });
        }
        function qe(e1, t1, i) {
            t1.push({
                command: We.removeSource,
                args: [
                    e1
                ]
            }), i[e1] = !0;
        }
        function $e(e1, t1, i, o) {
            qe(e1, i, o), Xe(e1, t1, i);
        }
        function He(e1, i, o) {
            let r;
            for(r in e1[o])if (e1[o].hasOwnProperty(r) && "data" !== r && !t1(e1[o][r], i[o][r])) return !1;
            for(r in i[o])if (i[o].hasOwnProperty(r) && "data" !== r && !t1(e1[o][r], i[o][r])) return !1;
            return !0;
        }
        function Ye(e1, i, o, r, n, s) {
            let a;
            for(a in i = i || {}, e1 = e1 || {})e1.hasOwnProperty(a) && (t1(e1[a], i[a]) || o.push({
                command: s,
                args: [
                    r,
                    a,
                    i[a],
                    n
                ]
            }));
            for(a in i)i.hasOwnProperty(a) && !e1.hasOwnProperty(a) && (t1(e1[a], i[a]) || o.push({
                command: s,
                args: [
                    r,
                    a,
                    i[a],
                    n
                ]
            }));
        }
        function Ke(e1) {
            return e1.id;
        }
        function Je(e1, t1) {
            return e1[t1.id] = t1, e1;
        }
        class Qe {
            constructor(e1, t1){
                this.reset(e1, t1);
            }
            reset(e1, t1) {
                this.points = e1 || [], this._distances = [
                    0
                ];
                for(let e1 = 1; e1 < this.points.length; e1++)this._distances[e1] = this._distances[e1 - 1] + this.points[e1].dist(this.points[e1 - 1]);
                this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t1) {
                if (1 === this.points.length) return this.points[0];
                t1 = e1.clamp(t1, 0, 1);
                let i = 1, o = this._distances[i];
                const r = t1 * this.paddedLength + this.padding;
                for(; o < r && i < this._distances.length;)o = this._distances[++i];
                const n = i - 1, s = this._distances[n], a = o - s, l = a > 0 ? (r - s) / a : 0;
                return this.points[n].mult(1 - l).add(this.points[i].mult(l));
            }
        }
        class et {
            constructor(e1, t1, i){
                const o = this.boxCells = [], r = this.circleCells = [];
                this.xCellCount = Math.ceil(e1 / i), this.yCellCount = Math.ceil(t1 / i);
                for(let e1 = 0; e1 < this.xCellCount * this.yCellCount; e1++)o.push([]), r.push([]);
                this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e1, this.height = t1, this.xScale = this.xCellCount / e1, this.yScale = this.yCellCount / t1, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e1, t1, i, o, r) {
                this._forEachCell(t1, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e1), this.bboxes.push(t1), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);
            }
            insertCircle(e1, t1, i, o) {
                this._forEachCell(t1 - o, i - o, t1 + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e1), this.circles.push(t1), this.circles.push(i), this.circles.push(o);
            }
            _insertBoxCell(e1, t1, i, o, r, n) {
                this.boxCells[r].push(n);
            }
            _insertCircleCell(e1, t1, i, o, r, n) {
                this.circleCells[r].push(n);
            }
            _query(e1, t1, i, o, r, n) {
                if (i < 0 || e1 > this.width || o < 0 || t1 > this.height) return !r && [];
                const s = [];
                if (e1 <= 0 && t1 <= 0 && this.width <= i && this.height <= o) {
                    if (r) return !0;
                    for(let e1 = 0; e1 < this.boxKeys.length; e1++)s.push({
                        key: this.boxKeys[e1],
                        x1: this.bboxes[4 * e1],
                        y1: this.bboxes[4 * e1 + 1],
                        x2: this.bboxes[4 * e1 + 2],
                        y2: this.bboxes[4 * e1 + 3]
                    });
                    for(let e1 = 0; e1 < this.circleKeys.length; e1++){
                        const t1 = this.circles[3 * e1], i = this.circles[3 * e1 + 1], o = this.circles[3 * e1 + 2];
                        s.push({
                            key: this.circleKeys[e1],
                            x1: t1 - o,
                            y1: i - o,
                            x2: t1 + o,
                            y2: i + o
                        });
                    }
                    return n ? s.filter(n) : s;
                }
                return this._forEachCell(e1, t1, i, o, this._queryCell, s, {
                    hitTest: r,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, n), r ? s.length > 0 : s;
            }
            _queryCircle(e1, t1, i, o, r) {
                const n = e1 - i, s = e1 + i, a = t1 - i, l = t1 + i;
                if (s < 0 || n > this.width || l < 0 || a > this.height) return !o && [];
                const c = [];
                return this._forEachCell(n, a, s, l, this._queryCellCircle, c, {
                    hitTest: o,
                    circle: {
                        x: e1,
                        y: t1,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, r), o ? c.length > 0 : c;
            }
            query(e1, t1, i, o, r) {
                return this._query(e1, t1, i, o, !1, r);
            }
            hitTest(e1, t1, i, o, r) {
                return this._query(e1, t1, i, o, !0, r);
            }
            hitTestCircle(e1, t1, i, o) {
                return this._queryCircle(e1, t1, i, !0, o);
            }
            _queryCell(e1, t1, i, o, r, n, s, a) {
                const l = s.seenUids, c = this.boxCells[r];
                if (null !== c) {
                    const r = this.bboxes;
                    for (const h of c)if (!l.box[h]) {
                        l.box[h] = !0;
                        const c = 4 * h;
                        if (e1 <= r[c + 2] && t1 <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!a || a(this.boxKeys[h]))) {
                            if (s.hitTest) return n.push(!0), !0;
                            n.push({
                                key: this.boxKeys[h],
                                x1: r[c],
                                y1: r[c + 1],
                                x2: r[c + 2],
                                y2: r[c + 3]
                            });
                        }
                    }
                }
                const h = this.circleCells[r];
                if (null !== h) {
                    const r = this.circles;
                    for (const c of h)if (!l.circle[c]) {
                        l.circle[c] = !0;
                        const h = 3 * c;
                        if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e1, t1, i, o) && (!a || a(this.circleKeys[c]))) {
                            if (s.hitTest) return n.push(!0), !0;
                            {
                                const e1 = r[h], t1 = r[h + 1], i = r[h + 2];
                                n.push({
                                    key: this.circleKeys[c],
                                    x1: e1 - i,
                                    y1: t1 - i,
                                    x2: e1 + i,
                                    y2: t1 + i
                                });
                            }
                        }
                    }
                }
            }
            _queryCellCircle(e1, t1, i, o, r, n, s, a) {
                const l = s.circle, c = s.seenUids, h = this.boxCells[r];
                if (null !== h) {
                    const e1 = this.bboxes;
                    for (const t1 of h)if (!c.box[t1]) {
                        c.box[t1] = !0;
                        const i = 4 * t1;
                        if (this._circleAndRectCollide(l.x, l.y, l.radius, e1[i + 0], e1[i + 1], e1[i + 2], e1[i + 3]) && (!a || a(this.boxKeys[t1]))) return n.push(!0), !0;
                    }
                }
                const u = this.circleCells[r];
                if (null !== u) {
                    const e1 = this.circles;
                    for (const t1 of u)if (!c.circle[t1]) {
                        c.circle[t1] = !0;
                        const i = 3 * t1;
                        if (this._circlesCollide(e1[i], e1[i + 1], e1[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t1]))) return n.push(!0), !0;
                    }
                }
            }
            _forEachCell(e1, t1, i, o, r, n, s, a) {
                const l = this._convertToXCellCoord(e1), c = this._convertToYCellCoord(t1), h = this._convertToXCellCoord(i), u = this._convertToYCellCoord(o);
                for(let _ = l; _ <= h; _++)for(let l = c; l <= u; l++)if (r.call(this, e1, t1, i, o, this.xCellCount * l + _, n, s, a)) return;
            }
            _convertToXCellCoord(e1) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e1 * this.xScale)));
            }
            _convertToYCellCoord(e1) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e1 * this.yScale)));
            }
            _circlesCollide(e1, t1, i, o, r, n) {
                const s = o - e1, a = r - t1, l = i + n;
                return l * l > s * s + a * a;
            }
            _circleAndRectCollide(e1, t1, i, o, r, n, s) {
                const a = (n - o) / 2, l = Math.abs(e1 - (o + a));
                if (l > a + i) return !1;
                const c = (s - r) / 2, h = Math.abs(t1 - (r + c));
                if (h > c + i) return !1;
                if (l <= a || h <= c) return !0;
                const u = l - a, _ = h - c;
                return u * u + _ * _ <= i * i;
            }
        }
        const tt = Math.tan(85 * Math.PI / 180);
        function it(t1, i, o, r, n, s, a) {
            const l = e1.create();
            if (o) {
                if ("globe" === s.name) {
                    const t1 = e1.calculateGlobeLabelMatrix(n, i);
                    e1.multiply(l, l, t1);
                } else {
                    const t1 = v([], a);
                    l[0] = t1[0], l[1] = t1[1], l[4] = t1[2], l[5] = t1[3], r || e1.rotateZ(l, l, n.angle);
                }
            } else e1.multiply(l, n.labelPlaneMatrix, t1);
            return l;
        }
        function ot(e1, t1, i, o, r, n, s) {
            const a = it(e1, t1, i, o, r, n, s);
            return "globe" === n.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;
        }
        function rt(t1, i, o, r, n, s, a) {
            if (o) {
                if ("globe" === s.name) {
                    const l = it(t1, i, o, r, n, s, a);
                    return e1.invert(l, l), e1.multiply(l, t1, l), l;
                }
                {
                    const i = e1.clone(t1), o = e1.identity([]);
                    return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e1.multiply(i, i, o), r || e1.rotateZ(i, i, -n.angle), i;
                }
            }
            return n.glCoordMatrix;
        }
        function nt(t1, i, o, r) {
            const n = [
                t1,
                i,
                o,
                1
            ];
            o ? e1.transformMat4$1(n, n, r) : ft(n, n, r);
            const s = n[3];
            return n[0] /= s, n[1] /= s, n[2] /= s, n;
        }
        function st(e1, t1) {
            return Math.min(.5 + e1 / t1 * .5, 1.5);
        }
        function at(e1, t1) {
            const i = e1[0] / e1[3], o = e1[1] / e1[3];
            return i >= -t1[0] && i <= t1[0] && o >= -t1[1] && o <= t1[1];
        }
        function lt(t1, i, o, r, n, s, a, l, c, h) {
            const u = o.transform, _ = r ? t1.textSizeData : t1.iconSizeData, d = e1.evaluateSizeForZoom(_, o.transform.zoom), p = "globe" === u.projection.name, m = [
                256 / o.width * 2 + 1,
                256 / o.height * 2 + 1
            ], f = r ? t1.text.dynamicLayoutVertexArray : t1.icon.dynamicLayoutVertexArray;
            f.clear();
            let g = null;
            p && (g = r ? t1.text.globeExtVertexArray : t1.icon.globeExtVertexArray);
            const v = t1.lineVertexArray, x = r ? t1.text.placedSymbolArray : t1.icon.placedSymbolArray, y = o.transform.width / o.transform.height;
            let b, w = !1;
            for(let r = 0; r < x.length; r++){
                const p = x.get(r), { numGlyphs: T , writingMode: E  } = p;
                if (E !== e1.WritingMode.vertical || w || b === e1.WritingMode.horizontal || (w = !0), b = E, (p.hidden || E === e1.WritingMode.vertical) && !w) {
                    mt(T, f);
                    continue;
                }
                w = !1;
                const C = new e1.pointGeometry(p.tileAnchorX, p.tileAnchorY);
                let { x: M , y: I , z: S  } = u.projection.projectTilePoint(C.x, C.y, h.canonical);
                if (c) {
                    const [e1, t1, i] = c(C);
                    M += e1, I += t1, S += i;
                }
                const D = [
                    M,
                    I,
                    S,
                    1
                ];
                if (e1.transformMat4$1(D, D, i), !at(D, m)) {
                    mt(T, f);
                    continue;
                }
                const L = st(o.transform.cameraToCenterDistance, D[3]), A = e1.evaluateSizeForFeature(_, d, p), z = a ? A / L : A * L, P = nt(M, I, S, n);
                if (P[3] <= 0) {
                    mt(T, f);
                    continue;
                }
                let R = {};
                const O = a ? null : c, B = ut(p, z, !1, l, i, n, s, t1.glyphOffsetArray, v, f, g, P, C, R, y, O, u.projection, h, a);
                w = B.useVertical, O && B.needsFlipping && (R = {}), (B.notEnoughRoom || w || B.needsFlipping && ut(p, z, !0, l, i, n, s, t1.glyphOffsetArray, v, f, g, P, C, R, y, O, u.projection, h, a).notEnoughRoom) && mt(T, f);
            }
            r ? (t1.text.dynamicLayoutVertexBuffer.updateData(f), g && t1.text.globeExtVertexBuffer.updateData(g)) : (t1.icon.dynamicLayoutVertexBuffer.updateData(f), g && t1.icon.globeExtVertexBuffer.updateData(g));
        }
        function ct(e1, t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
            const { lineStartIndex: f , glyphStartIndex: g , segment: v  } = a, x = g + a.numGlyphs, y = f + a.lineLength, b = t1.getoffsetX(g), w = t1.getoffsetX(x - 1), T = pt(e1 * b, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);
            if (!T) return null;
            const E = pt(e1 * w, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);
            return E ? {
                first: T,
                last: E
            } : null;
        }
        function ht(t1, i, o, r) {
            return t1 === e1.WritingMode.horizontal && Math.abs(r) > Math.abs(o) ? {
                useVertical: !0
            } : t1 === e1.WritingMode.vertical ? r > 0 ? {
                needsFlipping: !0
            } : null : 0 !== i && function(e1, t1) {
                return 0 === e1 || Math.abs(t1 / e1) > tt;
            }(o, r) ? 1 === i ? {
                needsFlipping: !0
            } : null : o < 0 ? {
                needsFlipping: !0
            } : null;
        }
        function ut(t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v, x) {
            const y = i / 24, b = t1.lineOffsetX * y, w = t1.lineOffsetY * y, { lineStartIndex: T , glyphStartIndex: E , numGlyphs: C , segment: M , writingMode: I , flipState: S  } = t1, D = T + t1.lineLength, L = (t1)=>{
                if (u) {
                    const [i, o, r] = t1.up, n = h.length;
                    e1.updateGlobeVertexNormal(u, n + 0, i, o, r), e1.updateGlobeVertexNormal(u, n + 1, i, o, r), e1.updateGlobeVertexNormal(u, n + 2, i, o, r), e1.updateGlobeVertexNormal(u, n + 3, i, o, r);
                }
                const [i, o, r] = t1.point;
                e1.addDynamicAttributes(h, i, o, r, t1.angle);
            };
            if (C > 1) {
                const e1 = ct(y, l, b, w, o, _, d, t1, c, s, p, f, !1, g, v, x);
                if (!e1) return {
                    notEnoughRoom: !0
                };
                if (r && !o) {
                    let [i, o, r] = e1.first.point, [n, s, l] = e1.last.point;
                    [i, o] = nt(i, o, r, a), [n, s] = nt(n, s, l, a);
                    const c = ht(I, S, (n - i) * m, s - o);
                    if (t1.flipState = c && c.needsFlipping ? 1 : 2, c) return c;
                }
                L(e1.first);
                for(let e1 = E + 1; e1 < E + C - 1; e1++){
                    const t1 = pt(y * l.getoffsetX(e1), b, w, o, _, d, M, T, D, c, s, p, f, !1, !1, g, v, x);
                    if (!t1) return h.length -= 4 * (e1 - E), {
                        notEnoughRoom: !0
                    };
                    L(t1);
                }
                L(e1.last);
            } else {
                if (r && !o) {
                    const i = nt(d.x, d.y, 0, n), o = T + M + 1, r = new e1.pointGeometry(c.getx(o), c.gety(o)), s = nt(r.x, r.y, 0, n), a = s[3] > 0 ? s : dt(d, r, i, 1, n, void 0, g, v.canonical), l = ht(I, S, (a[0] - i[0]) * m, a[1] - i[1]);
                    if (t1.flipState = l && l.needsFlipping ? 1 : 2, l) return l;
                }
                const i = pt(y * l.getoffsetX(E), b, w, o, _, d, M, T, D, c, s, p, f, !1, !1, g, v, x);
                if (!i) return {
                    notEnoughRoom: !0
                };
                L(i);
            }
            return {};
        }
        function _t(e1, t1, i, o, r) {
            const { x: n , y: s , z: a  } = o.projectTilePoint(e1.x, e1.y, t1);
            if (!r) return nt(n, s, a, i);
            const [l, c, h] = r(e1);
            return nt(n + l, s + c, a + h, i);
        }
        function dt(t1, i, o, r, n, s, a, l) {
            const c = _t(t1.sub(i)._unit()._add(t1), l, n, a, s);
            return e1.sub(c, o, c), e1.normalize(c, c), e1.scaleAndAdd(c, o, c, r);
        }
        function pt(t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v) {
            const x = r ? t1 - i : t1 + i;
            let y = x > 0 ? 1 : -1, b = 0;
            r && (y *= -1, b = Math.PI), y < 0 && (b += Math.PI);
            let w = l + a + (y > 0 ? 0 : 1) | 0, T = n, E = n, C = 0, M = 0;
            const I = Math.abs(x), S = [], D = [];
            let L = s, A = L;
            const z = ()=>dt(A, L, E, I - C + 1, u, d, f, g.canonical);
            for(; C + M <= I;){
                if (w += y, w < l || w >= c) return null;
                if (E = T, A = L, S.push(E), p && D.push(A), L = new e1.pointGeometry(h.getx(w), h.gety(w)), T = _[w], !T) {
                    const e1 = _t(L, g.canonical, u, f, d);
                    T = e1[3] > 0 ? _[w] = e1 : z();
                }
                C += M, M = e1.distance(E, T);
            }
            m && d && (_[w] && (T = z(), M = e1.distance(E, T)), _[w] = T);
            const P = (I - C) / M, R = L.sub(A)._mult(P)._add(A), O = e1.sub([], T, E), B = e1.scaleAndAdd([], E, O, P);
            let k = [
                0,
                0,
                1
            ], F = O[0], U = O[1];
            if (v && (k = f.upVector(g.canonical, R.x, R.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {
                const t1 = [
                    k[2],
                    0,
                    -k[0]
                ], i = e1.cross([], k, t1);
                e1.normalize(t1, t1), e1.normalize(i, i), F = e1.dot(O, t1), U = e1.dot(O, i);
            }
            if (o) {
                const t1 = e1.cross([], k, O);
                e1.normalize(t1, t1), e1.scaleAndAdd(B, B, t1, o * y);
            }
            const N = b + Math.atan2(U, F);
            return S.push(B), p && D.push(R), {
                point: B,
                angle: N,
                path: S,
                tilePath: D,
                up: k
            };
        }
        function mt(e1, t1) {
            const i = t1.length, o = i + 4 * e1;
            t1.resize(o), t1.float32.fill(-1 / 0, 4 * i, 4 * o);
        }
        function ft(e1, t1, i) {
            const o = t1[0], r = t1[1];
            return e1[0] = i[0] * o + i[4] * r + i[12], e1[1] = i[1] * o + i[5] * r + i[13], e1[3] = i[3] * o + i[7] * r + i[15], e1;
        }
        const gt = 100;
        class vt {
            constructor(e1, t1, i = new et(e1.width + 200, e1.height + 200, 25), o = new et(e1.width + 200, e1.height + 200, 25)){
                this.transform = e1, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e1._pitch) * e1.cameraToCenterDistance, this.screenRightBoundary = e1.width + gt, this.screenBottomBoundary = e1.height + gt, this.gridRightBoundary = e1.width + 200, this.gridBottomBoundary = e1.height + 200, this.fogState = t1;
            }
            placeCollisionBox(e1, t1, i, o, r, n, s, a) {
                let l = i.projectedAnchorX, c = i.projectedAnchorY, h = i.projectedAnchorZ;
                const u = i.elevation, _ = i.tileID, d = e1.getProjection();
                if (u && _) {
                    const [e1, t1, o] = d.upVector(_.canonical, i.tileAnchorX, i.tileAnchorY), r = d.upVectorScale(_.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    l += e1 * u * r, c += t1 * u * r, h += o * u * r;
                }
                const p = this.projectAndGetPerspectiveRatio(s, l, c, h, i.tileID, "globe" === d.name || !!u || this.transform.pitch > 0, d), m = n * p.perspectiveRatio, f = (i.x1 * t1 + o.x - i.padding) * m + p.point.x, g = (i.y1 * t1 + o.y - i.padding) * m + p.point.y, v = (i.x2 * t1 + o.x + i.padding) * m + p.point.x, x = (i.y2 * t1 + o.y + i.padding) * m + p.point.y, y = p.perspectiveRatio <= .55 || p.occluded;
                return !this.isInsideGrid(f, g, v, x) || !r && this.grid.hitTest(f, g, v, x, a) || y ? {
                    box: [],
                    offscreen: !1,
                    occluded: p.occluded
                } : {
                    box: [
                        f,
                        g,
                        v,
                        x
                    ],
                    offscreen: this.isOffscreen(f, g, v, x),
                    occluded: !1
                };
            }
            placeCollisionCircles(t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
                const f = [], g = this.transform.elevation, v = t1.getProjection(), x = g ? g.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, v) : null, y = new e1.pointGeometry(o.tileAnchorX, o.tileAnchorY);
                let { x: b , y: w , z: T  } = v.projectTilePoint(y.x, y.y, m.canonical);
                if (x) {
                    const [e1, t1, i] = x(y);
                    b += e1, w += t1, T += i;
                }
                const E = "globe" === v.name, C = this.projectAndGetPerspectiveRatio(a, b, w, T, m, E || !!g || this.transform.pitch > 0, v), { perspectiveRatio: M  } = C, I = (u ? s / M : s * M) / e1.ONE_EM, S = nt(b, w, T, l), D = C.signedDistanceFromCamera > 0 ? ct(I, n, o.lineOffsetX * I, o.lineOffsetY * I, !1, S, y, o, r, l, {}, g && !u ? x : null, u && !!g, v, m, u) : null;
                let L = !1, A = !1, z = !0;
                if (D && !C.occluded) {
                    const t1 = .5 * d * M + p, o = new e1.pointGeometry(-100, -100), r = new e1.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), n = new Qe, { first: s , last: a  } = D, l = s.path.length;
                    let u = [];
                    for(let e1 = l - 1; e1 >= 1; e1--)u.push(s.path[e1]);
                    for(let e1 = 1; e1 < a.path.length; e1++)u.push(a.path[e1]);
                    const m = 2.5 * t1;
                    c && (u = u.map(([e1, t1, i], o)=>(x && !E && (i = x(o < l - 1 ? s.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), nt(e1, t1, i, c))), u.some((e1)=>e1[3] <= 0) && (u = []));
                    let g = [];
                    if (u.length > 0) {
                        let t1 = 1 / 0, i = -1 / 0, n = 1 / 0, s = -1 / 0;
                        for (const e1 of u)t1 = Math.min(t1, e1[0]), n = Math.min(n, e1[1]), i = Math.max(i, e1[0]), s = Math.max(s, e1[1]);
                        i >= o.x && t1 <= r.x && s >= o.y && n <= r.y && (g = [
                            u.map((t1)=>new e1.pointGeometry(t1[0], t1[1]))
                        ], (t1 < o.x || i > r.x || n < o.y || s > r.y) && (g = e1.clipLine(g, o.x, o.y, r.x, r.y)));
                    }
                    for (const e1 of g){
                        n.reset(e1, .25 * t1);
                        let o = 0;
                        o = n.length <= .5 * t1 ? 1 : Math.ceil(n.paddedLength / m) + 1;
                        for(let e1 = 0; e1 < o; e1++){
                            const r = e1 / Math.max(o - 1, 1), s = n.lerp(r), a = s.x + gt, l = s.y + gt;
                            f.push(a, l, t1, 0);
                            const c = a - t1, u = l - t1, d = a + t1, p = l + t1;
                            if (z = z && this.isOffscreen(c, u, d, p), A = A || this.isInsideGrid(c, u, d, p), !i && this.grid.hitTestCircle(a, l, t1, _) && (L = !0, !h)) return {
                                circles: [],
                                offscreen: !1,
                                collisionDetected: L,
                                occluded: !1
                            };
                        }
                    }
                }
                return {
                    circles: !h && L || !A ? [] : f,
                    offscreen: z,
                    collisionDetected: L,
                    occluded: C.occluded
                };
            }
            queryRenderedSymbols(t1) {
                if (0 === t1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
                const i = [];
                let o = 1 / 0, r = 1 / 0, n = -1 / 0, s = -1 / 0;
                for (const a of t1){
                    const t1 = new e1.pointGeometry(a.x + gt, a.y + gt);
                    o = Math.min(o, t1.x), r = Math.min(r, t1.y), n = Math.max(n, t1.x), s = Math.max(s, t1.y), i.push(t1);
                }
                const a = this.grid.query(o, r, n, s).concat(this.ignoredGrid.query(o, r, n, s)), l = {}, c = {};
                for (const t1 of a){
                    const o = t1.key;
                    if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
                    const r = [
                        new e1.pointGeometry(t1.x1, t1.y1),
                        new e1.pointGeometry(t1.x2, t1.y1),
                        new e1.pointGeometry(t1.x2, t1.y2),
                        new e1.pointGeometry(t1.x1, t1.y2)
                    ];
                    e1.polygonIntersectsPolygon(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
                }
                return c;
            }
            insertCollisionBox(e1, t1, i, o, r) {
                (t1 ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                }, e1[0], e1[1], e1[2], e1[3]);
            }
            insertCollisionCircles(e1, t1, i, o, r) {
                const n = t1 ? this.ignoredGrid : this.grid, s = {
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                };
                for(let t1 = 0; t1 < e1.length; t1 += 4)n.insertCircle(s, e1[t1], e1[t1 + 1], e1[t1 + 2]);
            }
            projectAndGetPerspectiveRatio(t1, i, o, r, n, s, a) {
                const l = [
                    i,
                    o,
                    r,
                    1
                ];
                let c = !1;
                if (r || this.transform.pitch > 0) {
                    e1.transformMat4$1(l, l, t1);
                    const s = "globe" === a.name;
                    if (this.fogState && n && !s) {
                        const t1 = function(t1, i, o, r, n, s) {
                            const a = s.calculateFogTileMatrix(n), l = [
                                i,
                                o,
                                r
                            ];
                            return e1.transformMat4(l, l, a), I(t1, l, s.pitch, s._fov);
                        }(this.fogState, i, o, r, n.toUnwrapped(), this.transform);
                        c = t1 > .9;
                    }
                } else ft(l, l, t1);
                const h = l[3];
                return {
                    point: new e1.pointGeometry((l[0] / h + 1) / 2 * this.transform.width + gt, (-l[1] / h + 1) / 2 * this.transform.height + gt),
                    perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),
                    signedDistanceFromCamera: h,
                    occluded: s && l[2] > h || c
                };
            }
            isOffscreen(e1, t1, i, o) {
                return i < gt || e1 >= this.screenRightBoundary || o < gt || t1 > this.screenBottomBoundary;
            }
            isInsideGrid(e1, t1, i, o) {
                return i >= 0 && e1 < this.gridRightBoundary && o >= 0 && t1 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
                const t1 = e1.identity([]);
                return e1.translate(t1, t1, [
                    -100,
                    -100,
                    0
                ]), t1;
            }
        }
        function xt(t1, i, o) {
            const r = i.createTileMatrix(t1, t1.worldSize, o.toUnwrapped());
            return e1.multiply(new Float32Array(16), t1.projMatrix, r);
        }
        function yt(e1, t1, i) {
            if (t1.projection.name === i.projection.name) return e1.projMatrix;
            const o = i.clone();
            return o.setProjection(t1.projection), xt(o, t1.getProjection(), e1);
        }
        function bt(e1, t1, i) {
            return t1.name === i.projection.name ? e1.projMatrix : xt(i, t1, e1);
        }
        class wt {
            constructor(e1, t1, i, o){
                this.opacity = e1 ? Math.max(0, Math.min(1, e1.opacity + (e1.placed ? t1 : -t1))) : o && i ? 1 : 0, this.placed = i;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }
        class Tt {
            constructor(e1, t1, i, o, r, n = !1){
                this.text = new wt(e1 ? e1.text : null, t1, i, r), this.icon = new wt(e1 ? e1.icon : null, t1, o, r), this.clipped = n;
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }
        class Et {
            constructor(e1, t1, i, o = !1){
                this.text = e1, this.icon = t1, this.skipFade = i, this.clipped = o;
            }
        }
        class Ct {
            constructor(){
                this.invProjMatrix = e1.create(), this.viewportMatrix = e1.create(), this.circles = [];
            }
        }
        class Mt {
            constructor(e1, t1, i, o, r){
                this.bucketInstanceId = e1, this.featureIndex = t1, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;
            }
        }
        class It {
            constructor(e1){
                this.crossSourceCollisions = e1, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e1) {
                if (this.crossSourceCollisions) return {
                    ID: 0,
                    predicate: null
                };
                if (!this.collisionGroups[e1]) {
                    const t1 = ++this.maxGroupID;
                    this.collisionGroups[e1] = {
                        ID: t1,
                        predicate: (e1)=>e1.collisionGroupID === t1
                    };
                }
                return this.collisionGroups[e1];
            }
        }
        function St(t1, i, o, r, n) {
            const { horizontalAlign: s , verticalAlign: a  } = e1.getAnchorAlignment(t1), l = -(s - .5) * i, c = -(a - .5) * o, h = e1.evaluateVariableOffset(t1, r);
            return new e1.pointGeometry(l + h[0] * n, c + h[1] * n);
        }
        function Dt(t1, i, o, r, n) {
            const s = new e1.pointGeometry(t1, i);
            return o && s._rotate(r ? n : -n), s;
        }
        class Lt {
            constructor(e1, t1, i, o, r){
                this.transform = e1.clone(), this.projection = e1.projection.name, this.collisionIndex = new vt(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t1, this.retainedQueryData = {}, this.collisionGroups = new It(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(t1, i, o, r) {
                const n = o.getBucket(i), s = o.latestFeatureIndex;
                if (!n || !s || i.id !== n.layerIds[0]) return;
                const a = n.layers[0].layout, l = o.collisionBoxArray, c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), h = o.tileSize / e1.EXTENT, u = o.tileID.toUnwrapped();
                this.transform.setProjection(n.projection);
                const _ = (d = o.tileID, p = n.getProjection(), m = this.transform, p.name === this.projection ? m.calculateProjMatrix(d.toUnwrapped()) : xt(m, p, d));
                var d, p, m;
                const f = "map" === a.get("text-pitch-alignment"), g = "map" === a.get("text-rotation-alignment");
                i.compileFilter();
                const v = i.dynamicFilter(), x = i.dynamicFilterNeedsFeature(), y = this.transform.calculatePixelsToTileUnitsMatrix(o), b = ot(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);
                let w = null;
                if (f) {
                    const t1 = rt(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);
                    w = e1.multiply([], this.transform.labelPlaneMatrix, t1);
                }
                let T = null;
                v && o.latestFeatureIndex && (T = {
                    unwrappedTileID: u,
                    dynamicFilter: v,
                    dynamicFilterNeedsFeature: x,
                    featureIndex: o.latestFeatureIndex
                }), this.retainedQueryData[n.bucketInstanceId] = new Mt(n.bucketInstanceId, s, n.sourceLayerIndex, n.index, o.tileID);
                const E = {
                    bucket: n,
                    layout: a,
                    posMatrix: _,
                    textLabelPlaneMatrix: b,
                    labelToScreenMatrix: w,
                    clippingData: T,
                    scale: c,
                    textPixelRatio: h,
                    holdingForFade: o.holdingForFade(),
                    collisionBoxArray: l,
                    partiallyEvaluatedTextSize: e1.evaluateSizeForZoom(n.textSizeData, this.transform.zoom),
                    partiallyEvaluatedIconSize: e1.evaluateSizeForZoom(n.iconSizeData, this.transform.zoom),
                    collisionGroup: this.collisionGroups.get(n.sourceID)
                };
                if (r) for (const e1 of n.sortKeyRanges){
                    const { sortKey: i , symbolInstanceStart: o , symbolInstanceEnd: r  } = e1;
                    t1.push({
                        sortKey: i,
                        symbolInstanceStart: o,
                        symbolInstanceEnd: r,
                        parameters: E
                    });
                }
                else t1.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: n.symbolInstances.length,
                    parameters: E
                });
            }
            attemptAnchorPlacement(e1, t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) {
                const { textOffset0: v , textOffset1: x , crossTileID: y  } = u, b = [
                    v,
                    x
                ], w = St(e1, i, o, b, r), T = this.collisionIndex.placeCollisionBox(d, r, t1, Dt(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate);
                if (m) {
                    const e1 = d.getSymbolInstanceIconSize(g, this.transform.zoom, u.placedIconSymbolIndex);
                    if (0 === this.collisionIndex.placeCollisionBox(d, e1, m, Dt(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate).box.length) return;
                }
                if (T.box.length > 0) {
                    let t1;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[y] && this.prevPlacement.placements[y] && this.prevPlacement.placements[y].text && (t1 = this.prevPlacement.variableOffsets[y].anchor), this.variableOffsets[y] = {
                        textOffset: b,
                        width: i,
                        height: o,
                        anchor: e1,
                        textScale: r,
                        prevAnchor: t1
                    }, this.markUsedJustification(d, e1, u, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, u), this.placedOrientations[y] = p), {
                        shift: w,
                        placedGlyphBoxes: T
                    };
                }
            }
            placeLayerBucketPart(t1, i, o, r) {
                const { bucket: n , layout: s , posMatrix: a , textLabelPlaneMatrix: l , labelToScreenMatrix: c , clippingData: h , textPixelRatio: u , holdingForFade: _ , collisionBoxArray: d , partiallyEvaluatedTextSize: p , partiallyEvaluatedIconSize: m , collisionGroup: f  } = t1.parameters, g = s.get("text-optional"), v = s.get("icon-optional"), x = s.get("text-allow-overlap"), y = s.get("icon-allow-overlap"), b = "map" === s.get("text-rotation-alignment"), w = "map" === s.get("text-pitch-alignment"), T = "none" !== s.get("icon-text-fit"), E = "viewport-y" === s.get("symbol-z-order");
                this.transform.setProjection(n.projection);
                let C = x && (y || !n.hasIconData() || v), M = y && (x || !n.hasTextData() || g);
                !n.collisionArrays && d && n.deserializeCollisionBoxes(d), o && r && n.updateCollisionDebugBuffers(this.transform.zoom, d);
                const I = (t1, r, d)=>{
                    const { crossTileID: E , numVerticalGlyphVertices: I  } = t1;
                    if (h) {
                        const o = {
                            zoom: this.transform.zoom,
                            pitch: this.transform.pitch
                        };
                        let r = null;
                        if (h.dynamicFilterNeedsFeature) {
                            const e1 = this.retainedQueryData[n.bucketInstanceId];
                            r = h.featureIndex.loadFeature({
                                featureIndex: t1.featureIndex,
                                bucketIndex: e1.bucketIndex,
                                sourceLayerIndex: e1.sourceLayerIndex,
                                layoutVertexArrayOffset: 0
                            });
                        }
                        if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e1.pointGeometry(t1.tileAnchorX, t1.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[E] = new Et(!1, !1, !1, !0), void (i[E] = !0);
                    }
                    if (i[E]) return;
                    if (_) return void (this.placements[E] = new Et(!1, !1, !1));
                    let S = !1, D = !1, L = !0, A = !1, z = !1, P = null, R = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, O = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, B = null, k = null, F = null, U = 0, N = 0, G = 0;
                    d.textFeatureIndex ? U = d.textFeatureIndex : t1.useRuntimeCollisionCircles && (U = t1.featureIndex), d.verticalTextFeatureIndex && (N = d.verticalTextFeatureIndex);
                    const j = (e1)=>{
                        e1.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;
                        const t1 = this.transform.elevation;
                        (t1 || e1.elevation) && (e1.elevation = t1 ? t1.getAtTileOffset(e1.tileID, e1.tileAnchorX, e1.tileAnchorY) : 0);
                    }, Z = d.textBox;
                    if (Z) {
                        j(Z);
                        const i = (i)=>{
                            let o = e1.WritingMode.horizontal;
                            if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                                const e1 = this.prevPlacement.placedOrientations[E];
                                e1 && (this.placedOrientations[E] = e1, o = e1, this.markUsedOrientation(n, o, t1));
                            }
                            return o;
                        }, o = (t1, i)=>{
                            if (n.allowVerticalPlacement && I > 0 && d.verticalTextBox) {
                                for (const o of n.writingModes)if (o === e1.WritingMode.vertical ? (R = i(), O = R) : R = t1(), R && R.box && R.box.length) break;
                            } else R = t1();
                        };
                        if (s.get("text-variable-anchor")) {
                            let l = s.get("text-variable-anchor");
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[E]) {
                                const e1 = this.prevPlacement.variableOffsets[E];
                                l.indexOf(e1.anchor) > 0 && (l = l.filter((t1)=>t1 !== e1.anchor), l.unshift(e1.anchor));
                            }
                            const c = (e1, i, o)=>{
                                const s = n.getSymbolInstanceTextSize(p, t1, this.transform.zoom, r), c = (e1.x2 - e1.x1) * s + 2 * e1.padding, h = (e1.y2 - e1.y1) * s + 2 * e1.padding, _ = T && !y ? i : null;
                                _ && j(_);
                                let d = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const g = x ? 2 * l.length : l.length;
                                for(let i = 0; i < g; ++i){
                                    const g = this.attemptAnchorPlacement(l[i % l.length], e1, c, h, s, b, w, u, a, f, i >= l.length, t1, r, n, o, _, p, m);
                                    if (g && (d = g.placedGlyphBoxes, d && d.box && d.box.length)) {
                                        S = !0, P = g.shift;
                                        break;
                                    }
                                }
                                return d;
                            };
                            o(()=>c(Z, d.iconBox, e1.WritingMode.horizontal), ()=>{
                                const t1 = d.verticalTextBox;
                                return t1 && j(t1), n.allowVerticalPlacement && !(R && R.box && R.box.length) && I > 0 && t1 ? c(t1, d.verticalIconBox, e1.WritingMode.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), R && (S = R.box, L = R.offscreen, A = R.occluded);
                            const h = i(R && R.box);
                            if (!S && this.prevPlacement) {
                                const e1 = this.prevPlacement.variableOffsets[E];
                                e1 && (this.variableOffsets[E] = e1, this.markUsedJustification(n, e1.anchor, t1, h));
                            }
                        } else {
                            const s = (i, o)=>{
                                const s = n.getSymbolInstanceTextSize(p, t1, this.transform.zoom, r), l = this.collisionIndex.placeCollisionBox(n, s, i, new e1.pointGeometry(0, 0), x, u, a, f.predicate);
                                return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t1), this.placedOrientations[E] = o), l;
                            };
                            o(()=>s(Z, e1.WritingMode.horizontal), ()=>{
                                const t1 = d.verticalTextBox;
                                return n.allowVerticalPlacement && I > 0 && t1 ? (j(t1), s(t1, e1.WritingMode.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), i(R && R.box && R.box.length);
                        }
                    }
                    if (B = R, S = B && B.box && B.box.length > 0, L = B && B.offscreen, A = B && B.occluded, t1.useRuntimeCollisionCircles) {
                        const i = n.text.placedSymbolArray.get(t1.centerJustifiedTextSymbolIndex >= 0 ? t1.centerJustifiedTextSymbolIndex : t1.verticalPlacedTextSymbolIndex), r = e1.evaluateSizeForFeature(n.textSizeData, p, i), h = s.get("text-padding");
                        k = this.collisionIndex.placeCollisionCircles(n, x, i, n.lineVertexArray, n.glyphOffsetArray, r, a, l, c, o, w, f.predicate, t1.collisionCircleDiameter * r / e1.ONE_EM, h, this.retainedQueryData[n.bucketInstanceId].tileID), S = x || k.circles.length > 0 && !k.collisionDetected, L = L && k.offscreen, A = k.occluded;
                    }
                    if (d.iconFeatureIndex && (G = d.iconFeatureIndex), d.iconBox) {
                        const i = (i)=>{
                            j(i);
                            const o = T && P ? Dt(P.x, P.y, b, w, this.transform.angle) : new e1.pointGeometry(0, 0), r = n.getSymbolInstanceIconSize(m, this.transform.zoom, t1.placedIconSymbolIndex);
                            return this.collisionIndex.placeCollisionBox(n, r, i, o, y, u, a, f.predicate);
                        };
                        O && O.box && O.box.length && d.verticalIconBox ? (F = i(d.verticalIconBox), D = F.box.length > 0) : (F = i(d.iconBox), D = F.box.length > 0), L = L && F.offscreen, z = F.occluded;
                    }
                    const V = g || 0 === t1.numHorizontalGlyphVertices && 0 === I, W = v || 0 === t1.numIconVertices;
                    if (V || W ? W ? V || (D = D && S) : S = D && S : D = S = D && S, S && B && B.box && this.collisionIndex.insertCollisionBox(B.box, s.get("text-ignore-placement"), n.bucketInstanceId, O && O.box && N ? N : U, f.ID), D && F && this.collisionIndex.insertCollisionBox(F.box, s.get("icon-ignore-placement"), n.bucketInstanceId, G, f.ID), k && (S && this.collisionIndex.insertCollisionCircles(k.circles, s.get("text-ignore-placement"), n.bucketInstanceId, U, f.ID), o)) {
                        const e1 = n.bucketInstanceId;
                        let t1 = this.collisionCircleArrays[e1];
                        void 0 === t1 && (t1 = this.collisionCircleArrays[e1] = new Ct);
                        for(let e1 = 0; e1 < k.circles.length; e1 += 4)t1.circles.push(k.circles[e1 + 0]), t1.circles.push(k.circles[e1 + 1]), t1.circles.push(k.circles[e1 + 2]), t1.circles.push(k.collisionDetected ? 1 : 0);
                    }
                    const X = "globe" !== n.projection.name;
                    C = C && (X || !A), M = M && (X || !z), this.placements[E] = new Et(S || C, D || M, L || n.justReloaded), i[E] = !0;
                };
                if (E) {
                    const e1 = n.getSortedSymbolIndexes(this.transform.angle);
                    for(let t1 = e1.length - 1; t1 >= 0; --t1){
                        const i = e1[t1];
                        I(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                    }
                } else for(let e1 = t1.symbolInstanceStart; e1 < t1.symbolInstanceEnd; e1++)I(n.symbolInstances.get(e1), e1, n.collisionArrays[e1]);
                if (o && n.bucketInstanceId in this.collisionCircleArrays) {
                    const t1 = this.collisionCircleArrays[n.bucketInstanceId];
                    e1.invert(t1.invProjMatrix, a), t1.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                n.justReloaded = !1;
            }
            markUsedJustification(t1, i, o, r) {
                const { leftJustifiedTextSymbolIndex: n , centerJustifiedTextSymbolIndex: s , rightJustifiedTextSymbolIndex: a , verticalPlacedTextSymbolIndex: l , crossTileID: c  } = o, h = e1.getAnchorJustification(i), u = r === e1.WritingMode.vertical ? l : "left" === h ? n : "center" === h ? s : "right" === h ? a : -1;
                n >= 0 && (t1.text.placedSymbolArray.get(n).crossTileID = u >= 0 && n !== u ? 0 : c), s >= 0 && (t1.text.placedSymbolArray.get(s).crossTileID = u >= 0 && s !== u ? 0 : c), a >= 0 && (t1.text.placedSymbolArray.get(a).crossTileID = u >= 0 && a !== u ? 0 : c), l >= 0 && (t1.text.placedSymbolArray.get(l).crossTileID = u >= 0 && l !== u ? 0 : c);
            }
            markUsedOrientation(t1, i, o) {
                const r = i === e1.WritingMode.horizontal || i === e1.WritingMode.horizontalOnly ? i : 0, n = i === e1.WritingMode.vertical ? i : 0, { leftJustifiedTextSymbolIndex: s , centerJustifiedTextSymbolIndex: a , rightJustifiedTextSymbolIndex: l , verticalPlacedTextSymbolIndex: c  } = o, h = t1.text.placedSymbolArray;
                s >= 0 && (h.get(s).placedOrientation = r), a >= 0 && (h.get(a).placedOrientation = r), l >= 0 && (h.get(l).placedOrientation = r), c >= 0 && (h.get(c).placedOrientation = n);
            }
            commit(e1) {
                this.commitTime = e1, this.zoomAtLastRecencyCheck = this.transform.zoom;
                const t1 = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = t1 ? t1.zoomAdjustment(this.transform.zoom) : 0;
                const o = t1 ? t1.symbolFadeChange(e1) : 1, r = t1 ? t1.opacities : {}, n = t1 ? t1.variableOffsets : {}, s = t1 ? t1.placedOrientations : {};
                for(const e1 in this.placements){
                    const t1 = this.placements[e1], n = r[e1];
                    n ? (this.opacities[e1] = new Tt(n, o, t1.text, t1.icon, null, t1.clipped), i = i || t1.text !== n.text.placed || t1.icon !== n.icon.placed) : (this.opacities[e1] = new Tt(null, o, t1.text, t1.icon, t1.skipFade, t1.clipped), i = i || t1.text || t1.icon);
                }
                for(const e1 in r){
                    const t1 = r[e1];
                    if (!this.opacities[e1]) {
                        const r = new Tt(t1, o, !1, !1);
                        r.isHidden() || (this.opacities[e1] = r, i = i || t1.text.placed || t1.icon.placed);
                    }
                }
                for(const e1 in n)this.variableOffsets[e1] || !this.opacities[e1] || this.opacities[e1].isHidden() || (this.variableOffsets[e1] = n[e1]);
                for(const e1 in s)this.placedOrientations[e1] || !this.opacities[e1] || this.opacities[e1].isHidden() || (this.placedOrientations[e1] = s[e1]);
                i ? this.lastPlacementChangeTime = e1 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t1 ? t1.lastPlacementChangeTime : e1);
            }
            updateLayerOpacities(e1, t1) {
                const i = {};
                for (const o of t1){
                    const t1 = o.getBucket(e1);
                    t1 && o.latestFeatureIndex && e1.id === t1.layerIds[0] && this.updateBucketOpacities(t1, i, o.collisionBoxArray);
                }
            }
            updateBucketOpacities(t1, i, o) {
                t1.hasTextData() && t1.text.opacityVertexArray.clear(), t1.hasIconData() && t1.icon.opacityVertexArray.clear(), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexArray.clear(), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexArray.clear();
                const r = t1.layers[0].layout, n = !!t1.layers[0].dynamicFilter(), s = new Tt(null, 0, !1, !1, !0), a = r.get("text-allow-overlap"), l = r.get("icon-allow-overlap"), c = r.get("text-variable-anchor"), h = "map" === r.get("text-rotation-alignment"), u = "map" === r.get("text-pitch-alignment"), _ = "none" !== r.get("icon-text-fit"), d = new Tt(null, 0, a && (l || !t1.hasIconData() || r.get("icon-optional")), l && (a || !t1.hasTextData() || r.get("text-optional")), !0);
                !t1.collisionArrays && o && (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) && t1.deserializeCollisionBoxes(o);
                const p = (e1, t1, i)=>{
                    for(let o = 0; o < t1 / 4; o++)e1.opacityVertexArray.emplaceBack(i);
                };
                let m = 0;
                for(let o = 0; o < t1.symbolInstances.length; o++){
                    const r = t1.symbolInstances.get(o), { numHorizontalGlyphVertices: a , numVerticalGlyphVertices: l , crossTileID: f , numIconVertices: g  } = r;
                    let v = this.opacities[f];
                    i[f] ? v = s : v || (v = d, this.opacities[f] = v), i[f] = !0;
                    const x = a > 0 || l > 0, y = g > 0, b = this.placedOrientations[f], w = b === e1.WritingMode.vertical, T = b === e1.WritingMode.horizontal || b === e1.WritingMode.horizontalOnly;
                    if (!x && !y || v.isHidden() || m++, x) {
                        const e1 = Ut(v.text);
                        p(t1.text, a, w ? Nt : e1), p(t1.text, l, T ? Nt : e1);
                        const i = v.text.isHidden(), { leftJustifiedTextSymbolIndex: o , centerJustifiedTextSymbolIndex: n , rightJustifiedTextSymbolIndex: s , verticalPlacedTextSymbolIndex: c  } = r, h = t1.text.placedSymbolArray, u = i || w ? 1 : 0;
                        o >= 0 && (h.get(o).hidden = u), n >= 0 && (h.get(n).hidden = u), s >= 0 && (h.get(s).hidden = u), c >= 0 && (h.get(c).hidden = i || T ? 1 : 0);
                        const _ = this.variableOffsets[f];
                        _ && this.markUsedJustification(t1, _.anchor, r, b);
                        const d = this.placedOrientations[f];
                        d && (this.markUsedJustification(t1, "left", r, d), this.markUsedOrientation(t1, d, r));
                    }
                    if (y) {
                        const e1 = Ut(v.icon), { placedIconSymbolIndex: i , verticalPlacedIconSymbolIndex: o  } = r, n = t1.icon.placedSymbolArray, s = v.icon.isHidden() ? 1 : 0;
                        i >= 0 && (p(t1.icon, g, w ? Nt : e1), n.get(i).hidden = s), o >= 0 && (p(t1.icon, r.numVerticalIconVertices, T ? Nt : e1), n.get(o).hidden = s);
                    }
                    if (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) {
                        const i = t1.collisionArrays[o];
                        if (i) {
                            let o = new e1.pointGeometry(0, 0), r = !0;
                            if (i.textBox || i.verticalTextBox) {
                                if (c) {
                                    const e1 = this.variableOffsets[f];
                                    e1 ? (o = St(e1.anchor, e1.width, e1.height, e1.textOffset, e1.textScale), h && o._rotate(u ? this.transform.angle : -this.transform.angle)) : r = !1;
                                }
                                n && (r = !v.clipped), i.textBox && At(t1.textCollisionBox.collisionVertexArray, v.text.placed, !r || w, o.x, o.y), i.verticalTextBox && At(t1.textCollisionBox.collisionVertexArray, v.text.placed, !r || T, o.x, o.y);
                            }
                            const s = r && Boolean(!T && i.verticalIconBox);
                            i.iconBox && At(t1.iconCollisionBox.collisionVertexArray, v.icon.placed, s, _ ? o.x : 0, _ ? o.y : 0), i.verticalIconBox && At(t1.iconCollisionBox.collisionVertexArray, v.icon.placed, !s, _ ? o.x : 0, _ ? o.y : 0);
                        }
                    }
                }
                if (t1.fullyClipped = 0 === m, t1.sortFeatures(this.transform.angle), this.retainedQueryData[t1.bucketInstanceId] && (this.retainedQueryData[t1.bucketInstanceId].featureSortOrder = t1.featureSortOrder), t1.hasTextData() && t1.text.opacityVertexBuffer && t1.text.opacityVertexBuffer.updateData(t1.text.opacityVertexArray), t1.hasIconData() && t1.icon.opacityVertexBuffer && t1.icon.opacityVertexBuffer.updateData(t1.icon.opacityVertexArray), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexBuffer && t1.iconCollisionBox.collisionVertexBuffer.updateData(t1.iconCollisionBox.collisionVertexArray), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexBuffer && t1.textCollisionBox.collisionVertexBuffer.updateData(t1.textCollisionBox.collisionVertexArray), t1.bucketInstanceId in this.collisionCircleArrays) {
                    const e1 = this.collisionCircleArrays[t1.bucketInstanceId];
                    t1.placementInvProjMatrix = e1.invProjMatrix, t1.placementViewportMatrix = e1.viewportMatrix, t1.collisionCircleArray = e1.circles, delete this.collisionCircleArrays[t1.bucketInstanceId];
                }
            }
            symbolFadeChange(e1) {
                return 0 === this.fadeDuration ? 1 : (e1 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e1) {
                return Math.max(0, (this.transform.zoom - e1) / 1.5);
            }
            hasTransitions(e1) {
                return this.stale || e1 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e1, t1) {
                const i = this.zoomAtLastRecencyCheck === t1 ? 1 - this.zoomAdjustment(t1) : 1;
                return this.zoomAtLastRecencyCheck = t1, this.commitTime + this.fadeDuration * i > e1;
            }
            setStale() {
                this.stale = !0;
            }
        }
        function At(e1, t1, i, o, r) {
            e1.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e1.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e1.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e1.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, o || 0, r || 0);
        }
        const zt = Math.pow(2, 25), Pt = Math.pow(2, 24), Rt = Math.pow(2, 17), Ot = Math.pow(2, 16), Bt = Math.pow(2, 9), kt = Math.pow(2, 8), Ft = Math.pow(2, 1);
        function Ut(e1) {
            if (0 === e1.opacity && !e1.placed) return 0;
            if (1 === e1.opacity && e1.placed) return 4294967295;
            const t1 = e1.placed ? 1 : 0, i = Math.floor(127 * e1.opacity);
            return i * zt + t1 * Pt + i * Rt + t1 * Ot + i * Bt + t1 * kt + i * Ft + t1;
        }
        const Nt = 0;
        class Gt {
            constructor(e1){
                this._sortAcrossTiles = "viewport-y" !== e1.layout.get("symbol-z-order") && void 0 !== e1.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(e1, t1, i, o, r) {
                const n = this._bucketParts;
                for(; this._currentTileIndex < e1.length;)if (t1.getBucketParts(n, o, e1[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;
                for(this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e1, t1)=>e1.sortKey - t1.sortKey)); this._currentPartIndex < n.length;){
                    const e1 = n[this._currentPartIndex];
                    if (t1.placeLayerBucketPart(e1, this._seenCrossTileIDs, i, 0 === e1.symbolInstanceStart), this._currentPartIndex++, r()) return !0;
                }
                return !1;
            }
        }
        class jt {
            constructor(e1, t1, i, o, r, n, s, a){
                this.placement = new Lt(e1, r, n, s, a), this._currentPlacementIndex = t1.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;
            }
            isDone() {
                return this._done;
            }
            continuePlacement(t1, i, o) {
                const r = e1.exported.now(), n = ()=>{
                    const t1 = e1.exported.now() - r;
                    return !this._forceFullPlacement && t1 > 2;
                };
                for(; this._currentPlacementIndex >= 0;){
                    const e1 = i[t1[this._currentPlacementIndex]], r = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === e1.type && (!e1.minzoom || e1.minzoom <= r) && (!e1.maxzoom || e1.maxzoom > r)) {
                        if (this._inProgressLayer || (this._inProgressLayer = new Gt(e1)), this._inProgressLayer.continuePlacement(o[e1.source], this.placement, this._showCollisionBoxes, e1, n)) return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._done = !0;
            }
            commit(e1) {
                return this.placement.commit(e1), this.placement;
            }
        }
        const Zt = 512 / e1.EXTENT / 2;
        class Vt {
            constructor(e1, t1, i){
                this.tileID = e1, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;
                for(let i = 0; i < t1.length; i++){
                    const o = t1.get(i), r = o.key;
                    this.indexedSymbolInstances[r] || (this.indexedSymbolInstances[r] = []), this.indexedSymbolInstances[r].push({
                        crossTileID: o.crossTileID,
                        coord: this.getScaledCoordinates(o, e1)
                    });
                }
            }
            getScaledCoordinates(t1, i) {
                const o = Zt / Math.pow(2, i.canonical.z - this.tileID.canonical.z);
                return {
                    x: Math.floor((i.canonical.x * e1.EXTENT + t1.tileAnchorX) * o),
                    y: Math.floor((i.canonical.y * e1.EXTENT + t1.tileAnchorY) * o)
                };
            }
            findMatches(e1, t1, i) {
                const o = this.tileID.canonical.z < t1.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t1.canonical.z);
                for(let r = 0; r < e1.length; r++){
                    const n = e1.get(r);
                    if (n.crossTileID) continue;
                    const s = this.indexedSymbolInstances[n.key];
                    if (!s) continue;
                    const a = this.getScaledCoordinates(n, t1);
                    for (const e1 of s)if (Math.abs(e1.coord.x - a.x) <= o && Math.abs(e1.coord.y - a.y) <= o && !i[e1.crossTileID]) {
                        i[e1.crossTileID] = !0, n.crossTileID = e1.crossTileID;
                        break;
                    }
                }
            }
        }
        class Wt {
            constructor(){
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID;
            }
        }
        class Xt {
            constructor(){
                this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e1) {
                const t1 = Math.round((e1 - this.lng) / 360);
                if (0 !== t1) for(const e1 in this.indexes){
                    const i = this.indexes[e1], o = {};
                    for(const e1 in i){
                        const r = i[e1];
                        r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t1), o[r.tileID.key] = r;
                    }
                    this.indexes[e1] = o;
                }
                this.lng = e1;
            }
            addBucket(e1, t1, i) {
                if (this.indexes[e1.overscaledZ] && this.indexes[e1.overscaledZ][e1.key]) {
                    if (this.indexes[e1.overscaledZ][e1.key].bucketInstanceId === t1.bucketInstanceId) return !1;
                    this.removeBucketCrossTileIDs(e1.overscaledZ, this.indexes[e1.overscaledZ][e1.key]);
                }
                for(let e1 = 0; e1 < t1.symbolInstances.length; e1++)t1.symbolInstances.get(e1).crossTileID = 0;
                this.usedCrossTileIDs[e1.overscaledZ] || (this.usedCrossTileIDs[e1.overscaledZ] = {});
                const o = this.usedCrossTileIDs[e1.overscaledZ];
                for(const i in this.indexes){
                    const r = this.indexes[i];
                    if (Number(i) > e1.overscaledZ) for(const i in r){
                        const n = r[i];
                        n.tileID.isChildOf(e1) && n.findMatches(t1.symbolInstances, e1, o);
                    }
                    else {
                        const n = r[e1.scaledTo(Number(i)).key];
                        n && n.findMatches(t1.symbolInstances, e1, o);
                    }
                }
                for(let e1 = 0; e1 < t1.symbolInstances.length; e1++){
                    const r = t1.symbolInstances.get(e1);
                    r.crossTileID || (r.crossTileID = i.generate(), o[r.crossTileID] = !0);
                }
                return void 0 === this.indexes[e1.overscaledZ] && (this.indexes[e1.overscaledZ] = {}), this.indexes[e1.overscaledZ][e1.key] = new Vt(e1, t1.symbolInstances, t1.bucketInstanceId), !0;
            }
            removeBucketCrossTileIDs(e1, t1) {
                for(const i in t1.indexedSymbolInstances)for (const o of t1.indexedSymbolInstances[i])delete this.usedCrossTileIDs[e1][o.crossTileID];
            }
            removeStaleBuckets(e1) {
                let t1 = !1;
                for(const i in this.indexes){
                    const o = this.indexes[i];
                    for(const r in o)e1[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t1 = !0);
                }
                return t1;
            }
        }
        class qt {
            constructor(){
                this.layerIndexes = {}, this.crossTileIDs = new Wt, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e1, t1, i, o) {
                let r = this.layerIndexes[e1.id];
                void 0 === r && (r = this.layerIndexes[e1.id] = new Xt);
                let n = !1;
                const s = {};
                "globe" !== o.name && r.handleWrapJump(i);
                for (const i of t1){
                    const t1 = i.getBucket(e1);
                    t1 && e1.id === t1.layerIds[0] && (t1.bucketInstanceId || (t1.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t1, this.crossTileIDs) && (n = !0), s[t1.bucketInstanceId] = !0);
                }
                return r.removeStaleBuckets(s) && (n = !0), n;
            }
            pruneUnusedLayers(e1) {
                const t1 = {};
                e1.forEach((e1)=>{
                    t1[e1] = !0;
                });
                for(const e1 in this.layerIndexes)t1[e1] || delete this.layerIndexes[e1];
            }
        }
        const $t = (t1, i)=>e1.emitValidationErrors(t1, i && i.filter((e1)=>"source.canvas" !== e1.identifier)), Ht = e1.pick(We, [
            "addLayer",
            "removeLayer",
            "setPaintProperty",
            "setLayoutProperty",
            "setFilter",
            "addSource",
            "removeSource",
            "setLayerZoomRange",
            "setLight",
            "setTransition",
            "setGeoJSONSourceData",
            "setTerrain",
            "setFog",
            "setProjection"
        ]), Yt = e1.pick(We, [
            "setCenter",
            "setZoom",
            "setBearing",
            "setPitch"
        ]), Kt = {
            version: 8,
            layers: [],
            sources: {}
        }, Jt = {
            fill: !0,
            line: !0,
            background: !0,
            hillshade: !0,
            raster: !0
        };
        class Qt extends e1.Evented {
            constructor(t1, i = {}){
                super(), this.map = t1, this.dispatcher = new z(je(), this), this.imageManager = new y, this.imageManager.setEventedParent(this), this.glyphManager = new e1.GlyphManager(t1._requestManager, i.localFontFamily ? e1.LocalGlyphMode.all : i.localIdeographFontFamily ? e1.LocalGlyphMode.ideographs : e1.LocalGlyphMode.none, i.localFontFamily || i.localIdeographFontFamily), this.crossTileSymbolIndex = new qt, this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e1.getReferrer());
                const o = this;
                this._rtlTextPluginCallback = Qt.registerForPluginStateChange((t1)=>{
                    o.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: t1.pluginStatus,
                        pluginURL: t1.pluginURL
                    }, (t1, i)=>{
                        if (e1.triggerPluginCompletionEvent(t1), i && i.every((e1)=>e1)) for(const e1 in o._sourceCaches){
                            const t1 = o._sourceCaches[e1], i = t1.getSource().type;
                            "vector" !== i && "geojson" !== i || t1.reload();
                        }
                    });
                }), this.on("data", (e1)=>{
                    if ("source" !== e1.dataType || "metadata" !== e1.sourceDataType) return;
                    const t1 = this.getSource(e1.sourceId);
                    if (t1 && t1.vectorLayerIds) for(const e1 in this._layers){
                        const i = this._layers[e1];
                        i.source === t1.id && this._validateLayer(i);
                    }
                });
            }
            loadURL(t1, i = {}) {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                }));
                const o = "boolean" == typeof i.validate ? i.validate : !e1.isMapboxURL(t1);
                t1 = this.map._requestManager.normalizeStyleURL(t1, i.accessToken);
                const r = this.map._requestManager.transformRequest(t1, e1.ResourceType.Style);
                this._request = e1.getJSON(r, (t1, i)=>{
                    this._request = null, t1 ? this.fire(new e1.ErrorEvent(t1)) : i && this._load(i, o);
                });
            }
            loadJSON(t1, i = {}) {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                })), this._request = e1.exported.frame(()=>{
                    this._request = null, this._load(t1, !1 !== i.validate);
                });
            }
            loadEmpty() {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                })), this._load(Kt, !1);
            }
            _updateLayerCount(e1, t1) {
                const i = t1 ? 1 : -1;
                e1.is3D() && (this._num3DLayers += i), "circle" === e1.type && (this._numCircleLayers += i), "symbol" === e1.type && (this._numSymbolLayers += i);
            }
            _load(t1, i) {
                if (i && $t(this, e1.validateStyle(t1))) return;
                this._loaded = !0, this.stylesheet = e1.clone$1(t1), this._updateMapProjection();
                for(const e1 in t1.sources)this.addSource(e1, t1.sources[e1], {
                    validate: !1
                });
                this._changed = !1, t1.sprite ? this._loadSprite(t1.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(t1.glyphs);
                const o = Ve(this.stylesheet.layers);
                this._order = o.map((e1)=>e1.id), this._layers = {}, this._serializedLayers = {};
                for (let t1 of o)t1 = e1.createStyleLayer(t1), t1.setEventedParent(this, {
                    layer: {
                        id: t1.id
                    }
                }), this._layers[t1.id] = t1, this._serializedLayers[t1.id] = t1.serialize(), this._updateLayerCount(t1, !0);
                this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e1.Event("data", {
                    dataType: "style"
                })), this.fire(new e1.Event("style.load"));
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            setProjection(e1) {
                e1 ? this.stylesheet.projection = e1 : delete this.stylesheet.projection, this._updateMapProjection();
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
            }
            _updateMapProjection() {
                this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
            }
            _loadSprite(t1) {
                this._spriteRequest = function(t1, i, o) {
                    let r, n, s;
                    const a = e1.exported.devicePixelRatio > 1 ? "@2x" : "";
                    let l = e1.getJSON(i.transformRequest(i.normalizeSpriteURL(t1, a, ".json"), e1.ResourceType.SpriteJSON), (e1, t1)=>{
                        l = null, s || (s = e1, r = t1, h());
                    }), c = e1.getImage(i.transformRequest(i.normalizeSpriteURL(t1, a, ".png"), e1.ResourceType.SpriteImage), (e1, t1)=>{
                        c = null, s || (s = e1, n = t1, h());
                    });
                    function h() {
                        if (s) o(s);
                        else if (r && n) {
                            const t1 = e1.exported.getImageData(n), i = {};
                            for(const o in r){
                                const { width: n , height: s , x: a , y: l , sdf: c , pixelRatio: h , stretchX: u , stretchY: _ , content: d  } = r[o], p = new e1.RGBAImage({
                                    width: n,
                                    height: s
                                });
                                e1.RGBAImage.copy(t1, p, {
                                    x: a,
                                    y: l
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: n,
                                    height: s
                                }), i[o] = {
                                    data: p,
                                    pixelRatio: h,
                                    sdf: c,
                                    stretchX: u,
                                    stretchY: _,
                                    content: d
                                };
                            }
                            o(null, i);
                        }
                    }
                    return {
                        cancel () {
                            l && (l.cancel(), l = null), c && (c.cancel(), c = null);
                        }
                    };
                }(t1, this.map._requestManager, (t1, i)=>{
                    if (this._spriteRequest = null, t1) this.fire(new e1.ErrorEvent(t1));
                    else if (i) for(const e1 in i)this.imageManager.addImage(e1, i[e1]);
                    this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new e1.Event("data", {
                        dataType: "style"
                    }));
                });
            }
            _validateLayer(t1) {
                const i = this.getSource(t1.source);
                if (!i) return;
                const o = t1.sourceLayer;
                o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e1.ErrorEvent(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t1.id}"`)));
            }
            loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._updatedSources).length) return !1;
                for(const e1 in this._sourceCaches)if (!this._sourceCaches[e1].loaded()) return !1;
                return !!this.imageManager.isLoaded();
            }
            _serializeLayers(e1) {
                const t1 = [];
                for (const i of e1){
                    const e1 = this._layers[i];
                    "custom" !== e1.type && t1.push(e1.serialize());
                }
                return t1;
            }
            hasTransitions() {
                if (this.light && this.light.hasTransition()) return !0;
                if (this.fog && this.fog.hasTransition()) return !0;
                for(const e1 in this._sourceCaches)if (this._sourceCaches[e1].hasTransition()) return !0;
                for(const e1 in this._layers)if (this._layers[e1].hasTransition()) return !0;
                return !1;
            }
            get order() {
                return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
            }
            isLayerDraped(e1) {
                return !!this.terrain && ("function" == typeof e1.isLayerDraped ? e1.isLayerDraped() : Jt[e1.type]);
            }
            _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
            }
            update(t1) {
                if (!this._loaded) return;
                const i = this._changed;
                if (this._changed) {
                    const e1 = Object.keys(this._updatedLayers), i = Object.keys(this._removedLayers);
                    (e1.length || i.length) && this._updateWorkerLayers(e1, i);
                    for(const e1 in this._updatedSources){
                        const t1 = this._updatedSources[e1];
                        "reload" === t1 ? this._reloadSource(e1) : "clear" === t1 && this._clearSource(e1);
                    }
                    this._updateTilesForChangedImages();
                    for(const e1 in this._updatedPaintProps)this._layers[e1].updateTransitions(t1);
                    this.light.updateTransitions(t1), this.fog && this.fog.updateTransitions(t1), this._resetUpdates();
                }
                const o = {};
                for(const e1 in this._sourceCaches){
                    const t1 = this._sourceCaches[e1];
                    o[e1] = t1.used, t1.used = !1;
                }
                for (const e1 of this._order){
                    const i = this._layers[e1];
                    if (i.recalculate(t1, this._availableImages), !i.isHidden(t1.zoom)) {
                        const e1 = this._getLayerSourceCache(i);
                        e1 && (e1.used = !0);
                    }
                    const o = this.map.painter;
                    if (o) {
                        const e1 = i.getProgramIds();
                        if (!e1) continue;
                        const r = i.getProgramConfiguration(t1.zoom);
                        for (const t1 of e1)o.useProgram(t1, r);
                    }
                }
                for(const t1 in o){
                    const i = this._sourceCaches[t1];
                    o[t1] !== i.used && i.getSource().fire(new e1.Event("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i.getSource().id
                    }));
                }
                this.light.recalculate(t1), this.terrain && this.terrain.recalculate(t1), this.fog && this.fog.recalculate(t1), this.z = t1.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), i && this.fire(new e1.Event("data", {
                    dataType: "style"
                }));
            }
            _updateTilesForChangedImages() {
                const e1 = Object.keys(this._changedImages);
                if (e1.length) {
                    for(const t1 in this._sourceCaches)this._sourceCaches[t1].reloadTilesForDependencies([
                        "icons",
                        "patterns"
                    ], e1);
                    this._changedImages = {};
                }
            }
            _updateWorkerLayers(e1, t1) {
                this.dispatcher.broadcast("updateLayers", {
                    layers: this._serializeLayers(e1),
                    removedIds: t1
                });
            }
            _resetUpdates() {
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }
            setState(i) {
                if (this._checkLoaded(), $t(this, e1.validateStyle(i))) return !1;
                (i = e1.clone$1(i)).layers = Ve(i.layers);
                const o = (function(e1, i) {
                    if (!e1) return [
                        {
                            command: We.setStyle,
                            args: [
                                i
                            ]
                        }
                    ];
                    let o = [];
                    try {
                        if (!t1(e1.version, i.version)) return [
                            {
                                command: We.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        t1(e1.center, i.center) || o.push({
                            command: We.setCenter,
                            args: [
                                i.center
                            ]
                        }), t1(e1.zoom, i.zoom) || o.push({
                            command: We.setZoom,
                            args: [
                                i.zoom
                            ]
                        }), t1(e1.bearing, i.bearing) || o.push({
                            command: We.setBearing,
                            args: [
                                i.bearing
                            ]
                        }), t1(e1.pitch, i.pitch) || o.push({
                            command: We.setPitch,
                            args: [
                                i.pitch
                            ]
                        }), t1(e1.sprite, i.sprite) || o.push({
                            command: We.setSprite,
                            args: [
                                i.sprite
                            ]
                        }), t1(e1.glyphs, i.glyphs) || o.push({
                            command: We.setGlyphs,
                            args: [
                                i.glyphs
                            ]
                        }), t1(e1.transition, i.transition) || o.push({
                            command: We.setTransition,
                            args: [
                                i.transition
                            ]
                        }), t1(e1.light, i.light) || o.push({
                            command: We.setLight,
                            args: [
                                i.light
                            ]
                        }), t1(e1.fog, i.fog) || o.push({
                            command: We.setFog,
                            args: [
                                i.fog
                            ]
                        }), t1(e1.projection, i.projection) || o.push({
                            command: We.setProjection,
                            args: [
                                i.projection
                            ]
                        });
                        const r = {}, n = [];
                        !function(e1, i, o, r) {
                            let n;
                            for(n in i = i || {}, e1 = e1 || {})e1.hasOwnProperty(n) && (i.hasOwnProperty(n) || qe(n, o, r));
                            for(n in i)i.hasOwnProperty(n) && (e1.hasOwnProperty(n) ? t1(e1[n], i[n]) || ("geojson" === e1[n].type && "geojson" === i[n].type && He(e1, i, n) ? o.push({
                                command: We.setGeoJSONSourceData,
                                args: [
                                    n,
                                    i[n].data
                                ]
                            }) : $e(n, i, o, r)) : Xe(n, i, o));
                        }(e1.sources, i.sources, n, r);
                        const s = [];
                        e1.layers && e1.layers.forEach((e1)=>{
                            e1.source && r[e1.source] ? o.push({
                                command: We.removeLayer,
                                args: [
                                    e1.id
                                ]
                            }) : s.push(e1);
                        });
                        let a = e1.terrain;
                        a && r[a.source] && (o.push({
                            command: We.setTerrain,
                            args: [
                                void 0
                            ]
                        }), a = void 0), o = o.concat(n), t1(a, i.terrain) || o.push({
                            command: We.setTerrain,
                            args: [
                                i.terrain
                            ]
                        }), function(e1, i, o) {
                            i = i || [];
                            const r = (e1 = e1 || []).map(Ke), n = i.map(Ke), s = e1.reduce(Je, {}), a = i.reduce(Je, {}), l = r.slice(), c = Object.create(null);
                            let h, u, _, d, p, m, f;
                            for(h = 0, u = 0; h < r.length; h++)_ = r[h], a.hasOwnProperty(_) ? u++ : (o.push({
                                command: We.removeLayer,
                                args: [
                                    _
                                ]
                            }), l.splice(l.indexOf(_, u), 1));
                            for(h = 0, u = 0; h < n.length; h++)_ = n[n.length - 1 - h], l[l.length - 1 - h] !== _ && (s.hasOwnProperty(_) ? (o.push({
                                command: We.removeLayer,
                                args: [
                                    _
                                ]
                            }), l.splice(l.lastIndexOf(_, l.length - u), 1)) : u++, m = l[l.length - h], o.push({
                                command: We.addLayer,
                                args: [
                                    a[_],
                                    m
                                ]
                            }), l.splice(l.length - h, 0, _), c[_] = !0);
                            for(h = 0; h < n.length; h++)if (_ = n[h], d = s[_], p = a[_], !c[_] && !t1(d, p)) {
                                if (t1(d.source, p.source) && t1(d["source-layer"], p["source-layer"]) && t1(d.type, p.type)) {
                                    for(f in Ye(d.layout, p.layout, o, _, null, We.setLayoutProperty), Ye(d.paint, p.paint, o, _, null, We.setPaintProperty), t1(d.filter, p.filter) || o.push({
                                        command: We.setFilter,
                                        args: [
                                            _,
                                            p.filter
                                        ]
                                    }), t1(d.minzoom, p.minzoom) && t1(d.maxzoom, p.maxzoom) || o.push({
                                        command: We.setLayerZoomRange,
                                        args: [
                                            _,
                                            p.minzoom,
                                            p.maxzoom
                                        ]
                                    }), d)d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Ye(d[f], p[f], o, _, f.slice(6), We.setPaintProperty) : t1(d[f], p[f]) || o.push({
                                        command: We.setLayerProperty,
                                        args: [
                                            _,
                                            f,
                                            p[f]
                                        ]
                                    }));
                                    for(f in p)p.hasOwnProperty(f) && !d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Ye(d[f], p[f], o, _, f.slice(6), We.setPaintProperty) : t1(d[f], p[f]) || o.push({
                                        command: We.setLayerProperty,
                                        args: [
                                            _,
                                            f,
                                            p[f]
                                        ]
                                    }));
                                } else o.push({
                                    command: We.removeLayer,
                                    args: [
                                        _
                                    ]
                                }), m = l[l.lastIndexOf(_) + 1], o.push({
                                    command: We.addLayer,
                                    args: [
                                        p,
                                        m
                                    ]
                                });
                            }
                        }(s, i.layers, o);
                    } catch (e1) {
                        console.warn("Unable to compute style diff:", e1), o = [
                            {
                                command: We.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                    }
                    return o;
                })(this.serialize(), i).filter((e1)=>!(e1.command in Yt));
                if (0 === o.length) return !1;
                const r = o.filter((e1)=>!(e1.command in Ht));
                if (r.length > 0) throw new Error(`Unimplemented: ${r.map((e1)=>e1.command).join(", ")}.`);
                return o.forEach((e1)=>{
                    "setTransition" !== e1.command && "setProjection" !== e1.command && this[e1.command].apply(this, e1.args);
                }), this.stylesheet = i, this._updateMapProjection(), !0;
            }
            addImage(t1, i) {
                return this.getImage(t1) ? this.fire(new e1.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t1, i), this._afterImageUpdated(t1), this);
            }
            updateImage(e1, t1) {
                this.imageManager.updateImage(e1, t1);
            }
            getImage(e1) {
                return this.imageManager.getImage(e1);
            }
            removeImage(t1) {
                return this.getImage(t1) ? (this.imageManager.removeImage(t1), this._afterImageUpdated(t1), this) : this.fire(new e1.ErrorEvent(new Error("No image with this name exists.")));
            }
            _afterImageUpdated(t1) {
                this._availableImages = this.imageManager.listImages(), this._changedImages[t1] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e1.Event("data", {
                    dataType: "style"
                }));
            }
            listImages() {
                return this._checkLoaded(), this._availableImages.slice();
            }
            addSource(t1, i, o = {}) {
                if (this._checkLoaded(), void 0 !== this.getSource(t1)) throw new Error("There is already a source with this ID");
                if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if ([
                    "vector",
                    "raster",
                    "geojson",
                    "video",
                    "image"
                ].indexOf(i.type) >= 0 && this._validate(e1.validateSource, `sources.${t1}`, i, null, o)) return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const r = Pe(t1, i, this.dispatcher, this);
                r.setEventedParent(this, ()=>({
                        isSourceLoaded: this._isSourceCacheLoaded(t1),
                        source: r.serialize(),
                        sourceId: t1
                    }));
                const n = (i)=>{
                    const o = (i ? "symbol:" : "other:") + t1, n = this._sourceCaches[o] = new e1.SourceCache(o, r, i);
                    (i ? this._symbolSourceCaches : this._otherSourceCaches)[t1] = n, n.style = this, n.onAdd(this.map);
                };
                n(!1), "vector" !== i.type && "geojson" !== i.type || n(!0), r.onAdd && r.onAdd(this.map), this._changed = !0;
            }
            removeSource(t1) {
                this._checkLoaded();
                const i = this.getSource(t1);
                if (!i) throw new Error("There is no source with this ID");
                for(const i in this._layers)if (this._layers[i].source === t1) return this.fire(new e1.ErrorEvent(new Error(`Source "${t1}" cannot be removed while layer "${i}" is using it.`)));
                if (this.terrain && this.terrain.get().source === t1) return this.fire(new e1.ErrorEvent(new Error(`Source "${t1}" cannot be removed while terrain is using it.`)));
                const o = this._getSourceCaches(t1);
                for (const t1 of o)delete this._sourceCaches[t1.id], delete this._updatedSources[t1.id], t1.fire(new e1.Event("data", {
                    sourceDataType: "metadata",
                    dataType: "source",
                    sourceId: t1.getSource().id
                })), t1.setEventedParent(null), t1.clearTiles();
                return delete this._otherSourceCaches[t1], delete this._symbolSourceCaches[t1], i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changed = !0, this;
            }
            setGeoJSONSourceData(e1, t1) {
                this._checkLoaded(), this.getSource(e1).setData(t1), this._changed = !0;
            }
            getSource(e1) {
                const t1 = this._getSourceCache(e1);
                return t1 && t1.getSource();
            }
            _getSources() {
                const e1 = [];
                for(const t1 in this._otherSourceCaches){
                    const i = this._getSourceCache(t1);
                    i && e1.push(i.getSource());
                }
                return e1;
            }
            addLayer(t1, i, o = {}) {
                this._checkLoaded();
                const r = t1.id;
                if (this.getLayer(r)) return void this.fire(new e1.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));
                let n;
                if ("custom" === t1.type) {
                    if ($t(this, e1.validateCustomStyleLayer(t1))) return;
                    n = e1.createStyleLayer(t1);
                } else {
                    if ("object" == typeof t1.source && (this.addSource(r, t1.source), t1 = e1.clone$1(t1), t1 = e1.extend(t1, {
                        source: r
                    })), this._validate(e1.validateLayer, `layers.${r}`, t1, {
                        arrayIndex: -1
                    }, o)) return;
                    n = e1.createStyleLayer(t1), this._validateLayer(n), n.setEventedParent(this, {
                        layer: {
                            id: r
                        }
                    }), this._serializedLayers[n.id] = n.serialize(), this._updateLayerCount(n, !0);
                }
                const s = i ? this._order.indexOf(i) : this._order.length;
                if (i && -1 === s) return void this.fire(new e1.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
                this._order.splice(s, 0, r), this._layerOrderChanged = !0, this._layers[r] = n;
                const a = this._getLayerSourceCache(n);
                if (this._removedLayers[r] && n.source && a && "custom" !== n.type) {
                    const e1 = this._removedLayers[r];
                    delete this._removedLayers[r], e1.type !== n.type ? this._updatedSources[n.source] = "clear" : (this._updatedSources[n.source] = "reload", a.pause());
                }
                this._updateLayer(n), n.onAdd && n.onAdd(this.map), this._updateDrapeFirstLayers();
            }
            moveLayer(t1, i) {
                if (this._checkLoaded(), this._changed = !0, !this._layers[t1]) return void this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style and cannot be moved.`)));
                if (t1 === i) return;
                const o = this._order.indexOf(t1);
                this._order.splice(o, 1);
                const r = i ? this._order.indexOf(i) : this._order.length;
                i && -1 === r ? this.fire(new e1.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(r, 0, t1), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());
            }
            removeLayer(t1) {
                this._checkLoaded();
                const i = this._layers[t1];
                if (!i) return void this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style and cannot be removed.`)));
                i.setEventedParent(null), this._updateLayerCount(i, !1);
                const o = this._order.indexOf(t1);
                this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t1] = i, delete this._layers[t1], delete this._serializedLayers[t1], delete this._updatedLayers[t1], delete this._updatedPaintProps[t1], i.onRemove && i.onRemove(this.map), this._updateDrapeFirstLayers();
            }
            getLayer(e1) {
                return this._layers[e1];
            }
            hasLayer(e1) {
                return e1 in this._layers;
            }
            hasLayerType(e1) {
                for(const t1 in this._layers)if (this._layers[t1].type === e1) return !0;
                return !1;
            }
            setLayerZoomRange(t1, i, o) {
                this._checkLoaded();
                const r = this.getLayer(t1);
                r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style and cannot have zoom extent.`)));
            }
            setFilter(i, o, r = {}) {
                this._checkLoaded();
                const n = this.getLayer(i);
                if (n) {
                    if (!t1(n.filter, o)) return null == o ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(e1.validateFilter, `layers.${n.id}.filter`, o, {
                        layerType: n.type
                    }, r) || (n.filter = e1.clone$1(o), this._updateLayer(n)));
                } else this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)));
            }
            getFilter(t1) {
                const i = this.getLayer(t1);
                return i && e1.clone$1(i.filter);
            }
            setLayoutProperty(i, o, r, n = {}) {
                this._checkLoaded();
                const s = this.getLayer(i);
                s ? t1(s.getLayoutProperty(o), r) || (s.setLayoutProperty(o, r, n), this._updateLayer(s)) : this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
            }
            getLayoutProperty(t1, i) {
                const o = this.getLayer(t1);
                if (o) return o.getLayoutProperty(i);
                this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style.`)));
            }
            setPaintProperty(i, o, r, n = {}) {
                this._checkLoaded();
                const s = this.getLayer(i);
                s ? t1(s.getPaintProperty(o), r) || (s.setPaintProperty(o, r, n) && this._updateLayer(s), this._changed = !0, this._updatedPaintProps[i] = !0) : this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
            }
            getPaintProperty(e1, t1) {
                const i = this.getLayer(e1);
                return i && i.getPaintProperty(t1);
            }
            setFeatureState(t1, i) {
                this._checkLoaded();
                const o = t1.source, r = t1.sourceLayer, n = this.getSource(o);
                if (!n) return void this.fire(new e1.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
                const s = n.type;
                if ("geojson" === s && r) return void this.fire(new e1.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === s && !r) return void this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                void 0 === t1.id && this.fire(new e1.ErrorEvent(new Error("The feature id parameter must be provided.")));
                const a = this._getSourceCaches(o);
                for (const e1 of a)e1.setFeatureState(r, t1.id, i);
            }
            removeFeatureState(t1, i) {
                this._checkLoaded();
                const o = t1.source, r = this.getSource(o);
                if (!r) return void this.fire(new e1.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
                const n = r.type, s = "vector" === n ? t1.sourceLayer : void 0;
                if ("vector" === n && !s) return void this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof t1.id && "number" != typeof t1.id) return void this.fire(new e1.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
                const a = this._getSourceCaches(o);
                for (const e1 of a)e1.removeFeatureState(s, t1.id, i);
            }
            getFeatureState(t1) {
                this._checkLoaded();
                const i = t1.source, o = t1.sourceLayer, r = this.getSource(i);
                if (r) {
                    if ("vector" !== r.type || o) return void 0 === t1.id && this.fire(new e1.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i)[0].getFeatureState(o, t1.id);
                    this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                } else this.fire(new e1.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
            }
            getTransition() {
                return e1.extend({
                    duration: 300,
                    delay: 0
                }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
                const t1 = {};
                for(const e1 in this._sourceCaches){
                    const i = this._sourceCaches[e1].getSource();
                    t1[i.id] || (t1[i.id] = i.serialize());
                }
                return e1.filterObject({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    terrain: this.getTerrain() || void 0,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: t1,
                    layers: this._serializeLayers(this._order)
                }, (e1)=>void 0 !== e1);
            }
            _updateLayer(e1) {
                this._updatedLayers[e1.id] = !0;
                const t1 = this._getLayerSourceCache(e1);
                e1.source && !this._updatedSources[e1.source] && t1 && "raster" !== t1.getSource().type && (this._updatedSources[e1.source] = "reload", t1.pause()), this._changed = !0, e1.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e1) {
                const t1 = (e1)=>"fill-extrusion" === this._layers[e1].type, i = {}, o = [];
                for(let r = this._order.length - 1; r >= 0; r--){
                    const n = this._order[r];
                    if (t1(n)) {
                        i[n] = r;
                        for (const t1 of e1){
                            const e1 = t1[n];
                            if (e1) for (const t1 of e1)o.push(t1);
                        }
                    }
                }
                o.sort((e1, t1)=>t1.intersectionZ - e1.intersectionZ);
                const r = [];
                for(let n = this._order.length - 1; n >= 0; n--){
                    const s = this._order[n];
                    if (t1(s)) for(let e1 = o.length - 1; e1 >= 0; e1--){
                        const t1 = o[e1].feature;
                        if (i[t1.layer.id] < n) break;
                        r.push(t1), o.pop();
                    }
                    else for (const t1 of e1){
                        const e1 = t1[s];
                        if (e1) for (const t1 of e1)r.push(t1.feature);
                    }
                }
                return r;
            }
            queryRenderedFeatures(t1, i, o) {
                i && i.filter && this._validate(e1.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);
                const r = {};
                if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new e1.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                    for (const t1 of i.layers){
                        const i = this._layers[t1];
                        if (!i) return this.fire(new e1.ErrorEvent(new Error(`The layer '${t1}' does not exist in the map's style and cannot be queried for features.`))), [];
                        r[i.source] = !0;
                    }
                }
                const n = [];
                i.availableImages = this._availableImages;
                const s = i && i.layers ? i.layers.some((e1)=>{
                    const t1 = this.getLayer(e1);
                    return t1 && t1.is3D();
                }) : this.has3DLayers(), a = R.createFromScreenPoints(t1, o);
                for(const e1 in this._sourceCaches){
                    const t1 = this._sourceCaches[e1].getSource().id;
                    i.layers && !r[t1] || n.push(Oe(this._sourceCaches[e1], this._layers, this._serializedLayers, a, i, o, s, !!this.map._showQueryGeometry));
                }
                return this.placement && n.push(function(e1, t1, i, o, r, n, s) {
                    const a = {}, l = n.queryRenderedSymbols(o), c = [];
                    for (const e1 of Object.keys(l).map(Number))c.push(s[e1]);
                    c.sort(ke);
                    for (const i of c){
                        const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t1, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e1);
                        for(const e1 in o){
                            const t1 = a[e1] = a[e1] || [], r = o[e1];
                            r.sort((e1, t1)=>{
                                const o = i.featureSortOrder;
                                if (o) {
                                    const i = o.indexOf(e1.featureIndex);
                                    return o.indexOf(t1.featureIndex) - i;
                                }
                                return t1.featureIndex - e1.featureIndex;
                            });
                            for (const e1 of r)t1.push(e1);
                        }
                    }
                    for(const t1 in a)a[t1].forEach((o)=>{
                        const r = o.feature, n = i(e1[t1]).getFeatureState(r.layer["source-layer"], r.id);
                        r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = n;
                    });
                    return a;
                }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n);
            }
            querySourceFeatures(t1, i) {
                i && i.filter && this._validate(e1.validateFilter, "querySourceFeatures.filter", i.filter, null, i);
                const o = this._getSourceCaches(t1);
                let r = [];
                for (const e1 of o)r = r.concat(Be(e1, i));
                return r;
            }
            addSourceType(e1, t1, i) {
                return Qt.getSourceType(e1) ? i(new Error(`A source type called "${e1}" already exists.`)) : (Qt.setSourceType(e1, t1), t1.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: e1,
                    url: t1.workerSourceURL
                }, i) : i(null, null));
            }
            getLight() {
                return this.light.getLight();
            }
            setLight(e1, i = {}) {
                this._checkLoaded();
                const o = this.light.getLight();
                let r = !1;
                for(const i in e1)if (!t1(e1[i], o[i])) {
                    r = !0;
                    break;
                }
                if (!r) return;
                const n = this._setTransitionParameters({
                    duration: 300,
                    delay: 0
                });
                this.light.setLight(e1, i), this.light.updateTransitions(n);
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0);
            }
            setTerrain(i, o = 1) {
                if (this._checkLoaded(), !i) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                if (1 === o) {
                    if ("object" == typeof i.source) {
                        const t1 = "terrain-dem-src";
                        this.addSource(t1, i.source), i = e1.clone$1(i), i = e1.extend(i, {
                            source: t1
                        });
                    }
                    if (this._validate(e1.validateTerrain, "terrain", i)) return;
                }
                if (!this.terrain || this.terrain && o !== this.terrain.drapeRenderMode) this._createTerrain(i, o);
                else {
                    const o = this.terrain, r = o.get();
                    for (const t1 of Object.keys(e1.spec.terrain))!i.hasOwnProperty(t1) && e1.spec.terrain[t1].default && (i[t1] = e1.spec.terrain[t1].default);
                    for(const e1 in i)if (!t1(i[e1], r[e1])) {
                        o.set(i), this.stylesheet.terrain = i;
                        const e1 = this._setTransitionParameters({
                            duration: 0
                        });
                        o.updateTransitions(e1);
                        break;
                    }
                }
                this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
            }
            _createFog(e1) {
                const t1 = this.fog = new A(e1, this.map.transform);
                this.stylesheet.fog = e1;
                const i = this._setTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(()=>{
                    for (const e1 of this.map._markers)e1._evaluateOpacity();
                });
            }
            getFog() {
                return this.fog ? this.fog.get() : null;
            }
            setFog(e1) {
                if (this._checkLoaded(), !e1) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const i = this.fog, o = i.get();
                    0 === Object.keys(e1).length && i.set(e1);
                    for(const r in e1)if (!t1(e1[r], o[r])) {
                        i.set(e1), this.stylesheet.fog = e1;
                        const t1 = this._setTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(t1);
                        break;
                    }
                } else this._createFog(e1);
                this._markersNeedUpdate = !0;
            }
            _setTransitionParameters(t1) {
                return {
                    now: e1.exported.now(),
                    transition: e1.extend(t1, this.stylesheet.transition)
                };
            }
            _updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain) return;
                const e1 = this._order.filter((e1)=>this.isLayerDraped(this._layers[e1])), t1 = this._order.filter((e1)=>!this.isLayerDraped(this._layers[e1]));
                this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e1), this._drapedFirstOrder.push(...t1);
            }
            _createTerrain(e1, t1) {
                const i = this.terrain = new M(e1, t1);
                this.stylesheet.terrain = e1, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
                const o = this._setTransitionParameters({
                    duration: 0
                });
                i.updateTransitions(o);
            }
            _force3DLayerUpdate() {
                for(const e1 in this._layers){
                    const t1 = this._layers[e1];
                    "fill-extrusion" === t1.type && this._updateLayer(t1);
                }
            }
            _forceSymbolLayerUpdate() {
                for(const e1 in this._layers){
                    const t1 = this._layers[e1];
                    "symbol" === t1.type && this._updateLayer(t1);
                }
            }
            _validate(t1, i, o, r, n = {}) {
                return (!n || !1 !== n.validate) && $t(this, t1.call(e1.validateStyle, e1.extend({
                    key: i,
                    style: this.serialize(),
                    value: o,
                    styleSpec: e1.spec
                }, r)));
            }
            _remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e1.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                for(const e1 in this._layers)this._layers[e1].setEventedParent(null);
                for(const e1 in this._sourceCaches)this._sourceCaches[e1].clearTiles(), this._sourceCaches[e1].setEventedParent(null);
                this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }
            _clearSource(e1) {
                const t1 = this._getSourceCaches(e1);
                for (const e1 of t1)e1.clearTiles();
            }
            _reloadSource(e1) {
                const t1 = this._getSourceCaches(e1);
                for (const e1 of t1)e1.resume(), e1.reload();
            }
            _reloadSources() {
                for (const e1 of this._getSources())e1.reload && e1.reload();
            }
            _updateSources(e1) {
                for(const t1 in this._sourceCaches)this._sourceCaches[t1].update(e1);
            }
            _generateCollisionBoxes() {
                for(const e1 in this._sourceCaches){
                    const t1 = this._sourceCaches[e1];
                    t1.resume(), t1.reload();
                }
            }
            _updatePlacement(t1, i, o, r, n = !1) {
                let s = !1, a = !1;
                const l = {};
                for (const e1 of this._order){
                    const i = this._layers[e1];
                    if ("symbol" !== i.type) continue;
                    if (!l[i.source]) {
                        const e1 = this._getLayerSourceCache(i);
                        if (!e1) continue;
                        l[i.source] = e1.getRenderableIds(!0).map((t1)=>e1.getTileByID(t1)).sort((e1, t1)=>t1.tileID.overscaledZ - e1.tileID.overscaledZ || (e1.tileID.isLessThan(t1.tileID) ? -1 : 1));
                    }
                    const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], t1.center.lng, t1.projection);
                    s = s || o;
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n = n || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e1.Event("neworder")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e1.exported.now(), t1.zoom)) && (this.pauseablePlacement = new jt(t1, this._order, n, i, o, r, this.placement, this.fog && t1.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e1.exported.now()), a = !0), s && this.pauseablePlacement.placement.setStale()), a || s) for (const e1 of this._order){
                    const t1 = this._layers[e1];
                    "symbol" === t1.type && this.placement.updateLayerOpacities(t1, l[t1.source]);
                }
                return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e1.exported.now());
            }
            _releaseSymbolFadeTiles() {
                for(const e1 in this._sourceCaches)this._sourceCaches[e1].releaseSymbolFadeTiles();
            }
            getImages(e1, t1, i) {
                this.imageManager.getImages(t1.icons, i), this._updateTilesForChangedImages();
                const o = (e1)=>{
                    e1 && e1.setDependencies(t1.tileID.key, t1.type, t1.icons);
                };
                o(this._otherSourceCaches[t1.source]), o(this._symbolSourceCaches[t1.source]);
            }
            getGlyphs(e1, t1, i) {
                this.glyphManager.getGlyphs(t1.stacks, i);
            }
            getResource(t1, i, o) {
                return e1.makeRequest(i, o);
            }
            _getSourceCache(e1) {
                return this._otherSourceCaches[e1];
            }
            _getLayerSourceCache(e1) {
                return "symbol" === e1.type ? this._symbolSourceCaches[e1.source] : this._otherSourceCaches[e1.source];
            }
            _getSourceCaches(e1) {
                const t1 = [];
                return this._otherSourceCaches[e1] && t1.push(this._otherSourceCaches[e1]), this._symbolSourceCaches[e1] && t1.push(this._symbolSourceCaches[e1]), t1;
            }
            _isSourceCacheLoaded(t1) {
                const i = this._getSourceCaches(t1);
                return 0 === i.length ? (this.fire(new e1.ErrorEvent(new Error(`There is no source with ID '${t1}'`))), !1) : i.every((e1)=>e1.loaded());
            }
            has3DLayers() {
                return this._num3DLayers > 0;
            }
            hasSymbolLayers() {
                return this._numSymbolLayers > 0;
            }
            hasCircleLayers() {
                return this._numCircleLayers > 0;
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
                this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
        }
        Qt.getSourceType = function(e1) {
            return ze[e1];
        }, Qt.setSourceType = function(e1, t1) {
            ze[e1] = t1;
        }, Qt.registerForPluginStateChange = e1.registerForPluginStateChange;
        var ei = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", ti = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ii = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", oi = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ri = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
        let ni = {}, si = {};
        const ai = [];
        _i(ei, ai), _i(ii, ai), _i(oi, ai), _i(ri, ai), ni = di("", ii), si = di(ri, oi);
        const li = di("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), ci = ei, hi = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
        var ui = {
            background: di("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            backgroundPattern: di("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            circle: di("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
            clippingMask: di("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: di("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            heatmapTexture: di("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: di("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
            collisionCircle: di("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: di("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
            fill: di("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutline: di("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutlinePattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillExtrusion: di("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            fillExtrusionPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
            hillshadePrepare: di("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: di("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            line: di("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            linePattern: di("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            raster: di("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            symbolIcon: di("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),
            symbolSDF: di("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),
            symbolTextAndIcon: di("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),
            terrainRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"),
            terrainDepth: di("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
            skybox: di("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti),
            skyboxGradient: di("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti),
            skyboxCapture: di("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"),
            globeAtmosphere: di("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}")
        };
        function _i(e1, t1) {
            const i = e1.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e1 of i)if (e1 = e1.trim(), "#" === e1[0] && e1.includes("if") && !e1.includes("endif")) {
                e1 = e1.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                const i = e1.split(" ");
                for (const e1 of i)t1.includes(e1) || t1.push(e1);
            }
        }
        function di(e1, t1) {
            const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o = t1.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r = {}, n = [
                ...ai
            ];
            return _i(e1, n), _i(t1, n), {
                fragmentSource: e1 = e1.replace(i, (e1, t1, i, o, n)=>(r[n] = !0, "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${n}\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = u_${n};\n#endif\n`)),
                vertexSource: t1 = t1.replace(i, (e1, t1, i, o, n)=>{
                    const s = "float" === o ? "vec2" : "vec4", a = n.match(/color/) ? "color" : s;
                    return r[n] ? "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n`;
                }),
                staticAttributes: o,
                usedDefines: n
            };
        }
        class pi {
            constructor(){
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e1, t1, i, o, r, n, s) {
                this.context = e1;
                let a = this.boundPaintVertexBuffers.length !== o.length;
                for(let e1 = 0; !a && e1 < o.length; e1++)this.boundPaintVertexBuffers[e1] !== o[e1] && (a = !0);
                let l = this.boundDynamicVertexBuffers.length !== s.length;
                for(let e1 = 0; !l && e1 < s.length; e1++)this.boundDynamicVertexBuffers[e1] !== s[e1] && (l = !0);
                if (!e1.extVertexArrayObject || !this.vao || this.boundProgram !== t1 || this.boundLayoutVertexBuffer !== i || a || l || this.boundIndexBuffer !== r || this.boundVertexOffset !== n) this.freshBind(t1, i, o, r, n, s);
                else {
                    e1.bindVertexArrayOES.set(this.vao);
                    for (const e1 of s)e1 && e1.bind();
                    r && r.dynamicDraw && r.bind();
                }
            }
            freshBind(e1, t1, i, o, r, n) {
                let s;
                const a = e1.numAttributes, l = this.context, c = l.gl;
                if (l.extVertexArrayObject) this.vao && this.destroy(), this.vao = l.extVertexArrayObject.createVertexArrayOES(), l.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e1, this.boundLayoutVertexBuffer = t1, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = n;
                else {
                    s = l.currentNumAttributes || 0;
                    for(let e1 = a; e1 < s; e1++)c.disableVertexAttribArray(e1);
                }
                t1.enableAttributes(c, e1), t1.bind(), t1.setVertexAttribPointers(c, e1, r);
                for (const t1 of i)t1.enableAttributes(c, e1), t1.bind(), t1.setVertexAttribPointers(c, e1, r);
                for (const t1 of n)t1 && (t1.enableAttributes(c, e1), t1.bind(), t1.setVertexAttribPointers(c, e1, r));
                o && o.bind(), l.currentNumAttributes = a;
            }
            destroy() {
                this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
        }
        function mi(t1, i) {
            const o = Math.pow(2, i.canonical.z), r = i.canonical.y;
            return [
                new e1.MercatorCoordinate(0, r / o).toLngLat().lat,
                new e1.MercatorCoordinate(0, (r + 1) / o).toLngLat().lat
            ];
        }
        function fi(t1, i, o, r, n, s, a) {
            const l = t1.context, c = l.gl, h = o.fbo;
            if (!h) return;
            t1.prepareDrawTile();
            const u = t1.useProgram("hillshade");
            l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());
            const _ = ((e1, t1, i, o)=>{
                const r = i.paint.get("hillshade-shadow-color"), n = i.paint.get("hillshade-highlight-color"), s = i.paint.get("hillshade-accent-color");
                let a = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                "viewport" === i.paint.get("hillshade-illumination-anchor") && (a -= e1.transform.angle);
                const l = !e1.options.moving;
                return {
                    u_matrix: o || e1.transform.calculateProjMatrix(t1.tileID.toUnwrapped(), l),
                    u_image: 0,
                    u_latrange: mi(0, t1.tileID),
                    u_light: [
                        i.paint.get("hillshade-exaggeration"),
                        a
                    ],
                    u_shadow: r,
                    u_highlight: n,
                    u_accent: s
                };
            })(t1, o, r, t1.terrain ? i.projMatrix : null);
            t1.prepareDrawProgram(l, u, i.toUnwrapped());
            const { tileBoundsBuffer: d , tileBoundsIndexBuffer: p , tileBoundsSegments: m  } = t1.getTileBoundsBuffers(o);
            u.draw(l, c.TRIANGLES, n, s, a, e1.CullFaceMode.disabled, _, r.id, d, p, m);
        }
        function gi(t1, i, o) {
            if (!i.needsDEMTextureUpload) return;
            const r = t1.context, n = r.gl;
            r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t1.getTileTexture(o.stride);
            const s = o.getPixels();
            i.demTexture ? i.demTexture.update(s, {
                premultiply: !1
            }) : i.demTexture = new e1.Texture(r, s, n.RGBA, {
                premultiply: !1
            }), i.needsDEMTextureUpload = !1;
        }
        function vi(t1, i, o, r, n, s) {
            const a = t1.context, l = a.gl;
            if (!i.dem) return;
            const c = i.dem;
            if (a.activeTexture.set(l.TEXTURE1), gi(t1, i, c), !i.demTexture) return;
            i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
            const h = c.dim;
            a.activeTexture.set(l.TEXTURE0);
            let u = i.fbo;
            if (!u) {
                const t1 = new e1.Texture(a, {
                    width: h,
                    height: h,
                    data: null
                }, l.RGBA);
                t1.bind(l.LINEAR, l.CLAMP_TO_EDGE), u = i.fbo = a.createFramebuffer(h, h, !0), u.colorAttachment.set(t1.texture);
            }
            a.bindFramebuffer.set(u.framebuffer), a.viewport.set([
                0,
                0,
                h,
                h
            ]);
            const { tileBoundsBuffer: _ , tileBoundsIndexBuffer: d , tileBoundsSegments: p  } = t1.getMercatorTileBoundsBuffers();
            t1.useProgram("hillshadePrepare").draw(a, l.TRIANGLES, r, n, s, e1.CullFaceMode.disabled, ((t1, i)=>{
                const o = i.stride, r = e1.create();
                return e1.ortho(r, 0, e1.EXTENT, -e1.EXTENT, 0, 0, 1), e1.translate(r, r, [
                    0,
                    -e1.EXTENT,
                    0
                ]), {
                    u_matrix: r,
                    u_image: 1,
                    u_dimension: [
                        o,
                        o
                    ],
                    u_zoom: t1.overscaledZ,
                    u_unpack: i.unpackVector
                };
            })(i.tileID, c), o.id, _, d, p), i.needsHillshadePrepare = !1;
        }
        const xi = (t1)=>({
                u_matrix: new e1.UniformMatrix4f(t1),
                u_image0: new e1.Uniform1i(t1),
                u_skirt_height: new e1.Uniform1f(t1)
            }), yi = (e1, t1)=>({
                u_matrix: e1,
                u_image0: 0,
                u_skirt_height: t1
            }), bi = (e1, t1, i, o, r, n, s, a, l, c, h, u, _, d, p)=>({
                u_proj_matrix: Float32Array.from(e1),
                u_globe_matrix: t1,
                u_normalize_matrix: Float32Array.from(o),
                u_merc_matrix: i,
                u_zoom_transition: r,
                u_merc_center: n,
                u_image0: 0,
                u_frustum_tl: s,
                u_frustum_tr: a,
                u_frustum_br: l,
                u_frustum_bl: c,
                u_globe_pos: h,
                u_globe_radius: u,
                u_viewport: _,
                u_grid_matrix: p ? Float32Array.from(p) : new Float32Array(9),
                u_skirt_height: d
            });
        function wi(e1, t1) {
            return null != e1 && null != t1 && !(!e1.hasData() || !t1.hasData()) && null != e1.demTexture && null != t1.demTexture && e1.tileID.key !== t1.tileID.key;
        }
        const Ti = new class {
            constructor(){
                this.operations = {};
            }
            newMorphing(e1, t1, i, o, r) {
                if (e1 in this.operations) {
                    const t1 = this.operations[e1];
                    t1.to.tileID.key !== i.tileID.key && (t1.queued = i);
                } else this.operations[e1] = {
                    startTime: o,
                    phase: 0,
                    duration: r,
                    from: t1,
                    to: i,
                    queued: null
                };
            }
            getMorphValuesForProxy(e1) {
                if (!(e1 in this.operations)) return null;
                const t1 = this.operations[e1];
                return {
                    from: t1.from,
                    to: t1.to,
                    phase: t1.phase
                };
            }
            update(e1) {
                for(const t1 in this.operations){
                    const i = this.operations[t1];
                    for(i.phase = (e1 - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);)if (!this._nextOp(i, e1)) {
                        delete this.operations[t1];
                        break;
                    }
                }
            }
            _nextOp(e1, t1) {
                return !!e1.queued && (e1.from = e1.to, e1.to = e1.queued, e1.queued = null, e1.phase = 0, e1.startTime = t1, !0);
            }
            _validOp(e1) {
                return e1.from.hasData() && e1.to.hasData();
            }
        }, Ei = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING",
            2: "TERRAIN_WIREFRAME"
        };
        function Ci(e1) {
            return 6 * Math.pow(1.5, 22 - e1);
        }
        function Mi(e1, t1) {
            const i = 1 << e1.z;
            return !t1 && (0 === e1.x || e1.x === i - 1) || 0 === e1.y || e1.y === i - 1;
        }
        const Ii = (e1)=>({
                u_matrix: e1
            });
        function Si(t1, i, o, r, n) {
            if (n > 0) {
                const s = e1.exported.now(), a = (s - t1.timeAdded) / n, l = i ? (s - i.timeAdded) / n : -1, c = o.getSource(), h = r.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                }), u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t1.tileID.overscaledZ - h), _ = u && t1.refreshedUponExpiration ? 1 : e1.clamp(u ? a : 1 - l, 0, 1);
                return t1.refreshedUponExpiration && a >= 1 && (t1.refreshedUponExpiration = !1), i ? {
                    opacity: 1,
                    mix: 1 - _
                } : {
                    opacity: _,
                    mix: 0
                };
            }
            return {
                opacity: 1,
                mix: 0
            };
        }
        class Di extends e1.SourceCache {
            constructor(e1){
                const t1 = {
                    type: "raster-dem",
                    maxzoom: e1.transform.maxZoom
                }, i = new z(je(), null), o = Pe("mock-dem", t1, i, e1.style);
                super("mock-dem", o, !1), o.setEventedParent(this), this._sourceLoaded = !0;
            }
            _loadTile(e1, t1) {
                e1.state = "loaded", t1(null);
            }
        }
        class Li extends e1.SourceCache {
            constructor(e1){
                const t1 = Pe("proxy", {
                    type: "geojson",
                    maxzoom: e1.transform.maxZoom
                }, new z(je(), null), e1.style);
                super("proxy", t1, !1), t1.setEventedParent(this), this.map = this.getSource().map = e1, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(t1, i, o) {
                if (t1.freezeTileCoverage) return;
                this.transform = t1;
                const r = t1.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled
                }).reduce((i, o)=>{
                    if (i[o.key] = "", !this._tiles[o.key]) {
                        const i = new e1.Tile(o, this._source.tileSize * o.overscaleFactor(), t1.tileZoom);
                        i.state = "loaded", this._tiles[o.key] = i;
                    }
                    return i;
                }, {});
                for(const e1 in this._tiles)e1 in r || (this.freeFBO(e1), this._tiles[e1].unloadVectorData(), delete this._tiles[e1]);
            }
            freeFBO(e1) {
                const t1 = this.proxyCachedFBO[e1];
                if (void 0 !== t1) {
                    const i = Object.values(t1);
                    this.renderCachePool.push(...i), delete this.proxyCachedFBO[e1];
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((e1)=>e1.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
        }
        class Ai extends e1.OverscaledTileID {
            constructor(e1, t1, i){
                super(e1.overscaledZ, e1.wrap, e1.canonical.z, e1.canonical.x, e1.canonical.y), this.proxyTileKey = t1, this.projMatrix = i;
            }
        }
        class zi extends e1.Elevation {
            constructor(t1, i){
                super(), this.painter = t1, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
                const [o, r, n] = function(t1) {
                    const i = new e1.StructArrayLayout2i4, o = new e1.StructArrayLayout3ui6, r = 131;
                    i.reserve(17161), o.reserve(33800);
                    const n = e1.EXTENT / 128, s = e1.EXTENT + n / 2, a = s + n;
                    for(let t1 = -n; t1 < a; t1 += n)for(let o = -n; o < a; o += n){
                        const r = o < 0 || o > s || t1 < 0 || t1 > s ? 24575 : 0, n = e1.clamp(Math.round(o), 0, e1.EXTENT), a = e1.clamp(Math.round(t1), 0, e1.EXTENT);
                        i.emplaceBack(n + r, a);
                    }
                    const l = (e1, t1)=>{
                        const i = t1 * r + e1;
                        o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);
                    };
                    for(let e1 = 1; e1 < 129; e1++)for(let t1 = 1; t1 < 129; t1++)l(t1, e1);
                    return [
                        0,
                        129
                    ].forEach((e1)=>{
                        for(let t1 = 0; t1 < 130; t1++)l(t1, e1), l(e1, t1);
                    }), [
                        i,
                        o,
                        32768
                    ];
                }(), s = t1.context;
                this.gridBuffer = s.createVertexBuffer(o, e1.posAttributes.members), this.gridIndexBuffer = s.createIndexBuffer(r), this.gridSegments = e1.SegmentVector.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e1.SegmentVector.simpleSegment(0, 0, o.length, n), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Li(i.map), this.orthoMatrix = e1.create(), e1.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e1.EXTENT, 0, e1.EXTENT, 0, 1);
                const a = s.gl;
                this._overlapStencilMode = new e1.StencilMode({
                    func: a.GEQUAL,
                    mask: 255
                }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t1.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Di(i.map);
            }
            set style(e1) {
                e1.on("data", this._onStyleDataEvent.bind(this)), e1.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e1, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", ()=>{
                    this._clearLineLayersFromRenderCache();
                });
            }
            update(t1, i, o) {
                if (t1 && t1.terrain) {
                    this._style !== t1 && (this.style = t1), this.enabled = !0;
                    const r = t1.terrain.properties;
                    this.sourceCache = 0 === t1.terrain.drapeRenderMode ? this._mockSourceCache : t1._getSourceCache(r.get("source")), this._exaggeration = r.get("exaggeration");
                    const n = ()=>{
                        this.sourceCache.used && e1.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const t1 = this.getScaledDemTileSize();
                        this.sourceCache.update(i, t1, !0), this.resetTileLookupCache(this.sourceCache.id);
                    };
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, n(), this._initializing = !0), n(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0;
                } else this._disable();
            }
            resetTileLookupCache(e1) {
                this._findCoveringTileCache[e1] = {};
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _checkRenderCacheEfficiency() {
                const t1 = this.renderCacheEfficiency(this._style);
                this._style.map._optimizeForTerrain || 100 !== t1.efficiency && e1.warnOnce(`Terrain render cache efficiency is not optimal (${t1.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t1.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
            }
            _onStyleDataEvent(e1) {
                e1.coord && "source" === e1.dataType ? this._clearRenderCacheForTile(e1.sourceCacheId, e1.coord) : "style" === e1.dataType && (this._invalidateRenderCache = !0);
            }
            _disable() {
                if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for(const e1 in this._style._sourceCaches)this._style._sourceCaches[e1].usedForTerrain = !1;
            }
            destroy() {
                this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e1)=>e1.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
            }
            _source() {
                return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
                return this._exaggeration;
            }
            get visibleDemTiles() {
                return this._visibleDemTiles;
            }
            get drapeBufferSize() {
                const e1 = 2 * this.proxySourceCache.getSource().tileSize;
                return [
                    e1,
                    e1
                ];
            }
            set useVertexMorphing(e1) {
                this._useVertexMorphing = e1;
            }
            updateTileBinding(t1) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i = this.proxySourceCache, o = this.painter.transform;
                this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e1.MercatorCoordinate.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);
                const r = this.proxyCoords = i.getIds().map((e1)=>{
                    const t1 = i.getTileByID(e1).tileID;
                    return t1.projMatrix = o.calculateProjMatrix(t1.toUnwrapped()), t1;
                });
                !function(t1, i) {
                    const o = i.transform.pointCoordinate(i.transform.getCameraPoint()), r = new e1.pointGeometry(o.x, o.y);
                    t1.sort((t1, i)=>{
                        if (i.overscaledZ - t1.overscaledZ) return i.overscaledZ - t1.overscaledZ;
                        const o = new e1.pointGeometry(t1.canonical.x + (1 << t1.canonical.z) * t1.wrap, t1.canonical.y), n = new e1.pointGeometry(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y), s = r.mult(1 << t1.canonical.z);
                        return s.x -= .5, s.y -= .5, s.distSqr(o) - s.distSqr(n);
                    });
                }(r, this.painter), this._previousZoom = o.zoom;
                const n = this.proxyToSource || {};
                this.proxyToSource = {}, r.forEach((e1)=>{
                    this.proxyToSource[e1.key] = {};
                }), this.terrainTileForTile = {};
                const s = this._style._sourceCaches;
                for(const e1 in s){
                    const i = s[e1];
                    if (!i.used) continue;
                    if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t1[e1], n), i.usedForTerrain) continue;
                    const o = t1[e1];
                    i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
                }
                this.proxiedCoords[i.id] = r.map((e1)=>new Ai(e1, e1.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n), this.renderingToTexture = !1, this._updateTimestamp = e1.exported.now();
                const a = {};
                this._visibleDemTiles = [];
                for (const e1 of this.proxyCoords){
                    const t1 = this.terrainTileForTile[e1.key];
                    if (!t1) continue;
                    const i = t1.tileID.key;
                    i in a || (this._visibleDemTiles.push(t1), a[i] = i);
                }
            }
            _assignTerrainTiles(e1) {
                this._initializing || e1.forEach((e1)=>{
                    if (this.terrainTileForTile[e1.key]) return;
                    const t1 = this._findTileCoveringTileID(e1, this.sourceCache);
                    t1 && (this.terrainTileForTile[e1.key] = t1);
                });
            }
            _prepareDEMTextures() {
                const e1 = this.painter.context, t1 = e1.gl;
                for(const i in this.terrainTileForTile){
                    const o = this.terrainTileForTile[i], r = o.dem;
                    !r || o.demTexture && !o.needsDEMTextureUpload || (e1.activeTexture.set(t1.TEXTURE1), gi(this.painter, o, r));
                }
            }
            _prepareDemTileUniforms(e1, t1, i, o) {
                if (!t1 || null == t1.demTexture) return !1;
                const r = e1.tileID.canonical, n = Math.pow(2, t1.tileID.canonical.z - r.z), s = o || "";
                return i[`u_dem_tl${s}`] = [
                    r.x * n % 1,
                    r.y * n % 1
                ], i[`u_dem_scale${s}`] = n, !0;
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            get emptyDepthBufferTexture() {
                const t1 = this.painter.context, i = t1.gl;
                if (!this._emptyDepthBufferTexture) {
                    const o = new e1.RGBAImage({
                        width: 1,
                        height: 1
                    }, Uint8Array.of(255, 255, 255, 255));
                    this._emptyDepthBufferTexture = new e1.Texture(t1, o, i.RGBA, {
                        premultiply: !1
                    });
                }
                return this._emptyDepthBufferTexture;
            }
            _getLoadedAreaMinimum() {
                let e1 = 0;
                const t1 = this._visibleDemTiles.reduce((t1, i)=>{
                    if (!i.dem) return t1;
                    const o = i.dem.tree.minimums[0];
                    return o > 0 && e1++, t1 + o;
                }, 0);
                return e1 ? t1 / e1 : 0;
            }
            _updateEmptyDEMTexture() {
                const t1 = this.painter.context, i = t1.gl;
                t1.activeTexture.set(i.TEXTURE2);
                const o = this._getLoadedAreaMinimum(), r = new e1.RGBAImage({
                    width: 1,
                    height: 1
                }, new Uint8Array(e1.DEMData.pack(o, this.sourceCache.getSource().encoding)));
                this._emptyDEMTextureDirty = !1;
                let n = this._emptyDEMTexture;
                return n ? n.update(r, {
                    premultiply: !1
                }) : n = this._emptyDEMTexture = new e1.Texture(t1, r, i.RGBA, {
                    premultiply: !1
                }), n;
            }
            setupElevationDraw(t1, i, o) {
                const r = this.painter.context, n = r.gl, s = (a = this.sourceCache.getSource().encoding, {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_unpack: e1.DEMData.getUnpackVector(a),
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_exaggeration: 0
                });
                var a;
                s.u_dem_size = this.sourceCache.getSource().tileSize, s.u_exaggeration = this.exaggeration();
                let l = null, c = null, h = 1;
                if (o && o.morphing && this._useVertexMorphing) {
                    const e1 = o.morphing.srcDemTile, i = o.morphing.dstDemTile;
                    h = o.morphing.phase, e1 && i && (this._prepareDemTileUniforms(t1, e1, s, "_prev") && (c = e1), this._prepareDemTileUniforms(t1, i, s) && (l = i));
                }
                if (c && l ? (r.activeTexture.set(n.TEXTURE2), l.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), r.activeTexture.set(n.TEXTURE4), c.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), s.u_dem_lerp = h) : (l = this.terrainTileForTile[t1.tileID.key], r.activeTexture.set(n.TEXTURE2), (this._prepareDemTileUniforms(t1, l, s) ? l.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE)), r.activeTexture.set(n.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), this._depthFBO && (s.u_depth_size_inv = [
                    1 / this._depthFBO.width,
                    1 / this._depthFBO.height
                ])) : (this.emptyDepthBufferTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), s.u_depth_size_inv = [
                    1,
                    1
                ]), o && o.useMeterToDem && l) {
                    const t1 = (1 << l.tileID.canonical.z) * e1.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    s.u_meter_to_dem = t1;
                }
                if (o && o.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, s), "globe" === this.painter.transform.projection.name) {
                    const e1 = this.globeUniformValues(this.painter.transform, t1.tileID.canonical, o && o.useDenormalizedUpVectorScale);
                    i.setGlobeUniformValues(r, e1);
                }
            }
            globeUniformValues(t1, i, o) {
                const r = t1.projection;
                return {
                    u_tile_tl_up: r.upVector(i, 0, 0),
                    u_tile_tr_up: r.upVector(i, e1.EXTENT, 0),
                    u_tile_br_up: r.upVector(i, e1.EXTENT, e1.EXTENT),
                    u_tile_bl_up: r.upVector(i, 0, e1.EXTENT),
                    u_tile_up_scale: o ? e1.globeMetersToEcef(1) : r.upVectorScale(i, t1.center.lat, t1.worldSize).metersToTile
                };
            }
            renderToBackBuffer(t1) {
                const i = this.painter, o = this.painter.context;
                0 !== t1.length && (o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(t1, i, o, r, n) {
                    if ("globe" === t1.transform.projection.name) !function(t1, i, o, r, n) {
                        const s = t1.context, a = s.gl;
                        let l, c;
                        const h = t1.options.showTerrainWireframe ? 2 : 0, u = t1.transform, _ = e1.globeUseCustomAntiAliasing(t1, s, u), d = (e1, i)=>{
                            if (c === e1) return;
                            const o = [
                                Ei[e1],
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            _ && o.push("CUSTOM_ANTIALIASING"), i && o.push(Ei[h]), l = t1.useProgram("globeRaster", null, o), c = e1;
                        }, p = t1.colorModeForRenderPass(), m = new e1.DepthMode(a.LEQUAL, e1.DepthMode.ReadWrite, t1.depthRangeFor3D);
                        Ti.update(n);
                        const f = e1.calculateGlobeMercatorMatrix(u), g = [
                            e1.mercatorXfromLng(u.center.lng),
                            e1.mercatorYfromLat(u.center.lat)
                        ], v = h ? [
                            !1,
                            !0
                        ] : [
                            !1
                        ], x = t1.globeSharedBuffers, y = [
                            u.width * e1.exported.devicePixelRatio,
                            u.height * e1.exported.devicePixelRatio
                        ], b = Float32Array.from(u.globeMatrix), w = {
                            useDenormalizedUpVectorScale: !0
                        };
                        if (v.forEach((h)=>{
                            const u = t1.transform, _ = Ci(u.zoom) * i.exaggeration();
                            c = -1;
                            const v = h ? a.LINES : a.TRIANGLES;
                            for (const c of r){
                                const r = o.getTile(c), T = e1.StencilMode.disabled, E = i.prevTerrainTileForTile[c.key], C = i.terrainTileForTile[c.key];
                                wi(E, C) && Ti.newMorphing(c.key, E, C, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                const M = Ti.getMorphValuesForProxy(c.key), I = M ? 1 : 0;
                                M && e1.extend$1(w, {
                                    morphing: {
                                        srcDemTile: M.from,
                                        dstDemTile: M.to,
                                        phase: e1.easeCubicInOut(M.phase)
                                    }
                                });
                                const S = e1.tileCornersToBounds(c.canonical), D = e1.getLatitudinalLod(S.getCenter().lat), L = e1.getGridMatrix(c.canonical, S, D, u.worldSize / u._pixelsPerMercatorPixel), A = e1.globeNormalizeECEF(e1.globeTileBounds(c.canonical)), z = bi(u.projMatrix, b, f, A, e1.globeToMercatorTransition(u.zoom), g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, _, L);
                                if (d(I, h), i.setupElevationDraw(r, l, w), t1.prepareDrawProgram(s, l, c.toUnwrapped()), x) {
                                    const [i, o, r] = h ? x.getWirefameBuffers(t1.context, D) : x.getGridBuffers(D, 0 !== _);
                                    l.draw(s, v, m, T, p, e1.CullFaceMode.backCCW, z, "globe_raster", i, o, r);
                                }
                            }
                        }), x) {
                            const n = [
                                "GLOBE_POLES",
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            _ && n.push("CUSTOM_ANTIALIASING"), l = t1.useProgram("globeRaster", null, n);
                            for (const n of r){
                                const { x: r , y: c , z: h  } = n.canonical, _ = 0 === c, d = c === (1 << h) - 1, [f, v, b, T] = x.getPoleBuffers(h);
                                if (T && (_ || d)) {
                                    const c = o.getTile(n);
                                    s.activeTexture.set(a.TEXTURE0), c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                    let x = e1.globePoleMatrixForTile(h, r, u);
                                    const E = e1.globeNormalizeECEF(e1.globeTileBounds(n.canonical)), C = (t1, i)=>t1.draw(s, a.TRIANGLES, m, e1.StencilMode.disabled, p, e1.CullFaceMode.disabled, bi(u.projMatrix, x, x, E, 0, g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, 0), "globe_pole_raster", i, b, T);
                                    i.setupElevationDraw(c, l, w), t1.prepareDrawProgram(s, l, n.toUnwrapped()), _ && C(l, f), d && (x = e1.scale(e1.create(), x, [
                                        1,
                                        -1,
                                        1
                                    ]), C(l, v));
                                }
                            }
                        }
                    }(t1, i, o, r, n);
                    else {
                        const s = t1.context, a = s.gl;
                        let l, c;
                        const h = t1.options.showTerrainWireframe ? 2 : 0, u = (e1, i)=>{
                            if (c === e1) return;
                            const o = [
                                Ei[e1]
                            ];
                            i && o.push(Ei[h]), l = t1.useProgram("terrainRaster", null, o), c = e1;
                        }, _ = t1.colorModeForRenderPass(), d = new e1.DepthMode(a.LEQUAL, e1.DepthMode.ReadWrite, t1.depthRangeFor3D);
                        Ti.update(n);
                        const p = t1.transform, m = Ci(p.zoom) * i.exaggeration();
                        (h ? [
                            !1,
                            !0
                        ] : [
                            !1
                        ]).forEach((h)=>{
                            c = -1;
                            const f = h ? a.LINES : a.TRIANGLES, [g, v] = h ? i.getWirefameBuffer() : [
                                i.gridIndexBuffer,
                                i.gridSegments
                            ];
                            for (const c of r){
                                const r = o.getTile(c), x = e1.StencilMode.disabled, y = i.prevTerrainTileForTile[c.key], b = i.terrainTileForTile[c.key];
                                wi(y, b) && Ti.newMorphing(c.key, y, b, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);
                                const w = Ti.getMorphValuesForProxy(c.key), T = w ? 1 : 0;
                                let E;
                                w && (E = {
                                    morphing: {
                                        srcDemTile: w.from,
                                        dstDemTile: w.to,
                                        phase: e1.easeCubicInOut(w.phase)
                                    }
                                });
                                const C = yi(c.projMatrix, Mi(c.canonical, p.renderWorldCopies) ? m / 10 : m);
                                u(T, h), i.setupElevationDraw(r, l, E), t1.prepareDrawProgram(s, l, c.toUnwrapped()), l.draw(s, f, d, x, _, e1.CullFaceMode.backCCW, C, "terrain_raster", i.gridBuffer, g, v);
                            }
                        });
                    }
                }(i, this, this.proxySourceCache, t1, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t1.splice(0, t1.length));
            }
            renderBatch(t1) {
                if (0 === this._drapedRenderBatches.length) return t1 + 1;
                this.renderingToTexture = !0;
                const i = this.painter, o = this.painter.context, r = this.proxySourceCache, n = this.proxiedCoords[r.id], s = this._drapedRenderBatches.shift(), a = [], l = i.style.order;
                let c = 0;
                for (const h of n){
                    const n = r.getTileByID(h.proxyTileKey), u = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t1] : void 0, _ = void 0 !== u ? r.renderCache[u] : this.pool[c++], d = void 0 !== u;
                    if (n.texture = _.tex, d && !_.dirty) {
                        a.push(n.tileID);
                        continue;
                    }
                    let p;
                    o.bindFramebuffer.set(_.fb.framebuffer), this.renderedToTile = !1, _.dirty && (o.clear({
                        color: e1.Color.transparent,
                        stencil: 0
                    }), _.dirty = !1);
                    for(let e1 = s.start; e1 <= s.end; ++e1){
                        const t1 = i.style._layers[l[e1]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const r = i.style._getLayerSourceCache(t1), n = r ? this.proxyToSource[h.key][r.id] : [
                            h
                        ];
                        if (!n) continue;
                        const s = n;
                        o.viewport.set([
                            0,
                            0,
                            _.fb.width,
                            _.fb.height
                        ]), p !== (r ? r.id : null) && (this._setupStencil(_, n, t1, r), p = r ? r.id : null), i.renderLayer(i, r, t1, s);
                    }
                    this.renderedToTile ? (_.dirty = !0, a.push(n.tileID)) : d || --c, 5 === c && (c = 0, this.renderToBackBuffer(a));
                }
                return this.renderToBackBuffer(a), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), s.end + 1;
            }
            postRender() {}
            renderCacheEfficiency(e1) {
                const t1 = e1.order.length;
                if (0 === t1) return {
                    efficiency: 100
                };
                let i, o = 0, r = 0, n = !1;
                for(let s = 0; s < t1; ++s){
                    const t1 = e1._layers[e1.order[s]];
                    this._style.isLayerDraped(t1) ? (n && ++o, ++r) : n || (n = !0, i = t1.id);
                }
                return 0 === r ? {
                    efficiency: 100
                } : {
                    efficiency: 100 * (1 - o / r),
                    firstUndrapedLayer: i
                };
            }
            getMinElevationBelowMSL() {
                let e1 = 0;
                return this._visibleDemTiles.filter((e1)=>e1.dem).forEach((t1)=>{
                    e1 = Math.min(e1, t1.dem.tree.minimums[0]);
                }), 0 === e1 ? e1 : (e1 - 30) * this._exaggeration;
            }
            raycast(e1, t1, i) {
                if (!this._visibleDemTiles) return null;
                const o = this._visibleDemTiles.filter((e1)=>e1.dem).map((o)=>{
                    const r = o.tileID, n = 1 << r.overscaledZ, { x: s , y: a  } = r.canonical, l = s / n, c = (s + 1) / n, h = a / n, u = (a + 1) / n;
                    return {
                        minx: l,
                        miny: h,
                        maxx: c,
                        maxy: u,
                        t: o.dem.tree.raycastRoot(l, h, c, u, e1, t1, i),
                        tile: o
                    };
                });
                o.sort((e1, t1)=>(null !== e1.t ? e1.t : Number.MAX_VALUE) - (null !== t1.t ? t1.t : Number.MAX_VALUE));
                for (const r of o){
                    if (null == r.t) return null;
                    const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e1, t1, i);
                    if (null != o) return o;
                }
                return null;
            }
            _createFBO() {
                const t1 = this.painter.context, i = t1.gl, o = this.drapeBufferSize;
                t1.activeTexture.set(i.TEXTURE0);
                const r = new e1.Texture(t1, {
                    width: o[0],
                    height: o[1],
                    data: null
                }, i.RGBA);
                r.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                const n = t1.createFramebuffer(o[0], o[1], !1);
                return n.colorAttachment.set(r.texture), n.depthAttachment = new Ee(t1, n.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t1.createRenderbuffer(t1.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, n.depthAttachment.set(this._sharedDepthStencil), t1.clear({
                    stencil: 0
                })) : n.depthAttachment.set(this._sharedDepthStencil), t1.extTextureFilterAnisotropic && !t1.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, t1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t1.extTextureFilterAnisotropicMax), {
                    fb: n,
                    tex: r,
                    dirty: !1
                };
            }
            _initFBOPool() {
                for(; this.pool.length < Math.min(5, this.proxyCoords.length);)this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition()) return !0;
                for(const e1 in this._style._sourceCaches)if (this._style._sourceCaches[e1].hasTransition()) return !0;
                return this._style.order.some((e1)=>{
                    const t1 = this._style._layers[e1], i = t1.isHidden(this.painter.transform.zoom);
                    return "custom" === t1.type ? !i && t1.shouldRedrape() : !i && t1.hasTransition();
                });
            }
            _clearLineLayersFromRenderCache() {
                let t1 = !1;
                for (const e1 of this._style._getSources())if (e1 instanceof Ie) {
                    t1 = !0;
                    break;
                }
                if (!t1) return;
                const i = {};
                for(let t1 = 0; t1 < this._style.order.length; ++t1){
                    const o = this._style._layers[this._style.order[t1]], r = this._style._getLayerSourceCache(o);
                    if (r && !i[r.id] && !o.isHidden(this.painter.transform.zoom) && "line" === o.type && o.widthExpression() instanceof e1.ZoomDependentExpression) {
                        i[r.id] = !0;
                        for (const e1 of this.proxyCoords){
                            const t1 = this.proxyToSource[e1.key][r.id];
                            if (t1) for (const e1 of t1)this._clearRenderCacheForTile(r.id, e1);
                        }
                    }
                }
            }
            _clearRasterLayersFromRenderCache() {
                let e1 = !1;
                for(const t1 in this._style._sourceCaches)if (this._style._sourceCaches[t1]._source instanceof Se) {
                    e1 = !0;
                    break;
                }
                if (!e1) return;
                const t1 = {};
                for(let e1 = 0; e1 < this._style.order.length; ++e1){
                    const i = this._style._layers[this._style.order[e1]], o = this._style._getLayerSourceCache(i);
                    if (!o || t1[o.id]) continue;
                    if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type) continue;
                    const r = i.paint.get("raster-fade-duration");
                    for (const e1 of this.proxyCoords){
                        const t1 = this.proxyToSource[e1.key][o.id];
                        if (t1) for (const e1 of t1){
                            const t1 = Si(o.getTile(e1), o.findLoadedParent(e1, 0), o, this.painter.transform, r);
                            (1 !== t1.opacity || 0 !== t1.mix) && this._clearRenderCacheForTile(o.id, e1);
                        }
                    }
                }
            }
            _setupDrapedRenderBatches() {
                const e1 = this._style.order, t1 = e1.length;
                if (0 === t1) return;
                const i = [];
                let o, r = 0, n = this._style._layers[e1[r]];
                for(; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < t1;)n = this._style._layers[e1[r]];
                for(; r < t1; ++r){
                    const t1 = this._style._layers[e1[r]];
                    t1.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t1) ? void 0 === o && (o = r) : void 0 !== o && (i.push({
                        start: o,
                        end: r - 1
                    }), o = void 0));
                }
                void 0 !== o && i.push({
                    start: o,
                    end: r - 1
                }), this._drapedRenderBatches = i;
            }
            _setupRenderCache(e1) {
                const t1 = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                    if (this._invalidateRenderCache = !1, t1.renderCache.length > t1.renderCachePool.length) {
                        const e1 = Object.values(t1.proxyCachedFBO);
                        t1.proxyCachedFBO = {};
                        for(let i = 0; i < e1.length; ++i){
                            const o = Object.values(e1[i]);
                            t1.renderCachePool.push(...o);
                        }
                    }
                    return;
                }
                this._clearRasterLayersFromRenderCache();
                const i = this.proxyCoords, o = this._tilesDirty;
                for(let r = i.length - 1; r >= 0; r--){
                    const n = i[r];
                    if (t1.getTileByID(n.key), void 0 !== t1.proxyCachedFBO[n.key]) {
                        const i = e1[n.key], r = this.proxyToSource[n.key];
                        let s = 0;
                        for(const e1 in r){
                            const t1 = r[e1], n = i[e1];
                            if (!n || n.length !== t1.length || t1.some((t1, i)=>t1 !== n[i] || o[e1] && o[e1].hasOwnProperty(t1.key))) {
                                s = -1;
                                break;
                            }
                            ++s;
                        }
                        for(const e1 in t1.proxyCachedFBO[n.key])t1.renderCache[t1.proxyCachedFBO[n.key][e1]].dirty = s < 0 || s !== Object.values(i).length;
                    }
                }
                const r = [
                    ...this._drapedRenderBatches
                ];
                r.sort((e1, t1)=>t1.end - t1.start - (e1.end - e1.start));
                for (const e1 of r)for (const o of i){
                    if (t1.proxyCachedFBO[o.key]) continue;
                    let i = t1.renderCachePool.pop();
                    void 0 === i && t1.renderCache.length < 50 && (i = t1.renderCache.length, t1.renderCache.push(this._createFBO())), void 0 !== i && (t1.proxyCachedFBO[o.key] = {}, t1.proxyCachedFBO[o.key][e1.start] = i, t1.renderCache[i].dirty = !0);
                }
                this._tilesDirty = {};
            }
            _setupStencil(e1, t1, i, o) {
                if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const r = this.painter.context, n = r.gl;
                if (t1.length <= 1) return void (this._overlapStencilType = !1);
                let s;
                if (i.isTileClipped()) s = t1.length, this._overlapStencilMode.test = {
                    func: n.EQUAL,
                    mask: 255
                }, this._overlapStencilType = "Clip";
                else {
                    if (!(t1[0].overscaledZ > t1[t1.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                    s = 1, this._overlapStencilMode.test = {
                        func: n.GREATER,
                        mask: 255
                    }, this._overlapStencilType = "Mask";
                }
                this._stencilRef + s > 255 && (r.clear({
                    stencil: 0
                }), this._stencilRef = 0), this._stencilRef += s, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t1, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(t1) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t1.key]), this._overlapStencilMode) : e1.StencilMode.disabled;
            }
            _renderTileClippingMasks(t1, i) {
                const o = this.painter, r = this.painter.context, n = r.gl;
                o._tileClippingMaskIDs = {}, r.setColorMode(e1.ColorMode.disabled), r.setDepthMode(e1.DepthMode.disabled);
                const s = o.useProgram("clippingMask");
                for (const a of t1){
                    const t1 = o._tileClippingMaskIDs[a.key] = --i;
                    s.draw(r, n.TRIANGLES, e1.DepthMode.disabled, new e1.StencilMode({
                        func: n.ALWAYS,
                        mask: 0
                    }, t1, 255, n.KEEP, n.KEEP, n.REPLACE), e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ii(a.projMatrix), "$clipping", o.tileExtentBuffer, o.quadTriangleIndexBuffer, o.tileExtentSegments);
                }
            }
            pointCoordinate(t1) {
                const i = this.painter.transform;
                if (t1.x < 0 || t1.x > i.width || t1.y < 0 || t1.y > i.height) return null;
                const o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e1.transformMat4$1(o, o, i.pixelMatrixInverse), e1.scale$1(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;
                const r = i._camera.position, n = e1.mercatorZfromAltitude(1, i.center.lat), s = [
                    r[0],
                    r[1],
                    r[2] / n,
                    0
                ], a = e1.subtract([], o.slice(0, 3), s);
                e1.normalize(a, a);
                const l = this.raycast(s, a, this._exaggeration);
                return null !== l && l ? (e1.scaleAndAdd(s, s, a, l), s[3] = s[2], s[2] *= n, s) : null;
            }
            drawDepth() {
                const t1 = this.painter, i = t1.context, o = this.proxySourceCache, r = Math.ceil(t1.width), n = Math.ceil(t1.height);
                if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === n || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
                    const t1 = i.gl, o = i.createFramebuffer(r, n, !0);
                    i.activeTexture.set(t1.TEXTURE0);
                    const s = new e1.Texture(i, {
                        width: r,
                        height: n,
                        data: null
                    }, t1.RGBA);
                    s.bind(t1.NEAREST, t1.CLAMP_TO_EDGE), o.colorAttachment.set(s.texture);
                    const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, n);
                    o.depthAttachment.set(a), this._depthFBO = o, this._depthTexture = s;
                }
                i.bindFramebuffer.set(this._depthFBO.framebuffer), i.viewport.set([
                    0,
                    0,
                    r,
                    n
                ]), function(t1, i, o, r) {
                    if ("globe" === t1.transform.projection.name) return;
                    const n = t1.context, s = n.gl;
                    n.clear({
                        depth: 1
                    });
                    const a = t1.useProgram("terrainDepth"), l = new e1.DepthMode(s.LESS, e1.DepthMode.ReadWrite, t1.depthRangeFor3D);
                    for (const t1 of r){
                        const r = o.getTile(t1), c = yi(t1.projMatrix, 0);
                        i.setupElevationDraw(r, a), a.draw(n, s.TRIANGLES, l, e1.StencilMode.disabled, e1.ColorMode.unblended, e1.CullFaceMode.backCCW, c, "terrain_depth", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments);
                    }
                }(t1, this, o, this.proxyCoords);
            }
            _setupProxiedCoordsForOrtho(e1, t1, i) {
                if (e1.getSource() instanceof Ae) return this._setupProxiedCoordsForImageSource(e1, t1, i);
                this._findCoveringTileCache[e1.id] = this._findCoveringTileCache[e1.id] || {};
                const o = this.proxiedCoords[e1.id] = [], r = this.proxyCoords;
                for(let t1 = 0; t1 < r.length; t1++){
                    const n = r[t1], s = this._findTileCoveringTileID(n, e1);
                    if (s) {
                        const t1 = this._createProxiedId(n, s, i[n.key] && i[n.key][e1.id]);
                        o.push(t1), this.proxyToSource[n.key][e1.id] = [
                            t1
                        ];
                    }
                }
                let n = !1;
                for(let r = 0; r < t1.length; r++){
                    const s = e1.getTile(t1[r]);
                    if (!s || !s.hasData()) continue;
                    const a = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);
                    if (a && a.tileID.canonical.z !== s.tileID.canonical.z) {
                        const t1 = this.proxyToSource[a.tileID.key][e1.id], r = this._createProxiedId(a.tileID, s, i[a.tileID.key] && i[a.tileID.key][e1.id]);
                        t1 ? t1.splice(t1.length - 1, 0, r) : this.proxyToSource[a.tileID.key][e1.id] = [
                            r
                        ], o.push(r), n = !0;
                    }
                }
                this._sourceTilesOverlap[e1.id] = n;
            }
            _setupProxiedCoordsForImageSource(t1, i, o) {
                if (!t1.getSource().loaded()) return;
                const r = this.proxiedCoords[t1.id] = [], n = this.proxyCoords, s = t1.getSource(), a = new e1.pointGeometry(s.tileID.x, s.tileID.y)._div(1 << s.tileID.z), l = s.coordinates.map(e1.MercatorCoordinate.fromLngLat).reduce((e1, t1)=>(e1.min.x = Math.min(e1.min.x, t1.x - a.x), e1.min.y = Math.min(e1.min.y, t1.y - a.y), e1.max.x = Math.max(e1.max.x, t1.x - a.x), e1.max.y = Math.max(e1.max.y, t1.y - a.y), e1), {
                    min: new e1.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE),
                    max: new e1.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE)
                }), c = (t1, i)=>{
                    const o = t1.wrap + t1.canonical.x / (1 << t1.canonical.z), r = t1.canonical.y / (1 << t1.canonical.z), n = e1.EXTENT / (1 << t1.canonical.z), s = i.wrap + i.canonical.x / (1 << i.canonical.z), a = i.canonical.y / (1 << i.canonical.z);
                    return o + n < s + l.min.x || o > s + l.max.x || r + n < a + l.min.y || r > a + l.max.y;
                };
                for(let e1 = 0; e1 < n.length; e1++){
                    const s = n[e1];
                    for(let e1 = 0; e1 < i.length; e1++){
                        const n = t1.getTile(i[e1]);
                        if (!n || !n.hasData()) continue;
                        if (c(s, n.tileID)) continue;
                        const a = this._createProxiedId(s, n, o[s.key] && o[s.key][t1.id]), l = this.proxyToSource[s.key][t1.id];
                        l ? l.push(a) : this.proxyToSource[s.key][t1.id] = [
                            a
                        ], r.push(a);
                    }
                }
            }
            _createProxiedId(t1, i, o) {
                let r = this.orthoMatrix;
                if (o) {
                    const e1 = o.find((e1)=>e1.key === i.tileID.key);
                    if (e1) return e1;
                }
                if (i.tileID.key !== t1.key) {
                    const o = t1.canonical.z - i.tileID.canonical.z;
                    let n, s, a;
                    r = e1.create();
                    const l = i.tileID.wrap - t1.wrap << t1.overscaledZ;
                    o > 0 ? (n = e1.EXTENT >> o, s = n * ((i.tileID.canonical.x << o) - t1.canonical.x + l), a = n * ((i.tileID.canonical.y << o) - t1.canonical.y)) : (n = e1.EXTENT << -o, s = e1.EXTENT * (i.tileID.canonical.x - (t1.canonical.x + l << -o)), a = e1.EXTENT * (i.tileID.canonical.y - (t1.canonical.y << -o))), e1.ortho(r, 0, n, 0, n, 0, 1), e1.translate(r, r, [
                        s,
                        a,
                        0
                    ]);
                }
                return new Ai(i.tileID, t1.key, r);
            }
            _findTileCoveringTileID(t1, i) {
                let o = i.getTile(t1);
                if (o && o.hasData()) return o;
                const r = this._findCoveringTileCache[i.id], n = r[t1.key];
                if (o = n ? i.getTileByID(n) : null, o && o.hasData() || null === n) return o;
                let s = o ? o.tileID : t1, a = s.overscaledZ;
                const l = i.getSource().minzoom, c = [];
                if (!n) {
                    const r = i.getSource().maxzoom;
                    if (t1.canonical.z >= r) {
                        const o = t1.canonical.z - r;
                        i.getSource().reparseOverscaled ? (a = Math.max(t1.canonical.z + 2, i.transform.tileZoom), s = new e1.OverscaledTileID(a, t1.wrap, r, t1.canonical.x >> o, t1.canonical.y >> o)) : 0 !== o && (a = r, s = new e1.OverscaledTileID(a, t1.wrap, r, t1.canonical.x >> o, t1.canonical.y >> o));
                    }
                    s.key !== t1.key && (c.push(s.key), o = i.getTile(s));
                }
                const h = (e1)=>{
                    c.forEach((t1)=>{
                        r[t1] = e1;
                    }), c.length = 0;
                };
                for(a -= 1; a >= l && (!o || !o.hasData()); a--){
                    o && h(o.tileID.key);
                    const e1 = s.calculateScaledKey(a);
                    if (o = i.getTileByID(e1), o && o.hasData()) break;
                    const t1 = r[e1];
                    if (null === t1) break;
                    void 0 === t1 ? c.push(e1) : o = i.getTileByID(t1);
                }
                return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
            }
            findDEMTileFor(e1) {
                return this.enabled ? this._findTileCoveringTileID(e1, this.sourceCache) : null;
            }
            prepareDrawTile() {
                this.renderedToTile = !0;
            }
            _clearRenderCacheForTile(e1, t1) {
                let i = this._tilesDirty[e1];
                i || (i = this._tilesDirty[e1] = {}), i[t1.key] = !0;
            }
            getWirefameBuffer() {
                if (!this.wireframeSegments) {
                    const t1 = function(t1) {
                        let i = 0;
                        const o = new e1.StructArrayLayout2ui4, r = 131;
                        for(let e1 = 1; e1 < 129; e1++){
                            for(let t1 = 1; t1 < 129; t1++)i = e1 * r + t1, o.emplaceBack(i, i + 1), o.emplaceBack(i, i + r), o.emplaceBack(i + 1, i + r), 128 === e1 && o.emplaceBack(i + r, i + r + 1);
                            o.emplaceBack(i + 1, i + 1 + r);
                        }
                        return o;
                    }();
                    this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t1), this.wireframeSegments = e1.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t1.length);
                }
                return [
                    this.wireframeIndexBuffer,
                    this.wireframeSegments
                ];
            }
        }
        class Pi {
            static cacheKey(e1, t1, i, o) {
                let r = `${t1}${o ? o.cacheKey : ""}`;
                for (const t1 of i)e1.usedDefines.includes(t1) && (r += `/${t1}`);
                return r;
            }
            constructor(t1, i, o, r, n, s){
                const a = t1.gl;
                this.program = a.createProgram();
                const l = function(e1) {
                    const t1 = [];
                    for(let i = 0; i < e1.length; i++){
                        if (null === e1[i]) continue;
                        const o = e1[i].split(" ");
                        t1.push(o.pop());
                    }
                    return t1;
                }(o.staticAttributes), c = r ? r.getBinderAttributes() : [], h = l.concat(c);
                let u = r ? r.defines() : [];
                u = u.concat(s.map((e1)=>`#define ${e1}`));
                const _ = t1.isWebGL2 ? "#version 300 es\n" : "", d = _ + u.concat(t1.extStandardDerivatives && 0 === _.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(hi) : hi, hi, ci, li.fragmentSource, si.fragmentSource, o.fragmentSource).join("\n"), p = _ + u.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ci, li.vertexSource, si.vertexSource, ni.vertexSource, o.vertexSource).join("\n"), m = a.createShader(a.FRAGMENT_SHADER);
                if (a.isContextLost()) return void (this.failedToCreate = !0);
                a.shaderSource(m, d), a.compileShader(m), a.attachShader(this.program, m);
                const f = a.createShader(a.VERTEX_SHADER);
                if (a.isContextLost()) this.failedToCreate = !0;
                else {
                    a.shaderSource(f, p), a.compileShader(f), a.attachShader(this.program, f), this.attributes = {}, this.numAttributes = h.length;
                    for(let e1 = 0; e1 < this.numAttributes; e1++)h[e1] && (a.bindAttribLocation(this.program, e1, h[e1]), this.attributes[h[e1]] = e1);
                    a.linkProgram(this.program), a.deleteShader(f), a.deleteShader(m), this.fixedUniforms = n(t1), this.binderUniforms = r ? r.getUniforms(t1) : [], s.includes("TERRAIN") && (this.terrainUniforms = ((t1)=>({
                            u_dem: new e1.Uniform1i(t1),
                            u_dem_prev: new e1.Uniform1i(t1),
                            u_dem_unpack: new e1.Uniform4f(t1),
                            u_dem_tl: new e1.Uniform2f(t1),
                            u_dem_scale: new e1.Uniform1f(t1),
                            u_dem_tl_prev: new e1.Uniform2f(t1),
                            u_dem_scale_prev: new e1.Uniform1f(t1),
                            u_dem_size: new e1.Uniform1f(t1),
                            u_dem_lerp: new e1.Uniform1f(t1),
                            u_exaggeration: new e1.Uniform1f(t1),
                            u_depth: new e1.Uniform1i(t1),
                            u_depth_size_inv: new e1.Uniform2f(t1),
                            u_meter_to_dem: new e1.Uniform1f(t1),
                            u_label_plane_matrix_inv: new e1.UniformMatrix4f(t1)
                        }))(t1)), s.includes("GLOBE") && (this.globeUniforms = ((t1)=>({
                            u_tile_tl_up: new e1.Uniform3f(t1),
                            u_tile_tr_up: new e1.Uniform3f(t1),
                            u_tile_br_up: new e1.Uniform3f(t1),
                            u_tile_bl_up: new e1.Uniform3f(t1),
                            u_tile_up_scale: new e1.Uniform1f(t1)
                        }))(t1)), s.includes("FOG") && (this.fogUniforms = ((t1)=>({
                            u_fog_matrix: new e1.UniformMatrix4f(t1),
                            u_fog_range: new e1.Uniform2f(t1),
                            u_fog_color: new e1.Uniform4f(t1),
                            u_fog_horizon_blend: new e1.Uniform1f(t1),
                            u_fog_temporal_offset: new e1.Uniform1f(t1),
                            u_frustum_tl: new e1.Uniform3f(t1),
                            u_frustum_tr: new e1.Uniform3f(t1),
                            u_frustum_br: new e1.Uniform3f(t1),
                            u_frustum_bl: new e1.Uniform3f(t1),
                            u_globe_pos: new e1.Uniform3f(t1),
                            u_globe_radius: new e1.Uniform1f(t1),
                            u_globe_transition: new e1.Uniform1f(t1),
                            u_is_globe: new e1.Uniform1i(t1),
                            u_viewport: new e1.Uniform2f(t1)
                        }))(t1));
                }
            }
            setTerrainUniformValues(e1, t1) {
                if (!this.terrainUniforms) return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                    e1.program.set(this.program);
                    for(const e1 in t1)i[e1] && i[e1].set(this.program, e1, t1[e1]);
                }
            }
            setGlobeUniformValues(e1, t1) {
                if (!this.globeUniforms) return;
                const i = this.globeUniforms;
                if (!this.failedToCreate) {
                    e1.program.set(this.program);
                    for(const e1 in t1)i[e1] && i[e1].set(this.program, e1, t1[e1]);
                }
            }
            setFogUniformValues(e1, t1) {
                if (!this.fogUniforms) return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                    e1.program.set(this.program);
                    for(const e1 in t1)i[e1].set(this.program, e1, t1[e1]);
                }
            }
            draw(e1, t1, i, o, r, n, s, a, l, c, h, u, _, d, p) {
                const m = e1.gl;
                if (this.failedToCreate) return;
                e1.program.set(this.program), e1.setDepthMode(i), e1.setStencilMode(o), e1.setColorMode(r), e1.setCullFace(n);
                for (const e1 of Object.keys(this.fixedUniforms))this.fixedUniforms[e1].set(this.program, e1, s[e1]);
                d && d.setUniforms(this.program, e1, this.binderUniforms, u, {
                    zoom: _
                });
                const f = {
                    [m.LINES]: 2,
                    [m.TRIANGLES]: 3,
                    [m.LINE_STRIP]: 1
                }[t1];
                for (const i of h.get()){
                    const o = i.vaos || (i.vaos = {});
                    (o[a] || (o[a] = new pi)).bind(e1, this, l, d ? d.getPaintVertexBuffers() : [], c, i.vertexOffset, p || []), m.drawElements(t1, i.primitiveLength * f, m.UNSIGNED_SHORT, i.primitiveOffset * f * 2);
                }
            }
        }
        function Ri(e1, t1) {
            const i = Math.pow(2, t1.tileID.overscaledZ), o = t1.tileSize * Math.pow(2, e1.transform.tileZoom) / i, r = o * (t1.tileID.canonical.x + t1.tileID.wrap * i), n = o * t1.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: t1.imageAtlasTexture.size,
                u_tile_units_to_pixels: 1 / P(t1, 1, e1.transform.tileZoom),
                u_pixel_coord_upper: [
                    r >> 16,
                    n >> 16
                ],
                u_pixel_coord_lower: [
                    65535 & r,
                    65535 & n
                ]
            };
        }
        const Oi = e1.create(), Bi = (t1, i, o, r, n, s, a, l, c, h, u)=>{
            const _ = i.style.light, d = _.properties.get("position"), p = [
                d.x,
                d.y,
                d.z
            ], m = e1.create$1();
            "viewport" === _.properties.get("anchor") && (e1.fromRotation(m, -i.transform.angle), e1.transformMat3(p, p, m));
            const f = _.properties.get("color"), g = i.transform, v = {
                u_matrix: t1,
                u_lightpos: p,
                u_lightintensity: _.properties.get("intensity"),
                u_lightcolor: [
                    f.r,
                    f.g,
                    f.b
                ],
                u_vertical_gradient: +o,
                u_opacity: r,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: Oi,
                u_merc_center: [
                    0,
                    0
                ],
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_height_lift: 0,
                u_ao: n,
                u_edge_radius: s
            };
            return "globe" === g.projection.name && (v.u_tile_id = [
                a.canonical.x,
                a.canonical.y,
                1 << a.canonical.z
            ], v.u_zoom_transition = c, v.u_inv_rot_matrix = u, v.u_merc_center = h, v.u_up_dir = g.projection.upVector(new e1.CanonicalTileID(0, 0, 0), h[0] * e1.EXTENT, h[1] * e1.EXTENT), v.u_height_lift = l), v;
        }, ki = (t1, i, o, r, n, s, a, l, c, h, u, _)=>{
            const d = Bi(t1, i, o, r, n, s, a, c, h, u, _), p = {
                u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8
            };
            return e1.extend(d, Ri(i, l), p);
        }, Fi = (e1)=>({
                u_matrix: e1
            }), Ui = (t1, i, o)=>e1.extend(Fi(t1), Ri(i, o)), Ni = (e1, t1)=>({
                u_matrix: e1,
                u_world: t1
            }), Gi = (t1, i, o, r)=>e1.extend(Ui(t1, i, o), {
                u_world: r
            }), ji = e1.create(), Zi = (t1, i, o, r, n, s)=>{
            const a = t1.transform, l = "globe" === a.projection.name;
            let c;
            if ("map" === s.paint.get("circle-pitch-alignment")) {
                if (l) {
                    const t1 = e1.globePixelsToTileUnits(a.zoom, i.canonical) * a._pixelsPerMercatorPixel;
                    c = Float32Array.from([
                        t1,
                        0,
                        0,
                        t1
                    ]);
                } else c = a.calculatePixelsToTileUnitsMatrix(o);
            } else c = new Float32Array([
                a.pixelsToGLUnits[0],
                0,
                0,
                a.pixelsToGLUnits[1]
            ]);
            const h = {
                u_camera_to_center_distance: a.cameraToCenterDistance,
                u_matrix: t1.translatePosMatrix(i.projMatrix, o, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: e1.exported.devicePixelRatio,
                u_extrude_scale: c,
                u_inv_rot_matrix: ji,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (l) {
                h.u_inv_rot_matrix = r, h.u_merc_center = n, h.u_tile_id = [
                    i.canonical.x,
                    i.canonical.y,
                    1 << i.canonical.z
                ], h.u_zoom_transition = e1.globeToMercatorTransition(a.zoom);
                const t1 = n[0] * e1.EXTENT, o = n[1] * e1.EXTENT;
                h.u_up_dir = a.projection.upVector(new e1.CanonicalTileID(0, 0, 0), t1, o);
            }
            return h;
        }, Vi = (e1)=>{
            const t1 = [];
            return "map" === e1.paint.get("circle-pitch-alignment") && t1.push("PITCH_WITH_MAP"), "map" === e1.paint.get("circle-pitch-scale") && t1.push("SCALE_WITH_MAP"), t1;
        }, Wi = (t1, i, o, r)=>{
            const n = e1.EXTENT / o.tileSize;
            return {
                u_matrix: t1,
                u_camera_to_center_distance: i.getCameraToCenterDistance(r),
                u_extrude_scale: [
                    i.pixelsToGLUnits[0] / n,
                    i.pixelsToGLUnits[1] / n
                ]
            };
        }, Xi = (e1, t1, i = 1)=>({
                u_matrix: e1,
                u_color: t1,
                u_overlay: 0,
                u_overlay_scale: i
            }), qi = e1.create(), $i = (t1, i, o, r, n, s, a)=>{
            const l = t1.transform, c = "globe" === l.projection.name, h = c ? e1.globePixelsToTileUnits(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : P(o, 1, s), u = {
                u_matrix: i.projMatrix,
                u_extrude_scale: h,
                u_intensity: a,
                u_inv_rot_matrix: qi,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (c) {
                u.u_inv_rot_matrix = r, u.u_merc_center = n, u.u_tile_id = [
                    i.canonical.x,
                    i.canonical.y,
                    1 << i.canonical.z
                ], u.u_zoom_transition = e1.globeToMercatorTransition(l.zoom);
                const t1 = n[0] * e1.EXTENT, o = n[1] * e1.EXTENT;
                u.u_up_dir = l.projection.upVector(new e1.CanonicalTileID(0, 0, 0), t1, o);
            }
            return u;
        }, Hi = (e1, t1, i, o, r, n, s)=>{
            const a = e1.transform, l = a.calculatePixelsToTileUnitsMatrix(t1);
            return {
                u_matrix: Ji(e1, t1, i, o),
                u_pixels_to_tile_units: l,
                u_device_pixel_ratio: n,
                u_units_to_pixels: [
                    1 / a.pixelsToGLUnits[0],
                    1 / a.pixelsToGLUnits[1]
                ],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: r,
                u_texsize: Qi(i) ? t1.lineAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: Ki(t1, e1.transform),
                u_alpha_discard_threshold: 0,
                u_trim_offset: s
            };
        }, Yi = (e1, t1, i, o, r)=>{
            const n = e1.transform;
            return {
                u_matrix: Ji(e1, t1, i, o),
                u_texsize: t1.imageAtlasTexture.size,
                u_pixels_to_tile_units: n.calculatePixelsToTileUnitsMatrix(t1),
                u_device_pixel_ratio: r,
                u_image: 0,
                u_tile_units_to_pixels: Ki(t1, n),
                u_units_to_pixels: [
                    1 / n.pixelsToGLUnits[0],
                    1 / n.pixelsToGLUnits[1]
                ],
                u_alpha_discard_threshold: 0
            };
        };
        function Ki(e1, t1) {
            return 1 / P(e1, 1, t1.tileZoom);
        }
        function Ji(e1, t1, i, o) {
            return e1.translatePosMatrix(o || t1.tileID.projMatrix, t1, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
        }
        function Qi(e1) {
            const t1 = e1.paint.get("line-dasharray").value;
            return t1.value || "constant" !== t1.kind;
        }
        const eo = (e1, t1, i, o, r, n)=>{
            var s, a;
            return {
                u_matrix: e1,
                u_tl_parent: t1,
                u_scale_parent: i,
                u_fade_t: o.mix,
                u_opacity: o.opacity * r.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: r.paint.get("raster-brightness-min"),
                u_brightness_high: r.paint.get("raster-brightness-max"),
                u_saturation_factor: (a = r.paint.get("raster-saturation"), a > 0 ? 1 - 1 / (1.001 - a) : -a),
                u_contrast_factor: (s = r.paint.get("raster-contrast"), s > 0 ? 1 / (1 - s) : 1 + s),
                u_spin_weights: to(r.paint.get("raster-hue-rotate")),
                u_perspective_transform: n
            };
        };
        function to(e1) {
            e1 *= Math.PI / 180;
            const t1 = Math.sin(e1), i = Math.cos(e1);
            return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * t1 - i + 1) / 3,
                (Math.sqrt(3) * t1 - i + 1) / 3
            ];
        }
        const io = e1.create(), oo = (t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f)=>{
            const g = n.transform, v = {
                u_is_size_zoom_constant: +("constant" === t1 || "source" === t1),
                u_is_size_feature_constant: +("constant" === t1 || "camera" === t1),
                u_size_t: i ? i.uSizeT : 0,
                u_size: i ? i.uSize : 0,
                u_camera_to_center_distance: g.cameraToCenterDistance,
                u_rotate_symbol: +o,
                u_aspect_ratio: g.width / g.height,
                u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1,
                u_matrix: s,
                u_label_plane_matrix: a,
                u_coord_matrix: l,
                u_is_text: +c,
                u_pitch_with_map: +r,
                u_texsize: h,
                u_texture: 0,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: io,
                u_merc_center: [
                    0,
                    0
                ],
                u_camera_forward: [
                    0,
                    0,
                    0
                ],
                u_ecef_origin: [
                    0,
                    0,
                    0
                ],
                u_tile_matrix: io,
                u_up_vector: [
                    0,
                    -1,
                    0
                ]
            };
            return "globe" === f.name && (v.u_tile_id = [
                u.canonical.x,
                u.canonical.y,
                1 << u.canonical.z
            ], v.u_zoom_transition = _, v.u_inv_rot_matrix = p, v.u_merc_center = d, v.u_camera_forward = g._camera.forward(), v.u_ecef_origin = e1.globeECEFOrigin(g.globeMatrix, u.toUnwrapped()), v.u_tile_matrix = Float32Array.from(g.globeMatrix), v.u_up_vector = m), v;
        }, ro = (t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g)=>e1.extend(oo(t1, i, o, r, n, s, a, l, c, h, _, d, p, m, f, g), {
                u_gamma_scale: r ? n.transform.cameraToCenterDistance * Math.cos(n.terrain ? 0 : n.transform._pitch) : 1,
                u_device_pixel_ratio: e1.exported.devicePixelRatio,
                u_is_halo: +u
            }), no = (t1, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f)=>e1.extend(ro(t1, i, o, r, n, s, a, l, !0, c, !0, u, _, d, p, m, f), {
                u_texsize_icon: h,
                u_texture_icon: 1
            }), so = (e1, t1, i)=>({
                u_matrix: e1,
                u_opacity: t1,
                u_color: i
            }), ao = (t1, i, o, r, n)=>e1.extend(function(e1, t1, i) {
                const o = t1.imageManager.getPattern(e1.toString()), { width: r , height: n  } = t1.imageManager.getPixelSize(), s = Math.pow(2, i.tileID.overscaledZ), a = i.tileSize * Math.pow(2, t1.transform.tileZoom) / s, l = a * (i.tileID.canonical.x + i.tileID.wrap * s), c = a * i.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl: o.tl,
                    u_pattern_br: o.br,
                    u_texsize: [
                        r,
                        n
                    ],
                    u_pattern_size: o.displaySize,
                    u_tile_units_to_pixels: 1 / P(i, 1, t1.transform.tileZoom),
                    u_pixel_coord_upper: [
                        l >> 16,
                        c >> 16
                    ],
                    u_pixel_coord_lower: [
                        65535 & l,
                        65535 & c
                    ]
                };
            }(r, o, n), {
                u_matrix: t1,
                u_opacity: i
            }), lo = {
            fillExtrusion: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_lightpos: new e1.Uniform3f(t1),
                    u_lightintensity: new e1.Uniform1f(t1),
                    u_lightcolor: new e1.Uniform3f(t1),
                    u_vertical_gradient: new e1.Uniform1f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_edge_radius: new e1.Uniform1f(t1),
                    u_ao: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_up_dir: new e1.Uniform3f(t1),
                    u_height_lift: new e1.Uniform1f(t1)
                }),
            fillExtrusionPattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_lightpos: new e1.Uniform3f(t1),
                    u_lightintensity: new e1.Uniform1f(t1),
                    u_lightcolor: new e1.Uniform3f(t1),
                    u_vertical_gradient: new e1.Uniform1f(t1),
                    u_height_factor: new e1.Uniform1f(t1),
                    u_edge_radius: new e1.Uniform1f(t1),
                    u_ao: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_up_dir: new e1.Uniform3f(t1),
                    u_height_lift: new e1.Uniform1f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pixel_coord_upper: new e1.Uniform2f(t1),
                    u_pixel_coord_lower: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1),
                    u_opacity: new e1.Uniform1f(t1)
                }),
            fill: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1)
                }),
            fillPattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pixel_coord_upper: new e1.Uniform2f(t1),
                    u_pixel_coord_lower: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1)
                }),
            fillOutline: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_world: new e1.Uniform2f(t1)
                }),
            fillOutlinePattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_world: new e1.Uniform2f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pixel_coord_upper: new e1.Uniform2f(t1),
                    u_pixel_coord_lower: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1)
                }),
            circle: (t1)=>({
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_extrude_scale: new e1.UniformMatrix2f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_up_dir: new e1.Uniform3f(t1)
                }),
            collisionBox: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_extrude_scale: new e1.Uniform2f(t1)
                }),
            collisionCircle: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_inv_matrix: new e1.UniformMatrix4f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_viewport_size: new e1.Uniform2f(t1)
                }),
            debug: (t1)=>({
                    u_color: new e1.UniformColor(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_overlay: new e1.Uniform1i(t1),
                    u_overlay_scale: new e1.Uniform1f(t1)
                }),
            clippingMask: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1)
                }),
            heatmap: (t1)=>({
                    u_extrude_scale: new e1.Uniform1f(t1),
                    u_intensity: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_up_dir: new e1.Uniform3f(t1)
                }),
            heatmapTexture: (t1)=>({
                    u_image: new e1.Uniform1i(t1),
                    u_color_ramp: new e1.Uniform1i(t1),
                    u_opacity: new e1.Uniform1f(t1)
                }),
            hillshade: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_latrange: new e1.Uniform2f(t1),
                    u_light: new e1.Uniform2f(t1),
                    u_shadow: new e1.UniformColor(t1),
                    u_highlight: new e1.UniformColor(t1),
                    u_accent: new e1.UniformColor(t1)
                }),
            hillshadePrepare: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_dimension: new e1.Uniform2f(t1),
                    u_zoom: new e1.Uniform1f(t1),
                    u_unpack: new e1.Uniform4f(t1)
                }),
            line: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_pixels_to_tile_units: new e1.UniformMatrix2f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_units_to_pixels: new e1.Uniform2f(t1),
                    u_dash_image: new e1.Uniform1i(t1),
                    u_gradient_image: new e1.Uniform1i(t1),
                    u_image_height: new e1.Uniform1f(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1),
                    u_alpha_discard_threshold: new e1.Uniform1f(t1),
                    u_trim_offset: new e1.Uniform2f(t1)
                }),
            linePattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pixels_to_tile_units: new e1.UniformMatrix2f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_units_to_pixels: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1),
                    u_alpha_discard_threshold: new e1.Uniform1f(t1)
                }),
            raster: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_tl_parent: new e1.Uniform2f(t1),
                    u_scale_parent: new e1.Uniform1f(t1),
                    u_fade_t: new e1.Uniform1f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_image0: new e1.Uniform1i(t1),
                    u_image1: new e1.Uniform1i(t1),
                    u_brightness_low: new e1.Uniform1f(t1),
                    u_brightness_high: new e1.Uniform1f(t1),
                    u_saturation_factor: new e1.Uniform1f(t1),
                    u_contrast_factor: new e1.Uniform1f(t1),
                    u_spin_weights: new e1.Uniform3f(t1),
                    u_perspective_transform: new e1.Uniform2f(t1)
                }),
            symbolIcon: (t1)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t1),
                    u_is_size_feature_constant: new e1.Uniform1i(t1),
                    u_size_t: new e1.Uniform1f(t1),
                    u_size: new e1.Uniform1f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_rotate_symbol: new e1.Uniform1i(t1),
                    u_aspect_ratio: new e1.Uniform1f(t1),
                    u_fade_change: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t1),
                    u_coord_matrix: new e1.UniformMatrix4f(t1),
                    u_is_text: new e1.Uniform1i(t1),
                    u_pitch_with_map: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_camera_forward: new e1.Uniform3f(t1),
                    u_tile_matrix: new e1.UniformMatrix4f(t1),
                    u_up_vector: new e1.Uniform3f(t1),
                    u_ecef_origin: new e1.Uniform3f(t1),
                    u_texture: new e1.Uniform1i(t1)
                }),
            symbolSDF: (t1)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t1),
                    u_is_size_feature_constant: new e1.Uniform1i(t1),
                    u_size_t: new e1.Uniform1f(t1),
                    u_size: new e1.Uniform1f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_rotate_symbol: new e1.Uniform1i(t1),
                    u_aspect_ratio: new e1.Uniform1f(t1),
                    u_fade_change: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t1),
                    u_coord_matrix: new e1.UniformMatrix4f(t1),
                    u_is_text: new e1.Uniform1i(t1),
                    u_pitch_with_map: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_texture: new e1.Uniform1i(t1),
                    u_gamma_scale: new e1.Uniform1f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_tile_id: new e1.Uniform3f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_camera_forward: new e1.Uniform3f(t1),
                    u_tile_matrix: new e1.UniformMatrix4f(t1),
                    u_up_vector: new e1.Uniform3f(t1),
                    u_ecef_origin: new e1.Uniform3f(t1),
                    u_is_halo: new e1.Uniform1i(t1)
                }),
            symbolTextAndIcon: (t1)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t1),
                    u_is_size_feature_constant: new e1.Uniform1i(t1),
                    u_size_t: new e1.Uniform1f(t1),
                    u_size: new e1.Uniform1f(t1),
                    u_camera_to_center_distance: new e1.Uniform1f(t1),
                    u_rotate_symbol: new e1.Uniform1i(t1),
                    u_aspect_ratio: new e1.Uniform1f(t1),
                    u_fade_change: new e1.Uniform1f(t1),
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t1),
                    u_coord_matrix: new e1.UniformMatrix4f(t1),
                    u_is_text: new e1.Uniform1i(t1),
                    u_pitch_with_map: new e1.Uniform1i(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_texsize_icon: new e1.Uniform2f(t1),
                    u_texture: new e1.Uniform1i(t1),
                    u_texture_icon: new e1.Uniform1i(t1),
                    u_gamma_scale: new e1.Uniform1f(t1),
                    u_device_pixel_ratio: new e1.Uniform1f(t1),
                    u_is_halo: new e1.Uniform1i(t1)
                }),
            background: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_color: new e1.UniformColor(t1)
                }),
            backgroundPattern: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_image: new e1.Uniform1i(t1),
                    u_pattern_tl: new e1.Uniform2f(t1),
                    u_pattern_br: new e1.Uniform2f(t1),
                    u_texsize: new e1.Uniform2f(t1),
                    u_pattern_size: new e1.Uniform2f(t1),
                    u_pixel_coord_upper: new e1.Uniform2f(t1),
                    u_pixel_coord_lower: new e1.Uniform2f(t1),
                    u_tile_units_to_pixels: new e1.Uniform1f(t1)
                }),
            terrainRaster: xi,
            terrainDepth: xi,
            skybox: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_sun_direction: new e1.Uniform3f(t1),
                    u_cubemap: new e1.Uniform1i(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_temporal_offset: new e1.Uniform1f(t1)
                }),
            skyboxGradient: (t1)=>({
                    u_matrix: new e1.UniformMatrix4f(t1),
                    u_color_ramp: new e1.Uniform1i(t1),
                    u_center_direction: new e1.Uniform3f(t1),
                    u_radius: new e1.Uniform1f(t1),
                    u_opacity: new e1.Uniform1f(t1),
                    u_temporal_offset: new e1.Uniform1f(t1)
                }),
            skyboxCapture: (t1)=>({
                    u_matrix_3f: new e1.UniformMatrix3f(t1),
                    u_sun_direction: new e1.Uniform3f(t1),
                    u_sun_intensity: new e1.Uniform1f(t1),
                    u_color_tint_r: new e1.Uniform4f(t1),
                    u_color_tint_m: new e1.Uniform4f(t1),
                    u_luminance: new e1.Uniform1f(t1)
                }),
            globeRaster: (t1)=>({
                    u_proj_matrix: new e1.UniformMatrix4f(t1),
                    u_globe_matrix: new e1.UniformMatrix4f(t1),
                    u_normalize_matrix: new e1.UniformMatrix4f(t1),
                    u_merc_matrix: new e1.UniformMatrix4f(t1),
                    u_zoom_transition: new e1.Uniform1f(t1),
                    u_merc_center: new e1.Uniform2f(t1),
                    u_image0: new e1.Uniform1i(t1),
                    u_grid_matrix: new e1.UniformMatrix3f(t1),
                    u_skirt_height: new e1.Uniform1f(t1),
                    u_frustum_tl: new e1.Uniform3f(t1),
                    u_frustum_tr: new e1.Uniform3f(t1),
                    u_frustum_br: new e1.Uniform3f(t1),
                    u_frustum_bl: new e1.Uniform3f(t1),
                    u_globe_pos: new e1.Uniform3f(t1),
                    u_globe_radius: new e1.Uniform1f(t1),
                    u_viewport: new e1.Uniform2f(t1)
                }),
            globeAtmosphere: (t1)=>({
                    u_frustum_tl: new e1.Uniform3f(t1),
                    u_frustum_tr: new e1.Uniform3f(t1),
                    u_frustum_br: new e1.Uniform3f(t1),
                    u_frustum_bl: new e1.Uniform3f(t1),
                    u_horizon: new e1.Uniform1f(t1),
                    u_transition: new e1.Uniform1f(t1),
                    u_fadeout_range: new e1.Uniform1f(t1),
                    u_color: new e1.Uniform4f(t1),
                    u_high_color: new e1.Uniform4f(t1),
                    u_space_color: new e1.Uniform4f(t1),
                    u_star_intensity: new e1.Uniform1f(t1),
                    u_star_density: new e1.Uniform1f(t1),
                    u_star_size: new e1.Uniform1f(t1),
                    u_temporal_offset: new e1.Uniform1f(t1),
                    u_horizon_angle: new e1.Uniform1f(t1),
                    u_rotation_matrix: new e1.UniformMatrix4f(t1)
                })
        };
        let co;
        function ho(t1, i, o, r, n, s, a) {
            const l = t1.context, c = l.gl, h = t1.transform, u = t1.useProgram("collisionBox"), _ = [];
            let d = 0, p = 0;
            for(let m = 0; m < r.length; m++){
                const f = r[m], g = i.getTile(f), v = g.getBucket(o);
                if (!v) continue;
                const x = yt(f, v, h);
                let y = x;
                0 === n[0] && 0 === n[1] || (y = t1.translatePosMatrix(x, g, n, s));
                const b = a ? v.textCollisionBox : v.iconCollisionBox, w = v.collisionCircleArray;
                if (w.length > 0) {
                    const t1 = e1.create(), i = y;
                    e1.mul(t1, v.placementInvProjMatrix, h.glCoordMatrix), e1.mul(t1, t1, v.placementViewportMatrix), _.push({
                        circleArray: w,
                        circleOffset: p,
                        transform: i,
                        invTransform: t1,
                        projection: v.getProjection()
                    }), d += w.length / 4, p = d;
                }
                b && (t1.terrain && t1.terrain.setupElevationDraw(g, u), u.draw(l, c.LINES, e1.DepthMode.disabled, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.disabled, Wi(y, h, g, v.getProjection()), o.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, h.zoom, null, [
                    b.collisionVertexBuffer,
                    b.collisionVertexBufferExt
                ]));
            }
            if (!a || !_.length) return;
            const m = t1.useProgram("collisionCircle"), f = new e1.StructArrayLayout2f1f2i16;
            f.resize(4 * d), f._trim();
            let g = 0;
            for (const e1 of _)for(let t1 = 0; t1 < e1.circleArray.length / 4; t1++){
                const i = 4 * t1, o = e1.circleArray[i + 0], r = e1.circleArray[i + 1], n = e1.circleArray[i + 2], s = e1.circleArray[i + 3];
                f.emplace(g++, o, r, n, s, 0), f.emplace(g++, o, r, n, s, 1), f.emplace(g++, o, r, n, s, 2), f.emplace(g++, o, r, n, s, 3);
            }
            (!co || co.length < 2 * d) && (co = function(t1) {
                const i = 2 * t1, o = new e1.StructArrayLayout3ui6;
                o.resize(i), o._trim();
                for(let e1 = 0; e1 < i; e1++){
                    const t1 = 6 * e1;
                    o.uint16[t1 + 0] = 4 * e1 + 0, o.uint16[t1 + 1] = 4 * e1 + 1, o.uint16[t1 + 2] = 4 * e1 + 2, o.uint16[t1 + 3] = 4 * e1 + 2, o.uint16[t1 + 4] = 4 * e1 + 3, o.uint16[t1 + 5] = 4 * e1 + 0;
                }
                return o;
            }(d));
            const v = l.createIndexBuffer(co, !0), x = l.createVertexBuffer(f, e1.collisionCircleLayout.members, !0);
            for (const i of _){
                const r = {
                    u_matrix: i.transform,
                    u_inv_matrix: i.invTransform,
                    u_camera_to_center_distance: (y = h).getCameraToCenterDistance(i.projection),
                    u_viewport_size: [
                        y.width,
                        y.height
                    ]
                };
                m.draw(l, c.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.disabled, r, o.id, x, v, e1.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
            }
            var y;
            x.destroy(), v.destroy();
        }
        const uo = e1.create();
        function _o({ width: t1 , height: i , anchor: o , textOffset: r , textScale: n  }, s) {
            const { horizontalAlign: a , verticalAlign: l  } = e1.getAnchorAlignment(o), c = -(a - .5) * t1, h = -(l - .5) * i, u = e1.evaluateVariableOffset(o, r);
            return new e1.pointGeometry((c / n + u[0]) * s, (h / n + u[1]) * s);
        }
        function po(t1, i, o, r, n, s, a, l, c, h, u) {
            const _ = t1.text.placedSymbolArray, d = t1.text.dynamicLayoutVertexArray, p = t1.icon.dynamicLayoutVertexArray, m = {}, f = t1.getProjection(), g = bt(l, f, s), v = s.elevation, x = f.upVectorScale(l.canonical, s.center.lat, s.worldSize).metersToTile;
            d.clear();
            for(let p = 0; p < _.length; p++){
                const y = _.get(p), { tileAnchorX: b , tileAnchorY: w , numGlyphs: T  } = y, E = t1.allowVerticalPlacement && !y.placedOrientation, C = y.hidden || !y.crossTileID || E ? null : r[y.crossTileID];
                if (C) {
                    let r = 0, _ = 0, p = 0;
                    if (v) {
                        const e1 = v ? v.getAtTileOffset(l, b, w) : 0, [t1, i, o] = f.upVector(l.canonical, b, w);
                        r = e1 * t1 * x, _ = e1 * i * x, p = e1 * o * x;
                    }
                    let [E, M, I, S] = nt(y.projectedAnchorX + r, y.projectedAnchorY + _, y.projectedAnchorZ + p, o ? g : a);
                    const D = st(s.getCameraToCenterDistance(f), S);
                    let L = n.evaluateSizeForFeature(t1.textSizeData, h, y) * D / e1.ONE_EM;
                    o && (L *= t1.tilePixelRatio / c);
                    const A = _o(C, L);
                    o ? ({ x: E , y: M , z: I  } = f.projectTilePoint(b + A.x, w + A.y, l.canonical), [E, M, I] = nt(E + r, M + _, I + p, a)) : (i && A._rotate(-s.angle), E += A.x, M += A.y, I = 0);
                    const z = t1.allowVerticalPlacement && y.placedOrientation === e1.WritingMode.vertical ? Math.PI / 2 : 0;
                    for(let t1 = 0; t1 < T; t1++)e1.addDynamicAttributes(d, E, M, I, z);
                    u && y.associatedIconIndex >= 0 && (m[y.associatedIconIndex] = {
                        x: E,
                        y: M,
                        z: I,
                        angle: z
                    });
                } else mt(T, d);
            }
            if (u) {
                p.clear();
                const i = t1.icon.placedSymbolArray;
                for(let t1 = 0; t1 < i.length; t1++){
                    const o = i.get(t1), { numGlyphs: r  } = o, n = m[t1];
                    if (o.hidden || !n) mt(r, p);
                    else {
                        const { x: t1 , y: i , z: o , angle: s  } = n;
                        for(let n = 0; n < r; n++)e1.addDynamicAttributes(p, t1, i, o, s);
                    }
                }
                t1.icon.dynamicLayoutVertexBuffer.updateData(p);
            }
            t1.text.dynamicLayoutVertexBuffer.updateData(d);
        }
        function mo(e1, t1, i) {
            return i.iconsInText && t1 ? "symbolTextAndIcon" : e1 ? "symbolSDF" : "symbolIcon";
        }
        function fo(t1, i, o, r, n, s, a, l, c, h, u, _) {
            const d = t1.context, p = d.gl, m = t1.transform, f = "map" === l, g = "map" === c, v = f && "point" !== o.layout.get("symbol-placement"), x = f && !g && !v, y = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);
            let b = !1;
            const w = t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly), T = [
                e1.mercatorXfromLng(m.center.lng),
                e1.mercatorYfromLat(m.center.lat)
            ], E = o.layout.get("text-variable-anchor"), C = "globe" === m.projection.name, M = [], I = [
                0,
                -1,
                0
            ];
            let S = I;
            !C && !m.mercatorFromTransition || f || (S = function(t1) {
                const i = t1._camera.getWorldToCamera(t1.worldSize, 1), o = e1.multiply([], i, t1.globeMatrix);
                e1.invert(o, o);
                const r = [
                    0,
                    0,
                    0
                ], n = [
                    0,
                    1,
                    0,
                    0
                ];
                return e1.transformMat4$1(n, n, o), r[0] = n[0], r[1] = n[1], r[2] = n[2], e1.normalize(r, r), r;
            }(m));
            for (const l of r){
                const r = i.getTile(l), c = r.getBucket(o);
                if (!c) continue;
                if ("mercator" === c.projection.name && C) continue;
                const u = n ? c.text : c.icon;
                if (!u || c.fullyClipped || !u.segments.get().length) continue;
                const _ = u.programConfigurations.get(o.id), d = n || c.sdfIcons, w = n ? c.textSizeData : c.iconSizeData, D = g || 0 !== m.pitch, L = e1.evaluateSizeForZoom(w, m.zoom);
                let A, z, P, R, O = [
                    0,
                    0
                ], B = null;
                if (n) {
                    if (z = r.glyphAtlasTexture, P = p.LINEAR, A = r.glyphAtlasTexture.size, c.iconsInText) {
                        O = r.imageAtlasTexture.size, B = r.imageAtlasTexture;
                        const e1 = "composite" === w.kind || "camera" === w.kind;
                        R = D || t1.options.rotating || t1.options.zooming || e1 ? p.LINEAR : p.NEAREST;
                    }
                } else {
                    const e1 = 1 !== o.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
                    z = r.imageAtlasTexture, P = d || t1.options.rotating || t1.options.zooming || e1 || D ? p.LINEAR : p.NEAREST, A = r.imageAtlasTexture.size;
                }
                const k = "globe" === c.projection.name, F = k ? S : I, U = k ? e1.globeToMercatorTransition(m.zoom) : 0, N = bt(l, c.getProjection(), m), G = m.calculatePixelsToTileUnitsMatrix(r), j = it(N, r.tileID.canonical, g, f, m, c.getProjection(), G), Z = t1.terrain && g && v ? e1.invert(e1.create(), j) : uo, V = rt(N, r.tileID.canonical, g, f, m, c.getProjection(), G), W = E && c.hasTextData(), X = "none" !== o.layout.get("icon-text-fit") && W && c.hasIconData();
                if (v) {
                    const e1 = m.elevation, i = e1 ? e1.getAtTileOffsetFunc(l, m.center.lat, m.worldSize, c.getProjection()) : null, o = ot(N, r.tileID.canonical, g, f, m, c.getProjection(), G);
                    lt(c, N, t1, n, o, V, g, h, i, l);
                }
                const q = v || n && E || X, $ = t1.translatePosMatrix(N, r, s, a), H = q ? uo : j, Y = t1.translatePosMatrix(V, r, s, a, !0), K = c.getProjection().createInversionMatrix(m, l.canonical), J = [];
                t1.terrainRenderModeElevated() && g && J.push("PITCH_WITH_MAP_TERRAIN"), k && J.push("PROJECTION_GLOBE_VIEW"), q && J.push("PROJECTED_POS_ON_VIEWPORT");
                const Q = d && 0 !== o.paint.get(n ? "text-halo-width" : "icon-halo-width").constantOr(1);
                let ee;
                ee = d ? c.iconsInText ? no(w.kind, L, x, g, t1, $, H, Y, A, O, l, U, T, K, F, c.getProjection()) : ro(w.kind, L, x, g, t1, $, H, Y, n, A, !0, l, U, T, K, F, c.getProjection()) : oo(w.kind, L, x, g, t1, $, H, Y, n, A, l, U, T, K, F, c.getProjection());
                const te = {
                    program: t1.useProgram(mo(d, n, c), _, J),
                    buffers: u,
                    uniformValues: ee,
                    atlasTexture: z,
                    atlasTextureIcon: B,
                    atlasInterpolation: P,
                    atlasInterpolationIcon: R,
                    isSDF: d,
                    hasHalo: Q,
                    tile: r,
                    labelPlaneMatrixInv: Z
                };
                if (y && c.canOverlap) {
                    b = !0;
                    const t1 = u.segments.get();
                    for (const i of t1)M.push({
                        segments: new e1.SegmentVector([
                            i
                        ]),
                        sortKey: i.sortKey,
                        state: te
                    });
                } else M.push({
                    segments: u.segments,
                    sortKey: 0,
                    state: te
                });
            }
            b && M.sort((e1, t1)=>e1.sortKey - t1.sortKey);
            for (const e1 of M){
                const i = e1.state;
                if (t1.terrain && t1.terrain.setupElevationDraw(i.tile, i.program, {
                    useDepthForOcclusion: !C,
                    labelPlaneMatrixInv: i.labelPlaneMatrixInv
                }), d.activeTexture.set(p.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, p.CLAMP_TO_EDGE), i.atlasTextureIcon && (d.activeTexture.set(p.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, p.CLAMP_TO_EDGE)), i.isSDF) {
                    const r = i.uniformValues;
                    i.hasHalo && (r.u_is_halo = 1, go(i.buffers, e1.segments, o, t1, i.program, w, u, _, r)), r.u_is_halo = 0;
                }
                go(i.buffers, e1.segments, o, t1, i.program, w, u, _, i.uniformValues);
            }
        }
        function go(t1, i, o, r, n, s, a, l, c) {
            const h = r.context, u = [
                t1.dynamicLayoutVertexBuffer,
                t1.opacityVertexBuffer,
                t1.globeExtVertexBuffer
            ];
            n.draw(h, h.gl.TRIANGLES, s, a, l, e1.CullFaceMode.disabled, c, o.id, t1.layoutVertexBuffer, t1.indexBuffer, i, o.paint, r.transform.zoom, t1.programConfigurations.get(o.id), u);
        }
        function vo(t1, i, o, r, n, s, a) {
            const l = t1.context.gl, c = o.paint.get("fill-pattern"), h = c && c.constantOr(1);
            let u, _, d, p, m;
            a ? (_ = h && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u = l.LINES) : (_ = h ? "fillPattern" : "fill", u = l.TRIANGLES);
            for (const f of r){
                const r = i.getTile(f);
                if (h && !r.patternsLoaded()) continue;
                const g = r.getBucket(o);
                if (!g) continue;
                t1.prepareDrawTile();
                const v = g.programConfigurations.get(o.id), x = t1.useProgram(_, v);
                h && (t1.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers());
                const y = c.constantOr(null);
                if (y && r.imageAtlas) {
                    const e1 = r.imageAtlas.patternPositions[y.toString()];
                    e1 && v.setConstantPatternPositions(e1);
                }
                const b = t1.translatePosMatrix(f.projMatrix, r, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));
                if (a) {
                    p = g.indexBuffer2, m = g.segments2;
                    const e1 = t1.terrain && t1.terrain.renderingToTexture ? t1.terrain.drapeBufferSize : [
                        l.drawingBufferWidth,
                        l.drawingBufferHeight
                    ];
                    d = "fillOutlinePattern" === _ && h ? Gi(b, t1, r, e1) : Ni(b, e1);
                } else p = g.indexBuffer, m = g.segments, d = h ? Ui(b, t1, r) : Fi(b);
                t1.prepareDrawProgram(t1.context, x, f.toUnwrapped()), x.draw(t1.context, u, n, t1.stencilModeForClipping(f), s, e1.CullFaceMode.disabled, d, o.id, g.layoutVertexBuffer, p, m, o.paint, t1.transform.zoom, v);
            }
        }
        function xo(t1, i, o, r, n, s, a) {
            const l = t1.context, c = l.gl, h = t1.transform, u = o.paint.get("fill-extrusion-pattern"), _ = u.constantOr(1), d = o.paint.get("fill-extrusion-opacity"), p = [
                o.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                o.paint.get("fill-extrusion-ambient-occlusion-radius")
            ], m = o.layout.get("fill-extrusion-edge-radius"), f = "globe" === h.projection.name ? e1.fillExtrusionHeightLift() : 0, g = "globe" === h.projection.name, v = g ? e1.globeToMercatorTransition(h.zoom) : 0, x = [
                e1.mercatorXfromLng(h.center.lng),
                e1.mercatorYfromLat(h.center.lat)
            ], y = [];
            g && y.push("PROJECTION_GLOBE_VIEW"), p[0] > 0 && y.push("FAUX_AO");
            for (const b of r){
                const r = i.getTile(b), w = r.getBucket(o);
                if (!w || w.projection.name !== h.projection.name) continue;
                const T = w.programConfigurations.get(o.id), E = t1.useProgram(_ ? "fillExtrusionPattern" : "fillExtrusion", T, y);
                if (t1.terrain) {
                    const e1 = t1.terrain;
                    if (t1.style.terrainSetForDrapingOnly()) e1.setupElevationDraw(r, E, {
                        useMeterToDem: !0
                    });
                    else {
                        if (!w.enableTerrain) continue;
                        if (e1.setupElevationDraw(r, E, {
                            useMeterToDem: !0
                        }), yo(l, i, b, w, o, e1), !w.centroidVertexBuffer) {
                            const e1 = E.attributes.a_centroid_pos;
                            void 0 !== e1 && c.vertexAttrib2f(e1, 0, 0);
                        }
                    }
                }
                _ && (t1.context.activeTexture.set(c.TEXTURE0), r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), T.updatePaintBuffers());
                const C = u.constantOr(null);
                if (C && r.imageAtlas) {
                    const e1 = r.imageAtlas.patternPositions[C.toString()];
                    e1 && T.setConstantPatternPositions(e1);
                }
                const M = t1.translatePosMatrix(b.projMatrix, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), I = h.projection.createInversionMatrix(h, b.canonical), S = o.paint.get("fill-extrusion-vertical-gradient"), D = _ ? ki(M, t1, S, d, p, m, b, r, f, v, x, I) : Bi(M, t1, S, d, p, m, b, f, v, x, I);
                t1.prepareDrawProgram(l, E, b.toUnwrapped());
                const L = [];
                t1.terrain && L.push(w.centroidVertexBuffer), g && L.push(w.layoutVertexExtBuffer), E.draw(l, l.gl.TRIANGLES, n, s, a, e1.CullFaceMode.backCCW, D, o.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, o.paint, t1.transform.zoom, T, L);
            }
        }
        function yo(t1, i, o, r, n, s) {
            const a = [
                (t1)=>{
                    let i = t1.canonical.x - 1, o = t1.wrap;
                    return i < 0 && (i = (1 << t1.canonical.z) - 1, o--), new e1.OverscaledTileID(t1.overscaledZ, o, t1.canonical.z, i, t1.canonical.y);
                },
                (t1)=>{
                    let i = t1.canonical.x + 1, o = t1.wrap;
                    return i === 1 << t1.canonical.z && (i = 0, o++), new e1.OverscaledTileID(t1.overscaledZ, o, t1.canonical.z, i, t1.canonical.y);
                },
                (t1)=>new e1.OverscaledTileID(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, (0 === t1.canonical.y ? 1 << t1.canonical.z : t1.canonical.y) - 1),
                (t1)=>new e1.OverscaledTileID(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y === (1 << t1.canonical.z) - 1 ? 0 : t1.canonical.y + 1)
            ], l = (e1)=>{
                const t1 = i.getSource().minzoom, o = (e1)=>{
                    const t1 = i.getTileByID(e1);
                    if (t1 && t1.hasData()) return t1.getBucket(n);
                }, r = [
                    0,
                    -1,
                    1
                ];
                for (const i of r){
                    if (e1.overscaledZ + i < t1) continue;
                    const r = o(e1.calculateScaledKey(e1.overscaledZ + i));
                    if (r) return r;
                }
            }, c = [
                0,
                0,
                0
            ], h = (t1, i)=>(c[0] = Math.min(t1.min.y, i.min.y), c[1] = Math.max(t1.max.y, i.max.y), c[2] = e1.EXTENT - i.min.x > t1.max.x ? i.min.x - e1.EXTENT : t1.max.x, c), u = (t1, i)=>(c[0] = Math.min(t1.min.x, i.min.x), c[1] = Math.max(t1.max.x, i.max.x), c[2] = e1.EXTENT - i.min.y > t1.max.y ? i.min.y - e1.EXTENT : t1.max.y, c), _ = [
                (e1, t1)=>h(e1, t1),
                (e1, t1)=>h(t1, e1),
                (e1, t1)=>u(e1, t1),
                (e1, t1)=>u(t1, e1)
            ], d = new e1.pointGeometry(0, 0);
            let p, m, f;
            const g = (t1, i, r, n, a)=>{
                const l = [
                    [
                        n ? r : t1,
                        n ? t1 : r,
                        0
                    ],
                    [
                        n ? r : i,
                        n ? i : r,
                        0
                    ]
                ], c = a < 0 ? e1.EXTENT + a : a, h = [
                    n ? c : (t1 + i) / 2,
                    n ? (t1 + i) / 2 : c,
                    0
                ];
                return 0 === r && a < 0 || 0 !== r && a > 0 ? s.getForTilePoints(f, [
                    h
                ], !0, m) : l.push(h), s.getForTilePoints(o, l, !0, p), Math.max(l[0][2], l[1][2], h[2]) / s.exaggeration();
            };
            for(let t1 = 0; t1 < 4; t1++){
                const i = (t1 < 2 ? 1 : 5) - t1, n = r.borders[t1];
                if (0 === n.length) continue;
                const c = f = a[t1](o), h = l(c);
                if (!(h && h instanceof e1.FillExtrusionBucket && h.enableTerrain)) continue;
                if (r.borderDoneWithNeighborZ[t1] === h.canonical.z && h.borderDoneWithNeighborZ[i] === r.canonical.z) continue;
                if (m = s.findDEMTileFor(c), !m || !m.dem) continue;
                if (!p) {
                    const e1 = s.findDEMTileFor(o);
                    if (!e1 || !e1.dem) return;
                    p = e1;
                }
                const u = h.borders[i];
                let v = 0;
                const x = h.borderDoneWithNeighborZ[i] !== r.canonical.z;
                if (r.canonical.z === h.canonical.z) {
                    for(let o = 0; o < n.length; o++){
                        const s = r.featuresOnBorder[n[o]], a = s.borders[t1];
                        let l;
                        for(; v < u.length && (l = h.featuresOnBorder[u[v]], !(l.borders[i][1] > a[0] + 3));)x && h.encodeCentroid(void 0, l, !1), v++;
                        if (l && v < u.length) {
                            const o = v;
                            let n = 0;
                            for(; !(l.borders[i][0] > a[1] - 3) && (n++, ++v !== u.length);)l = h.featuresOnBorder[u[v]];
                            if (l = h.featuresOnBorder[u[o]], s.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== n) {
                                1 !== n && (v = o), r.encodeCentroid(void 0, s, !1), x && h.encodeCentroid(void 0, l, !1);
                                continue;
                            }
                            const c = _[t1](s, l), p = t1 % 2 ? e1.EXTENT - 1 : 0;
                            d.x = g(c[0], Math.min(e1.EXTENT - 1, c[1]), p, t1 < 2, c[2]), d.y = 0, r.encodeCentroid(d, s, !1), x && h.encodeCentroid(d, l, !1);
                        } else r.encodeCentroid(void 0, s, !1);
                    }
                    r.borderDoneWithNeighborZ[t1] = h.canonical.z, r.needsCentroidUpdate = !0, x && (h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0);
                } else {
                    for (const e1 of n)r.encodeCentroid(void 0, r.featuresOnBorder[e1], !1);
                    if (x) {
                        for (const e1 of u)h.encodeCentroid(void 0, h.featuresOnBorder[e1], !1);
                        h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0;
                    }
                    r.borderDoneWithNeighborZ[t1] = h.canonical.z, r.needsCentroidUpdate = !0;
                }
            }
            (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t1);
        }
        const bo = new e1.Color(1, 0, 0, 1), wo = new e1.Color(0, 1, 0, 1), To = new e1.Color(0, 0, 1, 1), Eo = new e1.Color(1, 0, 1, 1), Co = new e1.Color(0, 1, 1, 1);
        function Mo(t1, i, o) {
            const r = t1.context, n = t1.transform, s = r.gl, a = "globe" === n.projection.name, l = a ? [
                "PROJECTION_GLOBE_VIEW"
            ] : null;
            let c = o.projMatrix;
            if (a && e1.globeToMercatorTransition(n.zoom) > 0) {
                const t1 = e1.transitionTileAABBinECEF(o.canonical, n), i = e1.globeDenormalizeECEF(t1);
                c = e1.multiply(new Float32Array(16), n.globeMatrix, i), e1.multiply(c, n.projMatrix, c);
            }
            const h = t1.useProgram("debug", null, l), u = i.getTileByID(o.key);
            t1.terrain && t1.terrain.setupElevationDraw(u, h);
            const _ = e1.DepthMode.disabled, d = e1.StencilMode.disabled, p = t1.colorModeForRenderPass(), m = "$debug";
            r.activeTexture.set(s.TEXTURE0), t1.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), a ? u._makeGlobeTileDebugBuffers(t1.context, n) : u._makeDebugTileBoundsBuffers(t1.context, n.projection);
            const f = u._tileDebugBuffer || t1.debugBuffer, g = u._tileDebugIndexBuffer || t1.debugIndexBuffer, v = u._tileDebugSegments || t1.debugSegments;
            h.draw(r, s.LINE_STRIP, _, d, p, e1.CullFaceMode.disabled, Xi(c, e1.Color.red), m, f, g, v, null, null, null, [
                u._globeTileDebugBorderBuffer
            ]);
            const x = u.latestRawTileData, y = Math.floor((x && x.byteLength || 0) / 1024), b = i.getTile(o).tileSize, w = 512 / Math.min(b, 512) * (o.overscaledZ / n.zoom) * .5;
            let T = o.canonical.toString();
            o.overscaledZ !== o.canonical.z && (T += ` => ${o.overscaledZ}`), T += ` ${y}kb`, function(e1, t1) {
                e1.initDebugOverlayCanvas();
                const i = e1.debugOverlayCanvas, o = e1.context.gl, r = e1.debugOverlayCanvas.getContext("2d");
                r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(t1, 5, 5), r.strokeText(t1, 5, 5), e1.debugOverlayTexture.update(i), e1.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
            }(t1, T);
            const E = u._tileDebugTextBuffer || t1.debugBuffer, C = u._tileDebugTextIndexBuffer || t1.quadTriangleIndexBuffer, M = u._tileDebugTextSegments || t1.debugSegments;
            h.draw(r, s.TRIANGLES, _, d, e1.ColorMode.alphaBlended, e1.CullFaceMode.disabled, Xi(c, e1.Color.transparent, w), m, E, C, M, null, null, null, [
                u._globeTileDebugTextBuffer
            ]);
        }
        function Io(e1, t1, i, o) {
            Do(e1, 0, t1 + i / 2, e1.transform.width, i, o);
        }
        function So(e1, t1, i, o) {
            Do(e1, t1 - i / 2, 0, i, e1.transform.height, o);
        }
        function Do(t1, i, o, r, n, s) {
            const a = t1.context, l = a.gl;
            l.enable(l.SCISSOR_TEST), l.scissor(i * e1.exported.devicePixelRatio, o * e1.exported.devicePixelRatio, r * e1.exported.devicePixelRatio, n * e1.exported.devicePixelRatio), a.clear({
                color: s
            }), l.disable(l.SCISSOR_TEST);
        }
        const Lo = e1.createLayout([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), { members: Ao  } = Lo;
        function zo(e1, t1, i, o) {
            e1.emplaceBack(t1, i, o);
        }
        class Po {
            constructor(t1){
                this.vertexArray = new e1.StructArrayLayout3f12, this.indices = new e1.StructArrayLayout3ui6, zo(this.vertexArray, -1, -1, 1), zo(this.vertexArray, 1, -1, 1), zo(this.vertexArray, -1, 1, 1), zo(this.vertexArray, 1, 1, 1), zo(this.vertexArray, -1, -1, -1), zo(this.vertexArray, 1, -1, -1), zo(this.vertexArray, -1, 1, -1), zo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, Ao), this.indexBuffer = t1.createIndexBuffer(this.indices), this.segment = e1.SegmentVector.simpleSegment(0, 0, 36, 12);
            }
        }
        function Ro(t1, i, o, r, n, s) {
            const a = t1.gl, l = i.paint.get("sky-atmosphere-color"), c = i.paint.get("sky-atmosphere-halo-color"), h = i.paint.get("sky-atmosphere-sun-intensity"), u = ((e1, t1, i, o, r)=>({
                    u_matrix_3f: e1,
                    u_sun_direction: t1,
                    u_sun_intensity: i,
                    u_color_tint_r: [
                        o.r,
                        o.g,
                        o.b,
                        o.a
                    ],
                    u_color_tint_m: [
                        r.r,
                        r.g,
                        r.b,
                        r.a
                    ],
                    u_luminance: 5e-5
                }))(e1.fromMat4(e1.create$1(), r), n, h, l, c);
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, i.skyboxTexture, 0), o.draw(t1, a.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, e1.ColorMode.unblended, e1.CullFaceMode.frontCW, u, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }
        const Oo = e1.createLayout([
            {
                type: "Float32",
                name: "a_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]);
        class Bo {
            constructor(t1){
                const i = new e1.StructArrayLayout5f20;
                i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);
                const o = new e1.StructArrayLayout3ui6;
                o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t1.createVertexBuffer(i, Oo.members), this.indexBuffer = t1.createIndexBuffer(o), this.segments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
        }
        const ko = {
            symbol: function(t1, i, o, r, n) {
                if ("translucent" !== t1.renderPass) return;
                const s = e1.StencilMode.disabled, a = t1.colorModeForRenderPass();
                o.layout.get("text-variable-anchor") && function(t1, i, o, r, n, s, a) {
                    const l = i.transform, c = "map" === n, h = "map" === s;
                    for (const i of t1){
                        const t1 = r.getTile(i), n = t1.getBucket(o);
                        if (!n || !n.text || !n.text.segments.get().length) continue;
                        const s = e1.evaluateSizeForZoom(n.textSizeData, l.zoom), u = bt(i, n.getProjection(), l), _ = l.calculatePixelsToTileUnitsMatrix(t1), d = it(u, t1.tileID.canonical, h, c, l, n.getProjection(), _), p = "none" !== o.layout.get("icon-text-fit") && n.hasIconData();
                        if (s) {
                            const o = Math.pow(2, l.zoom - t1.tileID.overscaledZ);
                            po(n, c, h, a, e1.symbolSize, l, d, i, o, s, p);
                        }
                    }
                }(r, t1, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), n), 0 !== o.paint.get("icon-opacity").constantOr(1) && fo(t1, i, o, r, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), s, a), 0 !== o.paint.get("text-opacity").constantOr(1) && fo(t1, i, o, r, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), s, a), i.map.showCollisionBoxes && (ho(t1, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), ho(t1, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(t1, i, o, r) {
                if ("translucent" !== t1.renderPass) return;
                const n = o.paint.get("circle-opacity"), s = o.paint.get("circle-stroke-width"), a = o.paint.get("circle-stroke-opacity"), l = void 0 !== o.layout.get("circle-sort-key").constantOr(1);
                if (0 === n.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1))) return;
                const c = t1.context, h = c.gl, u = t1.transform, _ = t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly), d = e1.StencilMode.disabled, p = t1.colorModeForRenderPass(), m = "globe" === u.projection.name, f = [
                    e1.mercatorXfromLng(u.center.lng),
                    e1.mercatorYfromLat(u.center.lat)
                ], g = [];
                for(let n = 0; n < r.length; n++){
                    const s = r[n], a = i.getTile(s), c = a.getBucket(o);
                    if (!c || c.projection.name !== u.projection.name) continue;
                    const h = c.programConfigurations.get(o.id), _ = Vi(o);
                    m && _.push("PROJECTION_GLOBE_VIEW");
                    const d = t1.useProgram("circle", h, _), p = c.layoutVertexBuffer, v = c.globeExtVertexBuffer, x = c.indexBuffer, y = u.projection.createInversionMatrix(u, s.canonical), b = {
                        programConfiguration: h,
                        program: d,
                        layoutVertexBuffer: p,
                        globeExtVertexBuffer: v,
                        indexBuffer: x,
                        uniformValues: Zi(t1, s, a, y, f, o),
                        tile: a
                    };
                    if (l) {
                        const t1 = c.segments.get();
                        for (const i of t1)g.push({
                            segments: new e1.SegmentVector([
                                i
                            ]),
                            sortKey: i.sortKey,
                            state: b
                        });
                    } else g.push({
                        segments: c.segments,
                        sortKey: 0,
                        state: b
                    });
                }
                l && g.sort((e1, t1)=>e1.sortKey - t1.sortKey);
                const v = {
                    useDepthForOcclusion: !m
                };
                for (const i of g){
                    const { programConfiguration: r , program: n , layoutVertexBuffer: s , globeExtVertexBuffer: a , indexBuffer: l , uniformValues: m , tile: f  } = i.state, g = i.segments;
                    t1.terrain && t1.terrain.setupElevationDraw(f, n, v), t1.prepareDrawProgram(c, n, f.tileID.toUnwrapped()), n.draw(c, h.TRIANGLES, _, d, p, e1.CullFaceMode.disabled, m, o.id, s, l, g, o.paint, u.zoom, r, [
                        a
                    ]);
                }
            },
            heatmap: function(t1, i, o, r) {
                if (0 !== o.paint.get("heatmap-opacity")) {
                    if ("offscreen" === t1.renderPass) {
                        const n = t1.context, s = n.gl, a = e1.StencilMode.disabled, l = new e1.ColorMode([
                            s.ONE,
                            s.ONE
                        ], e1.Color.transparent, [
                            !0,
                            !0,
                            !0,
                            !0
                        ]);
                        !function(e1, t1, i, o) {
                            const r = e1.gl, n = t1.width * o, s = t1.height * o;
                            e1.activeTexture.set(r.TEXTURE1), e1.viewport.set([
                                0,
                                0,
                                n,
                                s
                            ]);
                            let a = i.heatmapFbo;
                            if (!a || a && (a.width !== n || a.height !== s)) {
                                a && a.destroy();
                                const t1 = r.createTexture();
                                r.bindTexture(r.TEXTURE_2D, t1), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), a = i.heatmapFbo = e1.createFramebuffer(n, s, !1), function(e1, t1, i, o, r, n) {
                                    const s = e1.gl;
                                    s.texImage2D(s.TEXTURE_2D, 0, e1.isWebGL2 && e1.extRenderToTextureHalfFloat ? s.RGBA16F : s.RGBA, r, n, 0, s.RGBA, e1.extRenderToTextureHalfFloat ? e1.isWebGL2 ? s.HALF_FLOAT : e1.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
                                }(e1, 0, t1, a, n, s);
                            } else r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), e1.bindFramebuffer.set(a.framebuffer);
                        }(n, t1, o, "globe" === t1.transform.projection.name ? .5 : .25), n.clear({
                            color: e1.Color.transparent
                        });
                        const c = t1.transform, h = "globe" === c.projection.name, u = h ? [
                            "PROJECTION_GLOBE_VIEW"
                        ] : null, _ = h ? e1.CullFaceMode.frontCCW : e1.CullFaceMode.disabled, d = [
                            e1.mercatorXfromLng(c.center.lng),
                            e1.mercatorYfromLat(c.center.lat)
                        ];
                        for(let p = 0; p < r.length; p++){
                            const m = r[p];
                            if (i.hasRenderableParent(m)) continue;
                            const f = i.getTile(m), g = f.getBucket(o);
                            if (!g || g.projection.name !== c.projection.name) continue;
                            const v = g.programConfigurations.get(o.id), x = t1.useProgram("heatmap", v, u), { zoom: y  } = t1.transform;
                            t1.terrain && t1.terrain.setupElevationDraw(f, x), t1.prepareDrawProgram(n, x, m.toUnwrapped());
                            const b = c.projection.createInversionMatrix(c, m.canonical);
                            x.draw(n, s.TRIANGLES, e1.DepthMode.disabled, a, l, _, $i(t1, m, f, b, d, y, o.paint.get("heatmap-intensity")), o.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, o.paint, t1.transform.zoom, v, h ? [
                                g.globeExtVertexBuffer
                            ] : null);
                        }
                        n.viewport.set([
                            0,
                            0,
                            t1.width,
                            t1.height
                        ]);
                    } else "translucent" === t1.renderPass && (t1.context.setColorMode(t1.colorModeForRenderPass()), function(t1, i) {
                        const o = t1.context, r = o.gl, n = i.heatmapFbo;
                        if (!n) return;
                        o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, n.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);
                        let s = i.colorRampTexture;
                        s || (s = i.colorRampTexture = new e1.Texture(o, i.colorRamp, r.RGBA)), s.bind(r.LINEAR, r.CLAMP_TO_EDGE), t1.useProgram("heatmapTexture").draw(o, r.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.disabled, ((e1, t1, i, o)=>({
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: t1.paint.get("heatmap-opacity")
                            }))(0, i), i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments, i.paint, t1.transform.zoom);
                    }(t1, o));
                }
            },
            line: function(t1, i, o, r) {
                if ("translucent" !== t1.renderPass) return;
                const n = o.paint.get("line-opacity"), s = o.paint.get("line-width");
                if (0 === n.constantOr(1) || 0 === s.constantOr(1)) return;
                const a = t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly), l = t1.colorModeForRenderPass(), c = t1.terrain && t1.terrain.renderingToTexture ? 1 : e1.exported.devicePixelRatio, h = o.paint.get("line-dasharray"), u = h.constantOr(1), _ = o.layout.get("line-cap"), d = o.paint.get("line-pattern"), p = d.constantOr(1), m = o.paint.get("line-gradient"), f = p ? "linePattern" : "line", g = t1.context, v = g.gl, x = ((e1)=>{
                    const t1 = [];
                    Qi(e1) && t1.push("RENDER_LINE_DASH"), e1.paint.get("line-gradient") && t1.push("RENDER_LINE_GRADIENT");
                    const i = e1.paint.get("line-trim-offset");
                    0 === i[0] && 0 === i[1] || t1.push("RENDER_LINE_TRIM_OFFSET");
                    const o = e1.paint.get("line-pattern").constantOr(1), r = 1 !== e1.paint.get("line-opacity").constantOr(1);
                    return !o && r && t1.push("RENDER_LINE_ALPHA_DISCARD"), t1;
                })(o);
                let y = x.includes("RENDER_LINE_ALPHA_DISCARD");
                t1.terrain && t1.terrain.clipOrMaskOverlapStencilType() && (y = !1);
                for (const n of r){
                    const r = i.getTile(n);
                    if (p && !r.patternsLoaded()) continue;
                    const s = r.getBucket(o);
                    if (!s) continue;
                    t1.prepareDrawTile();
                    const b = s.programConfigurations.get(o.id), w = t1.useProgram(f, b, x), T = d.constantOr(null);
                    if (T && r.imageAtlas) {
                        const e1 = r.imageAtlas.patternPositions[T.toString()];
                        e1 && b.setConstantPatternPositions(e1);
                    }
                    const E = h.constantOr(null), C = _.constantOr(null);
                    if (!p && E && C && r.lineAtlas) {
                        const e1 = r.lineAtlas.getDash(E, C);
                        e1 && b.setConstantPatternPositions(e1);
                    }
                    let [M, I] = o.paint.get("line-trim-offset");
                    if ("round" === C || "square" === C) {
                        const e1 = 1;
                        M !== I && (0 === M && (M -= e1), 1 === I && (I += e1));
                    }
                    const S = t1.terrain ? n.projMatrix : null, D = p ? Yi(t1, r, o, S, c) : Hi(t1, r, o, S, s.lineClipsArray.length, c, [
                        M,
                        I
                    ]);
                    if (m) {
                        const r = s.gradients[o.id];
                        let a = r.texture;
                        if (o.gradientVersion !== r.version) {
                            let l = 256;
                            if (o.stepInterpolant) {
                                const o = i.getSource().maxzoom, r = n.canonical.z === o ? Math.ceil(1 << t1.transform.maxZoom - n.canonical.z) : 1;
                                l = e1.clamp(e1.nextPowerOfTwo(s.maxLineLength / e1.EXTENT * 1024 * r), 256, g.maxTextureSize);
                            }
                            r.gradient = e1.renderColorRamp({
                                expression: o.gradientExpression(),
                                evaluationKey: "lineProgress",
                                resolution: l,
                                image: r.gradient || void 0,
                                clips: s.lineClipsArray
                            }), r.texture ? r.texture.update(r.gradient) : r.texture = new e1.Texture(g, r.gradient, v.RGBA), r.version = o.gradientVersion, a = r.texture;
                        }
                        g.activeTexture.set(v.TEXTURE1), a.bind(o.stepInterpolant ? v.NEAREST : v.LINEAR, v.CLAMP_TO_EDGE);
                    }
                    u && (g.activeTexture.set(v.TEXTURE0), r.lineAtlasTexture.bind(v.LINEAR, v.REPEAT), b.updatePaintBuffers()), p && (g.activeTexture.set(v.TEXTURE0), r.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE), b.updatePaintBuffers()), t1.prepareDrawProgram(g, w, n.toUnwrapped());
                    const L = (i)=>{
                        w.draw(g, v.TRIANGLES, a, i, l, e1.CullFaceMode.disabled, D, o.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, o.paint, t1.transform.zoom, b, [
                            s.layoutVertexBuffer2
                        ]);
                    };
                    if (y) {
                        const i = t1.stencilModeForClipping(n).ref;
                        0 === i && t1.terrain && g.clear({
                            stencil: 0
                        });
                        const o = {
                            func: v.EQUAL,
                            mask: 255
                        };
                        D.u_alpha_discard_threshold = .8, L(new e1.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.INVERT)), D.u_alpha_discard_threshold = 0, L(new e1.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.KEEP));
                    } else L(t1.stencilModeForClipping(n));
                }
                y && (t1.resetStencilClippingMasks(), t1.terrain && g.clear({
                    stencil: 0
                }));
            },
            fill: function(t1, i, o, r) {
                const n = o.paint.get("fill-color"), s = o.paint.get("fill-opacity");
                if (0 === s.constantOr(1)) return;
                const a = t1.colorModeForRenderPass(), l = o.paint.get("fill-pattern"), c = t1.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === n.constantOr(e1.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent";
                if (t1.renderPass === c) {
                    const n = t1.depthModeForSublayer(1, "opaque" === t1.renderPass ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly);
                    vo(t1, i, o, r, n, a, !1);
                }
                if ("translucent" === t1.renderPass && o.paint.get("fill-antialias")) {
                    const n = t1.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, e1.DepthMode.ReadOnly);
                    vo(t1, i, o, r, n, a, !0);
                }
            },
            "fill-extrusion": function(t1, i, o, r) {
                const n = o.paint.get("fill-extrusion-opacity");
                if (0 !== n && "translucent" === t1.renderPass) {
                    const s = new e1.DepthMode(t1.context.gl.LEQUAL, e1.DepthMode.ReadWrite, t1.depthRangeFor3D);
                    if (1 !== n || o.paint.get("fill-extrusion-pattern").constantOr(1)) xo(t1, i, o, r, s, e1.StencilMode.disabled, e1.ColorMode.disabled), xo(t1, i, o, r, s, t1.stencilModeFor3D(), t1.colorModeForRenderPass()), t1.resetStencilClippingMasks();
                    else {
                        const n = t1.colorModeForRenderPass();
                        xo(t1, i, o, r, s, e1.StencilMode.disabled, n);
                    }
                }
            },
            hillshade: function(t1, i, o, r) {
                if ("offscreen" !== t1.renderPass && "translucent" !== t1.renderPass) return;
                const n = t1.context, s = t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly), a = t1.colorModeForRenderPass(), l = t1.terrain && t1.terrain.renderingToTexture, [c, h] = "translucent" !== t1.renderPass || l ? [
                    {},
                    r
                ] : t1.stencilConfigForOverlap(r);
                for (const r of h){
                    const n = i.getTile(r);
                    if (n.needsHillshadePrepare && "offscreen" === t1.renderPass) vi(t1, n, o, s, e1.StencilMode.disabled, a);
                    else if ("translucent" === t1.renderPass) {
                        const e1 = l && t1.terrain ? t1.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];
                        fi(t1, r, n, o, s, e1, a);
                    }
                }
                n.viewport.set([
                    0,
                    0,
                    t1.width,
                    t1.height
                ]), t1.resetStencilClippingMasks();
            },
            raster: function(t1, i, o, r, n, s) {
                if ("translucent" !== t1.renderPass) return;
                if (0 === o.paint.get("raster-opacity")) return;
                if (!r.length) return;
                const a = t1.context, l = a.gl, c = i.getSource(), h = t1.useProgram("raster"), u = t1.colorModeForRenderPass(), _ = t1.terrain && t1.terrain.renderingToTexture, [d, p] = c instanceof Ae || _ ? [
                    {},
                    r
                ] : t1.stencilConfigForOverlap(r), m = p[p.length - 1].overscaledZ, f = !t1.options.moving;
                for (const r of p){
                    const n = _ ? e1.DepthMode.disabled : t1.depthModeForSublayer(r.overscaledZ - m, 1 === o.paint.get("raster-opacity") ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly, l.LESS), p = r.toUnwrapped(), g = i.getTile(r);
                    if (_ && (!g || !g.hasData())) continue;
                    const v = _ ? r.projMatrix : t1.transform.calculateProjMatrix(p, f), x = t1.terrain && _ ? t1.terrain.stencilModeForRTTOverlap(r) : d[r.overscaledZ], y = s ? 0 : o.paint.get("raster-fade-duration");
                    g.registerFadeDuration(y);
                    const b = i.findLoadedParent(r, 0), w = Si(g, b, i, t1.transform, y);
                    let T, E;
                    t1.terrain && t1.terrain.prepareDrawTile();
                    const C = "nearest" === o.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;
                    a.activeTexture.set(l.TEXTURE0), g.texture.bind(C, l.CLAMP_TO_EDGE), a.activeTexture.set(l.TEXTURE1), b ? (b.texture.bind(C, l.CLAMP_TO_EDGE), T = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ), E = [
                        g.tileID.canonical.x * T % 1,
                        g.tileID.canonical.y * T % 1
                    ]) : g.texture.bind(C, l.CLAMP_TO_EDGE);
                    const M = eo(v, E || [
                        0,
                        0
                    ], T || 1, w, o, c instanceof Ae ? c.perspectiveTransform : [
                        0,
                        0
                    ]);
                    if (t1.prepareDrawProgram(a, h, p), c instanceof Ae) c.boundsBuffer && c.boundsSegments && h.draw(a, l.TRIANGLES, n, e1.StencilMode.disabled, u, e1.CullFaceMode.disabled, M, o.id, c.boundsBuffer, t1.quadTriangleIndexBuffer, c.boundsSegments);
                    else {
                        const { tileBoundsBuffer: i , tileBoundsIndexBuffer: r , tileBoundsSegments: s  } = t1.getTileBoundsBuffers(g);
                        h.draw(a, l.TRIANGLES, n, x, u, e1.CullFaceMode.disabled, M, o.id, i, r, s);
                    }
                }
                t1.resetStencilClippingMasks();
            },
            background: function(t1, i, o, r) {
                const n = o.paint.get("background-color"), s = o.paint.get("background-opacity");
                if (0 === s) return;
                const a = t1.context, l = a.gl, c = t1.transform, h = c.tileSize, u = o.paint.get("background-pattern");
                if (t1.isPatternMissing(u)) return;
                const _ = !u && 1 === n.a && 1 === s && t1.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t1.renderPass !== _) return;
                const d = e1.StencilMode.disabled, p = t1.depthModeForSublayer(0, "opaque" === _ ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly), m = t1.colorModeForRenderPass(), f = t1.useProgram(u ? "backgroundPattern" : "background");
                let g, v = r;
                v || (g = t1.getBackgroundTiles(), v = Object.values(g).map((e1)=>e1.tileID)), u && (a.activeTexture.set(l.TEXTURE0), t1.imageManager.bind(t1.context));
                for (const _ of v){
                    const v = _.toUnwrapped(), x = r ? _.projMatrix : t1.transform.calculateProjMatrix(v);
                    t1.prepareDrawTile();
                    const y = i ? i.getTile(_) : g ? g[_.key] : new e1.Tile(_, h, c.zoom, t1), b = u ? ao(x, s, t1, u, {
                        tileID: _,
                        tileSize: h
                    }) : so(x, s, n);
                    t1.prepareDrawProgram(a, f, v);
                    const { tileBoundsBuffer: w , tileBoundsIndexBuffer: T , tileBoundsSegments: E  } = t1.getTileBoundsBuffers(y);
                    f.draw(a, l.TRIANGLES, p, d, m, e1.CullFaceMode.disabled, b, o.id, w, T, E);
                }
            },
            sky: function(t1, i, o) {
                const r = t1.transform, n = "mercator" === r.projection.name || "globe" === r.projection.name ? 1 : e1.smoothstep(7, 8, r.zoom), s = o.paint.get("sky-opacity") * n;
                if (0 === s) return;
                const a = t1.context, l = o.paint.get("sky-type"), c = new e1.DepthMode(a.gl.LEQUAL, e1.DepthMode.ReadOnly, [
                    0,
                    1
                ]), h = t1.frameCounter / 1e3 % 1;
                "atmosphere" === l ? "offscreen" === t1.renderPass ? o.needsSkyboxCapture(t1) && (function(t1, i, o, r) {
                    const n = t1.context, s = n.gl;
                    let a = i.skyboxFbo;
                    if (!a) {
                        a = i.skyboxFbo = n.createFramebuffer(32, 32, !1), i.skyboxGeometry = new Po(n), i.skyboxTexture = n.gl.createTexture(), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);
                        for(let e1 = 0; e1 < 6; ++e1)s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + e1, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null);
                    }
                    n.bindFramebuffer.set(a.framebuffer), n.viewport.set([
                        0,
                        0,
                        32,
                        32
                    ]);
                    const l = i.getCenter(t1, !0), c = t1.useProgram("skyboxCapture"), h = new Float64Array(16);
                    e1.identity(h), e1.rotateY(h, h, .5 * -Math.PI), Ro(n, i, c, h, l, 0), e1.identity(h), e1.rotateY(h, h, .5 * Math.PI), Ro(n, i, c, h, l, 1), e1.identity(h), e1.rotateX(h, h, .5 * -Math.PI), Ro(n, i, c, h, l, 2), e1.identity(h), e1.rotateX(h, h, .5 * Math.PI), Ro(n, i, c, h, l, 3), e1.identity(h), Ro(n, i, c, h, l, 4), e1.identity(h), e1.rotateY(h, h, Math.PI), Ro(n, i, c, h, l, 5), n.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                }(t1, o), o.markSkyboxValid(t1)) : "sky" === t1.renderPass && function(t1, i, o, r, n) {
                    const s = t1.context, a = s.gl, l = t1.transform, c = t1.useProgram("skybox");
                    s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture);
                    const h = ((e1, t1, i, o, r)=>({
                            u_matrix: e1,
                            u_sun_direction: t1,
                            u_cubemap: 0,
                            u_opacity: o,
                            u_temporal_offset: r
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), 0, r, n);
                    t1.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.backCW, h, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, c, s, h) : "gradient" === l && "sky" === t1.renderPass && function(t1, i, o, r, n) {
                    const s = t1.context, a = s.gl, l = t1.transform, c = t1.useProgram("skyboxGradient");
                    i.skyboxGeometry || (i.skyboxGeometry = new Po(s)), s.activeTexture.set(a.TEXTURE0);
                    let h = i.colorRampTexture;
                    h || (h = i.colorRampTexture = new e1.Texture(s, i.colorRamp, a.RGBA)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                    const u = ((t1, i, o, r, n)=>({
                            u_matrix: t1,
                            u_color_ramp: 0,
                            u_center_direction: i,
                            u_radius: e1.degToRad(o),
                            u_opacity: r,
                            u_temporal_offset: n
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), i.paint.get("sky-gradient-radius"), r, n);
                    t1.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e1.StencilMode.disabled, t1.colorModeForRenderPass(), e1.CullFaceMode.backCW, u, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, c, s, h);
            },
            debug: function(e1, t1, i) {
                for(let o = 0; o < i.length; o++)Mo(e1, t1, i[o]);
            },
            custom: function(t1, i, o, r) {
                const n = t1.context, s = o.implementation;
                if (!t1.transform.projection.unsupportedLayers || !t1.transform.projection.unsupportedLayers.includes("custom") || t1.terrain && (t1.terrain.renderingToTexture || "offscreen" === t1.renderPass) && o.isLayerDraped()) {
                    if ("offscreen" === t1.renderPass) {
                        const i = s.prerender;
                        if (i) {
                            if (t1.setCustomLayerDefaults(), n.setColorMode(t1.colorModeForRenderPass()), "globe" === t1.transform.projection.name) {
                                const o = t1.transform.pointMerc;
                                i.call(s, n.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e1.globeToMercatorTransition(t1.transform.zoom), [
                                    o.x,
                                    o.y
                                ], t1.transform.pixelsPerMeterRatio);
                            } else i.call(s, n.gl, t1.transform.customLayerMatrix());
                            n.setDirty(), t1.setBaseState();
                        }
                    } else if ("translucent" === t1.renderPass) {
                        if (t1.terrain && t1.terrain.renderingToTexture) {
                            const i = s.renderToTile;
                            if (i) {
                                const o = r[0].canonical, a = new e1.MercatorCoordinate(o.x + r[0].wrap * (1 << o.z), o.y, o.z);
                                n.setDepthMode(e1.DepthMode.disabled), n.setStencilMode(e1.StencilMode.disabled), n.setColorMode(t1.colorModeForRenderPass()), t1.setCustomLayerDefaults(), i.call(s, n.gl, a), n.setDirty(), t1.setBaseState();
                            }
                            return;
                        }
                        t1.setCustomLayerDefaults(), n.setColorMode(t1.colorModeForRenderPass()), n.setStencilMode(e1.StencilMode.disabled);
                        const i = "3d" === s.renderingMode ? new e1.DepthMode(t1.context.gl.LEQUAL, e1.DepthMode.ReadWrite, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, e1.DepthMode.ReadOnly);
                        if (n.setDepthMode(i), "globe" === t1.transform.projection.name) {
                            const i = t1.transform.pointMerc;
                            s.render(n.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e1.globeToMercatorTransition(t1.transform.zoom), [
                                i.x,
                                i.y
                            ], t1.transform.pixelsPerMeterRatio);
                        } else s.render(n.gl, t1.transform.customLayerMatrix());
                        n.setDirty(), t1.setBaseState(), n.bindFramebuffer.set(null);
                    }
                } else e1.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
            }
        };
        class Fo {
            constructor(t1, i, o = !1){
                this.context = new Me(t1, o), this.transform = i, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e1.SourceCache.maxUnderzooming + e1.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new qt, this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
            }
            updateTerrain(e1, t1) {
                const i = !!e1 && !!e1.terrain && this.transform.projection.supportsTerrain;
                if (!(i || this._terrain && this._terrain.enabled)) return;
                this._terrain || (this._terrain = new zi(this, e1));
                const o = this._terrain;
                this.transform.elevation = i ? o : null, o.update(e1, this.transform, t1);
            }
            _updateFog(e1) {
                const t1 = e1.fog;
                if (!t1 || "globe" === this.transform.projection.name || t1.getOpacity(this.transform.pitch) < 1 || t1.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
                const [i, o] = t1.getFovAdjustedRange(this.transform._fov);
                if (i > o) return void (this.transform.fogCullDistSq = null);
                const r = i + .78 * (o - i);
                this.transform.fogCullDistSq = r * r;
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
            }
            resize(t1, i) {
                if (this.width = t1 * e1.exported.devicePixelRatio, this.height = i * e1.exported.devicePixelRatio, this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.style) for (const e1 of this.style.order)this.style._layers[e1].resize();
            }
            setup() {
                const t1 = this.context, i = new e1.StructArrayLayout2i4;
                i.emplaceBack(0, 0), i.emplaceBack(e1.EXTENT, 0), i.emplaceBack(0, e1.EXTENT), i.emplaceBack(e1.EXTENT, e1.EXTENT), this.tileExtentBuffer = t1.createVertexBuffer(i, e1.posAttributes.members), this.tileExtentSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const o = new e1.StructArrayLayout2i4;
                o.emplaceBack(0, 0), o.emplaceBack(e1.EXTENT, 0), o.emplaceBack(0, e1.EXTENT), o.emplaceBack(e1.EXTENT, e1.EXTENT), this.debugBuffer = t1.createVertexBuffer(o, e1.posAttributes.members), this.debugSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 5);
                const r = new e1.StructArrayLayout2i4;
                r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t1.createVertexBuffer(r, e1.posAttributes.members), this.viewportSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const n = new e1.StructArrayLayout4i8;
                n.emplaceBack(0, 0, 0, 0), n.emplaceBack(e1.EXTENT, 0, e1.EXTENT, 0), n.emplaceBack(0, e1.EXTENT, 0, e1.EXTENT), n.emplaceBack(e1.EXTENT, e1.EXTENT, e1.EXTENT, e1.EXTENT), this.mercatorBoundsBuffer = t1.createVertexBuffer(n, e1.boundsAttributes.members), this.mercatorBoundsSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const s = new e1.StructArrayLayout3ui6;
                s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t1.createIndexBuffer(s);
                const a = new e1.StructArrayLayout1ui2;
                for (const e1 of [
                    0,
                    1,
                    3,
                    2,
                    0
                ])a.emplaceBack(e1);
                this.debugIndexBuffer = t1.createIndexBuffer(a), this.emptyTexture = new e1.Texture(t1, new e1.RGBAImage({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0)), t1.gl.RGBA), this.identityMat = e1.create();
                const l = this.context.gl;
                this.stencilClearMode = new e1.StencilMode({
                    func: l.ALWAYS,
                    mask: 0
                }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(e1.window.performance.now()), this.atmosphereBuffer = new Bo(this.context);
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                };
            }
            getTileBoundsBuffers(e1) {
                return e1._makeTileBoundsBuffers(this.context, this.transform.projection), e1._tileBoundsBuffer ? {
                    tileBoundsBuffer: e1._tileBoundsBuffer,
                    tileBoundsIndexBuffer: e1._tileBoundsIndexBuffer,
                    tileBoundsSegments: e1._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
                const t1 = this.context, i = t1.gl;
                this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t1, i.TRIANGLES, e1.DepthMode.disabled, this.stencilClearMode, e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ii(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(t1, i, o) {
                if (!i || this.currentStencilSource === i.id || !t1.isTileClipped() || !o || 0 === o.length) return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let e1 = !1;
                    for (const t1 of o)if (void 0 === this._tileClippingMaskIDs[t1.key]) {
                        e1 = !0;
                        break;
                    }
                    if (!e1) return;
                }
                this.currentStencilSource = i.id;
                const r = this.context, n = r.gl;
                this.nextStencilID + o.length > 256 && this.clearStencil(), r.setColorMode(e1.ColorMode.disabled), r.setDepthMode(e1.DepthMode.disabled);
                const s = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const t1 of o){
                    const o = i.getTile(t1), a = this._tileClippingMaskIDs[t1.key] = this.nextStencilID++, { tileBoundsBuffer: l , tileBoundsIndexBuffer: c , tileBoundsSegments: h  } = this.getTileBoundsBuffers(o);
                    s.draw(r, n.TRIANGLES, e1.DepthMode.disabled, new e1.StencilMode({
                        func: n.ALWAYS,
                        mask: 0
                    }, a, 255, n.KEEP, n.KEEP, n.REPLACE), e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ii(t1.projMatrix), "$clipping", l, c, h);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                const t1 = this.nextStencilID++, i = this.context.gl;
                return new e1.StencilMode({
                    func: i.NOTEQUAL,
                    mask: 255
                }, t1, 255, i.KEEP, i.KEEP, i.REPLACE);
            }
            stencilModeForClipping(t1) {
                if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t1);
                const i = this.context.gl;
                return new e1.StencilMode({
                    func: i.EQUAL,
                    mask: 255
                }, this._tileClippingMaskIDs[t1.key], 0, i.KEEP, i.KEEP, i.REPLACE);
            }
            stencilConfigForOverlap(t1) {
                const i = this.context.gl, o = t1.sort((e1, t1)=>t1.overscaledZ - e1.overscaledZ), r = o[o.length - 1].overscaledZ, n = o[0].overscaledZ - r + 1;
                if (n > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + n > 256 && this.clearStencil();
                    const t1 = {};
                    for(let o = 0; o < n; o++)t1[o + r] = new e1.StencilMode({
                        func: i.GEQUAL,
                        mask: 255
                    }, o + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
                    return this.nextStencilID += n, [
                        t1,
                        o
                    ];
                }
                return [
                    {
                        [r]: e1.StencilMode.disabled
                    },
                    o
                ];
            }
            colorModeForRenderPass() {
                const t1 = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new e1.ColorMode([
                        t1.CONSTANT_COLOR,
                        t1.ONE
                    ], new e1.Color(i, i, i, 0), [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                }
                return "opaque" === this.renderPass ? e1.ColorMode.unblended : e1.ColorMode.alphaBlended;
            }
            depthModeForSublayer(t1, i, o) {
                if (!this.opaquePassEnabledForLayer()) return e1.DepthMode.disabled;
                const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t1) * this.depthEpsilon;
                return new e1.DepthMode(o || this.context.gl.LEQUAL, i, [
                    r,
                    r
                ]);
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }
            render(t1, i) {
                this.style = t1, this.options = i, this.imageManager = t1.imageManager, this.glyphManager = t1.glyphManager, this.symbolFadeChange = t1.placement.symbolFadeChange(e1.exported.now()), this.imageManager.beginFrame();
                const o = this.style.order, r = this.style._sourceCaches;
                for(const e1 in r){
                    const t1 = r[e1];
                    t1.used && t1.prepare(this.context);
                }
                const n = {}, s = {}, a = {};
                for(const e1 in r){
                    const t1 = r[e1];
                    n[e1] = t1.getVisibleCoordinates(), s[e1] = n[e1].slice().reverse(), a[e1] = t1.getVisibleCoordinates(!0).reverse();
                }
                this.opaquePassCutoff = 1 / 0;
                for(let e1 = 0; e1 < o.length; e1++)if (this.style._layers[o[e1]].is3D()) {
                    this.opaquePassCutoff = e1;
                    break;
                }
                if (this.terrain && (this.terrain.updateTileBinding(a), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e1.GlobeSharedBuffers(this.context)), e1.isMapAuthenticated(this.context.gl)) {
                    this.renderPass = "offscreen";
                    for (const e1 of o){
                        const i = this.style._layers[e1], o = t1._getLayerSourceCache(i);
                        if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom)) continue;
                        const r = o ? s[o.id] : void 0;
                        ("custom" === i.type || i.isSky() || r && r.length) && this.renderLayer(this, o, i, r);
                    }
                    if (this.depthRangeFor3D = [
                        0,
                        1 - (t1.order.length + 2) * this.numSublayers * this.depthEpsilon
                    ], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([
                        0,
                        0,
                        this.width,
                        this.height
                    ]), this.context.clear({
                        color: i.showOverdrawInspector ? e1.Color.black : e1.Color.transparent,
                        depth: 1
                    }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for(this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--){
                        const e1 = this.style._layers[o[this.currentLayer]], i = t1._getLayerSourceCache(e1);
                        if (e1.isSky()) continue;
                        const r = i ? s[i.id] : void 0;
                        this._renderTileClippingMasks(e1, i, r), this.renderLayer(this, i, e1, r);
                    }
                    if (this.style.fog && this.transform.projection.supportsFog && function(t1, i) {
                        const o = t1.context, r = o.gl, n = t1.transform, s = new e1.DepthMode(r.LEQUAL, e1.DepthMode.ReadOnly, [
                            0,
                            1
                        ]), a = t1.useProgram("globeAtmosphere", null, "globe" === n.projection.name ? [
                            "PROJECTION_GLOBE_VIEW",
                            "FOG"
                        ] : [
                            "FOG"
                        ]), l = e1.globeToMercatorTransition(n.zoom), c = i.properties.get("color").toArray01(), h = i.properties.get("high-color").toArray01(), u = i.properties.get("space-color").toArray01PremultipliedAlpha(), _ = e1.identity$1([]);
                        e1.rotateY$1(_, _, -e1.degToRad(n._center.lng)), e1.rotateX$1(_, _, e1.degToRad(n._center.lat)), e1.rotateZ$1(_, _, n.angle), e1.rotateX$1(_, _, -n._pitch);
                        const d = e1.fromQuat(new Float32Array(16), _), p = e1.mapValue(i.properties.get("star-intensity"), 0, 1, 0, .25), m = 5e-4, f = e1.mapValue(i.properties.get("horizon-blend"), 0, 1, m, .25), g = e1.globeUseCustomAntiAliasing(t1, o, n) && f === m ? n.worldSize / (2 * Math.PI * 1.025) - 1 : n.globeRadius, v = t1.frameCounter / 1e3 % 1, x = e1.length(n.globeCenterInViewSpace), y = Math.sqrt(Math.pow(x, 2) - Math.pow(g, 2)), b = Math.acos(y / x), w = ((t1, i, o, r, n, s, a, l, c, h, u, _, d, p)=>({
                                u_frustum_tl: t1,
                                u_frustum_tr: i,
                                u_frustum_br: o,
                                u_frustum_bl: r,
                                u_horizon: n,
                                u_transition: s,
                                u_fadeout_range: a,
                                u_color: l,
                                u_high_color: c,
                                u_space_color: h,
                                u_star_intensity: u,
                                u_star_size: 5 * e1.exported.devicePixelRatio,
                                u_star_density: 0,
                                u_temporal_offset: _,
                                u_horizon_angle: d,
                                u_rotation_matrix: p
                            }))(n.frustumCorners.TL, n.frustumCorners.TR, n.frustumCorners.BR, n.frustumCorners.BL, n.frustumCorners.horizon, l, f, c, h, u, p, v, b, d);
                        t1.prepareDrawProgram(o, a);
                        const T = t1.atmosphereBuffer;
                        T && a.draw(o, r.TRIANGLES, s, e1.StencilMode.disabled, e1.ColorMode.alphaBlended, e1.CullFaceMode.backCW, w, "skybox", T.vertexBuffer, T.indexBuffer, T.segments);
                    }(this, this.style.fog), this.renderPass = "sky", (e1.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for(this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++){
                        const e1 = this.style._layers[o[this.currentLayer]], i = t1._getLayerSourceCache(e1);
                        e1.isSky() && this.renderLayer(this, i, e1, i ? s[i.id] : void 0);
                    }
                    for(this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o.length;){
                        const e1 = this.style._layers[o[this.currentLayer]], i = t1._getLayerSourceCache(e1);
                        if (e1.isSky()) {
                            ++this.currentLayer;
                            continue;
                        }
                        if (this.terrain && this.style.isLayerDraped(e1)) {
                            if (e1.isHidden(this.transform.zoom)) {
                                ++this.currentLayer;
                                continue;
                            }
                            this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                            continue;
                        }
                        const r = i ? ("symbol" === e1.type ? a : s)[i.id] : void 0;
                        this._renderTileClippingMasks(e1, i, i ? n[i.id] : void 0), this.renderLayer(this, i, e1, r), ++this.currentLayer;
                    }
                    if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                        let i = null;
                        e1.values(this.style._layers).forEach((e1)=>{
                            const o = t1._getLayerSourceCache(e1);
                            o && !e1.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
                        }), i && this.options.showTileBoundaries && ko.debug(this, i, i.getVisibleCoordinates());
                    }
                    this.options.showPadding && function(e1) {
                        const t1 = e1.transform.padding;
                        Io(e1, e1.transform.height - (t1.top || 0), 3, bo), Io(e1, t1.bottom || 0, 3, wo), So(e1, t1.left || 0, 3, To), So(e1, e1.transform.width - (t1.right || 0), 3, Eo);
                        const i = e1.transform.centerPoint;
                        !function(e1, t1, i, o) {
                            Do(e1, t1 - 1, i - 10, 2, 20, o), Do(e1, t1 - 10, i - 1, 20, 2, o);
                        }(e1, i.x, e1.transform.height - i.y, Co);
                    }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e1.window.performance.now()), this.saveCanvasCopy());
                }
            }
            renderLayer(e1, t1, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), (!e1.transform.projection.unsupportedLayers || !e1.transform.projection.unsupportedLayers.includes(i.type) || e1.terrain && "custom" === i.type) && ko[i.type](e1, t1, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e1) {
                if (!this.options.gpuTiming) return;
                const t1 = this.context.extTimerQuery;
                let i = this.gpuTimers[e1.id];
                i || (i = this.gpuTimers[e1.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: t1.createQueryEXT()
                }), i.calls++, t1.beginQueryEXT(t1.TIME_ELAPSED_EXT, i.query);
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const e1 = this.context.extTimerQuery, t1 = e1.createQueryEXT();
                    this.deferredRenderGpuTimeQueries.push(t1), e1.beginQueryEXT(e1.TIME_ELAPSED_EXT, t1);
                }
            }
            gpuTimingDeferredRenderEnd() {
                if (!this.options.gpuTimingDeferredRender) return;
                const e1 = this.context.extTimerQuery;
                e1.endQueryEXT(e1.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
                if (!this.options.gpuTiming) return;
                const e1 = this.context.extTimerQuery;
                e1.endQueryEXT(e1.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const e1 = this.gpuTimers;
                return this.gpuTimers = {}, e1;
            }
            collectDeferredRenderGpuQueries() {
                const e1 = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [], e1;
            }
            queryGpuTimers(e1) {
                const t1 = {};
                for(const i in e1){
                    const o = e1[i], r = this.context.extTimerQuery, n = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;
                    r.deleteQueryEXT(o.query), t1[i] = n;
                }
                return t1;
            }
            queryGpuTimeDeferredRender(e1) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const t1 = this.context.extTimerQuery;
                let i = 0;
                for (const o of e1)i += t1.getQueryObjectEXT(o, t1.QUERY_RESULT_EXT) / 1e6, t1.deleteQueryEXT(o);
                return i;
            }
            translatePosMatrix(t1, i, o, r, n) {
                if (!o[0] && !o[1]) return t1;
                const s = n ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;
                if (s) {
                    const e1 = Math.sin(s), t1 = Math.cos(s);
                    o = [
                        o[0] * t1 - o[1] * e1,
                        o[0] * e1 + o[1] * t1
                    ];
                }
                const a = [
                    n ? o[0] : P(i, o[0], this.transform.zoom),
                    n ? o[1] : P(i, o[1], this.transform.zoom),
                    0
                ], l = new Float32Array(16);
                return e1.translate(l, t1, a), l;
            }
            saveTileTexture(e1) {
                const t1 = this._tileTextures[e1.size[0]];
                t1 ? t1.push(e1) : this._tileTextures[e1.size[0]] = [
                    e1
                ];
            }
            getTileTexture(e1) {
                const t1 = this._tileTextures[e1];
                return t1 && t1.length > 0 ? t1.pop() : null;
            }
            isPatternMissing(e1) {
                return null === e1 || void 0 !== e1 && !this.imageManager.getPattern(e1.toString());
            }
            terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
            }
            currentGlobalDefines() {
                const e1 = this.terrain && this.terrain.renderingToTexture, t1 = this.terrain && 0 === this.terrain.exaggeration(), i = this.style && this.style.fog, o = [];
                return this.terrainRenderModeElevated() && o.push("TERRAIN"), "globe" === this.transform.projection.name && o.push("GLOBE"), t1 && o.push("ZERO_EXAGGERATION"), i && !e1 && 0 !== i.getOpacity(this.transform.pitch) && o.push("FOG"), e1 && o.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o.push("OVERDRAW_INSPECTOR"), o;
            }
            useProgram(e1, t1, i) {
                this.cache = this.cache || {};
                const o = i || [], r = this.currentGlobalDefines().concat(o), n = Pi.cacheKey(ui[e1], e1, r, t1);
                return this.cache[n] || (this.cache[n] = new Pi(this.context, e1, ui[e1], t1, lo[e1], r)), this.cache[n];
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const e1 = this.context.gl;
                this.context.cullFace.set(!1), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.blendEquation.set(e1.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e1.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e1.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
                this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }
            prepareDrawProgram(t1, i, o) {
                if (this.terrain && this.terrain.renderingToTexture) return;
                const r = this.style.fog;
                if (r) {
                    const n = r.getOpacity(this.transform.pitch), s = ((t1, i, o, r, n, s, a, l, c, h, u)=>{
                        const _ = t1.transform, d = i.properties.get("color").toArray01();
                        d[3] = r;
                        const p = t1.frameCounter / 1e3 % 1;
                        return {
                            u_fog_matrix: o ? _.calculateFogTileMatrix(o) : t1.identityMat,
                            u_fog_range: i.getFovAdjustedRange(_._fov),
                            u_fog_color: d,
                            u_fog_horizon_blend: i.properties.get("horizon-blend"),
                            u_fog_temporal_offset: p,
                            u_frustum_tl: n,
                            u_frustum_tr: s,
                            u_frustum_br: a,
                            u_frustum_bl: l,
                            u_globe_pos: c,
                            u_globe_radius: h,
                            u_viewport: u,
                            u_globe_transition: e1.globeToMercatorTransition(_.zoom),
                            u_is_globe: +("globe" === _.projection.name)
                        };
                    })(this, r, o, n, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [
                        this.transform.width * e1.exported.devicePixelRatio,
                        this.transform.height * e1.exported.devicePixelRatio
                    ]);
                    i.setFogUniformValues(t1, s);
                }
            }
            setTileLoadedFlag(e1) {
                this.tileLoaded = e1;
            }
            saveCanvasCopy() {
                const e1 = this.canvasCopy();
                e1 && (this.frameCopies.push(e1), this.tileLoaded = !1);
            }
            canvasCopy() {
                const e1 = this.context.gl, t1 = e1.createTexture();
                return e1.bindTexture(e1.TEXTURE_2D, t1), e1.copyTexImage2D(e1.TEXTURE_2D, 0, e1.RGBA, 0, 0, e1.drawingBufferWidth, e1.drawingBufferHeight, 0), t1;
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                };
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const e1 = this.style && this.style.fog;
                return !!e1 && 0 !== e1.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
                const t1 = this._backgroundTiles, i = this._backgroundTiles = {}, o = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const r of o)i[r.key] = t1[r.key] || new e1.Tile(r, 512, this.transform.tileZoom, this);
                return i;
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {};
            }
        }
        class Uo {
            constructor(e1 = 0, t1 = 0, i = 0, o = 0){
                if (isNaN(e1) || e1 < 0 || isNaN(t1) || t1 < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = e1, this.bottom = t1, this.left = i, this.right = o;
            }
            interpolate(t1, i, o) {
                return null != i.top && null != t1.top && (this.top = e1.number(t1.top, i.top, o)), null != i.bottom && null != t1.bottom && (this.bottom = e1.number(t1.bottom, i.bottom, o)), null != i.left && null != t1.left && (this.left = e1.number(t1.left, i.left, o)), null != i.right && null != t1.right && (this.right = e1.number(t1.right, i.right, o)), this;
            }
            getCenter(t1, i) {
                const o = e1.clamp((this.left + t1 - this.right) / 2, 0, t1), r = e1.clamp((this.top + i - this.bottom) / 2, 0, i);
                return new e1.pointGeometry(o, r);
            }
            equals(e1) {
                return this.top === e1.top && this.bottom === e1.bottom && this.left === e1.left && this.right === e1.right;
            }
            clone() {
                return new Uo(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                };
            }
        }
        function No(t1, i) {
            const o = e1.getColumn(t1, 3);
            e1.fromQuat(t1, i), e1.setColumn(t1, 3, o);
        }
        function Go(t1, i) {
            const o = e1.identity$1([]);
            return e1.rotateZ$1(o, o, -i), e1.rotateX$1(o, o, -t1), o;
        }
        function jo(t1, i) {
            const o = [
                t1[0],
                t1[1],
                0
            ], r = [
                i[0],
                i[1],
                0
            ];
            if (e1.length(o) >= 1e-15) {
                const t1 = e1.normalize([], o);
                e1.scale$2(r, t1, e1.dot(r, t1)), i[0] = r[0], i[1] = r[1];
            }
            const n = e1.cross([], i, t1);
            if (e1.len(n) < 1e-15) return null;
            const s = Math.atan2(-n[1], n[0]);
            return Go(Math.atan2(Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]), -t1[2]), s);
        }
        class Zo {
            constructor(e1, t1){
                this.position = e1, this.orientation = t1;
            }
            get position() {
                return this._position;
            }
            set position(t1) {
                if (t1) {
                    const i = t1 instanceof e1.MercatorCoordinate ? t1 : new e1.MercatorCoordinate(t1[0], t1[1], t1[2]);
                    this._renderWorldCopies && (i.x = e1.wrap(i.x, 0, 1)), this._position = i;
                } else this._position = null;
            }
            lookAtPoint(t1, i) {
                if (this.orientation = null, !this.position) return;
                const o = this._elevation ? this._elevation.getAtPointOrZero(e1.MercatorCoordinate.fromLngLat(t1)) : 0, r = this.position, n = e1.MercatorCoordinate.fromLngLat(t1, o), s = [
                    n.x - r.x,
                    n.y - r.y,
                    n.z - r.z
                ];
                i || (i = [
                    0,
                    0,
                    1
                ]), i[2] = Math.abs(i[2]), this.orientation = jo(s, i);
            }
            setPitchBearing(t1, i) {
                this.orientation = Go(e1.degToRad(t1), e1.degToRad(-i));
            }
        }
        class Vo {
            constructor(t1, i){
                this._transform = e1.identity([]), this.orientation = i, this.position = t1;
            }
            get mercatorPosition() {
                const t1 = this.position;
                return new e1.MercatorCoordinate(t1[0], t1[1], t1[2]);
            }
            get position() {
                const t1 = e1.getColumn(this._transform, 3);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            set position(t1) {
                var i;
                t1 && e1.setColumn(this._transform, 3, [
                    (i = t1)[0],
                    i[1],
                    i[2],
                    1
                ]);
            }
            get orientation() {
                return this._orientation;
            }
            set orientation(t1) {
                this._orientation = t1 || e1.identity$1([]), t1 && No(this._transform, this._orientation);
            }
            getPitchBearing() {
                const e1 = this.forward(), t1 = this.right();
                return {
                    bearing: Math.atan2(-t1[1], t1[0]),
                    pitch: Math.atan2(Math.sqrt(e1[0] * e1[0] + e1[1] * e1[1]), -e1[2])
                };
            }
            setPitchBearing(e1, t1) {
                this._orientation = Go(e1, t1), No(this._transform, this._orientation);
            }
            forward() {
                const t1 = e1.getColumn(this._transform, 2);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            up() {
                const t1 = e1.getColumn(this._transform, 1);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            right() {
                const t1 = e1.getColumn(this._transform, 0);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            getCameraToWorld(t1, i) {
                const o = new Float64Array(16);
                return e1.invert(o, this.getWorldToCamera(t1, i)), o;
            }
            getWorldToCameraPosition(t1, i, o) {
                const r = this.position;
                e1.scale$2(r, r, -t1);
                const n = new Float64Array(16);
                return e1.fromScaling(n, [
                    o,
                    o,
                    o
                ]), e1.translate(n, n, r), n[10] *= i, n;
            }
            getWorldToCamera(t1, i) {
                const o = new Float64Array(16), r = new Float64Array(4), n = this.position;
                return e1.conjugate(r, this._orientation), e1.scale$2(n, n, -t1), e1.fromQuat(o, r), e1.translate(o, o, n), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
            }
            getCameraToClipPerspective(t1, i, o, r) {
                const n = new Float64Array(16);
                return e1.perspective(n, t1, i, o, r), n;
            }
            getDistanceToElevation(t1, i = !1) {
                const o = 0 === t1 ? 0 : e1.mercatorZfromAltitude(t1, i ? e1.latFromMercatorY(this.position[1]) : this.position[1]), r = this.forward();
                return (o - this.position[2]) / r[2];
            }
            clone() {
                return new Vo([
                    ...this.position
                ], [
                    ...this.orientation
                ]);
            }
        }
        function Wo(t1, i) {
            const o = qo(t1.projection, t1.zoom, t1.width, t1.height), r = function(t1, i, o, r, n) {
                const s = new e1.LngLat(o.lng - 180 * $o, o.lat), a = new e1.LngLat(o.lng + 180 * $o, o.lat), l = t1.project(s.lng, s.lat), c = t1.project(a.lng, a.lat), h = -Math.atan2(c.y - l.y, c.x - l.x), u = e1.MercatorCoordinate.fromLngLat(o);
                u.y = e1.clamp(u.y, -0.999975, .999975);
                const _ = u.toLngLat(), d = t1.project(_.lng, _.lat), p = e1.MercatorCoordinate.fromLngLat(_);
                p.x += $o;
                const m = p.toLngLat(), f = t1.project(m.lng, m.lat), g = Yo(f.x - d.x, f.y - d.y, h), v = e1.MercatorCoordinate.fromLngLat(_);
                v.y += $o;
                const x = v.toLngLat(), y = t1.project(x.lng, x.lat), b = Yo(y.x - d.x, y.y - d.y, h), w = Math.abs(g.x) / Math.abs(b.y), T = e1.identity([]);
                e1.rotateZ(T, T, -h * (1 - (n ? 0 : r)));
                const E = e1.identity([]);
                return e1.scale(E, E, [
                    1,
                    1 - (1 - w) * r,
                    1
                ]), E[4] = -b.x / b.y * r, e1.rotateZ(E, E, h), e1.multiply(E, T, E), E;
            }(t1.projection, 0, t1.center, o, i), n = Xo(t1);
            return e1.scale(r, r, [
                n,
                n,
                1
            ]), r;
        }
        function Xo(t1) {
            const i = t1.projection, o = qo(t1.projection, t1.zoom, t1.width, t1.height), r = Ho(i, t1.center), n = Ho(i, e1.LngLat.convert(i.center));
            return Math.pow(2, r * o + (1 - o) * n);
        }
        function qo(t1, i, o, r, n = 1 / 0) {
            const s = t1.range;
            if (!s) return 0;
            const a = Math.min(n, Math.max(o, r)), l = Math.log(a / 1024) / Math.LN2;
            return e1.smoothstep(s[0] + l, s[1] + l, i);
        }
        const $o = 1 / 4e4;
        function Ho(t1, i) {
            const o = e1.clamp(i.lat, -e1.MAX_MERCATOR_LATITUDE, e1.MAX_MERCATOR_LATITUDE), r = new e1.LngLat(i.lng - 180 * $o, o), n = new e1.LngLat(i.lng + 180 * $o, o), s = t1.project(r.lng, o), a = t1.project(n.lng, o), l = e1.MercatorCoordinate.fromLngLat(r), c = e1.MercatorCoordinate.fromLngLat(n), h = a.x - s.x, u = a.y - s.y, _ = c.x - l.x, d = c.y - l.y, p = Math.sqrt((_ * _ + d * d) / (h * h + u * u));
            return Math.log(p) / Math.LN2;
        }
        function Yo(e1, t1, i) {
            const o = Math.cos(i), r = Math.sin(i);
            return {
                x: e1 * o - t1 * r,
                y: e1 * r + t1 * o
            };
        }
        class Ko {
            constructor(t1, i, o, r, n, s, a){
                this.tileSize = 512, this._renderWorldCopies = void 0 === n || n, this._minZoom = t1 || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setProjection(s), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e1.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Uo, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Vo, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [
                    0,
                    0,
                    0
                ], this._horizonShift = .1;
            }
            clone() {
                const e1 = new Ko(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
                return e1._elevation = this._elevation, e1._centerAltitude = this._centerAltitude, e1._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e1.tileSize = this.tileSize, e1.mercatorFromTransition = this.mercatorFromTransition, e1.width = this.width, e1.height = this.height, e1.cameraElevationReference = this.cameraElevationReference, e1._center = this._center, e1._setZoom(this.zoom), e1._seaLevelZoom = this._seaLevelZoom, e1.angle = this.angle, e1._fov = this._fov, e1._pitch = this._pitch, e1._nearZ = this._nearZ, e1._farZ = this._farZ, e1._averageElevation = this._averageElevation, e1._unmodified = this._unmodified, e1._edgeInsets = this._edgeInsets.clone(), e1._camera = this._camera.clone(), e1._calcMatrices(), e1.freezeTileCoverage = this.freezeTileCoverage, e1.frustumCorners = this.frustumCorners, e1;
            }
            get elevation() {
                return this._elevation;
            }
            set elevation(e1) {
                this._elevation !== e1 && (this._elevation = e1, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            updateElevation(e1, t1 = !1) {
                const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e1 || i) && this._constrainCamera(t1), this._calcMatrices();
            }
            getProjection() {
                return e1.pick(this.projection, [
                    "name",
                    "center",
                    "parallels"
                ]);
            }
            setProjection(i) {
                this.projectionOptions = i || {
                    name: "mercator"
                };
                const o = this.projection ? this.getProjection() : void 0;
                this.projection = e1.getProjection(this.projectionOptions);
                const r = !t1(o, this.getProjection());
                return r && this._calcMatrices(), this.mercatorFromTransition = !1, r;
            }
            setMercatorFromTransition() {
                const t1 = this.projection.name;
                this.mercatorFromTransition = !0, this.projectionOptions = {
                    name: "mercator"
                }, this.projection = e1.getProjection({
                    name: "mercator"
                });
                const i = t1 !== this.projection.name;
                return i && this._calcMatrices(), i;
            }
            get minZoom() {
                return this._minZoom;
            }
            set minZoom(e1) {
                this._minZoom !== e1 && (this._minZoom = e1, this.zoom = Math.max(this.zoom, e1));
            }
            get maxZoom() {
                return this._maxZoom;
            }
            set maxZoom(e1) {
                this._maxZoom !== e1 && (this._maxZoom = e1, this.zoom = Math.min(this.zoom, e1));
            }
            get minPitch() {
                return this._minPitch;
            }
            set minPitch(e1) {
                this._minPitch !== e1 && (this._minPitch = e1, this.pitch = Math.max(this.pitch, e1));
            }
            get maxPitch() {
                return this._maxPitch;
            }
            set maxPitch(e1) {
                this._maxPitch !== e1 && (this._maxPitch = e1, this.pitch = Math.min(this.pitch, e1));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e1) {
                void 0 === e1 ? e1 = !0 : null === e1 && (e1 = !1), this._renderWorldCopies = e1;
            }
            get worldSize() {
                return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
                const e1 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e1));
            }
            get cameraWorldSize() {
                const e1 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e1));
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
                return e1.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
                return new e1.pointGeometry(this.width, this.height);
            }
            get bearing() {
                return e1.wrap(this.rotation, -180, 180);
            }
            set bearing(e1) {
                this.rotation = e1;
            }
            get rotation() {
                return -this.angle / Math.PI * 180;
            }
            set rotation(t1) {
                const i = -t1 * Math.PI / 180;
                var o;
                this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = (o = new e1.ARRAY_TYPE(4), e1.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o), function(e1, t1, i) {
                    var o = t1[0], r = t1[1], n = t1[2], s = t1[3], a = Math.sin(i), l = Math.cos(i);
                    e1[0] = o * l + n * a, e1[1] = r * l + s * a, e1[2] = o * -a + n * l, e1[3] = r * -a + s * l;
                }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180;
            }
            set pitch(t1) {
                const i = e1.clamp(t1, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
            }
            get aspect() {
                return this.width / this.height;
            }
            get fovX() {
                return this._fov;
            }
            get fovY() {
                const e1 = 1 / Math.tan(.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / e1);
            }
            set fov(t1) {
                t1 = Math.max(.01, Math.min(60, t1)), this._fov !== t1 && (this._unmodified = !1, this._fov = e1.degToRad(t1), this._calcMatrices());
            }
            get averageElevation() {
                return this._averageElevation;
            }
            set averageElevation(e1) {
                this._averageElevation = e1, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
                return this._zoom;
            }
            set zoom(e1) {
                const t1 = Math.min(Math.max(e1, this.minZoom), this.maxZoom);
                this._zoom !== t1 && (this._unmodified = !1, this._setZoom(t1), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e1) {
                this._zoom = e1, this.scale = this.zoomScale(e1), this.tileZoom = Math.floor(e1), this.zoomFraction = e1 - this.tileZoom;
            }
            _updateCameraOnTerrain() {
                if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
                const e1 = this._elevation;
                this._centerAltitude = e1.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e1.exaggeration(), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
                if (!this._elevation) return 0;
                const t1 = this._elevation, i = [
                    [
                        .5,
                        .2
                    ],
                    [
                        .3,
                        .5
                    ],
                    [
                        .5,
                        .5
                    ],
                    [
                        .7,
                        .5
                    ],
                    [
                        .5,
                        .8
                    ]
                ], o = this.horizonLineFromTop();
                let r = 0, n = 0;
                for(let s = 0; s < i.length; s++){
                    const a = new e1.pointGeometry(i[s][0] * this.width, o + i[s][1] * (this.height - o)), l = t1.pointCoordinate(a);
                    if (!l) continue;
                    const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                    r += l[3] * c, n += c;
                }
                return 0 === n ? NaN : r / n;
            }
            get center() {
                return this._center;
            }
            set center(e1) {
                e1.lat === this._center.lat && e1.lng === this._center.lng || (this._unmodified = !1, this._center = e1, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const e1 = this._seaLevelZoom, t1 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i = this.pixelsPerMeter / this.worldSize * t1, o = this._mercatorZfromZoom(e1), r = this._mercatorZfromZoom(this._maxZoom), n = Math.max(o - i, r);
                this._setZoom(this._zoomFromMercatorZ(n));
            }
            get padding() {
                return this._edgeInsets.toJSON();
            }
            set padding(e1) {
                this._edgeInsets.equals(e1) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e1, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t1) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t1.toAltitude()));
                let o;
                o = t1.z < this._camera.position[2] ? [
                    i.x,
                    i.y,
                    i.z
                ] : [
                    t1.x,
                    t1.y,
                    t1.z
                ];
                const r = e1.length(e1.sub([], this._camera.position, o));
                return e1.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t1) {
                if (!this.height) return;
                if (!t1.position && !t1.orientation) return;
                this._updateCameraState();
                let i = !1;
                if (t1.orientation && !e1.exactEquals(t1.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t1.orientation)), t1.position) {
                    const o = [
                        t1.position.x,
                        t1.position.y,
                        t1.position.z
                    ];
                    e1.exactEquals$1(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
                }
                i && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const t1 = this._camera.position, i = new Zo;
                return i.position = new e1.MercatorCoordinate(t1[0], t1[1], t1[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
            }
            _setCameraOrientation(t1) {
                if (!e1.length$1(t1)) return !1;
                e1.normalize$1(t1, t1);
                const i = e1.transformQuat([], [
                    0,
                    0,
                    -1
                ], t1), o = e1.transformQuat([], [
                    0,
                    -1,
                    0
                ], t1);
                if (o[2] < 0) return !1;
                const r = jo(i, o);
                return !!r && (this._camera.orientation = r, !0);
            }
            _setCameraPosition(t1) {
                const i = this.zoomScale(this.minZoom) * this.tileSize, o = this.zoomScale(this.maxZoom) * this.tileSize, r = this.cameraToCenterDistance;
                t1[2] = e1.clamp(t1[2], r / o, r / i), this._camera.position = t1;
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e1) {
                return this._edgeInsets.equals(e1);
            }
            interpolatePadding(e1, t1, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(e1, t1, i), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e1) {
                const t1 = (e1.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e1.tileSize));
                return Math.max(0, t1);
            }
            getVisibleUnwrappedCoordinates(t1) {
                const i = [
                    new e1.UnwrappedTileID(0, t1)
                ];
                if (this.renderWorldCopies) {
                    const o = this.pointCoordinate(new e1.pointGeometry(0, 0)), r = this.pointCoordinate(new e1.pointGeometry(this.width, 0)), n = this.pointCoordinate(new e1.pointGeometry(this.width, this.height)), s = this.pointCoordinate(new e1.pointGeometry(0, this.height)), a = Math.floor(Math.min(o.x, r.x, n.x, s.x)), l = Math.floor(Math.max(o.x, r.x, n.x, s.x)), c = 1;
                    for(let o = a - c; o <= l + c; o++)0 !== o && i.push(new e1.UnwrappedTileID(o, t1));
                }
                return i;
            }
            coveringTiles(t1) {
                let i = this.coveringZoomLevel(t1);
                const o = i, r = this.elevation && !t1.isTerrainDEM, n = "mercator" === this.projection.name;
                if (void 0 !== t1.minzoom && i < t1.minzoom) return [];
                void 0 !== t1.maxzoom && i > t1.maxzoom && (i = t1.maxzoom);
                const s = this.locationCoordinate(this.center), a = this.center.lat, l = 1 << i, c = [
                    l * s.x,
                    l * s.y,
                    0
                ], h = "globe" === this.projection.name, u = !h, _ = e1.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u), d = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p = l * e1.mercatorZfromAltitude(1, this.center.lat), m = this._camera.position[2] / e1.mercatorZfromAltitude(1, this.center.lat), f = [
                    l * d.x,
                    l * d.y,
                    m * (u ? 1 : p)
                ], g = this.cameraToCenterDistance / t1.tileSize * (t1.roundZoom ? 1 : .502), v = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0, x = t1.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, y = t1.isTerrainDEM ? -x : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b = this.projection.isReprojectedInTileSpace ? Xo(this) : 1, w = (t1)=>{
                    const i = 1 / 4e4, o = new e1.MercatorCoordinate(t1.x + i, t1.y, t1.z), r = new e1.MercatorCoordinate(t1.x, t1.y + i, t1.z), n = t1.toLngLat(), s = o.toLngLat(), a = r.toLngLat(), l = this.locationCoordinate(n), c = this.locationCoordinate(s), h = this.locationCoordinate(a), u = Math.hypot(c.x - l.x, c.y - l.y), _ = Math.hypot(h.x - l.x, h.y - l.y);
                    return Math.sqrt(u * _) * b / i;
                }, T = (t1)=>{
                    const i = x, o = y;
                    return {
                        aabb: e1.tileAABB(this, l, 0, 0, 0, t1, o, i, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: o,
                        maxZ: i,
                        wrap: t1,
                        fullyVisible: !1
                    };
                }, E = [];
                let C = [];
                const M = i, I = t1.reparseOverscaled ? o : i, S = (e1)=>e1 * e1, D = S((m - this._centerAltitude) * p), L = (e1)=>{
                    if (!this._elevation || !e1.tileID || !n) return;
                    const t1 = this._elevation.getMinMaxForTile(e1.tileID), i = e1.aabb;
                    t1 ? (i.min[2] = t1.min, i.max[2] = t1.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e1.shouldSplit = A(e1), e1.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
                }, A = (t1)=>{
                    if (t1.zoom < v) return !0;
                    if (t1.zoom === M) return !1;
                    if (null != t1.shouldSplit) return t1.shouldSplit;
                    const i = t1.aabb.distanceX(f), n = t1.aabb.distanceY(f);
                    let s = D, l = 1;
                    if (h) {
                        s = S(t1.aabb.distanceZ(f));
                        const i = Math.pow(2, t1.zoom), o = e1.latFromMercatorY((t1.y + 1) / i), r = e1.latFromMercatorY(t1.y / i), n = Math.min(Math.max(a, o), r), c = e1.circumferenceAtLatitude(n) / e1.circumferenceAtLatitude(a);
                        if (l = n === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio), this.zoom <= e1.GLOBE_ZOOM_THRESHOLD_MIN && t1.zoom === M - 1 && c >= .9) return !0;
                    } else if (r && (s = S(t1.aabb.distanceZ(f) * p)), this.projection.isReprojectedInTileSpace && o <= 5) {
                        const i = Math.pow(2, t1.zoom), o = w(new e1.MercatorCoordinate((t1.x + .5) / i, (t1.y + .5) / i));
                        l = o > .85 ? 1 : o;
                    }
                    const c = i * i + n * n + s, u = S((1 << M - t1.zoom) * g * l * ((e1, t1)=>{
                        if (t1 * S(.707) < e1) return 1;
                        const i = Math.sqrt(t1 / e1);
                        return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                    })(Math.max(s, D), c));
                    return c < u;
                };
                if (this.renderWorldCopies) for(let e1 = 1; e1 <= 3; e1++)E.push(T(-e1)), E.push(T(e1));
                for(E.push(T(0)); E.length > 0;){
                    const o = E.pop(), s = o.x, a = o.y;
                    let u = o.fullyVisible;
                    if (!u) {
                        const e1 = o.aabb.intersects(_);
                        if (0 === e1) continue;
                        u = 2 === e1;
                    }
                    if (o.zoom !== M && A(o)) for(let t1 = 0; t1 < 4; t1++){
                        const i = (s << 1) + t1 % 2, c = (a << 1) + (t1 >> 1), _ = {
                            aabb: n ? o.aabb.quadrant(t1) : e1.tileAABB(this, l, o.zoom + 1, i, c, o.wrap, o.minZ, o.maxZ, this.projection),
                            zoom: o.zoom + 1,
                            x: i,
                            y: c,
                            wrap: o.wrap,
                            fullyVisible: u,
                            tileID: void 0,
                            shouldSplit: void 0,
                            minZ: o.minZ,
                            maxZ: o.maxZ
                        };
                        r && !h && (_.tileID = new e1.OverscaledTileID(o.zoom + 1 === M ? I : o.zoom + 1, o.wrap, o.zoom + 1, i, c), L(_)), E.push(_);
                    }
                    else {
                        const r = o.zoom === M ? I : o.zoom;
                        if (t1.minzoom && t1.minzoom > r) continue;
                        const n = c[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom), l = c[1] - .5 - a, h = o.tileID ? o.tileID : new e1.OverscaledTileID(r, o.wrap, o.zoom, s, a);
                        C.push({
                            tileID: h,
                            distanceSq: n * n + l * l
                        });
                    }
                }
                if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq, o = this.horizonLineFromTop();
                    C = C.filter((r)=>{
                        const n = [
                            0,
                            0,
                            0,
                            1
                        ], s = [
                            e1.EXTENT,
                            e1.EXTENT,
                            0,
                            1
                        ], a = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
                        e1.transformMat4$1(n, n, a), e1.transformMat4$1(s, s, a);
                        const l = e1.getAABBPointSquareDist(n, s);
                        if (0 === l) return !0;
                        let c = !1;
                        const h = this._elevation;
                        if (h && l > i && 0 !== o) {
                            const i = this.calculateProjMatrix(r.tileID.toUnwrapped());
                            let n;
                            t1.isTerrainDEM || (n = h.getMinMaxForTile(r.tileID)), n || (n = {
                                min: y,
                                max: x
                            });
                            const s = e1.furthestTileCorner(this.rotation), a = [
                                s[0] * e1.EXTENT,
                                s[1] * e1.EXTENT,
                                n.max
                            ];
                            e1.transformMat4(a, a, i), c = (1 - a[1]) * this.height * .5 < o;
                        }
                        return l < i || c;
                    });
                }
                return C.sort((e1, t1)=>e1.distanceSq - t1.distanceSq).map((e1)=>e1.tileID);
            }
            resize(e1, t1) {
                this.width = e1, this.height = t1, this.pixelsToGLUnits = [
                    2 / e1,
                    -2 / t1
                ], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified;
            }
            zoomScale(e1) {
                return Math.pow(2, e1);
            }
            scaleZoom(e1) {
                return Math.log(e1) / Math.LN2;
            }
            project(t1) {
                const i = e1.clamp(t1.lat, -e1.MAX_MERCATOR_LATITUDE, e1.MAX_MERCATOR_LATITUDE), o = this.projection.project(t1.lng, i);
                return new e1.pointGeometry(o.x * this.worldSize, o.y * this.worldSize);
            }
            unproject(e1) {
                return this.projection.unproject(e1.x / this.worldSize, e1.y / this.worldSize);
            }
            get point() {
                return this.project(this.center);
            }
            get pointMerc() {
                return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
                return this.pixelsPerMeter / e1.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t1, i) {
                let o, r;
                const n = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const e1 = this.worldSize;
                    o = (i.x - n.x) / e1, r = (i.y - n.y) / e1;
                } else {
                    const e1 = this.pointCoordinate(i), t1 = this.pointCoordinate(n);
                    o = e1.x - t1.x, r = e1.y - t1.y;
                }
                const s = this.locationCoordinate(t1);
                this.setLocation(new e1.MercatorCoordinate(s.x - o, s.y - r));
            }
            setLocation(e1) {
                this.center = this.coordinateLocation(e1), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e1) {
                return this.projection.locationPoint(this, e1);
            }
            locationPoint3D(e1) {
                return this.projection.locationPoint(this, e1, !0);
            }
            pointLocation(e1) {
                return this.coordinateLocation(this.pointCoordinate(e1));
            }
            pointLocation3D(e1) {
                return this.coordinateLocation(this.pointCoordinate3D(e1));
            }
            locationCoordinate(t1, i) {
                const o = i ? e1.mercatorZfromAltitude(i, t1.lat) : void 0, r = this.projection.project(t1.lng, t1.lat);
                return new e1.MercatorCoordinate(r.x, r.y, o);
            }
            coordinateLocation(e1) {
                return this.projection.unproject(e1.x, e1.y);
            }
            pointRayIntersection(t1, i) {
                const o = null != i ? i : this._centerAltitude, r = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], n = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e1.transformMat4$1(r, r, this.pixelMatrixInverse), e1.transformMat4$1(n, n, this.pixelMatrixInverse);
                const s = n[3];
                e1.scale$1(r, r, 1 / r[3]), e1.scale$1(n, n, 1 / s);
                const a = r[2], l = n[2];
                return {
                    p0: r,
                    p1: n,
                    t: a === l ? 0 : (o - a) / (l - a)
                };
            }
            screenPointToMercatorRay(t1) {
                const i = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                return e1.transformMat4$1(i, i, this.pixelMatrixInverse), e1.transformMat4$1(o, o, this.pixelMatrixInverse), e1.scale$1(i, i, 1 / i[3]), e1.scale$1(o, o, 1 / o[3]), i[2] = e1.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize, o[2] = e1.mercatorZfromAltitude(o[2], this._center.lat) * this.worldSize, e1.scale$1(i, i, 1 / this.worldSize), e1.scale$1(o, o, 1 / this.worldSize), new e1.Ray([
                    i[0],
                    i[1],
                    i[2]
                ], e1.normalize([], e1.sub([], o, i)));
            }
            rayIntersectionCoordinate(t1) {
                const { p0: i , p1: o , t: r  } = t1, n = e1.mercatorZfromAltitude(i[2], this._center.lat), s = e1.mercatorZfromAltitude(o[2], this._center.lat);
                return new e1.MercatorCoordinate(e1.number(i[0], o[0], r) / this.worldSize, e1.number(i[1], o[1], r) / this.worldSize, e1.number(n, s, r));
            }
            pointCoordinate(e1, t1 = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e1.x, e1.y, t1);
            }
            pointCoordinate3D(t1) {
                if (!this.elevation) return this.pointCoordinate(t1);
                let i = this.projection.pointCoordinate3D(this, t1.x, t1.y);
                if (i) return new e1.MercatorCoordinate(i[0], i[1], i[2]);
                let o = 0, r = this.horizonLineFromTop();
                if (t1.y > r) return this.pointCoordinate(t1);
                const n = .02 * r, s = t1.clone();
                for(let t1 = 0; t1 < 10 && r - o > n; t1++){
                    s.y = e1.number(o, r, .66);
                    const t1 = this.projection.pointCoordinate3D(this, s.x, s.y);
                    t1 ? (r = s.y, i = t1) : o = s.y;
                }
                return i ? new e1.MercatorCoordinate(i[0], i[1], i[2]) : this.pointCoordinate(t1);
            }
            isPointAboveHorizon(e1) {
                return this.projection.isPointAboveHorizon(this, e1);
            }
            _coordinatePoint(t1, i) {
                const o = i && this.elevation ? this.elevation.getAtPointOrZero(t1, this._centerAltitude) : this._centerAltitude, r = [
                    t1.x * this.worldSize,
                    t1.y * this.worldSize,
                    o + t1.toAltitude(),
                    1
                ];
                return e1.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e1.pointGeometry(r[0] / r[3], r[1] / r[3]) : new e1.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
                const { top: t1 , left: i  } = this._edgeInsets, o = this.height - this._edgeInsets.bottom, r = this.width - this._edgeInsets.right, n = this.pointLocation3D(new e1.pointGeometry(i, t1)), s = this.pointLocation3D(new e1.pointGeometry(r, t1)), a = this.pointLocation3D(new e1.pointGeometry(r, o)), l = this.pointLocation3D(new e1.pointGeometry(i, o));
                let c = Math.min(n.lng, s.lng, a.lng, l.lng), h = Math.max(n.lng, s.lng, a.lng, l.lng), u = Math.min(n.lat, s.lat, a.lat, l.lat), _ = Math.max(n.lat, s.lat, a.lat, l.lat);
                const d = Math.pow(2, -this.zoom) / 16 * 270, p = "globe" === this.projection.name ? 1 : 4, m = (t1, i, o, r, n)=>{
                    const s = (t1 + o) / 2, a = (i + r) / 2, l = new e1.pointGeometry(s, a), { lng: f , lat: g  } = this.pointLocation3D(l), v = Math.max(0, c - f, u - g, f - h, g - _);
                    c = Math.min(c, f), h = Math.max(h, f), u = Math.min(u, g), _ = Math.max(_, g), (n < p || v > d) && (m(t1, i, s, a, n + 1), m(s, a, o, r, n + 1));
                };
                if (m(i, t1, r, t1, 1), m(r, t1, r, o, 1), m(r, o, i, o, 1), m(i, o, i, t1, 1), "globe" === this.projection.name) {
                    const [t1, i] = e1.polesInViewport(this);
                    t1 ? (_ = 90, h = 180, c = -180) : i && (u = -90, h = 180, c = -180);
                }
                return new e1.LngLatBounds(new e1.LngLat(c, u), new e1.LngLat(h, _));
            }
            _getBoundsRectangular(t1, i) {
                const { top: o , left: r  } = this._edgeInsets, n = this.height - this._edgeInsets.bottom, s = this.width - this._edgeInsets.right, a = new e1.pointGeometry(r, o), l = new e1.pointGeometry(s, o), c = new e1.pointGeometry(s, n), h = new e1.pointGeometry(r, n);
                let u = this.pointCoordinate(a, t1), _ = this.pointCoordinate(l, t1);
                const d = this.pointCoordinate(c, i), p = this.pointCoordinate(h, i), m = (e1, t1)=>(t1.y - e1.y) / (t1.x - e1.x);
                return u.y > 1 && _.y >= 0 ? u = new e1.MercatorCoordinate((1 - p.y) / m(p, u) + p.x, 1) : u.y < 0 && _.y <= 1 && (u = new e1.MercatorCoordinate(-p.y / m(p, u) + p.x, 0)), _.y > 1 && u.y >= 0 ? _ = new e1.MercatorCoordinate((1 - d.y) / m(d, _) + d.x, 1) : _.y < 0 && u.y <= 1 && (_ = new e1.MercatorCoordinate(-d.y / m(d, _) + d.x, 0)), (new e1.LngLatBounds).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(_)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(d));
            }
            _getBoundsRectangularTerrain() {
                const e1 = this.elevation;
                if (!e1.visibleDemTiles.length || e1.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
                const t1 = e1.visibleDemTiles.reduce((e1, t1)=>{
                    if (t1.dem) {
                        const i = t1.dem.tree;
                        e1.min = Math.min(e1.min, i.minimums[0]), e1.max = Math.max(e1.max, i.maximums[0]);
                    }
                    return e1;
                }, {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBoundsRectangular(t1.min * e1.exaggeration(), t1.max * e1.exaggeration());
            }
            getBounds() {
                return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e1 = !0) {
                const t1 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y, i = this.height / 2 - t1 * (1 - this._horizonShift);
                return e1 ? Math.max(0, i) : i;
            }
            getMaxBounds() {
                return this.maxBounds;
            }
            setMaxBounds(t1) {
                this.maxBounds = t1, this.minLat = -e1.MAX_MERCATOR_LATITUDE, this.maxLat = e1.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t1 && (this.minLat = t1.getSouth(), this.maxLat = t1.getNorth(), this.minLng = t1.getWest(), this.maxLng = t1.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e1.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e1.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e1.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e1.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e1, t1) {
                return this.projection.createTileMatrix(this, t1, e1);
            }
            calculateDistanceTileData(t1) {
                const i = t1.key, o = this._distanceTileDataCache;
                if (o[i]) return o[i];
                const r = t1.canonical, n = 1 / this.height, s = this.cameraWorldSize, a = s / this.zoomScale(r.z), l = (r.x + Math.pow(2, r.z) * t1.wrap) * a, c = r.y * a, h = this.point;
                h.x *= s / this.worldSize, h.y *= s / this.worldSize;
                const u = this.angle, _ = Math.sin(-u), d = -Math.cos(-u);
                return o[i] = {
                    bearing: [
                        _,
                        d
                    ],
                    center: [
                        (h.x - l) * n,
                        (h.y - c) * n
                    ],
                    scale: a / e1.EXTENT * n
                }, o[i];
            }
            calculateFogTileMatrix(t1) {
                const i = t1.key, o = this._fogTileMatrixCache;
                if (o[i]) return o[i];
                const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t1);
                return e1.multiply(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];
            }
            calculateProjMatrix(t1, i = !1) {
                const o = t1.key, r = i ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (r[o]) return r[o];
                const n = this.calculatePosMatrix(t1, this.worldSize);
                return e1.multiply(n, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n), r[o] = new Float32Array(n), r[o];
            }
            calculatePixelsToTileUnitsMatrix(t1) {
                const i = t1.tileID.key, o = this._pixelsToTileUnitsCache;
                if (o[i]) return o[i];
                const r = function(t1, i) {
                    const { scale: o  } = t1.tileTransform, r = o * e1.EXTENT / (t1.tileSize * Math.pow(2, i.zoom - t1.tileID.overscaledZ + t1.tileID.canonical.z));
                    var n, s, a, l, c, h, u, _;
                    return n = new Float32Array(4), l = (s = i.inverseAdjustmentMatrix)[1], c = s[2], h = s[3], _ = (a = [
                        r,
                        r
                    ])[1], n[0] = s[0] * (u = a[0]), n[1] = l * u, n[2] = c * _, n[3] = h * _, n;
                }(t1, this);
                return o[i] = r, o[i];
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                    const t1 = 1 / this.worldSize, i = e1.fromScaling([], [
                        t1,
                        t1,
                        t1
                    ]);
                    return e1.multiply(i, i, this.globeMatrix), i;
                }
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name) return;
                const t1 = this._elevation;
                this._updateCameraState();
                const i = e1.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o = this._computeCameraPosition(i), r = this._camera.forward(), n = e1.mercatorZfromAltitude(1, this._center.lat);
                o[2] /= n, r[2] /= n, e1.normalize(r, r);
                const s = t1.raycast(o, r, t1.exaggeration());
                if (s) {
                    const t1 = e1.scaleAndAdd([], o, r, s), i = new e1.MercatorCoordinate(t1[0], t1[1], e1.mercatorZfromAltitude(t1[2], e1.latFromMercatorY(t1[1]))), a = (i.z + e1.length([
                        i.x - o[0],
                        i.y - o[1],
                        i.z - o[2] * n
                    ])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                }
            }
            _constrainCamera(t1 = !1) {
                if (!this._elevation) return;
                const i = this._elevation, o = e1.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, r = this._computeCameraPosition(o), n = i.getAtPointOrZero(new e1.MercatorCoordinate(...r)), s = this.pixelsPerMeter / this.worldSize * n, a = this._minimumHeightOverTerrain(), l = r[2] - s;
                if (l <= a) {
                    if (l < 0 || t1) {
                        const t1 = this.locationCoordinate(this._center, this._centerAltitude), i = [
                            r[0],
                            r[1],
                            t1.z - r[2]
                        ], o = e1.length(i);
                        i[2] -= (a - l) / this._pixelsPerMercatorPixel;
                        const n = e1.length(i);
                        if (0 === n) return;
                        e1.scale$2(i, i, o / n * this._pixelsPerMercatorPixel), this._camera.position = [
                            r[0],
                            r[1],
                            t1.z * this._pixelsPerMercatorPixel - i[2]
                        ], this._updateStateFromCamera();
                    } else this._isCameraConstrained = !0;
                }
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;
                this._constraining = !0;
                const t1 = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || t1) {
                    const i = this.center;
                    return i.lat = e1.clamp(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t1) && (i.lng = e1.clamp(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);
                }
                const i = this._unmodified, { x: o , y: r  } = this.point;
                let n = 0, s = o, a = r;
                const l = this.width / 2, c = this.height / 2, h = this.worldMinY * this.scale, u = this.worldMaxY * this.scale;
                if (r - c < h && (a = h + c), r + c > u && (a = u - c), u - h < this.height && (n = Math.max(n, this.height / (u - h)), a = (u + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const e1 = this.worldMinX * this.scale, t1 = this.worldMaxX * this.scale, i = this.worldSize / 2 - (e1 + t1) / 2;
                    s = (o + i + this.worldSize) % this.worldSize - i, s - l < e1 && (s = e1 + l), s + l > t1 && (s = t1 - l), t1 - e1 < this.width && (n = Math.max(n, this.width / (t1 - e1)), s = (t1 + e1) / 2);
                }
                s === o && a === r || (this.center = this.unproject(new e1.pointGeometry(s, a))), n && (this.zoom += this.scaleZoom(n)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;
            }
            _minZoomForBounds() {
                let e1 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (e1 = Math.max(e1, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e1;
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
                if (!this.height) return;
                const t1 = this.centerOffset, i = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = e1.mercatorZfromAltitude(1, this.center.lat) / e1.mercatorZfromAltitude(1, e1.GLOBE_SCALE_MATCH_LATITUDE));
                const o = qo(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                const r = "meters" === this.projection.zAxisUnit ? i : 1, n = this._camera.getWorldToCamera(this.worldSize, r), s = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                s[8] = 2 * -t1.x / this.width, s[9] = 2 * t1.y / this.height;
                let a = e1.mul([], s, n);
                if (this.projection.isReprojectedInTileSpace) {
                    const t1 = this.locationCoordinate(this.center), i = e1.identity([]);
                    e1.translate(i, i, [
                        t1.x * this.worldSize,
                        t1.y * this.worldSize,
                        0
                    ]), e1.multiply(i, i, Wo(this)), e1.translate(i, i, [
                        -t1.x * this.worldSize,
                        -t1.y * this.worldSize,
                        0
                    ]), e1.multiply(a, a, i), this.inverseAdjustmentMatrix = function(e1) {
                        const t1 = Wo(e1, !0);
                        return v([], [
                            t1[0],
                            t1[1],
                            t1[4],
                            t1[5]
                        ]);
                    }(this);
                } else this.inverseAdjustmentMatrix = [
                    1,
                    0,
                    0,
                    1
                ];
                this.mercatorMatrix = e1.scale([], a, [
                    this.worldSize,
                    this.worldSize,
                    this.worldSize / r,
                    1
                ]), this.projMatrix = a, this.invProjMatrix = e1.invert(new Float64Array(16), this.projMatrix);
                const l = e1.invert([], s);
                this.frustumCorners = e1.FrustumCorners.fromInvProjectionMatrix(l, this.horizonLineFromTop(), this.height);
                const c = new Float32Array(16);
                e1.identity(c), e1.scale(c, c, [
                    1,
                    -1,
                    1
                ]), e1.rotateX(c, c, this._pitch), e1.rotateZ(c, c, this.angle);
                const h = e1.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), u = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                h[8] = 2 * -t1.x / this.width, h[9] = 2 * (t1.y + u) / this.height, this.skyboxMatrix = e1.multiply(c, h, c);
                const _ = this.point, d = _.x, p = _.y, m = this.width % 2 / 2, f = this.height % 2 / 2, g = Math.cos(this.angle), x = Math.sin(this.angle), y = d - Math.round(d) + g * m + x * f, b = p - Math.round(p) + g * f + x * m, w = new Float64Array(a);
                if (e1.translate(w, w, [
                    y > .5 ? y - 1 : y,
                    b > .5 ? b - 1 : b,
                    0
                ]), this.alignedProjMatrix = w, a = e1.create(), e1.scale(a, a, [
                    this.width / 2,
                    -this.height / 2,
                    1
                ]), e1.translate(a, a, [
                    1,
                    -1,
                    0
                ]), this.labelPlaneMatrix = a, a = e1.create(), e1.scale(a, a, [
                    1,
                    -1,
                    1
                ]), e1.translate(a, a, [
                    -1,
                    -1,
                    0
                ]), e1.scale(a, a, [
                    2 / this.width,
                    2 / this.height,
                    1
                ]), this.glCoordMatrix = a, this.pixelMatrix = e1.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a = e1.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = a, "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = e1.calculateGlobeMatrix(this);
                    const t1 = [
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ];
                    this.globeCenterInViewSpace = e1.transformMat4(t1, t1, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else this.globeMatrix = a;
                this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const t1 = this.cameraWorldSizeForFog, i = this.cameraPixelsPerMeter, o = this._camera.position, r = 1 / this.height / this._pixelsPerMercatorPixel, n = [
                    t1,
                    t1,
                    i
                ];
                e1.scale$2(n, n, r), e1.scale$2(o, o, -1), e1.multiply$2(o, o, n);
                const s = e1.create();
                e1.translate(s, s, o), e1.scale(s, s, n), this.mercatorFogMatrix = s, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t1, i, r);
            }
            _computeCameraPosition(e1) {
                const t1 = (e1 = e1 || this.pixelsPerMeter) / this.pixelsPerMeter, i = this._camera.forward(), o = this.point, r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t1 - e1 / this.worldSize * this._centerAltitude;
                return [
                    o.x / this.worldSize - i[0] * r,
                    o.y / this.worldSize - i[1] * r,
                    e1 / this.worldSize * this._centerAltitude - i[2] * r
                ];
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t1) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o = this._camera.position[2], r = t1[2];
                let n = 1;
                this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (n = Math.min((i - o) / r, 1)), this._camera.position = e1.scaleAndAdd([], this._camera.position, t1, n), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
                const t1 = this._camera.position, i = this._camera.forward(), { pitch: o , bearing: r  } = this._camera.getPitchBearing(), n = e1.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e1.degToRad(this._maxPitch)), a = Math.max((t1[2] - n) / Math.cos(o), s), l = this._zoomFromMercatorZ(a);
                e1.scaleAndAdd(t1, t1, i, a), this._pitch = e1.clamp(o, e1.degToRad(this.minPitch), e1.degToRad(this.maxPitch)), this.angle = e1.wrap(r, -Math.PI, Math.PI), this._setZoom(e1.clamp(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e1.MercatorCoordinate(t1[0], t1[1], t1[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e1) {
                return Math.pow(2, e1) * this.tileSize;
            }
            _mercatorZfromZoom(e1) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(e1);
            }
            _minimumHeightOverTerrain() {
                const e1 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
                return this._mercatorZfromZoom(e1);
            }
            _zoomFromMercatorZ(e1) {
                return this.scaleZoom(this.cameraToCenterDistance / (e1 * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t1) {
                let i = 0, o = e1.GLOBE_ZOOM_THRESHOLD_MAX, r = 0, n = 1 / 0;
                for(; o - i > 1e-6 && o > i;){
                    const e1 = i + .5 * (o - i), s = this.tileSize * Math.pow(2, e1), a = this.getCameraToCenterDistance(this.projection, e1, s), l = this.scaleZoom(a / (t1 * this.tileSize)), c = Math.abs(e1 - l);
                    c < n && (n = c, r = e1), e1 < l ? i = e1 : o = e1;
                }
                return r;
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (e1.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t1, i) {
                const o = Math.min(t1.x, i.x), r = Math.max(t1.x, i.x), n = Math.min(t1.y, i.y), s = Math.max(t1.y, i.y);
                if (n < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const a = [
                    new e1.pointGeometry(o, n),
                    new e1.pointGeometry(r, s),
                    new e1.pointGeometry(o, s),
                    new e1.pointGeometry(r, n)
                ], l = this.renderWorldCopies ? -3 : 0, c = this.renderWorldCopies ? 4 : 1;
                for (const e1 of a){
                    const t1 = this.pointRayIntersection(e1);
                    if (t1.t < 0) return !0;
                    const i = this.rayIntersectionCoordinate(t1);
                    if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
                }
                return !1;
            }
            isHorizonVisible() {
                return this.pitch + e1.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e1.pointGeometry(0, 0), new e1.pointGeometry(this.width, this.height));
            }
            zoomDeltaToMovement(t1, i) {
                const o = e1.length(e1.sub([], this._camera.position, t1)), r = this._zoomFromMercatorZ(o) + i;
                return o - this._mercatorZfromZoom(r);
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const t1 = function([t1, i, o], r) {
                        const n = [
                            t1,
                            i,
                            o,
                            1
                        ];
                        e1.transformMat4$1(n, n, r);
                        const s = n[3] = Math.max(n[3], 1e-6);
                        return n[0] /= s, n[1] /= s, n[2] /= s, n;
                    }([
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ], this.pixelMatrix);
                    return new e1.pointGeometry(t1[0], t1[1]);
                }
                {
                    const t1 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new e1.pointGeometry(0, t1));
                }
            }
            getCameraToCenterDistance(e1, t1 = this.zoom, i = this.worldSize) {
                const o = qo(e1, t1, this.width, this.height, 1024), r = e1.pixelSpaceConversion(this.center.lat, i, o);
                return .5 / Math.tan(.5 * this._fov) * this.height * r;
            }
            getWorldToCameraMatrix() {
                const t1 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                return "globe" === this.projection.name && e1.multiply(t1, t1, this.globeMatrix), t1;
            }
        }
        function Jo(e1, t1) {
            let i = !1, o = null;
            const r = ()=>{
                o = null, i && (e1(), o = setTimeout(r, t1), i = !1);
            };
            return ()=>(i = !0, o || r(), o);
        }
        class Qo {
            constructor(t1){
                this._hashName = t1 && encodeURIComponent(t1), e1.bindAll([
                    "_getCurrentHash",
                    "_onHashChange",
                    "_updateHash"
                ], this), this._updateHash = Jo(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(t1) {
                return this._map = t1, e1.window.addEventListener("hashchange", this._onHashChange, !1), t1.on("moveend", this._updateHash), this;
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash), e1.window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
                const t1 = this._map;
                if (!t1) return "";
                const i = er(t1);
                if (this._hashName) {
                    const t1 = this._hashName;
                    let o = !1;
                    const r = e1.window.location.hash.slice(1).split("&").map((e1)=>{
                        const r = e1.split("=")[0];
                        return r === t1 ? (o = !0, `${r}=${i}`) : e1;
                    }).filter((e1)=>e1);
                    return o || r.push(`${t1}=${i}`), `#${r.join("&")}`;
                }
                return `#${i}`;
            }
            _getCurrentHash() {
                const t1 = e1.window.location.hash.replace("#", "");
                if (this._hashName) {
                    let e1;
                    return t1.split("&").map((e1)=>e1.split("=")).forEach((t1)=>{
                        t1[0] === this._hashName && (e1 = t1);
                    }), (e1 && e1[1] || "").split("/");
                }
                return t1.split("/");
            }
            _onHashChange() {
                const e1 = this._map;
                if (!e1) return !1;
                const t1 = this._getCurrentHash();
                if (t1.length >= 3 && !t1.some((e1)=>isNaN(e1))) {
                    const i = e1.dragRotate.isEnabled() && e1.touchZoomRotate.isEnabled() ? +(t1[3] || 0) : e1.getBearing();
                    return e1.jumpTo({
                        center: [
                            +t1[2],
                            +t1[1]
                        ],
                        zoom: +t1[0],
                        bearing: i,
                        pitch: +(t1[4] || 0)
                    }), !0;
                }
                return !1;
            }
            _updateHashUnthrottled() {
                const t1 = e1.window.location.href.replace(/(#.+)?$/, this.getHashString());
                e1.window.history.replaceState(e1.window.history.state, null, t1);
            }
        }
        function er(e1, t1) {
            const i = e1.getCenter(), o = Math.round(100 * e1.getZoom()) / 100, r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), n = Math.pow(10, r), s = Math.round(i.lng * n) / n, a = Math.round(i.lat * n) / n, l = e1.getBearing(), c = e1.getPitch();
            let h = t1 ? `/${s}/${a}/${o}` : `${o}/${a}/${s}`;
            return (l || c) && (h += "/" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;
        }
        const tr = {
            linearity: .3,
            easing: e1.bezier(0, 0, .3, 1)
        }, ir = e1.extend({
            deceleration: 2500,
            maxSpeed: 1400
        }, tr), or = e1.extend({
            deceleration: 20,
            maxSpeed: 1400
        }, tr), rr = e1.extend({
            deceleration: 1e3,
            maxSpeed: 360
        }, tr), nr = e1.extend({
            deceleration: 1e3,
            maxSpeed: 90
        }, tr);
        class sr {
            constructor(e1){
                this._map = e1, this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(t1) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({
                    time: e1.exported.now(),
                    settings: t1
                });
            }
            _drainInertiaBuffer() {
                const t1 = this._inertiaBuffer, i = e1.exported.now();
                for(; t1.length > 0 && i - t1[0].time > 160;)t1.shift();
            }
            _onMoveEnd(t1) {
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new e1.pointGeometry(0, 0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const { settings: e1  } of this._inertiaBuffer)i.zoom += e1.zoomDelta || 0, i.bearing += e1.bearingDelta || 0, i.pitch += e1.pitchDelta || 0, e1.panDelta && i.pan._add(e1.panDelta), e1.around && (i.around = e1.around), e1.pinchAround && (i.pinchAround = e1.pinchAround);
                const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r = {};
                if (i.pan.mag()) {
                    const n = lr(i.pan.mag(), o, e1.extend({}, ir, t1 || {}));
                    r.offset = i.pan.mult(n.amount / i.pan.mag()), r.center = this._map.transform.center, ar(r, n);
                }
                if (i.zoom) {
                    const e1 = lr(i.zoom, o, or);
                    r.zoom = this._map.transform.zoom + e1.amount, ar(r, e1);
                }
                if (i.bearing) {
                    const t1 = lr(i.bearing, o, rr);
                    r.bearing = this._map.transform.bearing + e1.clamp(t1.amount, -179, 179), ar(r, t1);
                }
                if (i.pitch) {
                    const e1 = lr(i.pitch, o, nr);
                    r.pitch = this._map.transform.pitch + e1.amount, ar(r, e1);
                }
                if (r.zoom || r.bearing) {
                    const e1 = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    r.around = e1 ? this._map.unproject(e1) : this._map.getCenter();
                }
                return this.clear(), r.noMoveStart = !0, r;
            }
        }
        function ar(e1, t1) {
            (!e1.duration || e1.duration < t1.duration) && (e1.duration = t1.duration, e1.easing = t1.easing);
        }
        function lr(t1, i, o) {
            const { maxSpeed: r , linearity: n , deceleration: s  } = o, a = e1.clamp(t1 * n / (i / 1e3), -r, r), l = Math.abs(a) / (s * n);
            return {
                easing: o.easing,
                duration: 1e3 * l,
                amount: a * (l / 2)
            };
        }
        class cr extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o, r = {}){
                const n = p(i.getCanvasContainer(), o), s = i.unproject(n);
                super(t1, e1.extend({
                    point: n,
                    lngLat: s,
                    originalEvent: o
                }, r)), this._defaultPrevented = !1, this.target = i;
            }
        }
        class hr extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o){
                const r = "touchend" === t1 ? o.changedTouches : o.touches, n = m(i.getCanvasContainer(), r), s = n.map((e1)=>i.unproject(e1)), a = n.reduce((e1, t1, i, o)=>e1.add(t1.div(o.length)), new e1.pointGeometry(0, 0));
                super(t1, {
                    points: n,
                    point: a,
                    lngLats: s,
                    lngLat: i.unproject(a),
                    originalEvent: o
                }), this._defaultPrevented = !1;
            }
        }
        class ur extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(e1, t1, i){
                super(e1, {
                    originalEvent: i
                }), this._defaultPrevented = !1;
            }
        }
        class _r {
            constructor(e1, t1){
                this._map = e1, this._clickTolerance = t1.clickTolerance;
            }
            reset() {
                this._mousedownPos = void 0;
            }
            wheel(e1) {
                return this._firePreventable(new ur(e1.type, this._map, e1));
            }
            mousedown(e1, t1) {
                return this._mousedownPos = t1, this._firePreventable(new cr(e1.type, this._map, e1));
            }
            mouseup(e1) {
                this._map.fire(new cr(e1.type, this._map, e1));
            }
            preclick(t1) {
                const i = e1.extend({}, t1);
                i.type = "preclick", this._map.fire(new cr(i.type, this._map, i));
            }
            click(e1, t1) {
                this._mousedownPos && this._mousedownPos.dist(t1) >= this._clickTolerance || (this.preclick(e1), this._map.fire(new cr(e1.type, this._map, e1)));
            }
            dblclick(e1) {
                return this._firePreventable(new cr(e1.type, this._map, e1));
            }
            mouseover(e1) {
                this._map.fire(new cr(e1.type, this._map, e1));
            }
            mouseout(e1) {
                this._map.fire(new cr(e1.type, this._map, e1));
            }
            touchstart(e1) {
                return this._firePreventable(new hr(e1.type, this._map, e1));
            }
            touchmove(e1) {
                this._map.fire(new hr(e1.type, this._map, e1));
            }
            touchend(e1) {
                this._map.fire(new hr(e1.type, this._map, e1));
            }
            touchcancel(e1) {
                this._map.fire(new hr(e1.type, this._map, e1));
            }
            _firePreventable(e1) {
                if (this._map.fire(e1), e1.defaultPrevented) return {};
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class dr {
            constructor(e1){
                this._map = e1;
            }
            reset() {
                this._delayContextMenu = !1, this._contextMenuEvent = void 0;
            }
            mousemove(e1) {
                this._map.fire(new cr(e1.type, this._map, e1));
            }
            mousedown() {
                this._delayContextMenu = !0;
            }
            mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new cr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e1) {
                this._delayContextMenu ? this._contextMenuEvent = e1 : this._map.fire(new cr(e1.type, this._map, e1)), this._map.listens("contextmenu") && e1.preventDefault();
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class pr {
            constructor(e1, t1){
                this._map = e1, this._el = e1.getCanvasContainer(), this._container = e1.getContainer(), this._clickTolerance = t1.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(e1, t1) {
                this.isEnabled() && e1.shiftKey && 0 === e1.button && (h(), this._startPos = this._lastPos = t1, this._active = !0);
            }
            mousemoveWindow(e1, t1) {
                if (!this._active) return;
                const i = t1, o = this._startPos, r = this._lastPos;
                if (!o || !r || r.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;
                this._lastPos = i, this._box || (this._box = n("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e1));
                const s = Math.min(o.x, i.x), a = Math.max(o.x, i.x), l = Math.min(o.y, i.y), c = Math.max(o.y, i.y);
                this._map._requestDomTask(()=>{
                    this._box && (this._box.style.transform = `translate(${s}px,${l}px)`, this._box.style.width = a - s + "px", this._box.style.height = c - l + "px");
                });
            }
            mouseupWindow(t1, i) {
                if (!this._active) return;
                const o = this._startPos, r = i;
                if (o && 0 === t1.button) {
                    if (this.reset(), d(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e1.Event("boxzoomend", {
                        originalEvent: t1
                    })), {
                        cameraAnimation: (e1)=>e1.fitScreenCoordinates(o, r, this._map.getBearing(), {
                                linear: !1
                            })
                    };
                    this._fireEvent("boxzoomcancel", t1);
                }
            }
            keydown(e1) {
                this._active && 27 === e1.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e1));
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t1, i) {
                return this._map.fire(new e1.Event(t1, {
                    originalEvent: i
                }));
            }
        }
        function mr(e1, t1) {
            const i = {};
            for(let o = 0; o < e1.length; o++)i[e1[o].identifier] = t1[o];
            return i;
        }
        class fr {
            constructor(e1){
                this.reset(), this.numTouches = e1.numTouches;
            }
            reset() {
                this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
            }
            touchstart(t1, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t1.timeStamp), o.length === this.numTouches && (this.centroid = function(t1) {
                    const i = new e1.pointGeometry(0, 0);
                    for (const e1 of t1)i._add(e1);
                    return i.div(t1.length);
                }(i), this.touches = mr(o, i)));
            }
            touchmove(e1, t1, i) {
                if (this.aborted || !this.centroid) return;
                const o = mr(i, t1);
                for(const e1 in this.touches){
                    const t1 = this.touches[e1], i = o[e1];
                    (!i || i.dist(t1) > 30) && (this.aborted = !0);
                }
            }
            touchend(e1, t1, i) {
                if ((!this.centroid || e1.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const e1 = !this.aborted && this.centroid;
                    if (this.reset(), e1) return e1;
                }
            }
        }
        class gr {
            constructor(e1){
                this.singleTap = new fr(e1), this.numTaps = e1.numTaps, this.reset();
            }
            reset() {
                this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e1, t1, i) {
                this.singleTap.touchstart(e1, t1, i);
            }
            touchmove(e1, t1, i) {
                this.singleTap.touchmove(e1, t1, i);
            }
            touchend(e1, t1, i) {
                const o = this.singleTap.touchend(e1, t1, i);
                if (o) {
                    const t1 = e1.timeStamp - this.lastTime < 500, i = !this.lastTap || this.lastTap.dist(o) < 30;
                    if (t1 && i || this.reset(), this.count++, this.lastTime = e1.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                }
            }
        }
        class vr {
            constructor(){
                this._zoomIn = new gr({
                    numTouches: 1,
                    numTaps: 2
                }), this._zoomOut = new gr({
                    numTouches: 2,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e1, t1, i) {
                this._zoomIn.touchstart(e1, t1, i), this._zoomOut.touchstart(e1, t1, i);
            }
            touchmove(e1, t1, i) {
                this._zoomIn.touchmove(e1, t1, i), this._zoomOut.touchmove(e1, t1, i);
            }
            touchend(e1, t1, i) {
                const o = this._zoomIn.touchend(e1, t1, i), r = this._zoomOut.touchend(e1, t1, i);
                return o ? (this._active = !0, e1.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() + 1,
                            around: t1.unproject(o)
                        }, {
                            originalEvent: e1
                        })
                }) : r ? (this._active = !0, e1.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() - 1,
                            around: t1.unproject(r)
                        }, {
                            originalEvent: e1
                        })
                }) : void 0;
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        const xr = {
            0: 1,
            2: 2
        };
        class yr {
            constructor(e1){
                this.reset(), this._clickTolerance = e1.clickTolerance || 1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e1, t1) {
                return !1;
            }
            _move(e1, t1) {
                return {};
            }
            mousedown(e1, t1) {
                if (this._lastPoint) return;
                const i = f(e1);
                this._correctButton(e1, i) && (this._lastPoint = t1, this._eventButton = i);
            }
            mousemoveWindow(e1, t1) {
                const i = this._lastPoint;
                if (i) {
                    if (e1.preventDefault(), null != this._eventButton && function(e1, t1) {
                        const i = xr[t1];
                        return void 0 === e1.buttons || (e1.buttons & i) !== i;
                    }(e1, this._eventButton)) this.reset();
                    else if (this._moved || !(t1.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t1, this._move(i, t1);
                }
            }
            mouseupWindow(e1) {
                this._lastPoint && f(e1) === this._eventButton && (this._moved && d(), this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class br extends yr {
            mousedown(e1, t1) {
                super.mousedown(e1, t1), this._lastPoint && (this._active = !0);
            }
            _correctButton(e1, t1) {
                return 0 === t1 && !e1.ctrlKey;
            }
            _move(e1, t1) {
                return {
                    around: t1,
                    panDelta: t1.sub(e1)
                };
            }
        }
        class wr extends yr {
            _correctButton(e1, t1) {
                return 0 === t1 && e1.ctrlKey || 2 === t1;
            }
            _move(e1, t1) {
                const i = .8 * (t1.x - e1.x);
                if (i) return this._active = !0, {
                    bearingDelta: i
                };
            }
            contextmenu(e1) {
                e1.preventDefault();
            }
        }
        class Tr extends yr {
            _correctButton(e1, t1) {
                return 0 === t1 && e1.ctrlKey || 2 === t1;
            }
            _move(e1, t1) {
                const i = -0.5 * (t1.y - e1.y);
                if (i) return this._active = !0, {
                    pitchDelta: i
                };
            }
            contextmenu(e1) {
                e1.preventDefault();
            }
        }
        class Er {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e1.bindAll([
                    "_addTouchPanBlocker",
                    "_showTouchPanBlockerAlert"
                ], this);
            }
            reset() {
                this._active = !1, this._touches = {}, this._sum = new e1.pointGeometry(0, 0);
            }
            touchstart(e1, t1, i) {
                return this._calculateTransform(e1, t1, i);
            }
            touchmove(t1, i, o) {
                if (this._active && !(o.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === o.length && !e1.isFullscreen()) return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }
                    return t1.cancelable && t1.preventDefault(), this._calculateTransform(t1, i, o);
                }
            }
            touchend(e1, t1, i) {
                this._calculateTransform(e1, t1, i), this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(t1, i, o) {
                o.length > 0 && (this._active = !0);
                const r = mr(o, i), n = new e1.pointGeometry(0, 0), s = new e1.pointGeometry(0, 0);
                let a = 0;
                for(const e1 in r){
                    const t1 = r[e1], i = this._touches[e1];
                    i && (n._add(t1), s._add(t1.sub(i)), a++, r[e1] = t1);
                }
                if (this._touches = r, a < this._minTouches || !s.mag()) return;
                const l = s.div(a);
                return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: n.div(a),
                    panDelta: l
                };
            }
            enable() {
                this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
                this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
                }, 500);
            }
        }
        class Cr {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1, this._firstTwoTouches = void 0;
            }
            _start(e1) {}
            _move(e1, t1, i) {
                return {};
            }
            touchstart(e1, t1, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [
                    i[0].identifier,
                    i[1].identifier
                ], this._start([
                    t1[0],
                    t1[1]
                ]));
            }
            touchmove(e1, t1, i) {
                const o = this._firstTwoTouches;
                if (!o) return;
                e1.preventDefault();
                const [r, n] = o, s = Mr(i, t1, r), a = Mr(i, t1, n);
                if (!s || !a) return;
                const l = this._aroundCenter ? null : s.add(a).div(2);
                return this._move([
                    s,
                    a
                ], l, e1);
            }
            touchend(e1, t1, i) {
                if (!this._firstTwoTouches) return;
                const [o, r] = this._firstTwoTouches, n = Mr(i, t1, o), s = Mr(i, t1, r);
                n && s || (this._active && d(), this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(e1) {
                this._enabled = !0, this._aroundCenter = !!e1 && "center" === e1.around;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        function Mr(e1, t1, i) {
            for(let o = 0; o < e1.length; o++)if (e1[o].identifier === i) return t1[o];
        }
        function Ir(e1, t1) {
            return Math.log(e1 / t1) / Math.LN2;
        }
        class Sr extends Cr {
            reset() {
                super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e1) {
                this._startDistance = this._distance = e1[0].dist(e1[1]);
            }
            _move(e1, t1) {
                const i = this._distance;
                if (this._distance = e1[0].dist(e1[1]), this._active || !(Math.abs(Ir(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                    zoomDelta: Ir(this._distance, i),
                    pinchAround: t1
                };
            }
        }
        function Dr(e1, t1) {
            return 180 * e1.angleWith(t1) / Math.PI;
        }
        class Lr extends Cr {
            reset() {
                super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e1) {
                this._startVector = this._vector = e1[0].sub(e1[1]), this._minDiameter = e1[0].dist(e1[1]);
            }
            _move(e1, t1) {
                const i = this._vector;
                if (this._vector = e1[0].sub(e1[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
                    bearingDelta: Dr(this._vector, i),
                    pinchAround: t1
                };
            }
            _isBelowThreshold(e1) {
                this._minDiameter = Math.min(this._minDiameter, e1.mag());
                const t1 = 25 / (Math.PI * this._minDiameter) * 360, i = this._startVector;
                if (!i) return !1;
                const o = Dr(e1, i);
                return Math.abs(o) < t1;
            }
        }
        function Ar(e1) {
            return Math.abs(e1.y) > Math.abs(e1.x);
        }
        class zr extends Cr {
            constructor(e1){
                super(), this._map = e1;
            }
            reset() {
                super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e1) {
                this._lastPoints = e1, Ar(e1[0].sub(e1[1])) && (this._valid = !1);
            }
            _move(t1, i, o) {
                const r = this._lastPoints;
                if (!r) return;
                const n = t1[0].sub(r[0]), s = t1[1].sub(r[1]);
                return this._map._cooperativeGestures && !e1.isFullscreen() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n, s, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t1, this._active = !0, {
                    pitchDelta: (n.y + s.y) / 2 * -0.5
                });
            }
            gestureBeginsVertically(e1, t1, i) {
                if (void 0 !== this._valid) return this._valid;
                const o = e1.mag() >= 2, r = t1.mag() >= 2;
                if (!o && !r) return;
                if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
                const n = e1.y > 0 == t1.y > 0;
                return Ar(e1) && Ar(t1) && n;
            }
        }
        const Pr = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class Rr {
            constructor(){
                const e1 = Pr;
                this._panStep = e1.panStep, this._bearingStep = e1.bearingStep, this._pitchStep = e1.pitchStep, this._rotationDisabled = !1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            keydown(e1) {
                if (e1.altKey || e1.ctrlKey || e1.metaKey) return;
                let t1 = 0, i = 0, o = 0, r = 0, n = 0;
                switch(e1.keyCode){
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        t1 = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        t1 = -1;
                        break;
                    case 37:
                        e1.shiftKey ? i = -1 : (e1.preventDefault(), r = -1);
                        break;
                    case 39:
                        e1.shiftKey ? i = 1 : (e1.preventDefault(), r = 1);
                        break;
                    case 38:
                        e1.shiftKey ? o = 1 : (e1.preventDefault(), n = -1);
                        break;
                    case 40:
                        e1.shiftKey ? o = -1 : (e1.preventDefault(), n = 1);
                        break;
                    default:
                        return;
                }
                return this._rotationDisabled && (i = 0, o = 0), {
                    cameraAnimation: (s)=>{
                        const a = s.getZoom();
                        s.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: Or,
                            zoom: t1 ? Math.round(a) + t1 * (e1.shiftKey ? 2 : 1) : a,
                            bearing: s.getBearing() + i * this._bearingStep,
                            pitch: s.getPitch() + o * this._pitchStep,
                            offset: [
                                -r * this._panStep,
                                -n * this._panStep
                            ],
                            center: s.getCenter()
                        }, {
                            originalEvent: e1
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function Or(e1) {
            return e1 * (2 - e1);
        }
        const Br = 4.000244140625;
        class kr {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e1.bindAll([
                    "_onTimeout",
                    "_addScrollZoomBlocker",
                    "_showBlockerAlert"
                ], this);
            }
            setZoomRate(e1) {
                this._defaultZoomRate = e1;
            }
            setWheelZoomRate(e1) {
                this._wheelZoomRate = e1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
                return !!this._zooming;
            }
            enable(e1) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e1 && "center" === e1.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
                this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t1) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                    if (!(t1.ctrlKey || t1.metaKey || this.isZooming() || e1.isFullscreen())) return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                let i = t1.deltaMode === e1.window.WheelEvent.DOM_DELTA_LINE ? 40 * t1.deltaY : t1.deltaY;
                const o = e1.exported.now(), r = o - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = o, 0 !== i && i % Br == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t1)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t1.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t1, this._delta -= i, this._active || this._start(t1)), t1.preventDefault();
            }
            _onTimeout(e1) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e1);
            }
            _start(e1) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                const t1 = p(this._el, e1);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t1, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId) return;
                if (this._frameId = null, !this.isActive()) return;
                const t1 = this._map.transform;
                "wheel" === this._type && t1.projection.wrap && (t1._center.lng >= 180 || t1._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
                const i = ()=>t1._terrainEnabled() && this._aroundCoord ? t1.computeZoomRelativeTo(this._aroundCoord) : t1.zoom;
                if (0 !== this._delta) {
                    const e1 = "wheel" === this._type && Math.abs(this._delta) > Br ? this._wheelZoomRate : this._defaultZoomRate;
                    let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e1)));
                    this._delta < 0 && 0 !== o && (o = 1 / o);
                    const r = i(), n = Math.pow(2, r), s = "number" == typeof this._targetZoom ? t1.zoomScale(this._targetZoom) : n;
                    this._targetZoom = Math.min(t1.maxZoom, Math.max(t1.minZoom, t1.scaleZoom(s * o))), "wheel" === this._type && (this._startZoom = r, this._easing = this._smoothOutEasing(200)), this._delta = 0;
                }
                const o = "number" == typeof this._targetZoom ? this._targetZoom : i(), r = this._startZoom, n = this._easing;
                let s, a = !1;
                if ("wheel" === this._type && r && n) {
                    const t1 = Math.min((e1.exported.now() - this._lastWheelEventTime) / 200, 1), i = n(t1);
                    s = e1.number(r, o, i), t1 < 1 ? this._frameId || (this._frameId = !0) : a = !0;
                } else s = o, a = !0;
                return this._active = !0, a && (this._active = !1, this._finishTimeout = setTimeout(()=>{
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200)), {
                    noInertia: !0,
                    needsRenderFrame: !a,
                    zoomDelta: s - i(),
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                };
            }
            _smoothOutEasing(t1) {
                let i = e1.ease;
                if (this._prevEase) {
                    const t1 = this._prevEase, o = (e1.exported.now() - t1.start) / t1.duration, r = t1.easing(o + .01) - t1.easing(o), n = .27 / Math.sqrt(r * r + 1e-4) * .01, s = Math.sqrt(.0729 - n * n);
                    i = e1.bezier(n, s, .25, 1);
                }
                return this._prevEase = {
                    start: e1.exported.now(),
                    duration: t1,
                    easing: i
                }, i;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e1.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
                }, 200);
            }
        }
        class Fr {
            constructor(e1, t1){
                this._clickZoom = e1, this._tapZoom = t1;
            }
            enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }
        class Ur {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            blur() {
                this.reset();
            }
            dblclick(e1, t1) {
                return e1.preventDefault(), {
                    cameraAnimation: (i)=>{
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (e1.shiftKey ? -1 : 1),
                            around: i.unproject(t1)
                        }, {
                            originalEvent: e1
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Nr {
            constructor(){
                this._tap = new gr({
                    numTouches: 1,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e1, t1, i) {
                this._swipePoint || (this._tapTime && e1.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t1[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e1, t1, i));
            }
            touchmove(e1, t1, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;
                        const o = t1[0], r = o.y - this._swipePoint.y;
                        return this._swipePoint = o, e1.preventDefault(), this._active = !0, {
                            zoomDelta: r / 128
                        };
                    }
                } else this._tap.touchmove(e1, t1, i);
            }
            touchend(e1, t1, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e1, t1, i) && (this._tapTime = e1.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Gr {
            constructor(e1, t1, i){
                this._el = e1, this._mousePan = t1, this._touchPan = i;
            }
            enable(e1) {
                this._inertiaOptions = e1 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }
        class jr {
            constructor(e1, t1, i){
                this._pitchWithRotate = e1.pitchWithRotate, this._mouseRotate = t1, this._mousePitch = i;
            }
            enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }
        class Zr {
            constructor(e1, t1, i, o){
                this._el = e1, this._touchZoom = t1, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
            }
            enable(e1) {
                this._touchZoom.enable(e1), this._rotationDisabled || this._touchRotate.enable(e1), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const Vr = (e1)=>e1.zoom || e1.drag || e1.pitch || e1.rotate;
        class Wr extends e1.Event {
        }
        class Xr {
            constructor(){
                this.constants = [
                    1,
                    1,
                    .01
                ], this.radius = 0;
            }
            setup(t1, i) {
                const o = e1.sub([], i, t1);
                this.radius = e1.length(o[2] < 0 ? e1.div([], o, this.constants) : [
                    o[0],
                    o[1],
                    0
                ]);
            }
            projectRay(t1) {
                e1.div(t1, t1, this.constants), e1.normalize(t1, t1), e1.mul$1(t1, t1, this.constants);
                const i = e1.scale$2([], t1, this.radius);
                if (i[2] > 0) {
                    const t1 = e1.scale$2([], [
                        0,
                        0,
                        1
                    ], e1.dot(i, [
                        0,
                        0,
                        1
                    ])), o = e1.scale$2([], e1.normalize([], [
                        i[0],
                        i[1],
                        0
                    ]), this.radius), r = e1.add([], i, e1.scale$2([], e1.sub([], e1.add([], o, t1), i), 2));
                    i[0] = r[0], i[1] = r[1];
                }
                return i;
            }
        }
        function qr(e1) {
            return e1.panDelta && e1.panDelta.mag() || e1.zoomDelta || e1.bearingDelta || e1.pitchDelta;
        }
        class $r {
            constructor(t1, i){
                this._map = t1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new sr(t1), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Xr, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e1.bindAll([
                    "handleEvent",
                    "handleWindowEvent"
                ], this);
                const o = this._el;
                this._listeners = [
                    [
                        o,
                        "touchstart",
                        {
                            passive: !0
                        }
                    ],
                    [
                        o,
                        "touchmove",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "touchend",
                        void 0
                    ],
                    [
                        o,
                        "touchcancel",
                        void 0
                    ],
                    [
                        o,
                        "mousedown",
                        void 0
                    ],
                    [
                        o,
                        "mousemove",
                        void 0
                    ],
                    [
                        o,
                        "mouseup",
                        void 0
                    ],
                    [
                        e1.window.document,
                        "mousemove",
                        {
                            capture: !0
                        }
                    ],
                    [
                        e1.window.document,
                        "mouseup",
                        void 0
                    ],
                    [
                        o,
                        "mouseover",
                        void 0
                    ],
                    [
                        o,
                        "mouseout",
                        void 0
                    ],
                    [
                        o,
                        "dblclick",
                        void 0
                    ],
                    [
                        o,
                        "click",
                        void 0
                    ],
                    [
                        o,
                        "keydown",
                        {
                            capture: !1
                        }
                    ],
                    [
                        o,
                        "keyup",
                        void 0
                    ],
                    [
                        o,
                        "wheel",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "contextmenu",
                        void 0
                    ],
                    [
                        e1.window,
                        "blur",
                        void 0
                    ]
                ];
                for (const [t1, i, o] of this._listeners)t1.addEventListener(i, t1 === e1.window.document ? this.handleWindowEvent : this.handleEvent, o);
            }
            destroy() {
                for (const [t1, i, o] of this._listeners)t1.removeEventListener(i, t1 === e1.window.document ? this.handleWindowEvent : this.handleEvent, o);
            }
            _addDefaultHandlers(e1) {
                const t1 = this._map, i = t1.getCanvasContainer();
                this._add("mapEvent", new _r(t1, e1));
                const o = t1.boxZoom = new pr(t1, e1);
                this._add("boxZoom", o);
                const r = new vr, n = new Ur;
                t1.doubleClickZoom = new Fr(n, r), this._add("tapZoom", r), this._add("clickZoom", n);
                const s = new Nr;
                this._add("tapDragZoom", s);
                const a = t1.touchPitch = new zr(t1);
                this._add("touchPitch", a);
                const l = new wr(e1), c = new Tr(e1);
                t1.dragRotate = new jr(e1, l, c), this._add("mouseRotate", l, [
                    "mousePitch"
                ]), this._add("mousePitch", c, [
                    "mouseRotate"
                ]);
                const h = new br(e1), u = new Er(t1, e1);
                t1.dragPan = new Gr(i, h, u), this._add("mousePan", h), this._add("touchPan", u, [
                    "touchZoom",
                    "touchRotate"
                ]);
                const _ = new Lr, d = new Sr;
                t1.touchZoomRotate = new Zr(i, d, _, s), this._add("touchRotate", _, [
                    "touchPan",
                    "touchZoom"
                ]), this._add("touchZoom", d, [
                    "touchPan",
                    "touchRotate"
                ]), this._add("blockableMapEvent", new dr(t1));
                const p = t1.scrollZoom = new kr(t1, this);
                this._add("scrollZoom", p, [
                    "mousePan"
                ]);
                const m = t1.keyboard = new Rr;
                this._add("keyboard", m);
                for (const i of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard"
                ])e1.interactive && e1[i] && t1[i].enable(e1[i]);
            }
            _add(e1, t1, i) {
                this._handlers.push({
                    handlerName: e1,
                    handler: t1,
                    allowed: i
                }), this._handlersById[e1] = t1;
            }
            stop(e1) {
                if (!this._updatingCamera) {
                    for (const { handler: e1  } of this._handlers)e1.reset();
                    this._inertia.clear(), this._fireEvents({}, {}, e1), this._changes = [];
                }
            }
            isActive() {
                for (const { handler: e1  } of this._handlers)if (e1.isActive()) return !0;
                return !1;
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
                return !!this._eventsInProgress.rotate;
            }
            isMoving() {
                return !!Vr(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
                return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e1, t1, i) {
                for(const o in e1)if (o !== i && (!t1 || t1.indexOf(o) < 0)) return !0;
                return !1;
            }
            handleWindowEvent(e1) {
                this.handleEvent(e1, `${e1.type}Window`);
            }
            _getMapTouches(e1) {
                const t1 = [];
                for (const i of e1)this._el.contains(i.target) && t1.push(i);
                return t1;
            }
            handleEvent(e1, t1) {
                this._updatingCamera = !0;
                const i = "renderFrame" === e1.type, o = i ? void 0 : e1, r = {
                    needsRenderFrame: !1
                }, n = {}, s = {}, a = e1.touches ? this._getMapTouches(e1.touches) : void 0, l = a ? m(this._el, a) : i ? void 0 : p(this._el, e1);
                for (const { handlerName: i , handler: c , allowed: h  } of this._handlers){
                    if (!c.isEnabled()) continue;
                    let u;
                    this._blockedByActive(s, h, i) ? c.reset() : c[t1 || e1.type] && (u = c[t1 || e1.type](e1, l, a), this.mergeHandlerResult(r, n, u, i, o), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || c.isActive()) && (s[i] = c);
                }
                const c = {};
                for(const e1 in this._previousActiveHandlers)s[e1] || (c[e1] = o);
                this._previousActiveHandlers = s, (Object.keys(c).length || qr(r)) && (this._changes.push([
                    r,
                    n,
                    c
                ]), this._triggerRenderFrame()), (Object.keys(s).length || qr(r)) && this._map._stop(!0), this._updatingCamera = !1;
                const { cameraAnimation: h  } = r;
                h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
            }
            mergeHandlerResult(t1, i, o, r, n) {
                if (!o) return;
                e1.extend(t1, o);
                const s = {
                    handlerName: r,
                    originalEvent: o.originalEvent || n
                };
                void 0 !== o.zoomDelta && (i.zoom = s), void 0 !== o.panDelta && (i.drag = s), void 0 !== o.pitchDelta && (i.pitch = s), void 0 !== o.bearingDelta && (i.rotate = s);
            }
            _applyChanges() {
                const t1 = {}, i = {}, o = {};
                for (const [r, n, s] of this._changes)r.panDelta && (t1.panDelta = (t1.panDelta || new e1.pointGeometry(0, 0))._add(r.panDelta)), r.zoomDelta && (t1.zoomDelta = (t1.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t1.bearingDelta = (t1.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t1.pitchDelta = (t1.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t1.around = r.around), void 0 !== r.aroundCoord && (t1.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t1.pinchAround = r.pinchAround), r.noInertia && (t1.noInertia = r.noInertia), e1.extend(i, n), e1.extend(o, s);
                this._updateMapTransform(t1, i, o), this._changes = [];
            }
            _updateMapTransform(t1, i, o) {
                const r = this._map, n = r.transform, s = (e1)=>[
                        e1.x,
                        e1.y,
                        e1.z
                    ];
                if (((e1)=>{
                    const t1 = this._eventsInProgress.drag;
                    return t1 && !this._handlersById[t1.handlerName].isActive();
                })() && !qr(t1)) {
                    const e1 = n.zoom;
                    n.cameraElevationReference = "sea", n.recenterOnTerrain(), n.cameraElevationReference = "ground", e1 !== n.zoom && this._map._update(!0);
                }
                if (n._isCameraConstrained && r._stop(!0), !qr(t1)) return void this._fireEvents(i, o, !0);
                let { panDelta: a , zoomDelta: l , bearingDelta: c , pitchDelta: h , around: u , aroundCoord: _ , pinchAround: d  } = t1;
                n._isCameraConstrained && (l > 0 && (l = 0), n._isCameraConstrained = !1), void 0 !== d && (u = d), (l || ((e1)=>i.drag && !this._eventsInProgress.drag)()) && u && (this._dragOrigin = s(n.pointCoordinate3D(u)), this._trackingEllipsoid.setup(n._camera.position, this._dragOrigin)), n.cameraElevationReference = "sea", r._stop(!0), u = u || r.transform.centerPoint, c && (n.bearing += c), h && (n.pitch += h), n._updateCameraState();
                const p = [
                    0,
                    0,
                    0
                ];
                if (a) {
                    if ("mercator" === n.projection.name) {
                        const e1 = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u).dir), t1 = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u.sub(a)).dir);
                        p[0] = t1[0] - e1[0], p[1] = t1[1] - e1[1];
                    } else {
                        const t1 = n.pointCoordinate(u);
                        if ("globe" === n.projection.name) {
                            a = a.rotate(-n.angle);
                            const i = n._pixelsPerMercatorPixel / n.worldSize;
                            p[0] = -a.x * e1.mercatorScale(e1.latFromMercatorY(t1.y)) * i, p[1] = -a.y * e1.mercatorScale(n.center.lat) * i;
                        } else {
                            const e1 = n.pointCoordinate(u.sub(a));
                            t1 && e1 && (p[0] = e1.x - t1.x, p[1] = e1.y - t1.y);
                        }
                    }
                }
                const m = n.zoom, f = [
                    0,
                    0,
                    0
                ];
                if (l) {
                    const t1 = s(_ || n.pointCoordinate3D(u)), i = {
                        dir: e1.normalize([], e1.sub([], t1, n._camera.position))
                    };
                    if (i.dir[2] < 0) {
                        const o = n.zoomDeltaToMovement(t1, l);
                        e1.scale$2(f, i.dir, o);
                    }
                }
                const g = e1.add(p, p, f);
                n._translateCameraConstrained(g), l && Math.abs(n.zoom - m) > 1e-4 && n.recenterOnTerrain(), n.cameraElevationReference = "ground", this._map._update(), t1.noInertia || this._inertia.record(t1), this._fireEvents(i, o, !0);
            }
            _fireEvents(t1, i, o) {
                const r = Vr(this._eventsInProgress), n = Vr(t1), s = {};
                for(const e1 in t1){
                    const { originalEvent: i  } = t1[e1];
                    this._eventsInProgress[e1] || (s[`${e1}start`] = i), this._eventsInProgress[e1] = t1[e1];
                }
                !r && n && this._fireEvent("movestart", n.originalEvent);
                for(const e1 in s)this._fireEvent(e1, s[e1]);
                n && this._fireEvent("move", n.originalEvent);
                for(const e1 in t1){
                    const { originalEvent: i  } = t1[e1];
                    this._fireEvent(e1, i);
                }
                const a = {};
                let l;
                for(const e1 in this._eventsInProgress){
                    const { handlerName: t1 , originalEvent: o  } = this._eventsInProgress[e1];
                    this._handlersById[t1].isActive() || (delete this._eventsInProgress[e1], l = i[t1] || o, a[`${e1}end`] = l);
                }
                for(const e1 in a)this._fireEvent(e1, a[e1]);
                const c = Vr(this._eventsInProgress);
                if (o && (r || n) && !c) {
                    this._updatingCamera = !0;
                    const t1 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i = (e1)=>0 !== e1 && -this._bearingSnap < e1 && e1 < this._bearingSnap;
                    t1 ? (i(t1.bearing || this._map.getBearing()) && (t1.bearing = 0), this._map.easeTo(t1, {
                        originalEvent: l
                    })) : (this._map.fire(new e1.Event("moveend", {
                        originalEvent: l
                    })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }
            _fireEvent(t1, i) {
                this._map.fire(new e1.Event(t1, i ? {
                    originalEvent: i
                } : {}));
            }
            _requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e1)=>{
                    this._frameId = void 0, this.handleEvent(new Wr("renderFrame", {
                        timeStamp: e1
                    })), this._applyChanges();
                });
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const Hr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Yr extends e1.Evented {
            constructor(t1, i){
                super(), this._moving = !1, this._zooming = !1, this.transform = t1, this._bearingSnap = i.bearingSnap, e1.bindAll([
                    "_renderFrameCallback"
                ], this);
            }
            getCenter() {
                return new e1.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e1, t1) {
                return this.jumpTo({
                    center: e1
                }, t1);
            }
            panBy(t1, i, o) {
                return t1 = e1.pointGeometry.convert(t1).mult(-1), this.panTo(this.transform.center, e1.extend({
                    offset: t1
                }, i), o);
            }
            panTo(t1, i, o) {
                return this.easeTo(e1.extend({
                    center: t1
                }, i), o);
            }
            getZoom() {
                return this.transform.zoom;
            }
            setZoom(e1, t1) {
                return this.jumpTo({
                    zoom: e1
                }, t1), this;
            }
            zoomTo(t1, i, o) {
                return this.easeTo(e1.extend({
                    zoom: t1
                }, i), o);
            }
            zoomIn(e1, t1) {
                return this.zoomTo(this.getZoom() + 1, e1, t1), this;
            }
            zoomOut(e1, t1) {
                return this.zoomTo(this.getZoom() - 1, e1, t1), this;
            }
            getBearing() {
                return this.transform.bearing;
            }
            setBearing(e1, t1) {
                return this.jumpTo({
                    bearing: e1
                }, t1), this;
            }
            getPadding() {
                return this.transform.padding;
            }
            setPadding(e1, t1) {
                return this.jumpTo({
                    padding: e1
                }, t1), this;
            }
            rotateTo(t1, i, o) {
                return this.easeTo(e1.extend({
                    bearing: t1
                }, i), o);
            }
            resetNorth(t1, i) {
                return this.rotateTo(0, e1.extend({
                    duration: 1e3
                }, t1), i), this;
            }
            resetNorthPitch(t1, i) {
                return this.easeTo(e1.extend({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, t1), i), this;
            }
            snapToNorth(e1, t1) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e1, t1) : this;
            }
            getPitch() {
                return this.transform.pitch;
            }
            setPitch(e1, t1) {
                return this.jumpTo({
                    pitch: e1
                }, t1), this;
            }
            cameraForBounds(t1, i) {
                t1 = e1.LngLatBounds.convert(t1);
                const o = i && i.bearing || 0, r = i && i.pitch || 0, n = t1.getNorthWest(), s = t1.getSouthEast();
                return this._cameraForBounds(this.transform, n, s, o, r, i);
            }
            _extendCameraOptions(t1) {
                const i = {
                    top: 0,
                    bottom: 0,
                    right: 0,
                    left: 0
                };
                if ("number" == typeof (t1 = e1.extend({
                    padding: i,
                    offset: [
                        0,
                        0
                    ],
                    maxZoom: this.transform.maxZoom
                }, t1)).padding) {
                    const e1 = t1.padding;
                    t1.padding = {
                        top: e1,
                        bottom: e1,
                        right: e1,
                        left: e1
                    };
                }
                return t1.padding = e1.extend(i, t1.padding), t1;
            }
            _minimumAABBFrustumDistance(e1, t1) {
                const i = t1.max[0] - t1.min[0], o = t1.max[1] - t1.min[1];
                return i / o > e1.aspect ? i / (2 * Math.tan(.5 * e1.fovX) * e1.aspect) : o / (2 * Math.tan(.5 * e1.fovY) * e1.aspect);
            }
            _cameraForBoundsOnGlobe(t1, i, o, r, n, s) {
                const a = t1.clone(), l = this._extendCameraOptions(s);
                a.bearing = r, a.pitch = n;
                const c = e1.LngLat.convert(i), h = e1.LngLat.convert(o), u = .5 * (c.lat + h.lat), _ = .5 * (c.lng + h.lng), d = e1.latLngToECEF(u, _), p = e1.normalize([], d), m = e1.normalize([], e1.cross([], p, [
                    0,
                    1,
                    0
                ])), f = e1.cross([], m, p), g = [
                    m[0],
                    m[1],
                    m[2],
                    0,
                    f[0],
                    f[1],
                    f[2],
                    0,
                    p[0],
                    p[1],
                    p[2],
                    0,
                    0,
                    0,
                    0,
                    1
                ], v = [
                    d,
                    e1.latLngToECEF(c.lat, c.lng),
                    e1.latLngToECEF(h.lat, c.lng),
                    e1.latLngToECEF(h.lat, h.lng),
                    e1.latLngToECEF(c.lat, h.lng),
                    e1.latLngToECEF(u, c.lng),
                    e1.latLngToECEF(u, h.lng),
                    e1.latLngToECEF(c.lat, _),
                    e1.latLngToECEF(h.lat, _)
                ];
                let x = e1.Aabb.fromPoints(v.map((t1)=>[
                        e1.dot(m, t1),
                        e1.dot(f, t1),
                        e1.dot(p, t1)
                    ]));
                const y = e1.transformMat4([], x.center, g);
                0 === e1.squaredLength(y) && e1.set(y, 0, 0, 1), e1.normalize(y, y), e1.scale$2(y, y, e1.GLOBE_RADIUS), a.center = e1.ecefToLatLng(y);
                const b = a.getWorldToCameraMatrix(), w = e1.invert(new Float64Array(16), b);
                x = e1.Aabb.applyTransform(x, e1.multiply([], b, g)), e1.transformMat4(y, y, b);
                const T = .5 * (x.max[2] - x.min[2]), E = this._minimumAABBFrustumDistance(a, x), C = e1.scale$2([], [
                    0,
                    0,
                    1
                ], T), M = e1.add(C, y, C), I = E + (0 === a.pitch ? 0 : e1.distance(y, M)), S = a.globeCenterInViewSpace, D = e1.sub([], y, [
                    S[0],
                    S[1],
                    S[2]
                ]);
                e1.normalize(D, D), e1.scale$2(D, D, I);
                const L = e1.add([], y, D);
                e1.transformMat4(L, L, w);
                const A = e1.earthRadius / e1.GLOBE_RADIUS, z = e1.length(L), P = e1.mercatorZfromAltitude(Math.max(z * A - e1.earthRadius, Number.EPSILON), 0), R = Math.min(a.zoomFromMercatorZAdjusted(P), l.maxZoom);
                return R > .5 * (e1.GLOBE_ZOOM_THRESHOLD_MIN + e1.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
                    name: "mercator"
                }), a.zoom = R, this._cameraForBounds(a, i, o, r, n, s)) : {
                    center: a.center,
                    zoom: R,
                    bearing: r,
                    pitch: n
                };
            }
            queryTerrainElevation(t1, i) {
                const o = this.transform.elevation;
                return o ? (i = e1.extend({}, {
                    exaggerated: !0
                }, i), o.getAtPoint(e1.MercatorCoordinate.fromLngLat(t1), null, i.exaggerated)) : null;
            }
            _cameraForBounds(t1, i, o, r, n, s) {
                if ("globe" === t1.projection.name) return this._cameraForBoundsOnGlobe(t1, i, o, r, n, s);
                const a = t1.clone(), l = this._extendCameraOptions(s), c = a.padding;
                a.bearing = r, a.pitch = n;
                const h = e1.LngLat.convert(i), u = e1.LngLat.convert(o), _ = new e1.LngLat(h.lng, u.lat), d = new e1.LngLat(u.lng, h.lat), p = a.project(h), m = a.project(u), f = this.queryTerrainElevation(h), g = this.queryTerrainElevation(u), v = this.queryTerrainElevation(_), x = this.queryTerrainElevation(d), y = [
                    [
                        p.x,
                        p.y,
                        Math.min(f || 0, g || 0, v || 0, x || 0)
                    ],
                    [
                        m.x,
                        m.y,
                        Math.max(f || 0, g || 0, v || 0, x || 0)
                    ]
                ];
                let b = e1.Aabb.fromPoints(y);
                const w = a.getWorldToCameraMatrix(), T = e1.invert(new Float64Array(16), w);
                b = e1.Aabb.applyTransform(b, w);
                const E = e1.sub([], b.max, b.min), C = c.left || 0, M = c.right || 0, I = c.bottom || 0, S = c.top || 0, { left: D , right: L , top: A , bottom: z  } = l.padding, P = .5 * (C + M), R = .5 * (S + I), O = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (C + M + D + L)) / E[0], (a.height - (I + S + z + A)) / E[1])), l.maxZoom), B = a.scale / a.zoomScale(O);
                b = new e1.Aabb([
                    b.min[0] - (D + P) * B,
                    b.min[1] - (z + R) * B,
                    b.min[2]
                ], [
                    b.max[0] + (L + P) * B,
                    b.max[1] + (A + R) * B,
                    b.max[2]
                ]);
                const k = .5 * E[2], F = this._minimumAABBFrustumDistance(a, b), U = [
                    0,
                    0,
                    1,
                    0
                ];
                e1.transformMat4$1(U, U, w), e1.normalize$2(U, U);
                const N = e1.scale$2([], U, F + k), G = e1.add([], b.center, N), j = ("number" == typeof l.offset.x && "number" == typeof l.offset.y ? new e1.pointGeometry(l.offset.x, l.offset.y) : e1.pointGeometry.convert(l.offset)).rotate(-e1.degToRad(r));
                b.center[0] -= j.x * B, b.center[1] += j.y * B, e1.transformMat4(b.center, b.center, T), e1.transformMat4(G, G, T);
                const Z = [
                    b.center[0],
                    b.center[1],
                    G[2] * a.pixelsPerMeter
                ];
                e1.scale$2(Z, Z, 1 / a.worldSize);
                const V = e1.lngFromMercatorX(Z[0]), W = e1.latFromMercatorY(Z[1]), X = Math.min(a._zoomFromMercatorZ(Z[2]), l.maxZoom), q = new e1.LngLat(V, W);
                return a.mercatorFromTransition && X < .5 * (e1.GLOBE_ZOOM_THRESHOLD_MIN + e1.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
                    name: "globe"
                }), a.zoom = X, this._cameraForBounds(a, i, o, r, n, s)) : {
                    center: q,
                    zoom: X,
                    bearing: r,
                    pitch: n
                };
            }
            fitBounds(e1, t1, i) {
                const o = this.cameraForBounds(e1, t1);
                return this._fitInternal(o, t1, i);
            }
            fitScreenCoordinates(t1, i, o, r, n) {
                const s = e1.pointGeometry.convert(t1), a = e1.pointGeometry.convert(i), l = new e1.pointGeometry(Math.min(s.x, a.x), Math.min(s.y, a.y)), c = new e1.pointGeometry(Math.max(s.x, a.x), Math.max(s.y, a.y));
                if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s, a)) return this;
                const h = this.transform.pointLocation3D(l), u = this.transform.pointLocation3D(c), _ = this.transform.pointLocation3D(new e1.pointGeometry(l.x, c.y)), d = this.transform.pointLocation3D(new e1.pointGeometry(c.x, l.y)), p = [
                    Math.min(h.lng, u.lng, _.lng, d.lng),
                    Math.min(h.lat, u.lat, _.lat, d.lat)
                ], m = [
                    Math.max(h.lng, u.lng, _.lng, d.lng),
                    Math.max(h.lat, u.lat, _.lat, d.lat)
                ], f = r && r.pitch ? r.pitch : this.getPitch(), g = this._cameraForBounds(this.transform, p, m, o, f, r);
                return this._fitInternal(g, r, n);
            }
            _fitInternal(t1, i, o) {
                return t1 ? (delete (i = e1.extend(t1, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;
            }
            jumpTo(t1, i) {
                this.stop();
                const o = t1.preloadOnly ? this.transform.clone() : this.transform;
                let r = !1, n = !1, s = !1;
                return "zoom" in t1 && o.zoom !== +t1.zoom && (r = !0, o.zoom = +t1.zoom), void 0 !== t1.center && (o.center = e1.LngLat.convert(t1.center)), "bearing" in t1 && o.bearing !== +t1.bearing && (n = !0, o.bearing = +t1.bearing), "pitch" in t1 && o.pitch !== +t1.pitch && (s = !0, o.pitch = +t1.pitch), null == t1.padding || o.isPaddingEqual(t1.padding) || (o.padding = t1.padding), t1.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e1.Event("movestart", i)).fire(new e1.Event("move", i)), r && this.fire(new e1.Event("zoomstart", i)).fire(new e1.Event("zoom", i)).fire(new e1.Event("zoomend", i)), n && this.fire(new e1.Event("rotatestart", i)).fire(new e1.Event("rotate", i)).fire(new e1.Event("rotateend", i)), s && this.fire(new e1.Event("pitchstart", i)).fire(new e1.Event("pitch", i)).fire(new e1.Event("pitchend", i)), this.fire(new e1.Event("moveend", i)));
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || e1.warnOnce(Hr), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t1, i) {
                const o = this.transform;
                if (!o.projection.supportsFreeCamera) return e1.warnOnce(Hr), this;
                this.stop();
                const r = o.zoom, n = o.pitch, s = o.bearing;
                o.setFreeCameraOptions(t1);
                const a = r !== o.zoom, l = n !== o.pitch, c = s !== o.bearing;
                return this.fire(new e1.Event("movestart", i)).fire(new e1.Event("move", i)), a && this.fire(new e1.Event("zoomstart", i)).fire(new e1.Event("zoom", i)).fire(new e1.Event("zoomend", i)), c && this.fire(new e1.Event("rotatestart", i)).fire(new e1.Event("rotate", i)).fire(new e1.Event("rotateend", i)), l && this.fire(new e1.Event("pitchstart", i)).fire(new e1.Event("pitch", i)).fire(new e1.Event("pitchend", i)), this.fire(new e1.Event("moveend", i)), this;
            }
            easeTo(t1, i) {
                this._stop(!1, t1.easeId), (!1 === (t1 = e1.extend({
                    offset: [
                        0,
                        0
                    ],
                    duration: 500,
                    easing: e1.ease
                }, t1)).animate || !t1.essential && e1.exported.prefersReducedMotion) && (t1.duration = 0);
                const o = this.transform, r = this.getZoom(), n = this.getBearing(), s = this.getPitch(), a = this.getPadding(), l = "zoom" in t1 ? +t1.zoom : r, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, n) : n, h = "pitch" in t1 ? +t1.pitch : s, u = "padding" in t1 ? t1.padding : o.padding, _ = e1.pointGeometry.convert(t1.offset);
                let d, p, m;
                if ("globe" === o.projection.name) {
                    const i = e1.MercatorCoordinate.fromLngLat(o.center), r = _.rotate(-o.angle);
                    i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;
                    const n = i.toLngLat(), s = e1.LngLat.convert(t1.center || n);
                    this._normalizeCenter(s), d = o.centerPoint.add(r), p = new e1.pointGeometry(i.x, i.y).mult(o.worldSize), m = new e1.pointGeometry(e1.mercatorXfromLng(s.lng), e1.mercatorYfromLat(s.lat)).mult(o.worldSize).sub(p);
                } else {
                    d = o.centerPoint.add(_);
                    const i = o.pointLocation(d), r = e1.LngLat.convert(t1.center || i);
                    this._normalizeCenter(r), p = o.project(i), m = o.project(r).sub(p);
                }
                const f = o.zoomScale(l - r);
                let g, v;
                t1.around && (g = e1.LngLat.convert(t1.around), v = o.locationPoint(g));
                const x = this._zooming || l !== r, y = this._rotating || n !== c, b = this._pitching || h !== s, w = !o.isPaddingEqual(u), T = (o)=>(T)=>{
                        if (x && (o.zoom = e1.number(r, l, T)), y && (o.bearing = e1.number(n, c, T)), b && (o.pitch = e1.number(s, h, T)), w && (o.interpolatePadding(a, u, T), d = o.centerPoint.add(_)), g) o.setLocationAtPoint(g, v);
                        else {
                            const e1 = o.zoomScale(o.zoom - r), t1 = l > r ? Math.min(2, f) : Math.max(.5, f), i = Math.pow(t1, 1 - T), n = o.unproject(p.add(m.mult(T * i)).mult(e1));
                            o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, d);
                        }
                        return t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e1 = this._emulate(T, t1.duration, o);
                    return this._preloadTiles(e1), this;
                }
                const E = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = x, this._rotating = y, this._pitching = b, this._padding = w, this._easeId = t1.easeId, this._prepareEase(i, t1.noMoveStart, E), this._ease(T(o), (e1)=>{
                    o.recenterOnTerrain(), this._afterEase(i, e1);
                }, t1), this;
            }
            _prepareEase(t1, i, o = {}) {
                this._moving = !0, this.transform.cameraElevationReference = "sea", i || o.moving || this.fire(new e1.Event("movestart", t1)), this._zooming && !o.zooming && this.fire(new e1.Event("zoomstart", t1)), this._rotating && !o.rotating && this.fire(new e1.Event("rotatestart", t1)), this._pitching && !o.pitching && this.fire(new e1.Event("pitchstart", t1));
            }
            _fireMoveEvents(t1) {
                this.fire(new e1.Event("move", t1)), this._zooming && this.fire(new e1.Event("zoom", t1)), this._rotating && this.fire(new e1.Event("rotate", t1)), this._pitching && this.fire(new e1.Event("pitch", t1));
            }
            _afterEase(t1, i) {
                if (this._easeId && i && this._easeId === i) return;
                this._easeId = void 0, this.transform.cameraElevationReference = "ground";
                const o = this._zooming, r = this._rotating, n = this._pitching;
                this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e1.Event("zoomend", t1)), r && this.fire(new e1.Event("rotateend", t1)), n && this.fire(new e1.Event("pitchend", t1)), this.fire(new e1.Event("moveend", t1));
            }
            flyTo(t1, i) {
                if (!t1.essential && e1.exported.prefersReducedMotion) {
                    const o = e1.pick(t1, [
                        "center",
                        "zoom",
                        "bearing",
                        "pitch",
                        "around"
                    ]);
                    return this.jumpTo(o, i);
                }
                this.stop(), t1 = e1.extend({
                    offset: [
                        0,
                        0
                    ],
                    speed: 1.2,
                    curve: 1.42,
                    easing: e1.ease
                }, t1);
                const o = this.transform, r = this.getZoom(), n = this.getBearing(), s = this.getPitch(), a = this.getPadding(), l = "zoom" in t1 ? e1.clamp(+t1.zoom, o.minZoom, o.maxZoom) : r, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, n) : n, h = "pitch" in t1 ? +t1.pitch : s, u = "padding" in t1 ? t1.padding : o.padding, _ = o.zoomScale(l - r), d = e1.pointGeometry.convert(t1.offset);
                let p = o.centerPoint.add(d);
                const m = o.pointLocation(p), f = e1.LngLat.convert(t1.center || m);
                this._normalizeCenter(f);
                const g = o.project(m), v = o.project(f).sub(g);
                let x = t1.curve;
                const y = Math.max(o.width, o.height), b = y / _, w = v.mag();
                if ("minZoom" in t1) {
                    const i = e1.clamp(Math.min(t1.minZoom, r, l), o.minZoom, o.maxZoom), n = y / o.zoomScale(i - r);
                    x = Math.sqrt(n / w * 2);
                }
                const T = x * x;
                function E(e1) {
                    const t1 = (b * b - y * y + (e1 ? -1 : 1) * T * T * w * w) / (2 * (e1 ? b : y) * T * w);
                    return Math.log(Math.sqrt(t1 * t1 + 1) - t1);
                }
                function C(e1) {
                    return (Math.exp(e1) - Math.exp(-e1)) / 2;
                }
                function M(e1) {
                    return (Math.exp(e1) + Math.exp(-e1)) / 2;
                }
                const I = E(0);
                let S = function(e1) {
                    return M(I) / M(I + x * e1);
                }, D = function(e1) {
                    var t1;
                    return y * ((M(I) * (C(t1 = I + x * e1) / M(t1)) - C(I)) / T) / w;
                }, L = (E(1) - I) / x;
                if (Math.abs(w) < 1e-6 || !isFinite(L)) {
                    if (Math.abs(y - b) < 1e-6) return this.easeTo(t1, i);
                    const e1 = b < y ? -1 : 1;
                    L = Math.abs(Math.log(b / y)) / x, D = function() {
                        return 0;
                    }, S = function(t1) {
                        return Math.exp(e1 * x * t1);
                    };
                }
                t1.duration = "duration" in t1 ? +t1.duration : 1e3 * L / ("screenSpeed" in t1 ? +t1.screenSpeed / x : +t1.speed), t1.maxDuration && t1.duration > t1.maxDuration && (t1.duration = 0);
                const A = n !== c, z = h !== s, P = !o.isPaddingEqual(u), R = (o)=>(_)=>{
                        const m = _ * L, x = 1 / S(m);
                        o.zoom = 1 === _ ? l : r + o.scaleZoom(x), A && (o.bearing = e1.number(n, c, _)), z && (o.pitch = e1.number(s, h, _)), P && (o.interpolatePadding(a, u, _), p = o.centerPoint.add(d));
                        const y = 1 === _ ? f : o.unproject(g.add(v.mult(D(m))).mult(x));
                        return o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, p), o._updateCameraOnTerrain(), t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e1 = this._emulate(R, t1.duration, o);
                    return this._preloadTiles(e1), this;
                }
                return this._zooming = !0, this._rotating = A, this._pitching = z, this._padding = P, this._prepareEase(i, !1), this._ease(R(o), ()=>this._afterEase(i), t1), this;
            }
            isEasing() {
                return !!this._easeFrameId;
            }
            stop() {
                return this._stop();
            }
            _stop(e1, t1) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const e1 = this._onEaseEnd;
                    this._onEaseEnd = void 0, e1.call(this, t1);
                }
                if (!e1) {
                    const e1 = this.handlers;
                    e1 && e1.stop(!1);
                }
                return this;
            }
            _ease(t1, i, o) {
                !1 === o.animate || 0 === o.duration ? (t1(1), i()) : (this._easeStart = e1.exported.now(), this._easeOptions = o, this._onEaseFrame = t1, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const t1 = Math.min((e1.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i = this._onEaseFrame;
                i && i(this._easeOptions.easing(t1)), t1 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t1, i) {
                t1 = e1.wrap(t1, -180, 180);
                const o = Math.abs(t1 - i);
                return Math.abs(t1 - 360 - i) < o && (t1 -= 360), Math.abs(t1 + 360 - i) < o && (t1 += 360), t1;
            }
            _normalizeCenter(e1) {
                const t1 = this.transform;
                if (!t1.renderWorldCopies || t1.maxBounds) return;
                const i = e1.lng - t1.center.lng;
                e1.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }
            _emulate(e1, t1, i) {
                const o = Math.ceil(15 * t1 / 1e3), r = [], n = e1(i.clone());
                for(let e1 = 0; e1 <= o; e1++){
                    const t1 = n(e1 / o);
                    r.push(t1.clone());
                }
                return r;
            }
        }
        class Kr {
            constructor(t1 = {}){
                this.options = t1, e1.bindAll([
                    "_toggleAttribution",
                    "_updateEditLink",
                    "_updateData",
                    "_updateCompact"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-right";
            }
            onAdd(e1) {
                const t1 = this.options && this.options.compact;
                return this._map = e1, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n("button", "mapboxgl-ctrl-attrib-button", this._container), n("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t1 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t1 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(e1, t1) {
                const i = this._map._getUIString(`AttributionControl.${t1}`);
                e1.setAttribute("aria-label", i), e1.removeAttribute("title"), e1.firstElementChild && e1.firstElementChild.setAttribute("title", i);
            }
            _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
                let t1 = this._editLink;
                t1 || (t1 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                const i = [
                    {
                        key: "owner",
                        value: this.styleOwner
                    },
                    {
                        key: "id",
                        value: this.styleId
                    },
                    {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || e1.config.ACCESS_TOKEN
                    }
                ];
                if (t1) {
                    const o = i.reduce((e1, t1, o)=>(t1.value && (e1 += `${t1.key}=${t1.value}${o < i.length - 1 ? "&" : ""}`), e1), "?");
                    t1.href = `${e1.config.FEEDBACK_URL}/${o}#${er(this._map, !0)}`, t1.rel = "noopener nofollow", this._setElementTitle(t1, "MapFeedback");
                }
            }
            _updateData(e1) {
                !e1 || "metadata" !== e1.sourceDataType && "visibility" !== e1.sourceDataType && "style" !== e1.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
                if (!this._map.style) return;
                let e1 = [];
                if (this._map.style.stylesheet) {
                    const e1 = this._map.style.stylesheet;
                    this.styleOwner = e1.owner, this.styleId = e1.id;
                }
                const t1 = this._map.style._sourceCaches;
                for(const i in t1){
                    const o = t1[i];
                    if (o.used) {
                        const t1 = o.getSource();
                        t1.attribution && e1.indexOf(t1.attribution) < 0 && e1.push(t1.attribution);
                    }
                }
                e1.sort((e1, t1)=>e1.length - t1.length), e1 = e1.filter((t1, i)=>{
                    for(let o = i + 1; o < e1.length; o++)if (e1[o].indexOf(t1) >= 0) return !1;
                    return !0;
                }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e1 = [
                    ...this.options.customAttribution,
                    ...e1
                ] : e1.unshift(this.options.customAttribution));
                const i = e1.join(" | ");
                i !== this._attribHTML && (this._attribHTML = i, e1.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
        }
        class Jr {
            constructor(){
                e1.bindAll([
                    "_updateLogo",
                    "_updateCompact"
                ], this);
            }
            onAdd(e1) {
                this._map = e1, this._container = n("div", "mapboxgl-ctrl");
                const t1 = n("a", "mapboxgl-ctrl-logo");
                return t1.target = "_blank", t1.rel = "noopener nofollow", t1.href = "https://www.mapbox.com/", t1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t1), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
                return "bottom-left";
            }
            _updateLogo(e1) {
                e1 && "metadata" !== e1.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
                if (!this._map.style) return !0;
                const e1 = this._map.style._sourceCaches;
                if (0 === Object.entries(e1).length) return !0;
                for(const t1 in e1){
                    const i = e1[t1].getSource();
                    if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
                }
                return !0;
            }
            _updateCompact() {
                const e1 = this._container.children;
                if (e1.length) {
                    const t1 = e1[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? t1.classList.add("mapboxgl-compact") : t1.classList.remove("mapboxgl-compact");
                }
            }
        }
        class Qr {
            constructor(){
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }
            add(e1) {
                const t1 = ++this._id;
                return this._queue.push({
                    callback: e1,
                    id: t1,
                    cancelled: !1
                }), t1;
            }
            remove(e1) {
                const t1 = this._currentlyRunning, i = t1 ? this._queue.concat(t1) : this._queue;
                for (const t1 of i)if (t1.id === e1) return void (t1.cancelled = !0);
            }
            run(e1 = 0) {
                const t1 = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of t1)if (!i.cancelled && (i.callback(e1), this._cleared)) break;
                this._cleared = !1, this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }
        function en(t1, i, o) {
            if (t1 = new e1.LngLat(t1.lng, t1.lat), i) {
                const r = new e1.LngLat(t1.lng - 360, t1.lat), n = new e1.LngLat(t1.lng + 360, t1.lat), s = 360 * Math.ceil(Math.abs(t1.lng - o.center.lng) / 360), a = o.locationPoint(t1).distSqr(i), l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;
                o.locationPoint(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < s) ? t1 = r : o.locationPoint(n).distSqr(i) < a && (l || Math.abs(n.lng - o.center.lng) < s) && (t1 = n);
            }
            for(; Math.abs(t1.lng - o.center.lng) > 180;){
                const e1 = o.locationPoint(t1);
                if (e1.x >= 0 && e1.y >= 0 && e1.x <= o.width && e1.y <= o.height) break;
                t1.lng > o.center.lng ? t1.lng -= 360 : t1.lng += 360;
            }
            return t1;
        }
        const tn = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        };
        class on extends e1.Evented {
            constructor(t1, i){
                if (super(), (t1 instanceof e1.window.HTMLElement || i) && (t1 = e1.extend({
                    element: t1
                }, i)), e1.bindAll([
                    "_update",
                    "_onMove",
                    "_onUp",
                    "_addDragHandler",
                    "_onMapClick",
                    "_onKeyPress",
                    "_clearFadeTimer"
                ], this), this._anchor = t1 && t1.anchor || "center", this._color = t1 && t1.color || "#3FB1CE", this._scale = t1 && t1.scale || 1, this._draggable = t1 && t1.draggable || !1, this._clickTolerance = t1 && t1.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t1 && t1.rotation || 0, this._rotationAlignment = t1 && t1.rotationAlignment || "auto", this._pitchAlignment = t1 && t1.pitchAlignment && t1.pitchAlignment || "auto", this._updateMoving = ()=>this._update(!0), this._occludedOpacity = t1 && t1.occludedOpacity || .2, t1 && t1.element) this._element = t1.element, this._offset = e1.pointGeometry.convert(t1 && t1.offset || [
                    0,
                    0
                ]);
                else {
                    this._defaultMarker = !0, this._element = n("div");
                    const i = 41, o = 27, r = s("svg", {
                        display: "block",
                        height: i * this._scale + "px",
                        width: o * this._scale + "px",
                        viewBox: `0 0 ${o} ${i}`
                    }, this._element), a = s("radialGradient", {
                        id: "shadowGradient"
                    }, s("defs", {}, r));
                    s("stop", {
                        offset: "10%",
                        "stop-opacity": .4
                    }, a), s("stop", {
                        offset: "100%",
                        "stop-opacity": .05
                    }, a), s("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, r), s("path", {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                    }, r), s("path", {
                        opacity: .25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                    }, r), s("circle", {
                        fill: "white",
                        cx: 13.5,
                        cy: 13.5,
                        r: 5.5
                    }, r), this._offset = e1.pointGeometry.convert(t1 && t1.offset || [
                        0,
                        -14
                    ]);
                }
                this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e1)=>{
                    e1.preventDefault();
                }), this._element.addEventListener("mousedown", (e1)=>{
                    e1.preventDefault();
                });
                const o = this._element.classList;
                for(const e1 in tn)o.remove(`mapboxgl-marker-anchor-${e1}`);
                o.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
            }
            addTo(e1) {
                return e1 === this._map || (this.remove(), this._map = e1, e1.getCanvasContainer().appendChild(this._element), e1.on("move", this._updateMoving), e1.on("moveend", this._update), e1.on("remove", this._clearFadeTimer), e1._addMarker(this), this.setDraggable(this._draggable), this._update(), e1.on("click", this._onMapClick)), this;
            }
            remove() {
                const e1 = this._map;
                return e1 && (e1.off("click", this._onMapClick), e1.off("move", this._updateMoving), e1.off("moveend", this._update), e1.off("mousedown", this._addDragHandler), e1.off("touchstart", this._addDragHandler), e1.off("mouseup", this._onUp), e1.off("touchend", this._onUp), e1.off("mousemove", this._onMove), e1.off("touchmove", this._onMove), e1.off("remove", this._clearFadeTimer), e1._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
                return this._lngLat;
            }
            setLngLat(t1) {
                return this._lngLat = e1.LngLat.convert(t1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
            }
            getElement() {
                return this._element;
            }
            setPopup(e1) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e1) {
                    if (!("offset" in e1.options)) {
                        const t1 = 38.1, i = 13.5, o = Math.sqrt(Math.pow(i, 2) / 2);
                        e1.options.offset = this._defaultMarker ? {
                            top: [
                                0,
                                0
                            ],
                            "top-left": [
                                0,
                                0
                            ],
                            "top-right": [
                                0,
                                0
                            ],
                            bottom: [
                                0,
                                -t1
                            ],
                            "bottom-left": [
                                o,
                                -1 * (t1 - i + o)
                            ],
                            "bottom-right": [
                                -o,
                                -1 * (t1 - i + o)
                            ],
                            left: [
                                i,
                                -1 * (t1 - i)
                            ],
                            right: [
                                -i,
                                -1 * (t1 - i)
                            ]
                        } : this._offset;
                    }
                    this._popup = e1, e1._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                }
                return this;
            }
            _onKeyPress(e1) {
                const t1 = e1.code, i = e1.charCode || e1.keyCode;
                "Space" !== t1 && "Enter" !== t1 && 32 !== i && 13 !== i || this.togglePopup();
            }
            _onMapClick(e1) {
                const t1 = e1.originalEvent.target, i = this._element;
                this._popup && (t1 === i || i.contains(t1)) && this.togglePopup();
            }
            getPopup() {
                return this._popup;
            }
            togglePopup() {
                const e1 = this._popup;
                return e1 ? (e1.isOpen() ? (e1.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e1.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
                const e1 = this._map, t1 = this._pos;
                if (!e1 || !t1) return !1;
                const i = e1.unproject(t1), o = e1.getFreeCameraOptions();
                if (!o.position) return !1;
                const r = o.position.toLngLat();
                return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
                const t1 = this._map;
                if (!t1) return;
                const i = this._pos;
                if (!i || i.x < 0 || i.x > t1.transform.width || i.y < 0 || i.y > t1.transform.height) return void this._clearFadeTimer();
                const o = t1.unproject(i);
                let r;
                t1._showingGlobe() && e1.isLngLatBehindGlobe(t1.transform, this._lngLat) ? r = 0 : (r = 1 - t1._queryFogOpacity(o), t1.transform._terrainEnabled() && t1.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
                const e1 = this._pos;
                if (!e1 || !this._map) return;
                const t1 = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${e1.x}px,${e1.y}px)\n            ${tn[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t1.x}px,${t1.y}px)\n        `;
            }
            _calculateXYTransform() {
                const t1 = this._pos, i = this._map, o = this.getPitchAlignment();
                if (!i || !t1 || "map" !== o) return "";
                if (!i._showingGlobe()) {
                    const e1 = i.getPitch();
                    return e1 ? `rotateX(${e1}deg)` : "";
                }
                const r = e1.radToDeg(e1.globeTiltAtLngLat(i.transform, this._lngLat)), n = t1.sub(e1.globeCenterToScreenPoint(i.transform)), s = Math.abs(n.x) + Math.abs(n.y);
                if (0 === s) return "";
                const a = r / s;
                return `rotateX(${-n.y * a}deg) rotateY(${n.x * a}deg)`;
            }
            _calculateZTransform() {
                const t1 = this._pos, i = this._map;
                if (!i || !t1) return "";
                let o = 0;
                const r = this.getRotationAlignment();
                if ("map" === r) {
                    if (i._showingGlobe()) {
                        const t1 = i.project(new e1.LngLat(this._lngLat.lng, this._lngLat.lat + .001)), r = i.project(new e1.LngLat(this._lngLat.lng, this._lngLat.lat - .001)).sub(t1);
                        o = e1.radToDeg(Math.atan2(r.y, r.x)) - 90;
                    } else o = -i.getBearing();
                } else if ("horizon" === r) {
                    const r = e1.smoothstep(4, 6, i.getZoom()), n = e1.globeCenterToScreenPoint(i.transform);
                    n.y += r * i.transform.height;
                    const s = t1.sub(n), a = e1.radToDeg(Math.atan2(s.y, s.x));
                    o = (a > 90 ? a - 270 : a + 90) * (1 - r);
                }
                return o += this._rotation, o ? `rotateZ(${o}deg)` : "";
            }
            _update(t1) {
                e1.window.cancelAnimationFrame(this._updateFrameId);
                const i = this._map;
                i && (i.transform.renderWorldCopies && (this._lngLat = en(this._lngLat, this._pos, i.transform)), this._pos = i.project(this._lngLat), !0 === t1 ? this._updateFrameId = e1.window.requestAnimationFrame(()=>{
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
                }) : this._pos = this._pos.round(), i._requestDomTask(()=>{
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
                }));
            }
            getOffset() {
                return this._offset;
            }
            setOffset(t1) {
                return this._offset = e1.pointGeometry.convert(t1), this._update(), this;
            }
            _onMove(t1) {
                const i = this._map;
                if (!i) return;
                const o = this._pointerdownPos, r = this._positionDelta;
                if (o && r) {
                    if (!this._isDragging) {
                        const e1 = this._clickTolerance || i._clickTolerance;
                        if (t1.point.dist(o) < e1) return;
                        this._isDragging = !0;
                    }
                    this._pos = t1.point.sub(r), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e1.Event("dragstart"))), this.fire(new e1.Event("drag"));
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
                const t1 = this._map;
                t1 && (t1.off("mousemove", this._onMove), t1.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e1.Event("dragend")), this._state = "inactive";
            }
            _addDragHandler(e1) {
                const t1 = this._map, i = this._pos;
                t1 && i && this._element.contains(e1.originalEvent.target) && (e1.preventDefault(), this._positionDelta = e1.point.sub(i), this._pointerdownPos = e1.point, this._state = "pending", t1.on("mousemove", this._onMove), t1.on("touchmove", this._onMove), t1.once("mouseup", this._onUp), t1.once("touchend", this._onUp));
            }
            setDraggable(e1) {
                this._draggable = !!e1;
                const t1 = this._map;
                return t1 && (e1 ? (t1.on("mousedown", this._addDragHandler), t1.on("touchstart", this._addDragHandler)) : (t1.off("mousedown", this._addDragHandler), t1.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
                return this._draggable;
            }
            setRotation(e1) {
                return this._rotation = e1 || 0, this._update(), this;
            }
            getRotation() {
                return this._rotation;
            }
            setRotationAlignment(e1) {
                return this._rotationAlignment = e1 || "auto", this._update(), this;
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e1) {
                return this._pitchAlignment = e1 || "auto", this._update(), this;
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e1) {
                return this._occludedOpacity = e1 || .2, this._update(), this;
            }
            getOccludedOpacity() {
                return this._occludedOpacity;
            }
        }
        const rn = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px"
        }, nn = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])"
        ].join(", ");
        function sn(t1 = new e1.pointGeometry(0, 0), i = "bottom") {
            if ("number" == typeof t1) {
                const o = Math.round(Math.sqrt(.5 * Math.pow(t1, 2)));
                switch(i){
                    case "top":
                        return new e1.pointGeometry(0, t1);
                    case "top-left":
                        return new e1.pointGeometry(o, o);
                    case "top-right":
                        return new e1.pointGeometry(-o, o);
                    case "bottom":
                        return new e1.pointGeometry(0, -t1);
                    case "bottom-left":
                        return new e1.pointGeometry(o, -o);
                    case "bottom-right":
                        return new e1.pointGeometry(-o, -o);
                    case "left":
                        return new e1.pointGeometry(t1, 0);
                    case "right":
                        return new e1.pointGeometry(-t1, 0);
                }
                return new e1.pointGeometry(0, 0);
            }
            return t1 instanceof e1.pointGeometry || Array.isArray(t1) ? e1.pointGeometry.convert(t1) : e1.pointGeometry.convert(t1[i] || [
                0,
                0
            ]);
        }
        class an {
            constructor(e1){
                this.jumpTo(e1);
            }
            getValue(t1) {
                if (t1 <= this._startTime) return this._start;
                if (t1 >= this._endTime) return this._end;
                const i = e1.easeCubicInOut((t1 - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i) + this._end * i;
            }
            isEasing(e1) {
                return e1 >= this._startTime && e1 <= this._endTime;
            }
            jumpTo(e1) {
                this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e1, this._end = e1;
            }
            easeTo(e1, t1, i) {
                this._start = this.getValue(t1), this._end = e1, this._startTime = t1, this._endTime = t1 + i;
            }
        }
        const ln = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox logo",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        }, cn = {
            center: [
                0,
                0
            ],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            performanceMetricsCollection: !0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            optimizeForTerrain: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            crossSourceCollisions: !0
        }, hn = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class un {
            constructor(t1, i, o = !1){
                this._clickTolerance = 10, this.element = i, this.mouseRotate = new wr({
                    clickTolerance: t1.dragRotate._mouseRotate._clickTolerance
                }), this.map = t1, o && (this.mousePitch = new Tr({
                    clickTolerance: t1.dragRotate._mousePitch._clickTolerance
                })), e1.bindAll([
                    "mousedown",
                    "mousemove",
                    "mouseup",
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "reset"
                ], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
            }
            down(e1, t1) {
                this.mouseRotate.mousedown(e1, t1), this.mousePitch && this.mousePitch.mousedown(e1, t1), h();
            }
            move(e1, t1) {
                const i = this.map, o = this.mouseRotate.mousemoveWindow(e1, t1), r = o && o.bearingDelta;
                if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {
                    const o = this.mousePitch.mousemoveWindow(e1, t1), r = o && o.pitchDelta;
                    r && i.setPitch(i.getPitch() + r);
                }
            }
            off() {
                const e1 = this.element;
                e1.removeEventListener("mousedown", this.mousedown), e1.removeEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), e1.removeEventListener("touchmove", this.touchmove), e1.removeEventListener("touchend", this.touchend), e1.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
                u(), e1.window.removeEventListener("mousemove", this.mousemove), e1.window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t1) {
                this.down(e1.extend({}, t1, {
                    ctrlKey: !0,
                    preventDefault: ()=>t1.preventDefault()
                }), p(this.element, t1)), e1.window.addEventListener("mousemove", this.mousemove), e1.window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e1) {
                this.move(e1, p(this.element, e1));
            }
            mouseup(e1) {
                this.mouseRotate.mouseupWindow(e1), this.mousePitch && this.mousePitch.mouseupWindow(e1), this.offTemp();
            }
            touchstart(e1) {
                1 !== e1.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e1.targetTouches)[0], this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>e1.preventDefault()
                }, this._startPos));
            }
            touchmove(e1) {
                1 !== e1.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e1.targetTouches)[0], this.move({
                    preventDefault: ()=>e1.preventDefault()
                }, this._lastPos));
            }
            touchend(e1) {
                0 === e1.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }
        const _n = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1
        }, dn = {
            maxWidth: 100,
            unit: "metric"
        };
        function pn(e1, t1, i) {
            const o = mn(t1), r = o / t1, n = {
                kilometer: "km",
                meter: "m",
                mile: "mi",
                foot: "ft",
                "nautical-mile": "nm"
            }[i];
            this._map._requestDomTask(()=>{
                this._container.style.width = e1 * r + "px", this._container.innerHTML = `${o}&nbsp;${n}`;
            });
        }
        function mn(e1) {
            const t1 = Math.pow(10, `${Math.floor(e1)}`.length - 1);
            let i = e1 / t1;
            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(e1) {
                const t1 = Math.pow(10, Math.ceil(-Math.log(e1) / Math.LN10));
                return Math.round(e1 * t1) / t1;
            }(i), t1 * i;
        }
        const fn = {
            version: e1.version,
            supported: i,
            setRTLTextPlugin: e1.setRTLTextPlugin,
            getRTLTextPluginStatus: e1.getRTLTextPluginStatus,
            Map: class extends Yr {
                constructor(t1){
                    if (e1.LivePerformanceUtils.mark(e1.PerformanceMarkers.create), null != (t1 = e1.extend({}, cn, t1)).minZoom && null != t1.maxZoom && t1.minZoom > t1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != t1.minPitch && null != t1.maxPitch && t1.minPitch > t1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != t1.minPitch && t1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (null != t1.maxPitch && t1.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1.antialias && e1.isSafariWithAntialiasingBug(e1.window) && (t1.antialias = !1, e1.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ko(t1.minZoom, t1.maxZoom, t1.minPitch, t1.maxPitch, t1.renderWorldCopies), t1), this._interactive = t1.interactive, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t1.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t1.preserveDrawingBuffer, this._antialias = t1.antialias, this._useWebGL2 = t1.useWebGL2, this._trackResize = t1.trackResize, this._bearingSnap = t1.bearingSnap, this._refreshExpiredTiles = t1.refreshExpiredTiles, this._fadeDuration = t1.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t1.crossSourceCollisions, this._collectResourceTiming = t1.collectResourceTiming, this._optimizeForTerrain = t1.optimizeForTerrain, this._language = this._parseLanguage(t1.language), this._worldview = t1.worldview, this._renderTaskQueue = new Qr, this._domRenderTaskQueue = new Qr, this._controls = [], this._markers = [], this._popups = [], this._mapId = e1.uniqueId(), this._locale = e1.extend({}, ln, t1.locale), this._clickTolerance = t1.clickTolerance, this._cooperativeGestures = t1.cooperativeGestures, this._performanceMetricsCollection = t1.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new an(0), this._interactionRange = [
                        1 / 0,
                        -1 / 0
                    ], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new e1.RequestManager(t1.transformRequest, t1.accessToken, t1.testMode), this._silenceAuthErrors = !!t1.testMode, "string" == typeof t1.container) {
                        if (this._container = e1.window.document.getElementById(t1.container), !this._container) throw new Error(`Container '${t1.container}' not found.`);
                    } else {
                        if (!(t1.container instanceof e1.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = t1.container;
                    }
                    if (this._container.childNodes.length > 0 && e1.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t1.maxBounds && this.setMaxBounds(t1.maxBounds), e1.bindAll([
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onVisibilityChange",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored"
                    ], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
                    this.on("move", ()=>this._update(!1)), this.on("moveend", ()=>this._update(!1)), this.on("zoom", ()=>this._update(!0)), void 0 !== e1.window && (e1.window.addEventListener("online", this._onWindowOnline, !1), e1.window.addEventListener("resize", this._onWindowResize, !1), e1.window.addEventListener("orientationchange", this._onWindowResize, !1), e1.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1), e1.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)), this.handlers = new $r(this, t1), this._localFontFamily = t1.localFontFamily, this._localIdeographFontFamily = t1.localIdeographFontFamily, t1.style && this.setStyle(t1.style, {
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }), t1.projection && this.setProjection(t1.projection), this._hash = t1.hash && new Qo("string" == typeof t1.hash && t1.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
                        center: t1.center,
                        zoom: t1.zoom,
                        bearing: t1.bearing,
                        pitch: t1.pitch
                    }), t1.bounds && (this.resize(), this.fitBounds(t1.bounds, e1.extend({}, t1.fitBoundsOptions, {
                        duration: 0
                    })))), this.resize(), t1.attributionControl && this.addControl(new Kr({
                        customAttribution: t1.customAttribution
                    })), this._logoControl = new Jr, this.addControl(this._logoControl, t1.logoPosition), this.on("style.load", ()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet);
                    }), this.on("data", (t1)=>{
                        this._update("style" === t1.dataType), this.fire(new e1.Event(`${t1.dataType}data`, t1));
                    }), this.on("dataloading", (t1)=>{
                        this.fire(new e1.Event(`${t1.dataType}dataloading`, t1));
                    });
                }
                _getMapId() {
                    return this._mapId;
                }
                addControl(t1, i) {
                    if (void 0 === i && (i = t1.getDefaultPosition ? t1.getDefaultPosition() : "top-right"), !t1 || !t1.onAdd) return this.fire(new e1.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const o = t1.onAdd(this);
                    this._controls.push(t1);
                    const r = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;
                }
                removeControl(t1) {
                    if (!t1 || !t1.onRemove) return this.fire(new e1.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i = this._controls.indexOf(t1);
                    return i > -1 && this._controls.splice(i, 1), t1.onRemove(this), this;
                }
                hasControl(e1) {
                    return this._controls.indexOf(e1) > -1;
                }
                getContainer() {
                    return this._container;
                }
                getCanvasContainer() {
                    return this._canvasContainer;
                }
                getCanvas() {
                    return this._canvas;
                }
                resize(t1) {
                    if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                    this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                    const i = !this._moving;
                    return i && this.fire(new e1.Event("movestart", t1)).fire(new e1.Event("move", t1)), this.fire(new e1.Event("resize", t1)), i && this.fire(new e1.Event("moveend", t1)), this;
                }
                getBounds() {
                    return this.transform.getBounds();
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                }
                setMaxBounds(t1) {
                    return this.transform.setMaxBounds(e1.LngLatBounds.convert(t1)), this._update();
                }
                setMinZoom(t1) {
                    if ((t1 = null == t1 ? -2 : t1) >= -2 && t1 <= this.transform.maxZoom) return this.transform.minZoom = t1, this._update(), this.getZoom() < t1 ? this.setZoom(t1) : this.fire(new e1.Event("zoomstart")).fire(new e1.Event("zoom")).fire(new e1.Event("zoomend")), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }
                getMinZoom() {
                    return this.transform.minZoom;
                }
                setMaxZoom(t1) {
                    if ((t1 = null == t1 ? 22 : t1) >= this.transform.minZoom) return this.transform.maxZoom = t1, this._update(), this.getZoom() > t1 ? this.setZoom(t1) : this.fire(new e1.Event("zoomstart")).fire(new e1.Event("zoom")).fire(new e1.Event("zoomend")), this;
                    throw new Error("maxZoom must be greater than the current minZoom");
                }
                getMaxZoom() {
                    return this.transform.maxZoom;
                }
                setMinPitch(t1) {
                    if ((t1 = null == t1 ? 0 : t1) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (t1 >= 0 && t1 <= this.transform.maxPitch) return this.transform.minPitch = t1, this._update(), this.getPitch() < t1 ? this.setPitch(t1) : this.fire(new e1.Event("pitchstart")).fire(new e1.Event("pitch")).fire(new e1.Event("pitchend")), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }
                getMinPitch() {
                    return this.transform.minPitch;
                }
                setMaxPitch(t1) {
                    if ((t1 = null == t1 ? 85 : t1) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1 >= this.transform.minPitch) return this.transform.maxPitch = t1, this._update(), this.getPitch() > t1 ? this.setPitch(t1) : this.fire(new e1.Event("pitchstart")).fire(new e1.Event("pitch")).fire(new e1.Event("pitchend")), this;
                    throw new Error("maxPitch must be greater than or equal to minPitch");
                }
                getMaxPitch() {
                    return this.transform.maxPitch;
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(e1) {
                    return this.transform.renderWorldCopies = e1, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
                }
                getLanguage() {
                    return this._language;
                }
                _parseLanguage(t1) {
                    return "auto" === t1 ? e1.window.navigator.language : Array.isArray(t1) ? 0 === t1.length ? void 0 : t1.map((t1)=>"auto" === t1 ? e1.window.navigator.language : t1) : t1;
                }
                setLanguage(e1) {
                    const t1 = this._parseLanguage(e1);
                    if (!this.style || t1 === this._language) return this;
                    this._language = t1, this.style._reloadSources();
                    for (const e1 of this._controls)e1._setLanguage && e1._setLanguage(this._language);
                    return this;
                }
                getWorldview() {
                    return this._worldview;
                }
                setWorldview(e1) {
                    return this.style && e1 !== this._worldview ? (this._worldview = e1, this.style._reloadSources(), this) : this;
                }
                getProjection() {
                    return this.transform.mercatorFromTransition ? {
                        name: "globe",
                        center: [
                            0,
                            0
                        ]
                    } : this.transform.getProjection();
                }
                _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                }
                setProjection(e1) {
                    return this._lazyInitEmptyStyle(), e1 ? "string" == typeof e1 && (e1 = {
                        name: e1
                    }) : e1 = null, this._useExplicitProjection = !!e1, this._prioritizeAndUpdateProjection(e1, this.style.stylesheet ? this.style.stylesheet.projection : null);
                }
                _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const t1 = this.transform, i = t1.projection.name;
                    let o;
                    "globe" === i && t1.zoom >= e1.GLOBE_ZOOM_THRESHOLD_MAX ? (t1.setMercatorFromTransition(), o = !0) : "mercator" === i && t1.zoom < e1.GLOBE_ZOOM_THRESHOLD_MAX && (t1.setProjection({
                        name: "globe"
                    }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
                }
                _prioritizeAndUpdateProjection(e1, t1) {
                    return this._updateProjection(e1 || t1 || {
                        name: "mercator"
                    });
                }
                _updateProjection(t1) {
                    let i;
                    if (i = "globe" === t1.name && this.transform.zoom >= e1.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t1), this.style.applyProjectionUpdate(), i) {
                        this.painter.clearBackgroundTiles();
                        for(const e1 in this.style._sourceCaches)this.style._sourceCaches[e1].clearTiles();
                        this._update(!0), this._forceMarkerAndPopupUpdate(!0);
                    }
                    return this;
                }
                project(t1) {
                    return this.transform.locationPoint3D(e1.LngLat.convert(t1));
                }
                unproject(t1) {
                    return this.transform.pointLocation3D(e1.pointGeometry.convert(t1));
                }
                isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1;
                }
                isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1;
                }
                isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1;
                }
                _isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1;
                }
                _createDelegatedListener(e1, t1, i) {
                    if ("mouseenter" === e1 || "mouseover" === e1) {
                        let o = !1;
                        const r = (r)=>{
                            const n = t1.filter((e1)=>this.getLayer(e1)), s = n.length ? this.queryRenderedFeatures(r.point, {
                                layers: n
                            }) : [];
                            s.length ? o || (o = !0, i.call(this, new cr(e1, this, r.originalEvent, {
                                features: s
                            }))) : o = !1;
                        }, n = ()=>{
                            o = !1;
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                mousemove: r,
                                mouseout: n
                            }
                        };
                    }
                    if ("mouseleave" === e1 || "mouseout" === e1) {
                        let o = !1;
                        const r = (r)=>{
                            const n = t1.filter((e1)=>this.getLayer(e1));
                            (n.length ? this.queryRenderedFeatures(r.point, {
                                layers: n
                            }) : []).length ? o = !0 : o && (o = !1, i.call(this, new cr(e1, this, r.originalEvent)));
                        }, n = (t1)=>{
                            o && (o = !1, i.call(this, new cr(e1, this, t1.originalEvent)));
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                mousemove: r,
                                mouseout: n
                            }
                        };
                    }
                    {
                        const o = (e1)=>{
                            const o = t1.filter((e1)=>this.getLayer(e1)), r = o.length ? this.queryRenderedFeatures(e1.point, {
                                layers: o
                            }) : [];
                            r.length && (e1.features = r, i.call(this, e1), delete e1.features);
                        };
                        return {
                            layers: new Set(t1),
                            listener: i,
                            delegates: {
                                [e1]: o
                            }
                        };
                    }
                }
                on(e1, t1, i) {
                    if (void 0 === i) return super.on(e1, t1);
                    Array.isArray(t1) || (t1 = [
                        t1
                    ]);
                    const o = this._createDelegatedListener(e1, t1, i);
                    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e1] = this._delegatedListeners[e1] || [], this._delegatedListeners[e1].push(o);
                    for(const e1 in o.delegates)this.on(e1, o.delegates[e1]);
                    return this;
                }
                once(e1, t1, i) {
                    if (void 0 === i) return super.once(e1, t1);
                    Array.isArray(t1) || (t1 = [
                        t1
                    ]);
                    const o = this._createDelegatedListener(e1, t1, i);
                    for(const e1 in o.delegates)this.once(e1, o.delegates[e1]);
                    return this;
                }
                off(e1, t1, i) {
                    if (void 0 === i) return super.off(e1, t1);
                    t1 = new Set(Array.isArray(t1) ? t1 : [
                        t1
                    ]);
                    const o = (e1, t1)=>{
                        if (e1.size !== t1.size) return !1;
                        for (const i of e1)if (!t1.has(i)) return !1;
                        return !0;
                    }, r = this._delegatedListeners ? this._delegatedListeners[e1] : void 0;
                    return r && ((e1)=>{
                        for(let r = 0; r < e1.length; r++){
                            const n = e1[r];
                            if (n.listener === i && o(n.layers, t1)) {
                                for(const e1 in n.delegates)this.off(e1, n.delegates[e1]);
                                return e1.splice(r, 1), this;
                            }
                        }
                    })(r), this;
                }
                queryRenderedFeatures(t1, i) {
                    return this.style ? (void 0 !== i || void 0 === t1 || t1 instanceof e1.pointGeometry || Array.isArray(t1) || (i = t1, t1 = void 0), this.style.queryRenderedFeatures(t1 = t1 || [
                        [
                            0,
                            0
                        ],
                        [
                            this.transform.width,
                            this.transform.height
                        ]
                    ], i = i || {}, this.transform)) : [];
                }
                querySourceFeatures(e1, t1) {
                    return this.style.querySourceFeatures(e1, t1);
                }
                setStyle(t1, i) {
                    return !1 !== (i = e1.extend({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily
                    }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t1 ? (this._diffStyle(t1, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t1, i));
                }
                _getUIString(e1) {
                    const t1 = this._locale[e1];
                    if (null == t1) throw new Error(`Missing UI string '${e1}'`);
                    return t1;
                }
                _updateStyle(e1, t1) {
                    return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e1 && (this.style = new Qt(this, t1 || {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), "string" == typeof e1 ? this.style.loadURL(e1) : this.style.loadJSON(e1)), this._updateTerrain(), this;
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new Qt(this, {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty());
                }
                _diffStyle(t1, i) {
                    if ("string" == typeof t1) {
                        const o = this._requestManager.normalizeStyleURL(t1), r = this._requestManager.transformRequest(o, e1.ResourceType.Style);
                        e1.getJSON(r, (t1, o)=>{
                            t1 ? this.fire(new e1.ErrorEvent(t1)) : o && this._updateDiff(o, i);
                        });
                    } else "object" == typeof t1 && this._updateDiff(t1, i);
                }
                _updateDiff(t1, i) {
                    try {
                        this.style.setState(t1) && this._update(!0);
                    } catch (o) {
                        e1.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(t1, i);
                    }
                }
                getStyle() {
                    if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : (e1.warnOnce("There is no style added to the map."), !1);
                }
                addSource(e1, t1) {
                    return this._lazyInitEmptyStyle(), this.style.addSource(e1, t1), this._update(!0);
                }
                isSourceLoaded(e1) {
                    return !!this.style && this.style._isSourceCacheLoaded(e1);
                }
                areTilesLoaded() {
                    const e1 = this.style && this.style._sourceCaches;
                    for(const t1 in e1){
                        const i = e1[t1]._tiles;
                        for(const e1 in i){
                            const t1 = i[e1];
                            if ("loaded" !== t1.state && "errored" !== t1.state) return !1;
                        }
                    }
                    return !0;
                }
                addSourceType(e1, t1, i) {
                    this._lazyInitEmptyStyle(), this.style.addSourceType(e1, t1, i);
                }
                removeSource(e1) {
                    return this.style.removeSource(e1), this._updateTerrain(), this._update(!0);
                }
                getSource(e1) {
                    return this.style.getSource(e1);
                }
                addImage(t1, i, { pixelRatio: o = 1 , sdf: r = !1 , stretchX: n , stretchY: s , content: a  } = {}) {
                    if (this._lazyInitEmptyStyle(), i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap) {
                        const { width: l , height: c , data: h  } = e1.exported.getImageData(i);
                        this.style.addImage(t1, {
                            data: new e1.RGBAImage({
                                width: l,
                                height: c
                            }, h),
                            pixelRatio: o,
                            stretchX: n,
                            stretchY: s,
                            content: a,
                            sdf: r,
                            version: 0
                        });
                    } else if (void 0 === i.width || void 0 === i.height) this.fire(new e1.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const { width: l , height: c  } = i, h = i;
                        this.style.addImage(t1, {
                            data: new e1.RGBAImage({
                                width: l,
                                height: c
                            }, new Uint8Array(h.data)),
                            pixelRatio: o,
                            stretchX: n,
                            stretchY: s,
                            content: a,
                            sdf: r,
                            version: 0,
                            userImage: h
                        }), h.onAdd && h.onAdd(this, t1);
                    }
                }
                updateImage(t1, i) {
                    const o = this.style.getImage(t1);
                    if (!o) return void this.fire(new e1.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const r = i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap ? e1.exported.getImageData(i) : i, { width: n , height: s  } = r;
                    void 0 !== n && void 0 !== s ? n === o.data.width && s === o.data.height ? (o.data.replace(r.data, !(i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap)), this.style.updateImage(t1, o)) : this.fire(new e1.ErrorEvent(new Error(`The width and height of the updated image (${n}, ${s})\n                must be that same as the previous version of the image\n                (${o.data.width}, ${o.data.height})`))) : this.fire(new e1.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                }
                hasImage(t1) {
                    return t1 ? !!this.style.getImage(t1) : (this.fire(new e1.ErrorEvent(new Error("Missing required image id"))), !1);
                }
                removeImage(e1) {
                    this.style.removeImage(e1);
                }
                loadImage(t1, i) {
                    e1.getImage(this._requestManager.transformRequest(t1, e1.ResourceType.Image), (t1, o)=>{
                        i(t1, o instanceof e1.window.HTMLImageElement ? e1.exported.getImageData(o) : o);
                    });
                }
                listImages() {
                    return this.style.listImages();
                }
                addLayer(e1, t1) {
                    return this._lazyInitEmptyStyle(), this.style.addLayer(e1, t1), this._update(!0);
                }
                moveLayer(e1, t1) {
                    return this.style.moveLayer(e1, t1), this._update(!0);
                }
                removeLayer(e1) {
                    return this.style.removeLayer(e1), this._update(!0);
                }
                getLayer(e1) {
                    return this.style.getLayer(e1);
                }
                setLayerZoomRange(e1, t1, i) {
                    return this.style.setLayerZoomRange(e1, t1, i), this._update(!0);
                }
                setFilter(e1, t1, i = {}) {
                    return this.style.setFilter(e1, t1, i), this._update(!0);
                }
                getFilter(e1) {
                    return this.style.getFilter(e1);
                }
                setPaintProperty(e1, t1, i, o = {}) {
                    return this.style.setPaintProperty(e1, t1, i, o), this._update(!0);
                }
                getPaintProperty(e1, t1) {
                    return this.style.getPaintProperty(e1, t1);
                }
                setLayoutProperty(e1, t1, i, o = {}) {
                    return this.style.setLayoutProperty(e1, t1, i, o), this._update(!0);
                }
                getLayoutProperty(e1, t1) {
                    return this.style.getLayoutProperty(e1, t1);
                }
                setLight(e1, t1 = {}) {
                    return this._lazyInitEmptyStyle(), this.style.setLight(e1, t1), this._update(!0);
                }
                getLight() {
                    return this.style.getLight();
                }
                setTerrain(e1) {
                    return this._lazyInitEmptyStyle(), !e1 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e1), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
                }
                getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                }
                setFog(e1) {
                    return this._lazyInitEmptyStyle(), this.style.setFog(e1), this._update(!0);
                }
                getFog() {
                    return this.style ? this.style.getFog() : null;
                }
                _queryFogOpacity(t1) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e1.LngLat.convert(t1), this.transform) : 0;
                }
                setFeatureState(e1, t1) {
                    return this.style.setFeatureState(e1, t1), this._update();
                }
                removeFeatureState(e1, t1) {
                    return this.style.removeFeatureState(e1, t1), this._update();
                }
                getFeatureState(e1) {
                    return this.style.getFeatureState(e1);
                }
                _updateContainerDimensions() {
                    if (!this._container) return;
                    const t1 = this._container.getBoundingClientRect().width || 400, i = this._container.getBoundingClientRect().height || 300;
                    let o, r, n, s = this._container;
                    for(; s && (!r || !n);){
                        const t1 = e1.window.getComputedStyle(s).transform;
                        t1 && "none" !== t1 && (o = t1.match(/matrix.*\((.+)\)/)[1].split(", "), o[0] && "0" !== o[0] && "1" !== o[0] && (r = o[0]), o[3] && "0" !== o[3] && "1" !== o[3] && (n = o[3])), s = s.parentElement;
                    }
                    this._containerWidth = r ? Math.abs(t1 / r) : t1, this._containerHeight = n ? Math.abs(i / n) : i;
                }
                _detectMissingCSS() {
                    "rgb(250, 128, 114)" !== e1.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e1.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
                }
                _setupContainer() {
                    const e1 = this._container;
                    e1.classList.add("mapboxgl-map"), (this._missingCSSCanary = n("div", "mapboxgl-canary", e1)).style.visibility = "hidden", this._detectMissingCSS();
                    const t1 = this._canvasContainer = n("div", "mapboxgl-canvas-container", e1);
                    this._interactive && t1.classList.add("mapboxgl-interactive"), this._canvas = n("canvas", "mapboxgl-canvas", t1), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                    const i = this._controlContainer = n("div", "mapboxgl-control-container", e1), o = this._controlPositions = {};
                    [
                        "top-left",
                        "top-right",
                        "bottom-left",
                        "bottom-right"
                    ].forEach((e1)=>{
                        o[e1] = n("div", `mapboxgl-ctrl-${e1}`, i);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }
                _resizeCanvas(t1, i) {
                    const o = e1.exported.devicePixelRatio || 1;
                    this._canvas.width = o * Math.ceil(t1), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t1}px`, this._canvas.style.height = `${i}px`;
                }
                _addMarker(e1) {
                    this._markers.push(e1);
                }
                _removeMarker(e1) {
                    const t1 = this._markers.indexOf(e1);
                    -1 !== t1 && this._markers.splice(t1, 1);
                }
                _addPopup(e1) {
                    this._popups.push(e1);
                }
                _removePopup(e1) {
                    const t1 = this._popups.indexOf(e1);
                    -1 !== t1 && this._popups.splice(t1, 1);
                }
                _setupPainter() {
                    const t1 = e1.extend({}, i.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    }), o = this._useWebGL2 && this._canvas.getContext("webgl2", t1), r = o || this._canvas.getContext("webgl", t1) || this._canvas.getContext("experimental-webgl", t1);
                    r ? (this._useWebGL2 && !o && e1.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e1.storeAuthState(r, !0), this.painter = new Fo(r, this.transform, !!o), this.on("data", (e1)=>{
                        "source" === e1.dataType && this.painter.setTileLoadedFlag(!0);
                    }), e1.exported$1.testSupport(r)) : this.fire(new e1.ErrorEvent(new Error("Failed to initialize WebGL")));
                }
                _contextLost(t1) {
                    t1.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e1.Event("webglcontextlost", {
                        originalEvent: t1
                    }));
                }
                _contextRestored(t1) {
                    this._setupPainter(), this.resize(), this._update(), this.fire(new e1.Event("webglcontextrestored", {
                        originalEvent: t1
                    }));
                }
                _onMapScroll(e1) {
                    if (e1.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }
                _update(e1) {
                    return this.style ? (this._styleDirty = this._styleDirty || e1, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }
                _requestRenderFrame(e1) {
                    return this._update(), this._renderTaskQueue.add(e1);
                }
                _cancelRenderFrame(e1) {
                    this._renderTaskQueue.remove(e1);
                }
                _requestDomTask(e1) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? e1() : this._domRenderTaskQueue.add(e1);
                }
                _render(t1) {
                    let i;
                    const o = this.painter.context.extTimerQuery, r = e1.exported.now();
                    if (this.listens("gpu-timing-frame") && (i = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e1.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e1.window.performance.now())), this._renderTaskQueue.run(t1), this._domRenderTaskQueue.run(t1), this._removed) return;
                    this._updateProjectionTransition();
                    const n = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const t1 = this.transform.zoom, i = this.transform.pitch, o = e1.exported.now(), r = new e1.EvaluationParameters(t1, {
                            now: o,
                            fadeDuration: n,
                            pitch: i,
                            transition: this.style.getTransition()
                        });
                        this.style.update(r);
                    }
                    this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
                    let s = !1;
                    if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(r), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n, this._crossSourceCollisions), this.style && this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showTerrainWireframe: this.showTerrainWireframe,
                        showOverdrawInspector: this._showOverdrawInspector,
                        showQueryGeometry: !!this._showQueryGeometry,
                        showTileAABBs: this.showTileAABBs,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: n,
                        isInitialLoad: this._isInitialLoad,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer"),
                        gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                        speedIndexTiming: this.speedIndexTiming
                    }), this.fire(new e1.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e1.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i) {
                        const t1 = e1.exported.now() - r;
                        o.endQueryEXT(o.TIME_ELAPSED_EXT, i), setTimeout(()=>{
                            const n = o.getQueryObjectEXT(i, o.QUERY_RESULT_EXT) / 1e6;
                            o.deleteQueryEXT(i), this.fire(new e1.Event("gpu-timing-frame", {
                                cpuTime: t1,
                                gpuTime: n
                            })), e1.window.performance.mark("frame-gpu", {
                                startTime: r,
                                detail: {
                                    gpuTime: n
                                }
                            });
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const t1 = this.painter.collectGpuTimers();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimers(t1);
                            this.fire(new e1.Event("gpu-timing-layer", {
                                layerTimes: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                        const t1 = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimeDeferredRender(t1);
                            this.fire(new e1.Event("gpu-timing-deferred-render", {
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s;
                    if (a || this._repaint) this.triggerRepaint();
                    else {
                        const t1 = !this.isMoving() && this.loaded();
                        if (t1 && (s = this._updateAverageElevation(r, !0)), s) this.triggerRepaint();
                        else if (this._triggerFrame(!1), t1 && (this.fire(new e1.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const t1 = this._calculateSpeedIndex();
                            this.fire(new e1.Event("speedindexcompleted", {
                                speedIndex: t1
                            })), this.speedIndexTiming = !1;
                        }
                    }
                    !this._loaded || this._fullyLoaded || a || (this._fullyLoaded = !0, e1.LivePerformanceUtils.mark(e1.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e1.postPerformanceEvent(this._requestManager._customAccessToken, {
                        width: this.painter.width,
                        height: this.painter.height,
                        interactionRange: this._interactionRange,
                        visibilityHidden: this._visibilityHidden,
                        terrainEnabled: !!this.painter.style.getTerrain(),
                        fogEnabled: !!this.painter.style.getFog(),
                        projection: this.getProjection().name,
                        zoom: this.transform.zoom,
                        renderer: this.painter.context.renderer,
                        vendor: this.painter.context.vendor
                    }), this._authenticate());
                }
                _forceMarkerAndPopupUpdate(e1) {
                    for (const t1 of this._markers)e1 && !this.getRenderWorldCopies() && (t1._lngLat = t1._lngLat.wrap()), t1._update();
                    for (const t1 of this._popups)!e1 || this.getRenderWorldCopies() || t1._trackPointer || (t1._lngLat = t1._lngLat.wrap()), t1._update();
                }
                _updateAverageElevation(e1, t1 = !1) {
                    const i = (e1)=>(this.transform.averageElevation = e1, this._update(!1), !0);
                    if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);
                    if ((t1 || e1 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e1)) {
                        const t1 = this.transform.averageElevation;
                        let o = this.transform.sampleAverageElevation(), r = !1;
                        this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o) ? o = 0 : this._averageElevationLastSampledAt = e1;
                        const n = Math.abs(t1 - o);
                        if (n > 1) {
                            if (this._isInitialLoad || r) return this._averageElevation.jumpTo(o), i(o);
                            this._averageElevation.easeTo(o, e1, 300);
                        } else if (n > 1e-4) return this._averageElevation.jumpTo(o), i(o);
                    }
                    return !!this._averageElevation.isEasing(e1) && i(this._averageElevation.getValue(e1));
                }
                _authenticate() {
                    e1.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t1)=>{
                        if (t1 && (t1.message === e1.AUTH_ERR_MSG || 401 === t1.status)) {
                            const t1 = this.painter.context.gl;
                            e1.storeAuthState(t1, !1), this._logoControl instanceof Jr && this._logoControl._updateLogo(), t1 && t1.clear(t1.DEPTH_BUFFER_BIT | t1.COLOR_BUFFER_BIT | t1.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e1.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                        }
                    }), e1.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ()=>{});
                }
                _updateTerrain() {
                    const e1 = this._isDragging();
                    this.painter.updateTerrain(this.style, e1);
                }
                _calculateSpeedIndex() {
                    const e1 = this.painter.canvasCopy(), t1 = this.painter.getCanvasCopiesAndTimestamps();
                    t1.timeStamps.push(performance.now());
                    const i = this.painter.context.gl, o = i.createFramebuffer();
                    function r(e1) {
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e1, 0);
                        const t1 = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                        return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t1), t1;
                    }
                    return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e1), t1.canvasCopies.map(r), t1.timeStamps);
                }
                _canvasPixelComparison(e1, t1, i) {
                    let o = i[1] - i[0];
                    const r = e1.length / 4;
                    for(let n = 0; n < t1.length; n++){
                        const s = t1[n];
                        let a = 0;
                        for(let t1 = 0; t1 < s.length; t1 += 4)s[t1] === e1[t1] && s[t1 + 1] === e1[t1 + 1] && s[t1 + 2] === e1[t1 + 2] && s[t1 + 3] === e1[t1 + 3] && (a += 1);
                        o += (i[n + 2] - i[n + 1]) * (1 - a / r);
                    }
                    return o;
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const e1 of this._controls)e1.onRemove(this);
                    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e1.window && (e1.window.removeEventListener("resize", this._onWindowResize, !1), e1.window.removeEventListener("orientationchange", this._onWindowResize, !1), e1.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), e1.window.removeEventListener("online", this._onWindowOnline, !1), e1.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
                    const t1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    t1 && t1.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), e1.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e1.Event("remove"));
                }
                triggerRepaint() {
                    this._triggerFrame(!0);
                }
                _triggerFrame(t1) {
                    this._renderNextFrame = this._renderNextFrame || t1, this.style && !this._frame && (this._frame = e1.exported.frame((e1)=>{
                        const t1 = !!this._renderNextFrame;
                        this._frame = null, this._renderNextFrame = null, t1 && this._render(e1);
                    }));
                }
                _preloadTiles(t1) {
                    const i = this.style ? Object.values(this.style._sourceCaches) : [];
                    return e1.asyncAll(i, (e1, i)=>e1._preloadTiles(t1, i), ()=>{
                        this.triggerRepaint();
                    }), this;
                }
                _onWindowOnline() {
                    this._update();
                }
                _onWindowResize(e1) {
                    this._trackResize && this.resize({
                        originalEvent: e1
                    })._update();
                }
                _onVisibilityChange() {
                    "hidden" === e1.window.document.visibilityState && this._visibilityHidden++;
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }
                set showTileBoundaries(e1) {
                    this._showTileBoundaries !== e1 && (this._showTileBoundaries = e1, this._update());
                }
                get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                }
                set showTerrainWireframe(e1) {
                    this._showTerrainWireframe !== e1 && (this._showTerrainWireframe = e1, this._update());
                }
                get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                }
                set speedIndexTiming(e1) {
                    this._speedIndexTiming !== e1 && (this._speedIndexTiming = e1, this._update());
                }
                get showPadding() {
                    return !!this._showPadding;
                }
                set showPadding(e1) {
                    this._showPadding !== e1 && (this._showPadding = e1, this._update());
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(e1) {
                    this._showCollisionBoxes !== e1 && (this._showCollisionBoxes = e1, e1 ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(e1) {
                    this._showOverdrawInspector !== e1 && (this._showOverdrawInspector = e1, this._update());
                }
                get repaint() {
                    return !!this._repaint;
                }
                set repaint(e1) {
                    this._repaint !== e1 && (this._repaint = e1, this.triggerRepaint());
                }
                get vertices() {
                    return !!this._vertices;
                }
                set vertices(e1) {
                    this._vertices = e1, this._update();
                }
                get showTileAABBs() {
                    return !!this._showTileAABBs;
                }
                set showTileAABBs(e1) {
                    this._showTileAABBs !== e1 && (this._showTileAABBs = e1, e1 && this._update());
                }
                _setCacheLimits(t1, i) {
                    e1.setCacheLimits(t1, i);
                }
                get version() {
                    return e1.version;
                }
            },
            NavigationControl: class {
                constructor(t1){
                    this.options = e1.extend({}, hn, t1), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e1)=>e1.preventDefault()), this.options.showZoom && (e1.bindAll([
                        "_setButtonTitle",
                        "_updateZoomButtons"
                    ], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e1)=>{
                        this._map && this._map.zoomIn({}, {
                            originalEvent: e1
                        });
                    }), n("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e1)=>{
                        this._map && this._map.zoomOut({}, {
                            originalEvent: e1
                        });
                    }), n("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e1.bindAll([
                        "_rotateCompassArrow"
                    ], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e1)=>{
                        const t1 = this._map;
                        t1 && (this.options.visualizePitch ? t1.resetNorthPitch({}, {
                            originalEvent: e1
                        }) : t1.resetNorth({}, {
                            originalEvent: e1
                        }));
                    }), this._compassIcon = n("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const e1 = this._map;
                    if (!e1) return;
                    const t1 = e1.getZoom(), i = t1 === e1.getMaxZoom(), o = t1 === e1.getMinZoom();
                    this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
                }
                _rotateCompassArrow() {
                    const e1 = this._map;
                    if (!e1) return;
                    const t1 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e1.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e1.transform.pitch}deg) rotateZ(${e1.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e1.transform.angle * (180 / Math.PI)}deg)`;
                    e1._requestDomTask(()=>{
                        this._compassIcon && (this._compassIcon.style.transform = t1);
                    });
                }
                onAdd(e1) {
                    return this._map = e1, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e1.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e1.on("pitch", this._rotateCompassArrow), e1.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new un(e1, this._compass, this.options.visualizePitch)), this._container;
                }
                onRemove() {
                    const e1 = this._map;
                    e1 && (this._container.remove(), this.options.showZoom && e1.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e1.off("pitch", this._rotateCompassArrow), e1.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
                }
                _createButton(e1, t1) {
                    const i = n("button", e1, this._container);
                    return i.type = "button", i.addEventListener("click", t1), i;
                }
                _setButtonTitle(e1, t1) {
                    if (!this._map) return;
                    const i = this._map._getUIString(`NavigationControl.${t1}`);
                    e1.setAttribute("aria-label", i), e1.firstElementChild && e1.firstElementChild.setAttribute("title", i);
                }
            },
            GeolocateControl: class extends e1.Evented {
                constructor(t1){
                    super(), this.options = e1.extend({
                        geolocation: e1.window.navigator.geolocation
                    }, _n, t1), e1.bindAll([
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker",
                        "_updateMarkerRotation",
                        "_onDeviceOrientation"
                    ], this), this._updateMarkerRotationThrottled = Jo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
                }
                onAdd(e1) {
                    return this._map = e1, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
                }
                onRemove() {
                    void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
                }
                _checkGeolocationSupport(t1) {
                    const i = (e1 = !!this.options.geolocation)=>{
                        this._supportsGeolocation = e1, t1(e1);
                    };
                    void 0 !== this._supportsGeolocation ? t1(this._supportsGeolocation) : void 0 !== e1.window.navigator.permissions ? e1.window.navigator.permissions.query({
                        name: "geolocation"
                    }).then((e1)=>i("denied" !== e1.state)).catch(()=>i()) : i();
                }
                _isOutOfMapMaxBounds(e1) {
                    const t1 = this._map.getMaxBounds(), i = e1.coords;
                    return !!t1 && (i.longitude < t1.getWest() || i.longitude > t1.getEast() || i.latitude < t1.getSouth() || i.latitude > t1.getNorth());
                }
                _setErrorState() {
                    switch(this._watchState){
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                    }
                }
                _onSuccess(t1) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(t1)) return this._setErrorState(), this.fire(new e1.Event("outofmaxbounds", t1)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation) switch(this._lastKnownPosition = t1, this._watchState){
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                        }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t1), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t1), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e1.Event("geolocate", t1)), this._finish();
                    }
                }
                _updateCamera(t1) {
                    const i = new e1.LngLat(t1.coords.longitude, t1.coords.latitude), o = t1.coords.accuracy, r = this._map.getBearing(), n = e1.extend({
                        bearing: r
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i.toBounds(o), n, {
                        geolocateSource: !0
                    });
                }
                _updateMarker(t1) {
                    if (t1) {
                        const i = new e1.LngLat(t1.coords.longitude, t1.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t1.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                    const t1 = this._map.transform, i = e1.mercatorZfromAltitude(1, t1._center.lat) * t1.worldSize, o = Math.ceil(2 * this._accuracy * i);
                    this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }
                _updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
                }
                _onError(t1) {
                    if (this._map) {
                        if (this.options.trackUserLocation) {
                            if (1 === t1.code) {
                                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                const e1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.setAttribute("aria-label", e1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e1), void 0 !== this._geolocationWatchID && this._clearWatch();
                            } else {
                                if (3 === t1.code && this._noTimeout) return;
                                this._setErrorState();
                            }
                        }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e1.Event("error", t1)), this._finish();
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }
                _setupUI(t1) {
                    if (void 0 !== this._map) {
                        if (this._container.addEventListener("contextmenu", (e1)=>e1.preventDefault()), this._geolocateButton = n("button", "mapboxgl-ctrl-geolocate", this._container), n("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t1) {
                            e1.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const t1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t1);
                        } else {
                            const e1 = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", e1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e1);
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n("div", "mapboxgl-user-location"), this._dotElement.appendChild(n("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new on({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map"
                        }), this._circleElement = n("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new on({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t1)=>{
                            t1.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t1.originalEvent && "resize" === t1.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e1.Event("trackuserlocationend")));
                        });
                    }
                }
                _onDeviceOrientation(e1) {
                    this._userLocationDotMarker && (e1.webkitCompassHeading ? this._heading = e1.webkitCompassHeading : !0 === e1.absolute && (this._heading = -1 * e1.alpha), this._updateMarkerRotationThrottled());
                }
                trigger() {
                    if (!this._setup) return e1.warnOnce("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch(this._watchState){
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new e1.Event("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e1.Event("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e1.Event("trackuserlocationstart"));
                        }
                        switch(this._watchState){
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                        }
                        if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                        else if (void 0 === this._geolocationWatchID) {
                            let e1;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e1 = {
                                maximumAge: 6e5,
                                timeout: 0
                            }, this._noTimeout = !0) : (e1 = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e1), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
                    return !0;
                }
                _addDeviceOrientationListener() {
                    const t1 = ()=>{
                        e1.window.addEventListener("ondeviceorientationabsolute" in e1.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
                    };
                    void 0 !== e1.window.DeviceMotionEvent && "function" == typeof e1.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e1)=>{
                        "granted" === e1 && t1();
                    }).catch(console.error) : t1();
                }
                _clearWatch() {
                    this.options.geolocation.clearWatch(this._geolocationWatchID), e1.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e1.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            },
            AttributionControl: Kr,
            ScaleControl: class {
                constructor(t1){
                    this.options = e1.extend({}, dn, t1), function() {
                        try {
                            return new Intl.NumberFormat("en", {
                                style: "unit",
                                unitDisplay: "narrow",
                                unit: "meter"
                            }), !0;
                        } catch (e1) {
                            return !1;
                        }
                    }() || (this._setScale = pn.bind(this)), e1.bindAll([
                        "_update",
                        "_setScale",
                        "setUnit"
                    ], this);
                }
                getDefaultPosition() {
                    return "bottom-left";
                }
                _update() {
                    const e1 = this.options.maxWidth || 100, t1 = this._map, i = t1._containerHeight / 2, o = t1._containerWidth / 2 - e1 / 2, r = t1.unproject([
                        o,
                        i
                    ]), n = t1.unproject([
                        o + e1,
                        i
                    ]), s = r.distanceTo(n);
                    if ("imperial" === this.options.unit) {
                        const t1 = 3.2808 * s;
                        t1 > 5280 ? this._setScale(e1, t1 / 5280, "mile") : this._setScale(e1, t1, "foot");
                    } else "nautical" === this.options.unit ? this._setScale(e1, s / 1852, "nautical-mile") : s >= 1e3 ? this._setScale(e1, s / 1e3, "kilometer") : this._setScale(e1, s, "meter");
                }
                _setScale(e1, t1, i) {
                    const o = mn(t1), r = o / t1;
                    this._map._requestDomTask(()=>{
                        this._container.style.width = e1 * r + "px", this._container.innerHTML = "nautical-mile" !== i ? new Intl.NumberFormat(this._language, {
                            style: "unit",
                            unitDisplay: "narrow",
                            unit: i
                        }).format(o) : `${o}&nbsp;nm`;
                    });
                }
                onAdd(e1) {
                    return this._map = e1, this._language = e1.getLanguage(), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e1.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
                }
                onRemove() {
                    this._container.remove(), this._map.off("move", this._update), this._map = void 0;
                }
                _setLanguage(e1) {
                    this._language = e1, this._update();
                }
                setUnit(e1) {
                    this.options.unit = e1, this._update();
                }
            },
            FullscreenControl: class {
                constructor(t1){
                    this._fullscreen = !1, t1 && t1.container && (t1.container instanceof e1.window.HTMLElement ? this._container = t1.container : e1.warnOnce("Full screen control 'container' must be a DOM element.")), e1.bindAll([
                        "_onClickFullscreen",
                        "_changeIcon"
                    ], this), "onfullscreenchange" in e1.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e1.window.document && (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(t1) {
                    return this._map = t1, this._container || (this._container = this._map.getContainer()), this._controlContainer = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e1.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
                }
                onRemove() {
                    this._controlContainer.remove(), this._map = null, e1.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !(!e1.window.document.fullscreenEnabled && !e1.window.document.webkitFullscreenEnabled);
                }
                _setupUI() {
                    const t1 = this._fullscreenButton = n("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                    n("span", "mapboxgl-ctrl-icon", t1).setAttribute("aria-hidden", "true"), t1.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e1.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const e1 = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", e1), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e1);
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }
                _isFullscreen() {
                    return this._fullscreen;
                }
                _changeIcon() {
                    (e1.window.document.fullscreenElement || e1.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? e1.window.document.exitFullscreen ? e1.window.document.exitFullscreen() : e1.window.document.webkitCancelFullScreen && e1.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            },
            Popup: class extends e1.Evented {
                constructor(t1){
                    super(), this.options = e1.extend(Object.create(rn), t1), e1.bindAll([
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseEvent"
                    ], this), this._classList = new Set(t1 && t1.className ? t1.className.trim().split(/\s+/) : []);
                }
                addTo(t1) {
                    return this._map && this.remove(), this._map = t1, this.options.closeOnClick && t1.on("preclick", this._onClose), this.options.closeOnMove && t1.on("move", this._onClose), t1.on("remove", this.remove), this._update(), t1._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t1.on("mousemove", this._onMouseEvent), t1.on("mouseup", this._onMouseEvent), t1._canvasContainer.classList.add("mapboxgl-track-pointer")) : t1.on("move", this._update), this.fire(new e1.Event("open")), this;
                }
                isOpen() {
                    return !!this._map;
                }
                remove() {
                    this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
                    const t1 = this._map;
                    return t1 && (t1.off("move", this._update), t1.off("move", this._onClose), t1.off("preclick", this._onClose), t1.off("click", this._onClose), t1.off("remove", this.remove), t1.off("mousemove", this._onMouseEvent), t1.off("mouseup", this._onMouseEvent), t1.off("drag", this._onMouseEvent), t1._canvasContainer && t1._canvasContainer.classList.remove("mapboxgl-track-pointer"), t1._removePopup(this), this._map = void 0), this.fire(new e1.Event("close")), this;
                }
                getLngLat() {
                    return this._lngLat;
                }
                setLngLat(t1) {
                    this._lngLat = e1.LngLat.convert(t1), this._pos = null, this._trackPointer = !1, this._update();
                    const i = this._map;
                    return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
                }
                trackPointer() {
                    this._trackPointer = !0, this._pos = null, this._update();
                    const e1 = this._map;
                    return e1 && (e1.off("move", this._update), e1.on("mousemove", this._onMouseEvent), e1.on("drag", this._onMouseEvent), e1._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
                }
                getElement() {
                    return this._container;
                }
                setText(t1) {
                    return this.setDOMContent(e1.window.document.createTextNode(t1));
                }
                setHTML(t1) {
                    const i = e1.window.document.createDocumentFragment(), o = e1.window.document.createElement("body");
                    let r;
                    for(o.innerHTML = t1; r = o.firstChild, r;)i.appendChild(r);
                    return this.setDOMContent(i);
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(e1) {
                    return this.options.maxWidth = e1, this._update(), this;
                }
                setDOMContent(e1) {
                    let t1 = this._content;
                    if (t1) for(; t1.hasChildNodes();)t1.firstChild && t1.removeChild(t1.firstChild);
                    else t1 = this._content = n("div", "mapboxgl-popup-content", this._container || void 0);
                    if (t1.appendChild(e1), this.options.closeButton) {
                        const e1 = this._closeButton = n("button", "mapboxgl-popup-close-button", t1);
                        e1.type = "button", e1.setAttribute("aria-label", "Close popup"), e1.setAttribute("aria-hidden", "true"), e1.innerHTML = "&#215;", e1.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                }
                addClassName(e1) {
                    return this._classList.add(e1), this._updateClassList(), this;
                }
                removeClassName(e1) {
                    return this._classList.delete(e1), this._updateClassList(), this;
                }
                setOffset(e1) {
                    return this.options.offset = e1, this._update(), this;
                }
                toggleClassName(e1) {
                    let t1;
                    return this._classList.delete(e1) ? t1 = !1 : (this._classList.add(e1), t1 = !0), this._updateClassList(), t1;
                }
                _onMouseEvent(e1) {
                    this._update(e1.point);
                }
                _getAnchor(e1) {
                    if (this.options.anchor) return this.options.anchor;
                    const t1 = this._map, i = this._container, o = this._pos;
                    if (!t1 || !i || !o) return "bottom";
                    const r = i.offsetWidth, n = i.offsetHeight, s = o.x < r / 2, a = o.x > t1.transform.width - r / 2;
                    if (o.y + e1 < n) return s ? "top-left" : a ? "top-right" : "top";
                    if (o.y > t1.transform.height - n) {
                        if (s) return "bottom-left";
                        if (a) return "bottom-right";
                    }
                    return s ? "left" : a ? "right" : "bottom";
                }
                _updateClassList() {
                    const e1 = this._container;
                    if (!e1) return;
                    const t1 = [
                        ...this._classList
                    ];
                    t1.push("mapboxgl-popup"), this._anchor && t1.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t1.push("mapboxgl-popup-track-pointer"), e1.className = t1.join(" ");
                }
                _update(t1) {
                    const i = this._map, o = this._content;
                    if (!i || !this._lngLat && !this._trackPointer || !o) return;
                    let r = this._container;
                    if (r || (r = this._container = n("div", "mapboxgl-popup", i.getContainer()), this._tip = n("div", "mapboxgl-popup-tip", r), r.appendChild(o)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = en(this._lngLat, this._pos, i.transform)), !this._trackPointer || t1) {
                        const e1 = this._pos = this._trackPointer && t1 ? t1 : i.project(this._lngLat), o = sn(this.options.offset), r = this._anchor = this._getAnchor(o.y), n = sn(this.options.offset, r), s = e1.add(n).round();
                        i._requestDomTask(()=>{
                            this._container && r && (this._container.style.transform = `${tn[r]} translate(${s.x}px,${s.y}px)`);
                        });
                    }
                    if (!this._marker && i._showingGlobe()) {
                        const t1 = e1.isLngLatBehindGlobe(i.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(t1);
                    }
                    this._updateClassList();
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const e1 = this._container.querySelector(nn);
                    e1 && e1.focus();
                }
                _onClose() {
                    this.remove();
                }
                _setOpacity(e1) {
                    this._container && (this._container.style.opacity = `${e1}`), this._content && (this._content.style.pointerEvents = e1 ? "auto" : "none");
                }
            },
            Marker: on,
            Style: Qt,
            LngLat: e1.LngLat,
            LngLatBounds: e1.LngLatBounds,
            Point: e1.pointGeometry,
            MercatorCoordinate: e1.MercatorCoordinate,
            FreeCameraOptions: Zo,
            Evented: e1.Evented,
            config: e1.config,
            prewarm: function() {
                je().acquire(Ue);
            },
            clearPrewarmedResources: function() {
                const e1 = Ge;
                e1 && (e1.isPreloaded() && 1 === e1.numActive() ? (e1.release(Ue), Ge = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
            },
            get accessToken () {
                return e1.config.ACCESS_TOKEN;
            },
            set accessToken (t){
                e1.config.ACCESS_TOKEN = t;
            },
            get baseApiUrl () {
                return e1.config.API_URL;
            },
            set baseApiUrl (t){
                e1.config.API_URL = t;
            },
            get workerCount () {
                return Ne.workerCount;
            },
            set workerCount (e){
                Ne.workerCount = e;
            },
            get maxParallelImageRequests () {
                return e1.config.MAX_PARALLEL_IMAGE_REQUESTS;
            },
            set maxParallelImageRequests (t){
                e1.config.MAX_PARALLEL_IMAGE_REQUESTS = t;
            },
            clearStorage (t1) {
                e1.clearTileCache(t1);
            },
            workerUrl: "",
            workerClass: null,
            setNow: e1.exported.setNow,
            restoreNow: e1.exported.restoreNow
        };
        return fn;
    });
    //
    var mapboxgl$1 = mapboxgl;
    return mapboxgl$1;
});

},{}],"cxbpN":[function(require,module,exports) {
// import { mapboxgl, MapboxClient } from "mapbox-gl";
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapboxClient", ()=>mapboxClient);
const MapboxClient = require("8c8bf1d9f17e1045");
const MAPBOX_TOKEN = "pk.eyJ1IjoiZGFuaWVsYS1ha2VybWFuIiwiYSI6ImNsZGs3aXo0MzE1MG4zdXMyNXF3ZDRnYzUifQ.kr3GsybRoqh2YOfz4faKgw";
const mapboxClient = new MapboxClient(MAPBOX_TOKEN);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","8c8bf1d9f17e1045":"jvDer"}],"jvDer":[function(require,module,exports) {
"use strict";
var makeClient = require("297fe6b7c9f15728");
var xtend = require("f2354ba18748522c").extendMutable;
var getUser = require("59b7289fa2b6ca6b");
var MapboxGeocoding = require("dc22f07adac0ce26");
var MapboxSurface = require("460484905ba1c67a");
var MapboxDirections = require("9327a42de4d1c7ed");
var MapboxUploads = require("4d4c72574a464562");
var MapboxMatching = require("781141d7d4680a70");
var MapboxDatasets = require("2abbbf26a96ea7ba");
var MapboxMatrix = require("6e6439956748c2fd");
var MapboxTilestats = require("e838eadfd55f3e36");
var MapboxStyles = require("7a7287de50c8e6b4");
var MapboxStatic = require("e51dabac14227737");
var MapboxTilesets = require("5449d11c39cf07f3");
var MapboxTokens = require("e195f593fa92d659");
/**
 * The JavaScript API to Mapbox services
 *
 * @class
 * @throws {Error} if accessToken is not provided
 * @param {string} accessToken a private or public access token
 * @param {Object} options additional options provided for configuration
 * @param {string} [options.endpoint=https://api.mapbox.com] location
 * of the Mapbox API pointed-to. This can be customized to point to a
 * Mapbox Atlas Server instance, or a different service, a mock,
 * or a staging endpoint. Usually you don't need to customize this.
 * @param {string} [options.account] account id to use for api
 * requests. If not is specified, the account defaults to the owner
 * of the provided accessToken.
 * @example
 * var client = new MapboxClient('ACCESSTOKEN');
 */ var MapboxClient = makeClient("MapboxClient");
// Combine all client APIs into one API for when people require()
// the main mapbox-sdk-js library.
xtend(MapboxClient.prototype, MapboxGeocoding.prototype, MapboxSurface.prototype, MapboxDirections.prototype, MapboxMatrix.prototype, MapboxMatching.prototype, MapboxDatasets.prototype, MapboxUploads.prototype, MapboxTilestats.prototype, MapboxStyles.prototype, MapboxStatic.prototype, MapboxTilesets.prototype, MapboxTokens.prototype);
MapboxClient.getUser = getUser;
module.exports = MapboxClient;

},{"297fe6b7c9f15728":"czhc8","f2354ba18748522c":"oeR9s","59b7289fa2b6ca6b":"k0he1","dc22f07adac0ce26":"1DWGK","460484905ba1c67a":"jClEW","9327a42de4d1c7ed":"7zyxf","4d4c72574a464562":"gbvyF","781141d7d4680a70":"k2iff","2abbbf26a96ea7ba":"l2usb","6e6439956748c2fd":"4ViaM","e838eadfd55f3e36":"gukND","7a7287de50c8e6b4":"3yiai","e51dabac14227737":"eRiQz","5449d11c39cf07f3":"6pINk","e195f593fa92d659":"kACIX"}],"czhc8":[function(require,module,exports) {
"use strict";
var invariant = require("88216b00806496d4");
var constants = require("fdf0d7a2e449d5ae");
var client = require("df2b060595d9608f");
var getUser = require("da95aedcabd8c967");
/**
 * Services all have the same constructor pattern: you initialize them
 * with an access token and options, and they validate those arguments
 * in a predictable way. This is a constructor-generator that makes
 * it possible to require each service's API individually.
 *
 * @private
 * @param {string} name the name of the Mapbox API this class will access:
 * this is set to the name of the function so it will show up in tracebacks
 * @returns {Function} constructor function
 */ function makeService(name) {
    function service(accessToken, options) {
        this.name = name;
        invariant(typeof accessToken === "string", "accessToken required to instantiate Mapbox client");
        var endpoint = constants.DEFAULT_ENDPOINT;
        if (options !== undefined) {
            invariant(typeof options === "object", "options must be an object");
            if (options.endpoint) {
                invariant(typeof options.endpoint === "string", "endpoint must be a string");
                endpoint = options.endpoint;
            }
            if (options.account) {
                invariant(typeof options.account === "string", "account must be a string");
                this.owner = options.account;
            }
        }
        this.client = client({
            endpoint: endpoint,
            accessToken: accessToken
        });
        this.accessToken = accessToken;
        this.endpoint = endpoint;
        this.owner = this.owner || getUser(accessToken);
        invariant(!!this.owner, "could not determine account from provided accessToken");
    }
    return service;
}
module.exports = makeService;

},{"88216b00806496d4":"ja2cL","fdf0d7a2e449d5ae":"cQLum","df2b060595d9608f":"9LFDB","da95aedcabd8c967":"k0he1"}],"ja2cL":[function(require,module,exports) {
/*
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */ "use strict";
/*
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */ var NODE_ENV = "development";
var invariant = function(condition, format, a, b, c, d, e, f) {
    if (NODE_ENV !== "production") {
        if (format === undefined) throw new Error("invariant requires an error message argument");
    }
    if (!condition) {
        var error;
        if (format === undefined) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        else {
            var args = [
                a,
                b,
                c,
                d,
                e,
                f
            ];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function() {
                return args[argIndex++];
            }));
            error.name = "Invariant Violation";
        }
        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
    }
};
module.exports = invariant;

},{}],"cQLum":[function(require,module,exports) {
module.exports.DEFAULT_ENDPOINT = "https://api.mapbox.com";

},{}],"9LFDB":[function(require,module,exports) {
"use strict";
// install ES6 Promise polyfill
require("7385d2e4caa2b111");
var rest = require("fdf1711c97915975");
// rest.js client with MIME support
module.exports = function(config) {
    return rest.wrap(require("21edf2bcb395f8cf")).wrap(require("8bd4ba4e782c9d0b"), {
        prefix: config.endpoint
    }).wrap(require("ea486fa5decf9d2b"), {
        mime: "application/json"
    }).wrap(require("343ec9c79b5d55e7")).wrap(require("1e7c230899b5576a"), {
        params: {
            access_token: config.accessToken
        }
    }).wrap(require("4d066230983eae11"), {
        access_token: config.accessToken
    }).wrap(require("c4870de32e2bc8e0")).wrap(require("f9aa01ada7ac5727"));
};

},{"7385d2e4caa2b111":"1vHlJ","fdf1711c97915975":"klm3A","21edf2bcb395f8cf":"j8RoM","8bd4ba4e782c9d0b":"32XoP","ea486fa5decf9d2b":"7Uegs","343ec9c79b5d55e7":"j3KMB","1e7c230899b5576a":"92BbG","4d066230983eae11":"3RKwg","c4870de32e2bc8e0":"74Bhx","f9aa01ada7ac5727":"5Rn3i"}],"1vHlJ":[function(require,module,exports) {
"use strict";
// Installs ES6 Promise polyfill if a native Promise is not available
if (typeof Promise === "undefined") require("14be8fa22228d622").polyfill();
module.export = Promise;

},{"14be8fa22228d622":"kDkOs"}],"kDkOs":[function(require,module,exports) {
var process = require("6176c6218d752994");
var global = arguments[3];
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */ (function(global, factory) {
    module.exports = factory();
})(this, function() {
    "use strict";
    function objectOrFunction(x) {
        var type = typeof x;
        return x !== null && (type === "object" || type === "function");
    }
    function isFunction(x) {
        return typeof x === "function";
    }
    var _isArray = void 0;
    if (Array.isArray) _isArray = Array.isArray;
    else _isArray = function(x) {
        return Object.prototype.toString.call(x) === "[object Array]";
    };
    var isArray = _isArray;
    var len = 0;
    var vertxNext = void 0;
    var customSchedulerFn = void 0;
    var asap = function asap(callback, arg) {
        queue[len] = callback;
        queue[len + 1] = arg;
        len += 2;
        if (len === 2) {
            // If len is 2, that means that we need to schedule an async flush.
            // If additional callbacks are queued before the queue is flushed, they
            // will be processed by this flush that we are scheduling.
            if (customSchedulerFn) customSchedulerFn(flush);
            else scheduleFlush();
        }
    };
    function setScheduler(scheduleFn) {
        customSchedulerFn = scheduleFn;
    }
    function setAsap(asapFn) {
        asap = asapFn;
    }
    var browserWindow = typeof window !== "undefined" ? window : undefined;
    var browserGlobal = browserWindow || {};
    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
    var isNode = typeof self === "undefined" && typeof process !== "undefined" && ({}).toString.call(process) === "[object process]";
    // test for web worker but not in IE10
    var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
    // node
    function useNextTick() {
        // node version 0.10.x displays a deprecation warning when nextTick is used recursively
        // see https://github.com/cujojs/when/issues/410 for details
        return function() {
            return process.nextTick(flush);
        };
    }
    // vertx
    function useVertxTimer() {
        if (typeof vertxNext !== "undefined") return function() {
            vertxNext(flush);
        };
        return useSetTimeout();
    }
    function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node = document.createTextNode("");
        observer.observe(node, {
            characterData: true
        });
        return function() {
            node.data = iterations = ++iterations % 2;
        };
    }
    // web worker
    function useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = flush;
        return function() {
            return channel.port2.postMessage(0);
        };
    }
    function useSetTimeout() {
        // Store setTimeout reference so es6-promise will be unaffected by
        // other code modifying setTimeout (like sinon.useFakeTimers())
        var globalSetTimeout = setTimeout;
        return function() {
            return globalSetTimeout(flush, 1);
        };
    }
    var queue = new Array(1000);
    function flush() {
        for(var i = 0; i < len; i += 2){
            var callback = queue[i];
            var arg = queue[i + 1];
            callback(arg);
            queue[i] = undefined;
            queue[i + 1] = undefined;
        }
        len = 0;
    }
    function attemptVertx() {
        try {
            var vertx = Function("return this")().require("vertx");
            vertxNext = vertx.runOnLoop || vertx.runOnContext;
            return useVertxTimer();
        } catch (e) {
            return useSetTimeout();
        }
    }
    var scheduleFlush = void 0;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (isNode) scheduleFlush = useNextTick();
    else if (BrowserMutationObserver) scheduleFlush = useMutationObserver();
    else if (isWorker) scheduleFlush = useMessageChannel();
    else if (browserWindow === undefined && true) scheduleFlush = attemptVertx();
    else scheduleFlush = useSetTimeout();
    function then(onFulfillment, onRejection) {
        var parent = this;
        var child = new this.constructor(noop);
        if (child[PROMISE_ID] === undefined) makePromise(child);
        var _state = parent._state;
        if (_state) {
            var callback = arguments[_state - 1];
            asap(function() {
                return invokeCallback(_state, child, callback, parent._result);
            });
        } else subscribe(parent, child, onFulfillment, onRejection);
        return child;
    }
    /**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/ function resolve$1(object) {
        /*jshint validthis:true */ var Constructor = this;
        if (object && typeof object === "object" && object.constructor === Constructor) return object;
        var promise = new Constructor(noop);
        resolve(promise, object);
        return promise;
    }
    var PROMISE_ID = Math.random().toString(36).substring(2);
    function noop() {}
    var PENDING = void 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    function selfFulfillment() {
        return new TypeError("You cannot resolve a promise with itself");
    }
    function cannotReturnOwn() {
        return new TypeError("A promises callback cannot return that same promise.");
    }
    function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
        try {
            then$$1.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
            return e;
        }
    }
    function handleForeignThenable(promise, thenable, then$$1) {
        asap(function(promise) {
            var sealed = false;
            var error = tryThen(then$$1, thenable, function(value) {
                if (sealed) return;
                sealed = true;
                if (thenable !== value) resolve(promise, value);
                else fulfill(promise, value);
            }, function(reason) {
                if (sealed) return;
                sealed = true;
                reject(promise, reason);
            }, "Settle: " + (promise._label || " unknown promise"));
            if (!sealed && error) {
                sealed = true;
                reject(promise, error);
            }
        }, promise);
    }
    function handleOwnThenable(promise, thenable) {
        if (thenable._state === FULFILLED) fulfill(promise, thenable._result);
        else if (thenable._state === REJECTED) reject(promise, thenable._result);
        else subscribe(thenable, undefined, function(value) {
            return resolve(promise, value);
        }, function(reason) {
            return reject(promise, reason);
        });
    }
    function handleMaybeThenable(promise, maybeThenable, then$$1) {
        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) handleOwnThenable(promise, maybeThenable);
        else {
            if (then$$1 === undefined) fulfill(promise, maybeThenable);
            else if (isFunction(then$$1)) handleForeignThenable(promise, maybeThenable, then$$1);
            else fulfill(promise, maybeThenable);
        }
    }
    function resolve(promise, value) {
        if (promise === value) reject(promise, selfFulfillment());
        else if (objectOrFunction(value)) {
            var then$$1 = void 0;
            try {
                then$$1 = value.then;
            } catch (error) {
                reject(promise, error);
                return;
            }
            handleMaybeThenable(promise, value, then$$1);
        } else fulfill(promise, value);
    }
    function publishRejection(promise) {
        if (promise._onerror) promise._onerror(promise._result);
        publish(promise);
    }
    function fulfill(promise, value) {
        if (promise._state !== PENDING) return;
        promise._result = value;
        promise._state = FULFILLED;
        if (promise._subscribers.length !== 0) asap(publish, promise);
    }
    function reject(promise, reason) {
        if (promise._state !== PENDING) return;
        promise._state = REJECTED;
        promise._result = reason;
        asap(publishRejection, promise);
    }
    function subscribe(parent, child, onFulfillment, onRejection) {
        var _subscribers = parent._subscribers;
        var length = _subscribers.length;
        parent._onerror = null;
        _subscribers[length] = child;
        _subscribers[length + FULFILLED] = onFulfillment;
        _subscribers[length + REJECTED] = onRejection;
        if (length === 0 && parent._state) asap(publish, parent);
    }
    function publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) return;
        var child = void 0, callback = void 0, detail = promise._result;
        for(var i = 0; i < subscribers.length; i += 3){
            child = subscribers[i];
            callback = subscribers[i + settled];
            if (child) invokeCallback(settled, child, callback, detail);
            else callback(detail);
        }
        promise._subscribers.length = 0;
    }
    function invokeCallback(settled, promise, callback, detail) {
        var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = true;
        if (hasCallback) {
            try {
                value = callback(detail);
            } catch (e) {
                succeeded = false;
                error = e;
            }
            if (promise === value) {
                reject(promise, cannotReturnOwn());
                return;
            }
        } else value = detail;
        if (promise._state !== PENDING) ;
        else if (hasCallback && succeeded) resolve(promise, value);
        else if (succeeded === false) reject(promise, error);
        else if (settled === FULFILLED) fulfill(promise, value);
        else if (settled === REJECTED) reject(promise, value);
    }
    function initializePromise(promise, resolver) {
        try {
            resolver(function resolvePromise(value) {
                resolve(promise, value);
            }, function rejectPromise(reason) {
                reject(promise, reason);
            });
        } catch (e) {
            reject(promise, e);
        }
    }
    var id = 0;
    function nextId() {
        return id++;
    }
    function makePromise(promise) {
        promise[PROMISE_ID] = id++;
        promise._state = undefined;
        promise._result = undefined;
        promise._subscribers = [];
    }
    function validationError() {
        return new Error("Array Methods must be provided an Array");
    }
    var Enumerator = function() {
        function Enumerator(Constructor, input) {
            this._instanceConstructor = Constructor;
            this.promise = new Constructor(noop);
            if (!this.promise[PROMISE_ID]) makePromise(this.promise);
            if (isArray(input)) {
                this.length = input.length;
                this._remaining = input.length;
                this._result = new Array(this.length);
                if (this.length === 0) fulfill(this.promise, this._result);
                else {
                    this.length = this.length || 0;
                    this._enumerate(input);
                    if (this._remaining === 0) fulfill(this.promise, this._result);
                }
            } else reject(this.promise, validationError());
        }
        Enumerator.prototype._enumerate = function _enumerate(input) {
            for(var i = 0; this._state === PENDING && i < input.length; i++)this._eachEntry(input[i], i);
        };
        Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
            var c = this._instanceConstructor;
            var resolve$$1 = c.resolve;
            if (resolve$$1 === resolve$1) {
                var _then = void 0;
                var error = void 0;
                var didError = false;
                try {
                    _then = entry.then;
                } catch (e) {
                    didError = true;
                    error = e;
                }
                if (_then === then && entry._state !== PENDING) this._settledAt(entry._state, i, entry._result);
                else if (typeof _then !== "function") {
                    this._remaining--;
                    this._result[i] = entry;
                } else if (c === Promise$1) {
                    var promise = new c(noop);
                    if (didError) reject(promise, error);
                    else handleMaybeThenable(promise, entry, _then);
                    this._willSettleAt(promise, i);
                } else this._willSettleAt(new c(function(resolve$$1) {
                    return resolve$$1(entry);
                }), i);
            } else this._willSettleAt(resolve$$1(entry), i);
        };
        Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
            var promise = this.promise;
            if (promise._state === PENDING) {
                this._remaining--;
                if (state === REJECTED) reject(promise, value);
                else this._result[i] = value;
            }
            if (this._remaining === 0) fulfill(promise, this._result);
        };
        Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
            var enumerator = this;
            subscribe(promise, undefined, function(value) {
                return enumerator._settledAt(FULFILLED, i, value);
            }, function(reason) {
                return enumerator._settledAt(REJECTED, i, reason);
            });
        };
        return Enumerator;
    }();
    /**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/ function all(entries) {
        return new Enumerator(this, entries).promise;
    }
    /**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/ function race(entries) {
        /*jshint validthis:true */ var Constructor = this;
        if (!isArray(entries)) return new Constructor(function(_, reject) {
            return reject(new TypeError("You must pass an array to race."));
        });
        else return new Constructor(function(resolve, reject) {
            var length = entries.length;
            for(var i = 0; i < length; i++)Constructor.resolve(entries[i]).then(resolve, reject);
        });
    }
    /**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/ function reject$1(reason) {
        /*jshint validthis:true */ var Constructor = this;
        var promise = new Constructor(noop);
        reject(promise, reason);
        return promise;
    }
    function needsResolver() {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
    }
    function needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }
    /**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/ var Promise$1 = function() {
        function Promise(resolver) {
            this[PROMISE_ID] = nextId();
            this._result = this._state = undefined;
            this._subscribers = [];
            if (noop !== resolver) {
                typeof resolver !== "function" && needsResolver();
                this instanceof Promise ? initializePromise(this, resolver) : needsNew();
            }
        }
        /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */ /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */ Promise.prototype.catch = function _catch(onRejection) {
            return this.then(null, onRejection);
        };
        /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */ Promise.prototype.finally = function _finally(callback) {
            var promise = this;
            var constructor = promise.constructor;
            if (isFunction(callback)) return promise.then(function(value) {
                return constructor.resolve(callback()).then(function() {
                    return value;
                });
            }, function(reason) {
                return constructor.resolve(callback()).then(function() {
                    throw reason;
                });
            });
            return promise.then(callback, callback);
        };
        return Promise;
    }();
    Promise$1.prototype.then = then;
    Promise$1.all = all;
    Promise$1.race = race;
    Promise$1.resolve = resolve$1;
    Promise$1.reject = reject$1;
    Promise$1._setScheduler = setScheduler;
    Promise$1._setAsap = setAsap;
    Promise$1._asap = asap;
    /*global self*/ function polyfill() {
        var local = void 0;
        if (typeof global !== "undefined") local = global;
        else if (typeof self !== "undefined") local = self;
        else try {
            local = Function("return this")();
        } catch (e) {
            throw new Error("polyfill failed because global object is unavailable in this environment");
        }
        var P = local.Promise;
        if (P) {
            var promiseToString = null;
            try {
                promiseToString = Object.prototype.toString.call(P.resolve());
            } catch (e) {
            // silently ignored
            }
            if (promiseToString === "[object Promise]" && !P.cast) return;
        }
        local.Promise = Promise$1;
    }
    // Strange compat..
    Promise$1.polyfill = polyfill;
    Promise$1.Promise = Promise$1;
    return Promise$1;
});

},{"6176c6218d752994":"d5jf4"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"klm3A":[function(require,module,exports) {
/*
 * Copyright 2014-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var rest = require("b3a8ec48345f1c68"), browser = require("b6a0027e5462b99e");
rest.setPlatformDefaultClient(browser);
module.exports = rest;

},{"b3a8ec48345f1c68":"eVvvO","b6a0027e5462b99e":"bLW0F"}],"eVvvO":[function(require,module,exports) {
/*
 * Copyright 2014-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
/**
 * Plain JS Object containing properties that represent an HTTP request.
 *
 * Depending on the capabilities of the underlying client, a request
 * may be cancelable. If a request may be canceled, the client will add
 * a canceled flag and cancel function to the request object. Canceling
 * the request will put the response into an error state.
 *
 * @field {string} [method='GET'] HTTP method, commonly GET, POST, PUT, DELETE or HEAD
 * @field {string|UrlBuilder} [path=''] path template with optional path variables
 * @field {Object} [params] parameters for the path template and query string
 * @field {Object} [headers] custom HTTP headers to send, in addition to the clients default headers
 * @field [entity] the HTTP entity, common for POST or PUT requests
 * @field {boolean} [canceled] true if the request has been canceled, set by the client
 * @field {Function} [cancel] cancels the request if invoked, provided by the client
 * @field {Client} [originator] the client that first handled this request, provided by the interceptor
 *
 * @class Request
 */ /**
 * Plain JS Object containing properties that represent an HTTP response
 *
 * @field {Object} [request] the request object as received by the root client
 * @field {Object} [raw] the underlying request object, like XmlHttpRequest in a browser
 * @field {number} [status.code] status code of the response (i.e. 200, 404)
 * @field {string} [status.text] status phrase of the response
 * @field {Object] [headers] response headers hash of normalized name, value pairs
 * @field [entity] the response body
 *
 * @class Response
 */ /**
 * HTTP client particularly suited for RESTful operations.
 *
 * @field {function} wrap wraps this client with a new interceptor returning the wrapped client
 *
 * @param {Request} the HTTP request
 * @returns {ResponsePromise<Response>} a promise the resolves to the HTTP response
 *
 * @class Client
 */ /**
  * Extended when.js Promises/A+ promise with HTTP specific helpers
  *q
  * @method entity promise for the HTTP entity
  * @method status promise for the HTTP status code
  * @method headers promise for the HTTP response headers
  * @method header promise for a specific HTTP response header
  *
  * @class ResponsePromise
  * @extends Promise
  */ var client, target, platformDefault;
client = require("ff4afcb7d6bce038");
if (typeof Promise !== "function" && console && console.log) console.log("An ES6 Promise implementation is required to use rest.js. See https://github.com/cujojs/when/blob/master/docs/es6-promise-shim.md for using when.js as a Promise polyfill.");
/**
 * Make a request with the default client
 * @param {Request} the HTTP request
 * @returns {Promise<Response>} a promise the resolves to the HTTP response
 */ function defaultClient() {
    return target.apply(void 0, arguments);
}
/**
 * Change the default client
 * @param {Client} client the new default client
 */ defaultClient.setDefaultClient = function setDefaultClient(client) {
    target = client;
};
/**
 * Obtain a direct reference to the current default client
 * @returns {Client} the default client
 */ defaultClient.getDefaultClient = function getDefaultClient() {
    return target;
};
/**
 * Reset the default client to the platform default
 */ defaultClient.resetDefaultClient = function resetDefaultClient() {
    target = platformDefault;
};
/**
 * @private
 */ defaultClient.setPlatformDefaultClient = function setPlatformDefaultClient(client) {
    if (platformDefault) throw new Error("Unable to redefine platformDefaultClient");
    target = platformDefault = client;
};
module.exports = client(defaultClient);

},{"ff4afcb7d6bce038":"7CC82"}],"7CC82":[function(require,module,exports) {
/*
 * Copyright 2014-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
/**
 * Add common helper methods to a client impl
 *
 * @param {function} impl the client implementation
 * @param {Client} [target] target of this client, used when wrapping other clients
 * @returns {Client} the client impl with additional methods
 */ module.exports = function client(impl, target) {
    if (target) /**
		 * @returns {Client} the target client
		 */ impl.skip = function skip() {
        return target;
    };
    /**
	 * Allow a client to easily be wrapped by an interceptor
	 *
	 * @param {Interceptor} interceptor the interceptor to wrap this client with
	 * @param [config] configuration for the interceptor
	 * @returns {Client} the newly wrapped client
	 */ impl.wrap = function wrap(interceptor, config) {
        return interceptor(impl, config);
    };
    /**
	 * @deprecated
	 */ impl.chain = function chain() {
        if (typeof console !== "undefined") console.log("rest.js: client.chain() is deprecated, use client.wrap() instead");
        return impl.wrap.apply(this, arguments);
    };
    return impl;
};

},{}],"bLW0F":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var normalizeHeaderName, responsePromise, client, headerSplitRE;
normalizeHeaderName = require("199fbd66004eb65e");
responsePromise = require("ffda9e5b35b968c6");
client = require("95565ffa50d120e1");
// according to the spec, the line break is '\r\n', but doesn't hold true in practice
headerSplitRE = /[\r|\n]+/;
function parseHeaders(raw) {
    // Note: Set-Cookie will be removed by the browser
    var headers = {};
    if (!raw) return headers;
    raw.trim().split(headerSplitRE).forEach(function(header) {
        var boundary, name, value;
        boundary = header.indexOf(":");
        name = normalizeHeaderName(header.substring(0, boundary).trim());
        value = header.substring(boundary + 1).trim();
        if (headers[name]) {
            if (Array.isArray(headers[name])) // add to an existing array
            headers[name].push(value);
            else // convert single value to array
            headers[name] = [
                headers[name],
                value
            ];
        } else // new, single value
        headers[name] = value;
    });
    return headers;
}
function safeMixin(target, source) {
    Object.keys(source || {}).forEach(function(prop) {
        // make sure the property already exists as
        // IE 6 will blow up if we add a new prop
        if (source.hasOwnProperty(prop) && prop in target) try {
            target[prop] = source[prop];
        } catch (e) {
        // ignore, expected for some properties at some points in the request lifecycle
        }
    });
    return target;
}
module.exports = client(function xhr(request) {
    return responsePromise.promise(function(resolve, reject) {
        /*jshint maxcomplexity:20 */ var client, method, url, headers, entity, headerName, response, XHR;
        request = typeof request === "string" ? {
            path: request
        } : request || {};
        response = {
            request: request
        };
        if (request.canceled) {
            response.error = "precanceled";
            reject(response);
            return;
        }
        XHR = request.engine || XMLHttpRequest;
        if (!XHR) {
            reject({
                request: request,
                error: "xhr-not-available"
            });
            return;
        }
        entity = request.entity;
        request.method = request.method || (entity ? "POST" : "GET");
        method = request.method;
        url = response.url = request.path || "";
        try {
            client = response.raw = new XHR();
            // mixin extra request properties before and after opening the request as some properties require being set at different phases of the request
            safeMixin(client, request.mixin);
            client.open(method, url, true);
            safeMixin(client, request.mixin);
            headers = request.headers;
            for(headerName in headers){
                /*jshint forin:false */ if (headerName === "Content-Type" && headers[headerName] === "multipart/form-data") continue;
                client.setRequestHeader(headerName, headers[headerName]);
            }
            request.canceled = false;
            request.cancel = function cancel() {
                request.canceled = true;
                client.abort();
                reject(response);
            };
            client.onreadystatechange = function() {
                if (request.canceled) return;
                if (client.readyState === (XHR.DONE || 4)) {
                    response.status = {
                        code: client.status,
                        text: client.statusText
                    };
                    response.headers = parseHeaders(client.getAllResponseHeaders());
                    response.entity = client.responseText;
                    // #125 -- Sometimes IE8-9 uses 1223 instead of 204
                    // http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
                    if (response.status.code === 1223) response.status.code = 204;
                    if (response.status.code > 0) // check status code as readystatechange fires before error event
                    resolve(response);
                    else // give the error callback a chance to fire before resolving
                    // requests for file:// URLs do not have a status code
                    setTimeout(function() {
                        resolve(response);
                    }, 0);
                }
            };
            try {
                client.onerror = function() {
                    response.error = "loaderror";
                    reject(response);
                };
            } catch (e) {
            // IE 6 will not support error handling
            }
            client.send(entity);
        } catch (e) {
            response.error = "loaderror";
            reject(response);
        }
    });
});

},{"199fbd66004eb65e":"4jAqO","ffda9e5b35b968c6":"luA85","95565ffa50d120e1":"7CC82"}],"4jAqO":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
/**
 * Normalize HTTP header names using the pseudo camel case.
 *
 * For example:
 *   content-type         -> Content-Type
 *   accepts              -> Accepts
 *   x-custom-header-name -> X-Custom-Header-Name
 *
 * @param {string} name the raw header name
 * @return {string} the normalized header name
 */ function normalizeHeaderName(name) {
    return name.toLowerCase().split("-").map(function(chunk) {
        return chunk.charAt(0).toUpperCase() + chunk.slice(1);
    }).join("-");
}
module.exports = normalizeHeaderName;

},{}],"luA85":[function(require,module,exports) {
/*
 * Copyright 2014-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
/*jshint latedef: nofunc */ var normalizeHeaderName = require("3366d2946309a45a");
function property(promise, name) {
    return promise.then(function(value) {
        return value && value[name];
    }, function(value) {
        return Promise.reject(value && value[name]);
    });
}
/**
 * Obtain the response entity
 *
 * @returns {Promise} for the response entity
 */ function entity() {
    /*jshint validthis:true */ return property(this, "entity");
}
/**
 * Obtain the response status
 *
 * @returns {Promise} for the response status
 */ function status() {
    /*jshint validthis:true */ return property(property(this, "status"), "code");
}
/**
 * Obtain the response headers map
 *
 * @returns {Promise} for the response headers map
 */ function headers() {
    /*jshint validthis:true */ return property(this, "headers");
}
/**
 * Obtain a specific response header
 *
 * @param {String} headerName the header to retrieve
 * @returns {Promise} for the response header's value
 */ function header(headerName) {
    /*jshint validthis:true */ headerName = normalizeHeaderName(headerName);
    return property(this.headers(), headerName);
}
/**
 * Follow a related resource
 *
 * The relationship to follow may be define as a plain string, an object
 * with the rel and params, or an array containing one or more entries
 * with the previous forms.
 *
 * Examples:
 *   response.follow('next')
 *
 *   response.follow({ rel: 'next', params: { pageSize: 100 } })
 *
 *   response.follow([
 *       { rel: 'items', params: { projection: 'noImages' } },
 *       'search',
 *       { rel: 'findByGalleryIsNull', params: { projection: 'noImages' } },
 *       'items'
 *   ])
 *
 * @param {String|Object|Array} rels one, or more, relationships to follow
 * @returns ResponsePromise<Response> related resource
 */ function follow(rels) {
    /*jshint validthis:true */ rels = [].concat(rels);
    return make(rels.reduce(function(response, rel) {
        return response.then(function(response) {
            if (typeof rel === "string") rel = {
                rel: rel
            };
            if (typeof response.entity.clientFor !== "function") throw new Error("Hypermedia response expected");
            var client = response.entity.clientFor(rel.rel);
            return client({
                params: rel.params
            });
        });
    }, this));
}
/**
 * Wrap a Promise as an ResponsePromise
 *
 * @param {Promise<Response>} promise the promise for an HTTP Response
 * @returns {ResponsePromise<Response>} wrapped promise for Response with additional helper methods
 */ function make(promise) {
    promise.status = status;
    promise.headers = headers;
    promise.header = header;
    promise.entity = entity;
    promise.follow = follow;
    return promise;
}
function responsePromise(obj, callback, errback) {
    return make(Promise.resolve(obj).then(callback, errback));
}
responsePromise.make = make;
responsePromise.reject = function(val) {
    return make(Promise.reject(val));
};
responsePromise.promise = function(func) {
    return make(new Promise(func));
};
module.exports = responsePromise;

},{"3366d2946309a45a":"4jAqO"}],"j8RoM":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var interceptor;
interceptor = require("6e7bd47554a72ab4");
/**
 * Rejects the response promise based on the status code.
 *
 * Codes greater than or equal to the provided value are rejected.  Default
 * value 400.
 *
 * @param {Client} [client] client to wrap
 * @param {number} [config.code=400] code to indicate a rejection
 *
 * @returns {Client}
 */ module.exports = interceptor({
    init: function(config) {
        config.code = config.code || 400;
        return config;
    },
    response: function(response, config) {
        if (response.status && response.status.code >= config.code) return Promise.reject(response);
        return response;
    }
});

},{"6e7bd47554a72ab4":"ddaBh"}],"ddaBh":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var defaultClient, mixin, responsePromise, client;
defaultClient = require("ff81395f7972d0a3");
mixin = require("111a11f125777bbe");
responsePromise = require("d8904532e332dc0b");
client = require("47e1635a3baa2f84");
/**
 * Interceptors have the ability to intercept the request and/org response
 * objects.  They may augment, prune, transform or replace the
 * request/response as needed.  Clients may be composed by wrapping
 * together multiple interceptors.
 *
 * Configured interceptors are functional in nature.  Wrapping a client in
 * an interceptor will not affect the client, merely the data that flows in
 * and out of that client.  A common configuration can be created once and
 * shared; specialization can be created by further wrapping that client
 * with custom interceptors.
 *
 * @param {Client} [target] client to wrap
 * @param {Object} [config] configuration for the interceptor, properties will be specific to the interceptor implementation
 * @returns {Client} A client wrapped with the interceptor
 *
 * @class Interceptor
 */ function defaultInitHandler(config) {
    return config;
}
function defaultRequestHandler(request /*, config, meta */ ) {
    return request;
}
function defaultResponseHandler(response /*, config, meta */ ) {
    return response;
}
/**
 * Alternate return type for the request handler that allows for more complex interactions.
 *
 * @param properties.request the traditional request return object
 * @param {Promise} [properties.abort] promise that resolves if/when the request is aborted
 * @param {Client} [properties.client] override the defined client with an alternate client
 * @param [properties.response] response for the request, short circuit the request
 */ function ComplexRequest(properties) {
    if (!(this instanceof ComplexRequest)) // in case users forget the 'new' don't mix into the interceptor
    return new ComplexRequest(properties);
    mixin(this, properties);
}
/**
 * Create a new interceptor for the provided handlers.
 *
 * @param {Function} [handlers.init] one time intialization, must return the config object
 * @param {Function} [handlers.request] request handler
 * @param {Function} [handlers.response] response handler regardless of error state
 * @param {Function} [handlers.success] response handler when the request is not in error
 * @param {Function} [handlers.error] response handler when the request is in error, may be used to 'unreject' an error state
 * @param {Function} [handlers.client] the client to use if otherwise not specified, defaults to platform default client
 *
 * @returns {Interceptor}
 */ function interceptor(handlers) {
    var initHandler, requestHandler, successResponseHandler, errorResponseHandler;
    handlers = handlers || {};
    initHandler = handlers.init || defaultInitHandler;
    requestHandler = handlers.request || defaultRequestHandler;
    successResponseHandler = handlers.success || handlers.response || defaultResponseHandler;
    errorResponseHandler = handlers.error || function() {
        // Propagate the rejection, with the result of the handler
        return Promise.resolve((handlers.response || defaultResponseHandler).apply(this, arguments)).then(Promise.reject.bind(Promise));
    };
    return function(target, config) {
        if (typeof target === "object") config = target;
        if (typeof target !== "function") target = handlers.client || defaultClient;
        config = initHandler(config || {});
        function interceptedClient(request) {
            var context, meta;
            context = {};
            meta = {
                "arguments": Array.prototype.slice.call(arguments),
                client: interceptedClient
            };
            request = typeof request === "string" ? {
                path: request
            } : request || {};
            request.originator = request.originator || interceptedClient;
            return responsePromise(requestHandler.call(context, request, config, meta), function(request) {
                var response, abort, next;
                next = target;
                if (request instanceof ComplexRequest) {
                    // unpack request
                    abort = request.abort;
                    next = request.client || next;
                    response = request.response;
                    // normalize request, must be last
                    request = request.request;
                }
                response = response || Promise.resolve(request).then(function(request) {
                    return Promise.resolve(next(request)).then(function(response) {
                        return successResponseHandler.call(context, response, config, meta);
                    }, function(response) {
                        return errorResponseHandler.call(context, response, config, meta);
                    });
                });
                return abort ? Promise.race([
                    response,
                    abort
                ]) : response;
            }, function(error) {
                return Promise.reject({
                    request: request,
                    error: error
                });
            });
        }
        return client(interceptedClient, target);
    };
}
interceptor.ComplexRequest = ComplexRequest;
module.exports = interceptor;

},{"ff81395f7972d0a3":"eVvvO","111a11f125777bbe":"5rb73","d8904532e332dc0b":"luA85","47e1635a3baa2f84":"7CC82"}],"5rb73":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var empty = {};
/**
 * Mix the properties from the source object into the destination object.
 * When the same property occurs in more then one object, the right most
 * value wins.
 *
 * @param {Object} dest the object to copy properties to
 * @param {Object} sources the objects to copy properties from.  May be 1 to N arguments, but not an Array.
 * @return {Object} the destination object
 */ function mixin(dest /*, sources... */ ) {
    var i, l, source, name;
    if (!dest) dest = {};
    for(i = 1, l = arguments.length; i < l; i += 1){
        source = arguments[i];
        for(name in source)if (!(name in dest) || dest[name] !== source[name] && (!(name in empty) || empty[name] !== source[name])) dest[name] = source[name];
    }
    return dest; // Object
}
module.exports = mixin;

},{}],"32XoP":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var interceptor, UrlBuilder;
interceptor = require("24507624d13caf4d");
UrlBuilder = require("28d5fee1f6b1f8c7");
function startsWith(str, prefix) {
    return str.indexOf(prefix) === 0;
}
function endsWith(str, suffix) {
    return str.lastIndexOf(suffix) + suffix.length === str.length;
}
/**
 * Prefixes the request path with a common value.
 *
 * @param {Client} [client] client to wrap
 * @param {number} [config.prefix] path prefix
 *
 * @returns {Client}
 */ module.exports = interceptor({
    request: function(request, config) {
        var path;
        if (config.prefix && !new UrlBuilder(request.path).isFullyQualified()) {
            path = config.prefix;
            if (request.path) {
                if (!endsWith(path, "/") && !startsWith(request.path, "/")) // add missing '/' between path sections
                path += "/";
                path += request.path;
            }
            request.path = path;
        }
        return request;
    }
});

},{"24507624d13caf4d":"ddaBh","28d5fee1f6b1f8c7":"jLXtm"}],"jLXtm":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var mixin, xWWWFormURLEncoder, origin, urlRE, absoluteUrlRE, fullyQualifiedUrlRE;
mixin = require("f2499ca3701cce3a");
xWWWFormURLEncoder = require("3bbfd7c72df251e");
urlRE = /([a-z][a-z0-9\+\-\.]*:)\/\/([^@]+@)?(([^:\/]+)(:([0-9]+))?)?(\/[^?#]*)?(\?[^#]*)?(#\S*)?/i;
absoluteUrlRE = /^([a-z][a-z0-9\-\+\.]*:\/\/|\/)/i;
fullyQualifiedUrlRE = /([a-z][a-z0-9\+\-\.]*:)\/\/([^@]+@)?(([^:\/]+)(:([0-9]+))?)?\//i;
/**
 * Apply params to the template to create a URL.
 *
 * Parameters that are not applied directly to the template, are appended
 * to the URL as query string parameters.
 *
 * @param {string} template the URI template
 * @param {Object} params parameters to apply to the template
 * @return {string} the resulting URL
 */ function buildUrl(template, params) {
    // internal builder to convert template with params.
    var url, name, queryStringParams, queryString, re;
    url = template;
    queryStringParams = {};
    if (params) {
        for(name in params){
            /*jshint forin:false */ re = new RegExp("\\{" + name + "\\}");
            if (re.test(url)) url = url.replace(re, encodeURIComponent(params[name]), "g");
            else queryStringParams[name] = params[name];
        }
        queryString = xWWWFormURLEncoder.write(queryStringParams);
        if (queryString) {
            url += url.indexOf("?") === -1 ? "?" : "&";
            url += queryString;
        }
    }
    return url;
}
function startsWith(str, test) {
    return str.indexOf(test) === 0;
}
/**
 * Create a new URL Builder
 *
 * @param {string|UrlBuilder} template the base template to build from, may be another UrlBuilder
 * @param {Object} [params] base parameters
 * @constructor
 */ function UrlBuilder(template, params) {
    if (!(this instanceof UrlBuilder)) // invoke as a constructor
    return new UrlBuilder(template, params);
    if (template instanceof UrlBuilder) {
        this._template = template.template;
        this._params = mixin({}, this._params, params);
    } else {
        this._template = (template || "").toString();
        this._params = params || {};
    }
}
UrlBuilder.prototype = {
    /**
	 * Create a new UrlBuilder instance that extends the current builder.
	 * The current builder is unmodified.
	 *
	 * @param {string} [template] URL template to append to the current template
	 * @param {Object} [params] params to combine with current params.  New params override existing params
	 * @return {UrlBuilder} the new builder
	 */ append: function(template, params) {
        // TODO consider query strings and fragments
        return new UrlBuilder(this._template + template, mixin({}, this._params, params));
    },
    /**
	 * Create a new UrlBuilder with a fully qualified URL based on the
	 * window's location or base href and the current templates relative URL.
	 *
	 * Path variables are preserved.
	 *
	 * *Browser only*
	 *
	 * @return {UrlBuilder} the fully qualified URL template
	 */ fullyQualify: function() {
        if (typeof location === "undefined") return this;
        if (this.isFullyQualified()) return this;
        var template = this._template;
        if (startsWith(template, "//")) template = origin.protocol + template;
        else if (startsWith(template, "/")) template = origin.origin + template;
        else if (!this.isAbsolute()) template = origin.origin + origin.pathname.substring(0, origin.pathname.lastIndexOf("/") + 1);
        if (template.indexOf("/", 8) === -1) // default the pathname to '/'
        template = template + "/";
        return new UrlBuilder(template, this._params);
    },
    /**
	 * True if the URL is absolute
	 *
	 * @return {boolean}
	 */ isAbsolute: function() {
        return absoluteUrlRE.test(this.build());
    },
    /**
	 * True if the URL is fully qualified
	 *
	 * @return {boolean}
	 */ isFullyQualified: function() {
        return fullyQualifiedUrlRE.test(this.build());
    },
    /**
	 * True if the URL is cross origin. The protocol, host and port must not be
	 * the same in order to be cross origin,
	 *
	 * @return {boolean}
	 */ isCrossOrigin: function() {
        if (!origin) return true;
        var url = this.parts();
        return url.protocol !== origin.protocol || url.hostname !== origin.hostname || url.port !== origin.port;
    },
    /**
	 * Split a URL into its consituent parts following the naming convention of
	 * 'window.location'. One difference is that the port will contain the
	 * protocol default if not specified.
	 *
	 * @see https://developer.mozilla.org/en-US/docs/DOM/window.location
	 *
	 * @returns {Object} a 'window.location'-like object
	 */ parts: function() {
        /*jshint maxcomplexity:20 */ var url, parts;
        url = this.fullyQualify().build().match(urlRE);
        parts = {
            href: url[0],
            protocol: url[1],
            host: url[3] || "",
            hostname: url[4] || "",
            port: url[6],
            pathname: url[7] || "",
            search: url[8] || "",
            hash: url[9] || ""
        };
        parts.origin = parts.protocol + "//" + parts.host;
        parts.port = parts.port || (parts.protocol === "https:" ? "443" : parts.protocol === "http:" ? "80" : "");
        return parts;
    },
    /**
	 * Expand the template replacing path variables with parameters
	 *
	 * @param {Object} [params] params to combine with current params.  New params override existing params
	 * @return {string} the expanded URL
	 */ build: function(params) {
        return buildUrl(this._template, mixin({}, this._params, params));
    },
    /**
	 * @see build
	 */ toString: function() {
        return this.build();
    }
};
origin = typeof location !== "undefined" ? new UrlBuilder(location.href).parts() : void 0;
module.exports = UrlBuilder;

},{"f2499ca3701cce3a":"5rb73","3bbfd7c72df251e":"9k4Z6"}],"9k4Z6":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var encodedSpaceRE, urlEncodedSpaceRE;
encodedSpaceRE = /%20/g;
urlEncodedSpaceRE = /\+/g;
function urlEncode(str) {
    str = encodeURIComponent(str);
    // spec says space should be encoded as '+'
    return str.replace(encodedSpaceRE, "+");
}
function urlDecode(str) {
    // spec says space should be encoded as '+'
    str = str.replace(urlEncodedSpaceRE, " ");
    return decodeURIComponent(str);
}
function append(str, name, value) {
    if (Array.isArray(value)) value.forEach(function(value) {
        str = append(str, name, value);
    });
    else {
        if (str.length > 0) str += "&";
        str += urlEncode(name);
        if (value !== undefined && value !== null) str += "=" + urlEncode(value);
    }
    return str;
}
module.exports = {
    read: function(str) {
        var obj = {};
        str.split("&").forEach(function(entry) {
            var pair, name, value;
            pair = entry.split("=");
            name = urlDecode(pair[0]);
            if (pair.length === 2) value = urlDecode(pair[1]);
            else value = null;
            if (name in obj) {
                if (!Array.isArray(obj[name])) // convert to an array, perserving currnent value
                obj[name] = [
                    obj[name]
                ];
                obj[name].push(value);
            } else obj[name] = value;
        });
        return obj;
    },
    write: function(obj) {
        var str = "";
        Object.keys(obj).forEach(function(name) {
            str = append(str, name, obj[name]);
        });
        return str;
    }
};

},{}],"7Uegs":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var interceptor, mime, registry, noopConverter, missingConverter, attempt;
interceptor = require("7f63c19a70268939");
mime = require("eece5bb8bf30681e");
registry = require("785ff3e55136ce0e");
attempt = require("be2aca8d10c87ca4");
noopConverter = {
    read: function(obj) {
        return obj;
    },
    write: function(obj) {
        return obj;
    }
};
missingConverter = {
    read: function() {
        throw "No read method found on converter";
    },
    write: function() {
        throw "No write method found on converter";
    }
};
/**
 * MIME type support for request and response entities.  Entities are
 * (de)serialized using the converter for the MIME type.
 *
 * Request entities are converted using the desired converter and the
 * 'Accept' request header prefers this MIME.
 *
 * Response entities are converted based on the Content-Type response header.
 *
 * @param {Client} [client] client to wrap
 * @param {string} [config.mime='text/plain'] MIME type to encode the request
 *   entity
 * @param {string} [config.accept] Accept header for the request
 * @param {Client} [config.client=<request.originator>] client passed to the
 *   converter, defaults to the client originating the request
 * @param {Registry} [config.registry] MIME registry, defaults to the root
 *   registry
 * @param {boolean} [config.permissive] Allow an unkown request MIME type
 *
 * @returns {Client}
 */ module.exports = interceptor({
    init: function(config) {
        config.registry = config.registry || registry;
        return config;
    },
    request: function(request, config) {
        var type, headers;
        headers = request.headers || (request.headers = {});
        type = mime.parse(headers["Content-Type"] || config.mime || "text/plain");
        headers.Accept = headers.Accept || config.accept || type.raw + ", application/json;q=0.8, text/plain;q=0.5, */*;q=0.2";
        if (!("entity" in request)) return request;
        headers["Content-Type"] = type.raw;
        return config.registry.lookup(type)["catch"](function() {
            // failed to resolve converter
            if (config.permissive) return noopConverter;
            throw "mime-unknown";
        }).then(function(converter) {
            var client = config.client || request.originator, write = converter.write || missingConverter.write;
            return attempt(write.bind(void 0, request.entity, {
                client: client,
                request: request,
                mime: type,
                registry: config.registry
            }))["catch"](function() {
                throw "mime-serialization";
            }).then(function(entity) {
                request.entity = entity;
                return request;
            });
        });
    },
    response: function(response, config) {
        if (!(response.headers && response.headers["Content-Type"] && response.entity)) return response;
        var type = mime.parse(response.headers["Content-Type"]);
        return config.registry.lookup(type)["catch"](function() {
            return noopConverter;
        }).then(function(converter) {
            var client = config.client || response.request && response.request.originator, read = converter.read || missingConverter.read;
            return attempt(read.bind(void 0, response.entity, {
                client: client,
                response: response,
                mime: type,
                registry: config.registry
            }))["catch"](function(e) {
                response.error = "mime-deserialization";
                response.cause = e;
                throw response;
            }).then(function(entity) {
                response.entity = entity;
                return response;
            });
        });
    }
});

},{"7f63c19a70268939":"ddaBh","eece5bb8bf30681e":"dfJqc","785ff3e55136ce0e":"l6aiV","be2aca8d10c87ca4":"8Gawb"}],"dfJqc":[function(require,module,exports) {
/*
* Copyright 2014-2016 the original author or authors
* @license MIT, see LICENSE.txt for details
*
* @author Scott Andrews
*/ "use strict";
/**
 * Parse a MIME type into it's constituent parts
 *
 * @param {string} mime MIME type to parse
 * @return {{
 *   {string} raw the original MIME type
 *   {string} type the type and subtype
 *   {string} [suffix] mime suffix, including the plus, if any
 *   {Object} params key/value pair of attributes
 * }}
 */ function parse(mime) {
    var params, type;
    params = mime.split(";");
    type = params[0].trim().split("+");
    return {
        raw: mime,
        type: type[0],
        suffix: type[1] ? "+" + type[1] : "",
        params: params.slice(1).reduce(function(params, pair) {
            pair = pair.split("=");
            params[pair[0].trim()] = pair[1] ? pair[1].trim() : void 0;
            return params;
        }, {})
    };
}
module.exports = {
    parse: parse
};

},{}],"l6aiV":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var mime, registry;
mime = require("8356c23723df344f");
function Registry(mimes) {
    /**
	 * Lookup the converter for a MIME type
	 *
	 * @param {string} type the MIME type
	 * @return a promise for the converter
	 */ this.lookup = function lookup(type) {
        var parsed;
        parsed = typeof type === "string" ? mime.parse(type) : type;
        if (mimes[parsed.raw]) return mimes[parsed.raw];
        if (mimes[parsed.type + parsed.suffix]) return mimes[parsed.type + parsed.suffix];
        if (mimes[parsed.type]) return mimes[parsed.type];
        if (mimes[parsed.suffix]) return mimes[parsed.suffix];
        return Promise.reject(new Error('Unable to locate converter for mime "' + parsed.raw + '"'));
    };
    /**
	 * Create a late dispatched proxy to the target converter.
	 *
	 * Common when a converter is registered under multiple names and
	 * should be kept in sync if updated.
	 *
	 * @param {string} type mime converter to dispatch to
	 * @returns converter whose read/write methods target the desired mime converter
	 */ this.delegate = function delegate(type) {
        return {
            read: (function() {
                var args = arguments;
                return this.lookup(type).then((function(converter) {
                    return converter.read.apply(this, args);
                }).bind(this));
            }).bind(this),
            write: (function() {
                var args = arguments;
                return this.lookup(type).then((function(converter) {
                    return converter.write.apply(this, args);
                }).bind(this));
            }).bind(this)
        };
    };
    /**
	 * Register a custom converter for a MIME type
	 *
	 * @param {string} type the MIME type
	 * @param converter the converter for the MIME type
	 * @return a promise for the converter
	 */ this.register = function register(type, converter) {
        mimes[type] = Promise.resolve(converter);
        return mimes[type];
    };
    /**
	 * Create a child registry whoes registered converters remain local, while
	 * able to lookup converters from its parent.
	 *
	 * @returns child MIME registry
	 */ this.child = function child() {
        return new Registry(Object.create(mimes));
    };
}
registry = new Registry({});
// include provided serializers
registry.register("application/hal", require("8bb8004747412474"));
registry.register("application/json", require("2dff7ca57cfe2297"));
registry.register("application/x-www-form-urlencoded", require("e2be1509b6ce60bd"));
registry.register("multipart/form-data", require("4d9aa7b35b79ff4d"));
registry.register("text/plain", require("642c950098870269"));
registry.register("+json", registry.delegate("application/json"));
module.exports = registry;

},{"8356c23723df344f":"dfJqc","8bb8004747412474":"fhhHX","2dff7ca57cfe2297":"l2Ugc","e2be1509b6ce60bd":"9k4Z6","4d9aa7b35b79ff4d":"eKJt2","642c950098870269":"iOeWa"}],"fhhHX":[function(require,module,exports) {
/*
 * Copyright 2013-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var pathPrefix, template, find, lazyPromise, responsePromise;
pathPrefix = require("6128379a6e4bf231");
template = require("b763500e4fc293a4");
find = require("94261b329959ad40");
lazyPromise = require("43c61b69892eee71");
responsePromise = require("6659eb38a25edc7a");
function defineProperty(obj, name, value) {
    Object.defineProperty(obj, name, {
        value: value,
        configurable: true,
        enumerable: false,
        writeable: true
    });
}
/**
 * Hypertext Application Language serializer
 *
 * Implemented to https://tools.ietf.org/html/draft-kelly-json-hal-06
 *
 * As the spec is still a draft, this implementation will be updated as the
 * spec evolves
 *
 * Objects are read as HAL indexing links and embedded objects on to the
 * resource. Objects are written as plain JSON.
 *
 * Embedded relationships are indexed onto the resource by the relationship
 * as a promise for the related resource.
 *
 * Links are indexed onto the resource as a lazy promise that will GET the
 * resource when a handler is first registered on the promise.
 *
 * A `requestFor` method is added to the entity to make a request for the
 * relationship.
 *
 * A `clientFor` method is added to the entity to get a full Client for a
 * relationship.
 *
 * The `_links` and `_embedded` properties on the resource are made
 * non-enumerable.
 */ module.exports = {
    read: function(str, opts) {
        var client, console;
        opts = opts || {};
        client = opts.client;
        console = opts.console || console;
        function deprecationWarning(relationship, deprecation) {
            if (deprecation && console && console.warn || console.log) (console.warn || console.log).call(console, "Relationship '" + relationship + "' is deprecated, see " + deprecation);
        }
        return opts.registry.lookup(opts.mime.suffix).then(function(converter) {
            return converter.read(str, opts);
        }).then(function(root) {
            find.findProperties(root, "_embedded", function(embedded, resource, name) {
                Object.keys(embedded).forEach(function(relationship) {
                    if (relationship in resource) return;
                    var related = responsePromise({
                        entity: embedded[relationship]
                    });
                    defineProperty(resource, relationship, related);
                });
                defineProperty(resource, name, embedded);
            });
            find.findProperties(root, "_links", function(links, resource, name) {
                Object.keys(links).forEach(function(relationship) {
                    var link = links[relationship];
                    if (relationship in resource) return;
                    defineProperty(resource, relationship, responsePromise.make(lazyPromise(function() {
                        if (link.deprecation) deprecationWarning(relationship, link.deprecation);
                        if (link.templated === true) return template(client)({
                            path: link.href
                        });
                        return client({
                            path: link.href
                        });
                    })));
                });
                defineProperty(resource, name, links);
                defineProperty(resource, "clientFor", function(relationship, clientOverride) {
                    var link = links[relationship];
                    if (!link) throw new Error("Unknown relationship: " + relationship);
                    if (link.deprecation) deprecationWarning(relationship, link.deprecation);
                    if (link.templated === true) return template(clientOverride || client, {
                        template: link.href
                    });
                    return pathPrefix(clientOverride || client, {
                        prefix: link.href
                    });
                });
                defineProperty(resource, "requestFor", function(relationship, request, clientOverride) {
                    var client = this.clientFor(relationship, clientOverride);
                    return client(request);
                });
            });
            return root;
        });
    },
    write: function(obj, opts) {
        return opts.registry.lookup(opts.mime.suffix).then(function(converter) {
            return converter.write(obj, opts);
        });
    }
};

},{"6128379a6e4bf231":"32XoP","b763500e4fc293a4":"j3KMB","94261b329959ad40":"gvxde","43c61b69892eee71":"brYj5","6659eb38a25edc7a":"luA85"}],"j3KMB":[function(require,module,exports) {
/*
 * Copyright 2015-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var interceptor, uriTemplate, mixin;
interceptor = require("ac35b0572947f8c7");
uriTemplate = require("9ecc93a2313040fd");
mixin = require("3043a0afdd2d04b2");
/**
 * Applies request params to the path as a URI Template
 *
 * Params are removed from the request object, as they have been consumed.
 *
 * @see https://tools.ietf.org/html/rfc6570
 *
 * @param {Client} [client] client to wrap
 * @param {Object} [config.params] default param values
 * @param {string} [config.template] default template
 *
 * @returns {Client}
 */ module.exports = interceptor({
    init: function(config) {
        config.params = config.params || {};
        config.template = config.template || "";
        return config;
    },
    request: function(request, config) {
        var template, params;
        template = request.path || config.template;
        params = mixin({}, request.params, config.params);
        request.path = uriTemplate.expand(template, params);
        delete request.params;
        return request;
    }
});

},{"ac35b0572947f8c7":"ddaBh","9ecc93a2313040fd":"9Ktmx","3043a0afdd2d04b2":"5rb73"}],"9Ktmx":[function(require,module,exports) {
/*
 * Copyright 2015-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var uriEncoder, operations, prefixRE;
uriEncoder = require("53d27ec6526e3aac");
prefixRE = /^([^:]*):([0-9]+)$/;
operations = {
    "": {
        first: "",
        separator: ",",
        named: false,
        empty: "",
        encoder: uriEncoder.encode
    },
    "+": {
        first: "",
        separator: ",",
        named: false,
        empty: "",
        encoder: uriEncoder.encodeURL
    },
    "#": {
        first: "#",
        separator: ",",
        named: false,
        empty: "",
        encoder: uriEncoder.encodeURL
    },
    ".": {
        first: ".",
        separator: ".",
        named: false,
        empty: "",
        encoder: uriEncoder.encode
    },
    "/": {
        first: "/",
        separator: "/",
        named: false,
        empty: "",
        encoder: uriEncoder.encode
    },
    ";": {
        first: ";",
        separator: ";",
        named: true,
        empty: "",
        encoder: uriEncoder.encode
    },
    "?": {
        first: "?",
        separator: "&",
        named: true,
        empty: "=",
        encoder: uriEncoder.encode
    },
    "&": {
        first: "&",
        separator: "&",
        named: true,
        empty: "=",
        encoder: uriEncoder.encode
    },
    "=": {
        reserved: true
    },
    ",": {
        reserved: true
    },
    "!": {
        reserved: true
    },
    "@": {
        reserved: true
    },
    "|": {
        reserved: true
    }
};
function apply(operation, expression, params) {
    /*jshint maxcomplexity:11 */ return expression.split(",").reduce(function(result, variable) {
        var opts, value;
        opts = {};
        if (variable.slice(-1) === "*") {
            variable = variable.slice(0, -1);
            opts.explode = true;
        }
        if (prefixRE.test(variable)) {
            var prefix = prefixRE.exec(variable);
            variable = prefix[1];
            opts.maxLength = parseInt(prefix[2]);
        }
        variable = uriEncoder.decode(variable);
        value = params[variable];
        if (value === void 0 || value === null) return result;
        if (Array.isArray(value)) result = value.reduce(function(result, value) {
            if (result.length) {
                result += opts.explode ? operation.separator : ",";
                if (operation.named && opts.explode) {
                    result += operation.encoder(variable);
                    result += value.length ? "=" : operation.empty;
                }
            } else {
                result += operation.first;
                if (operation.named) {
                    result += operation.encoder(variable);
                    result += value.length ? "=" : operation.empty;
                }
            }
            result += operation.encoder(value);
            return result;
        }, result);
        else if (typeof value === "object") result = Object.keys(value).reduce(function(result, name) {
            if (result.length) result += opts.explode ? operation.separator : ",";
            else {
                result += operation.first;
                if (operation.named && !opts.explode) {
                    result += operation.encoder(variable);
                    result += value[name].length ? "=" : operation.empty;
                }
            }
            result += operation.encoder(name);
            result += opts.explode ? "=" : ",";
            result += operation.encoder(value[name]);
            return result;
        }, result);
        else {
            value = String(value);
            if (opts.maxLength) value = value.slice(0, opts.maxLength);
            result += result.length ? operation.separator : operation.first;
            if (operation.named) {
                result += operation.encoder(variable);
                result += value.length ? "=" : operation.empty;
            }
            result += operation.encoder(value);
        }
        return result;
    }, "");
}
function expandExpression(expression, params) {
    var operation;
    operation = operations[expression.slice(0, 1)];
    if (operation) expression = expression.slice(1);
    else operation = operations[""];
    if (operation.reserved) throw new Error("Reserved expression operations are not supported");
    return apply(operation, expression, params);
}
function expandTemplate(template, params) {
    var start, end, uri;
    uri = "";
    end = 0;
    while(true){
        start = template.indexOf("{", end);
        if (start === -1) {
            // no more expressions
            uri += template.slice(end);
            break;
        }
        uri += template.slice(end, start);
        end = template.indexOf("}", start) + 1;
        uri += expandExpression(template.slice(start + 1, end - 1), params);
    }
    return uri;
}
module.exports = {
    /**
	 * Expand a URI Template with parameters to form a URI.
	 *
	 * Full implementation (level 4) of rfc6570.
	 * @see https://tools.ietf.org/html/rfc6570
	 *
	 * @param {string} template URI template
	 * @param {Object} [params] params to apply to the template durring expantion
	 * @returns {string} expanded URI
	 */ expand: expandTemplate
};

},{"53d27ec6526e3aac":"jwKCL"}],"jwKCL":[function(require,module,exports) {
/*
 * Copyright 2015-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var charMap;
charMap = function() {
    var strings = {
        alpha: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
        digit: "0123456789"
    };
    strings.genDelims = ":/?#[]@";
    strings.subDelims = "!$&'()*+,;=";
    strings.reserved = strings.genDelims + strings.subDelims;
    strings.unreserved = strings.alpha + strings.digit + "-._~";
    strings.url = strings.reserved + strings.unreserved;
    strings.scheme = strings.alpha + strings.digit + "+-.";
    strings.userinfo = strings.unreserved + strings.subDelims + ":";
    strings.host = strings.unreserved + strings.subDelims;
    strings.port = strings.digit;
    strings.pchar = strings.unreserved + strings.subDelims + ":@";
    strings.segment = strings.pchar;
    strings.path = strings.segment + "/";
    strings.query = strings.pchar + "/?";
    strings.fragment = strings.pchar + "/?";
    return Object.keys(strings).reduce(function(charMap, set) {
        charMap[set] = strings[set].split("").reduce(function(chars, myChar) {
            chars[myChar] = true;
            return chars;
        }, {});
        return charMap;
    }, {});
}();
function encode(str, allowed) {
    if (typeof str !== "string") throw new Error("String required for URL encoding");
    return str.split("").map(function(myChar) {
        if (allowed.hasOwnProperty(myChar)) return myChar;
        var code = myChar.charCodeAt(0);
        if (code <= 127) {
            var encoded = code.toString(16).toUpperCase();
            return "%" + (encoded.length % 2 === 1 ? "0" : "") + encoded;
        } else return encodeURIComponent(myChar).toUpperCase();
    }).join("");
}
function makeEncoder(allowed) {
    allowed = allowed || charMap.unreserved;
    return function(str) {
        return encode(str, allowed);
    };
}
function decode(str) {
    return decodeURIComponent(str);
}
module.exports = {
    /*
	 * Decode URL encoded strings
	 *
	 * @param {string} URL encoded string
	 * @returns {string} URL decoded string
	 */ decode: decode,
    /*
	 * URL encode a string
	 *
	 * All but alpha-numerics and a very limited set of punctuation - . _ ~ are
	 * encoded.
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encode: makeEncoder(),
    /*
	* URL encode a URL
	*
	* All character permitted anywhere in a URL are left unencoded even
	* if that character is not permitted in that portion of a URL.
	*
	* Note: This method is typically not what you want.
	*
	* @param {string} string to encode
	* @returns {string} URL encoded string
	*/ encodeURL: makeEncoder(charMap.url),
    /*
	 * URL encode the scheme portion of a URL
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encodeScheme: makeEncoder(charMap.scheme),
    /*
	 * URL encode the user info portion of a URL
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encodeUserInfo: makeEncoder(charMap.userinfo),
    /*
	 * URL encode the host portion of a URL
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encodeHost: makeEncoder(charMap.host),
    /*
	 * URL encode the port portion of a URL
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encodePort: makeEncoder(charMap.port),
    /*
	 * URL encode a path segment portion of a URL
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encodePathSegment: makeEncoder(charMap.segment),
    /*
	 * URL encode the path portion of a URL
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encodePath: makeEncoder(charMap.path),
    /*
	 * URL encode the query portion of a URL
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encodeQuery: makeEncoder(charMap.query),
    /*
	 * URL encode the fragment portion of a URL
	 *
	 * @param {string} string to encode
	 * @returns {string} URL encoded string
	 */ encodeFragment: makeEncoder(charMap.fragment)
};

},{}],"gvxde":[function(require,module,exports) {
/*
 * Copyright 2013-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
module.exports = {
    /**
	 * Find objects within a graph the contain a property of a certain name.
	 *
	 * NOTE: this method will not discover object graph cycles.
	 *
	 * @param {*} obj object to search on
	 * @param {string} prop name of the property to search for
	 * @param {Function} callback function to receive the found properties and their parent
	 */ findProperties: function findProperties(obj, prop, callback) {
        if (typeof obj !== "object" || obj === null) return;
        if (prop in obj) callback(obj[prop], obj, prop);
        Object.keys(obj).forEach(function(key) {
            findProperties(obj[key], prop, callback);
        });
    }
};

},{}],"brYj5":[function(require,module,exports) {
/*
 * Copyright 2013-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var attempt = require("f24ed768ada90684");
/**
 * Create a promise whose work is started only when a handler is registered.
 *
 * The work function will be invoked at most once. Thrown values will result
 * in promise rejection.
 *
 * @param {Function} work function whose ouput is used to resolve the
 *   returned promise.
 * @returns {Promise} a lazy promise
 */ function lazyPromise(work) {
    var started, resolver, promise, then;
    started = false;
    promise = new Promise(function(resolve, reject) {
        resolver = {
            resolve: resolve,
            reject: reject
        };
    });
    then = promise.then;
    promise.then = function() {
        if (!started) {
            started = true;
            attempt(work).then(resolver.resolve, resolver.reject);
        }
        return then.apply(promise, arguments);
    };
    return promise;
}
module.exports = lazyPromise;

},{"f24ed768ada90684":"8Gawb"}],"8Gawb":[function(require,module,exports) {
/*
 * Copyright 2015-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
/**
 * Attempt to invoke a function capturing the resulting value as a Promise
 *
 * If the method throws, the caught value used to reject the Promise.
 *
 * @param {function} work function to invoke
 * @returns {Promise} Promise for the output of the work function
 */ function attempt(work) {
    try {
        return Promise.resolve(work());
    } catch (e) {
        return Promise.reject(e);
    }
}
module.exports = attempt;

},{}],"l2Ugc":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
/**
 * Create a new JSON converter with custom reviver/replacer.
 *
 * The extended converter must be published to a MIME registry in order
 * to be used. The existing converter will not be modified.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON
 *
 * @param {function} [reviver=undefined] custom JSON.parse reviver
 * @param {function|Array} [replacer=undefined] custom JSON.stringify replacer
 */ function createConverter(reviver, replacer) {
    return {
        read: function(str) {
            return JSON.parse(str, reviver);
        },
        write: function(obj) {
            return JSON.stringify(obj, replacer);
        },
        extend: createConverter
    };
}
module.exports = createConverter();

},{}],"eKJt2":[function(require,module,exports) {
/*
 * Copyright 2014-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Michael Jackson
 */ /* global FormData, File, Blob */ "use strict";
function isFormElement(object) {
    return object && object.nodeType === 1 && // Node.ELEMENT_NODE
    object.tagName === "FORM";
}
function createFormDataFromObject(object) {
    var formData = new FormData();
    var value;
    for(var property in object)if (object.hasOwnProperty(property)) {
        value = object[property];
        if (value instanceof File) formData.append(property, value, value.name);
        else if (value instanceof Blob) formData.append(property, value);
        else formData.append(property, String(value));
    }
    return formData;
}
module.exports = {
    write: function(object) {
        if (typeof FormData === "undefined") throw new Error("The multipart/form-data mime serializer requires FormData support");
        // Support FormData directly.
        if (object instanceof FormData) return object;
        // Support <form> elements.
        if (isFormElement(object)) return new FormData(object);
        // Support plain objects, may contain File/Blob as value.
        if (typeof object === "object" && object !== null) return createFormDataFromObject(object);
        throw new Error("Unable to create FormData from object " + object);
    }
};

},{}],"iOeWa":[function(require,module,exports) {
/*
 * Copyright 2012-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
module.exports = {
    read: function(str) {
        return str;
    },
    write: function(obj) {
        return obj.toString();
    }
};

},{}],"92BbG":[function(require,module,exports) {
/*
 * Copyright 2013-2016 the original author or authors
 * @license MIT, see LICENSE.txt for details
 *
 * @author Scott Andrews
 */ "use strict";
var interceptor, mixinUtil, defaulter;
interceptor = require("27fe1a9f100b0515");
mixinUtil = require("22b33be11fdb2d39");
defaulter = function() {
    function mixin(prop, target, defaults) {
        if (prop in target || prop in defaults) target[prop] = mixinUtil({}, defaults[prop], target[prop]);
    }
    function copy(prop, target, defaults) {
        if (prop in defaults && !(prop in target)) target[prop] = defaults[prop];
    }
    var mappings = {
        method: copy,
        path: copy,
        params: mixin,
        headers: mixin,
        entity: copy,
        mixin: mixin
    };
    return function(target, defaults) {
        for(var prop in mappings)/*jshint forin: false */ mappings[prop](prop, target, defaults);
        return target;
    };
}();
/**
 * Provide default values for a request. These values will be applied to the
 * request if the request object does not already contain an explicit value.
 *
 * For 'params', 'headers', and 'mixin', individual values are mixed in with the
 * request's values. The result is a new object representiing the combined
 * request and config values. Neither input object is mutated.
 *
 * @param {Client} [client] client to wrap
 * @param {string} [config.method] the default method
 * @param {string} [config.path] the default path
 * @param {Object} [config.params] the default params, mixed with the request's existing params
 * @param {Object} [config.headers] the default headers, mixed with the request's existing headers
 * @param {Object} [config.mixin] the default "mixins" (http/https options), mixed with the request's existing "mixins"
 *
 * @returns {Client}
 */ module.exports = interceptor({
    request: function handleRequest(request, config) {
        return defaulter(request, config);
    }
});

},{"27fe1a9f100b0515":"ddaBh","22b33be11fdb2d39":"5rb73"}],"3RKwg":[function(require,module,exports) {
"use strict";
// install ES6 Promise polyfill
require("62a95c9f2b4854d5");
var interceptor = require("6ff9454758a660fe");
var linkParser = require("275e306c47446a4d");
var url = require("530dab385443b651");
var querystring = require("92744720195e0ad9");
var paginator = interceptor({
    success: function(response, config) {
        var link = response && response.headers && response.headers.Link;
        var client = response && response.request && response.request.originator;
        if (link) {
            var nextLink = linkParser.parse(link).filter(function(link) {
                return link.rel === "next";
            })[0];
            if (nextLink) response.nextPage = function(callback) {
                var linkParts = url.parse(nextLink.href);
                var linkQuery = querystring.parse(linkParts.query);
                linkQuery.access_token = linkQuery.access_token || config.access_token;
                linkParts.search = querystring.stringify(linkQuery);
                return client({
                    path: url.format(linkParts),
                    callback: callback
                });
            };
        }
        return response;
    }
});
module.exports = paginator;

},{"62a95c9f2b4854d5":"1vHlJ","6ff9454758a660fe":"ddaBh","275e306c47446a4d":"9Gcnz","530dab385443b651":"7qjc7","92744720195e0ad9":"7oCJH"}],"9Gcnz":[function(require,module,exports) {
module.exports = function() {
    /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */ function quote(s) {
        /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */ return '"' + s.replace(/\\/g, "\\\\") // backslash
        .replace(/"/g, '\\"') // closing quote character
        .replace(/\x08/g, "\\b") // backspace
        .replace(/\t/g, "\\t") // horizontal tab
        .replace(/\n/g, "\\n") // line feed
        .replace(/\f/g, "\\f") // form feed
        .replace(/\r/g, "\\r") // carriage return
        .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
    }
    var result = {
        /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */ parse: function(input, startRule) {
            var parseFunctions = {
                "start": parse_start,
                "LinkValue": parse_LinkValue,
                "LinkParams": parse_LinkParams,
                "URIReference": parse_URIReference,
                "LinkParam": parse_LinkParam,
                "LinkParamName": parse_LinkParamName,
                "LinkParamValue": parse_LinkParamValue,
                "PToken": parse_PToken,
                "PTokenChar": parse_PTokenChar,
                "OptionalSP": parse_OptionalSP,
                "QuotedString": parse_QuotedString,
                "QuotedStringInternal": parse_QuotedStringInternal,
                "Char": parse_Char,
                "UpAlpha": parse_UpAlpha,
                "LoAlpha": parse_LoAlpha,
                "Alpha": parse_Alpha,
                "Digit": parse_Digit,
                "SP": parse_SP,
                "DQ": parse_DQ,
                "QDText": parse_QDText,
                "QuotedPair": parse_QuotedPair
            };
            if (startRule !== undefined) {
                if (parseFunctions[startRule] === undefined) throw new Error("Invalid rule name: " + quote(startRule) + ".");
            } else startRule = "start";
            var pos = 0;
            var reportFailures = 0;
            var rightmostFailuresPos = 0;
            var rightmostFailuresExpected = [];
            function padLeft(input, padding, length) {
                var result = input;
                var padLength = length - input.length;
                for(var i = 0; i < padLength; i++)result = padding + result;
                return result;
            }
            function escape1(ch) {
                var charCode = ch.charCodeAt(0);
                var escapeChar;
                var length;
                if (charCode <= 0xFF) {
                    escapeChar = "x";
                    length = 2;
                } else {
                    escapeChar = "u";
                    length = 4;
                }
                return "\\" + escapeChar + padLeft(charCode.toString(16).toUpperCase(), "0", length);
            }
            function matchFailed(failure) {
                if (pos < rightmostFailuresPos) return;
                if (pos > rightmostFailuresPos) {
                    rightmostFailuresPos = pos;
                    rightmostFailuresExpected = [];
                }
                rightmostFailuresExpected.push(failure);
            }
            function parse_start() {
                var result0, result1, result2, result3, result4;
                var pos0, pos1, pos2, pos3;
                pos0 = pos;
                pos1 = pos;
                result0 = [];
                pos2 = pos;
                pos3 = pos;
                result1 = parse_LinkValue();
                if (result1 !== null) {
                    result2 = parse_OptionalSP();
                    if (result2 !== null) {
                        if (input.charCodeAt(pos) === 44) {
                            result3 = ",";
                            pos++;
                        } else {
                            result3 = null;
                            if (reportFailures === 0) matchFailed('","');
                        }
                        if (result3 !== null) {
                            result4 = parse_OptionalSP();
                            if (result4 !== null) result1 = [
                                result1,
                                result2,
                                result3,
                                result4
                            ];
                            else {
                                result1 = null;
                                pos = pos3;
                            }
                        } else {
                            result1 = null;
                            pos = pos3;
                        }
                    } else {
                        result1 = null;
                        pos = pos3;
                    }
                } else {
                    result1 = null;
                    pos = pos3;
                }
                if (result1 !== null) result1 = function(offset, i) {
                    return i;
                }(pos2, result1[0]);
                if (result1 === null) pos = pos2;
                while(result1 !== null){
                    result0.push(result1);
                    pos2 = pos;
                    pos3 = pos;
                    result1 = parse_LinkValue();
                    if (result1 !== null) {
                        result2 = parse_OptionalSP();
                        if (result2 !== null) {
                            if (input.charCodeAt(pos) === 44) {
                                result3 = ",";
                                pos++;
                            } else {
                                result3 = null;
                                if (reportFailures === 0) matchFailed('","');
                            }
                            if (result3 !== null) {
                                result4 = parse_OptionalSP();
                                if (result4 !== null) result1 = [
                                    result1,
                                    result2,
                                    result3,
                                    result4
                                ];
                                else {
                                    result1 = null;
                                    pos = pos3;
                                }
                            } else {
                                result1 = null;
                                pos = pos3;
                            }
                        } else {
                            result1 = null;
                            pos = pos3;
                        }
                    } else {
                        result1 = null;
                        pos = pos3;
                    }
                    if (result1 !== null) result1 = function(offset, i) {
                        return i;
                    }(pos2, result1[0]);
                    if (result1 === null) pos = pos2;
                }
                if (result0 !== null) {
                    result1 = parse_LinkValue();
                    if (result1 !== null) result0 = [
                        result0,
                        result1
                    ];
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                } else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) result0 = function(offset, start, last) {
                    return start.concat([
                        last
                    ]);
                }(pos0, result0[0], result0[1]);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_LinkValue() {
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 60) {
                    result0 = "<";
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed('"<"');
                }
                if (result0 !== null) {
                    result1 = parse_URIReference();
                    if (result1 !== null) {
                        if (input.charCodeAt(pos) === 62) {
                            result2 = ">";
                            pos++;
                        } else {
                            result2 = null;
                            if (reportFailures === 0) matchFailed('">"');
                        }
                        if (result2 !== null) {
                            result3 = parse_OptionalSP();
                            if (result3 !== null) {
                                result4 = [];
                                result5 = parse_LinkParams();
                                while(result5 !== null){
                                    result4.push(result5);
                                    result5 = parse_LinkParams();
                                }
                                if (result4 !== null) result0 = [
                                    result0,
                                    result1,
                                    result2,
                                    result3,
                                    result4
                                ];
                                else {
                                    result0 = null;
                                    pos = pos1;
                                }
                            } else {
                                result0 = null;
                                pos = pos1;
                            }
                        } else {
                            result0 = null;
                            pos = pos1;
                        }
                    } else {
                        result0 = null;
                        pos = pos1;
                    }
                } else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) result0 = function(offset, href, params) {
                    var link = {};
                    params.forEach(function(param) {
                        link[param[0]] = param[1];
                    });
                    link.href = href;
                    return link;
                }(pos0, result0[1], result0[4]);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_LinkParams() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 59) {
                    result0 = ";";
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed('";"');
                }
                if (result0 !== null) {
                    result1 = parse_OptionalSP();
                    if (result1 !== null) {
                        result2 = parse_LinkParam();
                        if (result2 !== null) {
                            result3 = parse_OptionalSP();
                            if (result3 !== null) result0 = [
                                result0,
                                result1,
                                result2,
                                result3
                            ];
                            else {
                                result0 = null;
                                pos = pos1;
                            }
                        } else {
                            result0 = null;
                            pos = pos1;
                        }
                    } else {
                        result0 = null;
                        pos = pos1;
                    }
                } else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) result0 = function(offset, param) {
                    return param;
                }(pos0, result0[2]);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_URIReference() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                if (/^[^>]/.test(input.charAt(pos))) {
                    result1 = input.charAt(pos);
                    pos++;
                } else {
                    result1 = null;
                    if (reportFailures === 0) matchFailed("[^>]");
                }
                if (result1 !== null) {
                    result0 = [];
                    while(result1 !== null){
                        result0.push(result1);
                        if (/^[^>]/.test(input.charAt(pos))) {
                            result1 = input.charAt(pos);
                            pos++;
                        } else {
                            result1 = null;
                            if (reportFailures === 0) matchFailed("[^>]");
                        }
                    }
                } else result0 = null;
                if (result0 !== null) result0 = function(offset, url) {
                    return url.join("");
                }(pos0, result0);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_LinkParam() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_LinkParamName();
                if (result0 !== null) {
                    result1 = parse_LinkParamValue();
                    result1 = result1 !== null ? result1 : "";
                    if (result1 !== null) result0 = [
                        result0,
                        result1
                    ];
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                } else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) result0 = function(offset, name, value) {
                    return [
                        name,
                        value
                    ];
                }(pos0, result0[0], result0[1]);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_LinkParamName() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                if (/^[a-z]/.test(input.charAt(pos))) {
                    result1 = input.charAt(pos);
                    pos++;
                } else {
                    result1 = null;
                    if (reportFailures === 0) matchFailed("[a-z]");
                }
                if (result1 !== null) {
                    result0 = [];
                    while(result1 !== null){
                        result0.push(result1);
                        if (/^[a-z]/.test(input.charAt(pos))) {
                            result1 = input.charAt(pos);
                            pos++;
                        } else {
                            result1 = null;
                            if (reportFailures === 0) matchFailed("[a-z]");
                        }
                    }
                } else result0 = null;
                if (result0 !== null) result0 = function(offset, name) {
                    return name.join("");
                }(pos0, result0);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_LinkParamValue() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                if (input.charCodeAt(pos) === 61) {
                    result0 = "=";
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed('"="');
                }
                if (result0 !== null) {
                    result1 = parse_PToken();
                    if (result1 === null) result1 = parse_QuotedString();
                    if (result1 !== null) result0 = [
                        result0,
                        result1
                    ];
                    else {
                        result0 = null;
                        pos = pos1;
                    }
                } else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) result0 = function(offset, str) {
                    return str;
                }(pos0, result0[1]);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_PToken() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_PTokenChar();
                if (result1 !== null) {
                    result0 = [];
                    while(result1 !== null){
                        result0.push(result1);
                        result1 = parse_PTokenChar();
                    }
                } else result0 = null;
                if (result0 !== null) result0 = function(offset, token) {
                    return token.join("");
                }(pos0, result0);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_PTokenChar() {
                var result0;
                if (input.charCodeAt(pos) === 33) {
                    result0 = "!";
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed('"!"');
                }
                if (result0 === null) {
                    if (input.charCodeAt(pos) === 35) {
                        result0 = "#";
                        pos++;
                    } else {
                        result0 = null;
                        if (reportFailures === 0) matchFailed('"#"');
                    }
                    if (result0 === null) {
                        if (input.charCodeAt(pos) === 36) {
                            result0 = "$";
                            pos++;
                        } else {
                            result0 = null;
                            if (reportFailures === 0) matchFailed('"$"');
                        }
                        if (result0 === null) {
                            if (input.charCodeAt(pos) === 37) {
                                result0 = "%";
                                pos++;
                            } else {
                                result0 = null;
                                if (reportFailures === 0) matchFailed('"%"');
                            }
                            if (result0 === null) {
                                if (input.charCodeAt(pos) === 38) {
                                    result0 = "&";
                                    pos++;
                                } else {
                                    result0 = null;
                                    if (reportFailures === 0) matchFailed('"&"');
                                }
                                if (result0 === null) {
                                    if (input.charCodeAt(pos) === 39) {
                                        result0 = "'";
                                        pos++;
                                    } else {
                                        result0 = null;
                                        if (reportFailures === 0) matchFailed('"\'"');
                                    }
                                    if (result0 === null) {
                                        if (input.charCodeAt(pos) === 40) {
                                            result0 = "(";
                                            pos++;
                                        } else {
                                            result0 = null;
                                            if (reportFailures === 0) matchFailed('"("');
                                        }
                                        if (result0 === null) {
                                            if (input.charCodeAt(pos) === 41) {
                                                result0 = ")";
                                                pos++;
                                            } else {
                                                result0 = null;
                                                if (reportFailures === 0) matchFailed('")"');
                                            }
                                            if (result0 === null) {
                                                if (input.charCodeAt(pos) === 42) {
                                                    result0 = "*";
                                                    pos++;
                                                } else {
                                                    result0 = null;
                                                    if (reportFailures === 0) matchFailed('"*"');
                                                }
                                                if (result0 === null) {
                                                    if (input.charCodeAt(pos) === 43) {
                                                        result0 = "+";
                                                        pos++;
                                                    } else {
                                                        result0 = null;
                                                        if (reportFailures === 0) matchFailed('"+"');
                                                    }
                                                    if (result0 === null) {
                                                        if (input.charCodeAt(pos) === 45) {
                                                            result0 = "-";
                                                            pos++;
                                                        } else {
                                                            result0 = null;
                                                            if (reportFailures === 0) matchFailed('"-"');
                                                        }
                                                        if (result0 === null) {
                                                            if (input.charCodeAt(pos) === 46) {
                                                                result0 = ".";
                                                                pos++;
                                                            } else {
                                                                result0 = null;
                                                                if (reportFailures === 0) matchFailed('"."');
                                                            }
                                                            if (result0 === null) {
                                                                if (input.charCodeAt(pos) === 124) {
                                                                    result0 = "|";
                                                                    pos++;
                                                                } else {
                                                                    result0 = null;
                                                                    if (reportFailures === 0) matchFailed('"|"');
                                                                }
                                                                if (result0 === null) {
                                                                    result0 = parse_Digit();
                                                                    if (result0 === null) {
                                                                        if (input.charCodeAt(pos) === 58) {
                                                                            result0 = ":";
                                                                            pos++;
                                                                        } else {
                                                                            result0 = null;
                                                                            if (reportFailures === 0) matchFailed('":"');
                                                                        }
                                                                        if (result0 === null) {
                                                                            if (input.charCodeAt(pos) === 60) {
                                                                                result0 = "<";
                                                                                pos++;
                                                                            } else {
                                                                                result0 = null;
                                                                                if (reportFailures === 0) matchFailed('"<"');
                                                                            }
                                                                            if (result0 === null) {
                                                                                if (input.charCodeAt(pos) === 61) {
                                                                                    result0 = "=";
                                                                                    pos++;
                                                                                } else {
                                                                                    result0 = null;
                                                                                    if (reportFailures === 0) matchFailed('"="');
                                                                                }
                                                                                if (result0 === null) {
                                                                                    if (input.charCodeAt(pos) === 62) {
                                                                                        result0 = ">";
                                                                                        pos++;
                                                                                    } else {
                                                                                        result0 = null;
                                                                                        if (reportFailures === 0) matchFailed('">"');
                                                                                    }
                                                                                    if (result0 === null) {
                                                                                        if (input.charCodeAt(pos) === 63) {
                                                                                            result0 = "?";
                                                                                            pos++;
                                                                                        } else {
                                                                                            result0 = null;
                                                                                            if (reportFailures === 0) matchFailed('"?"');
                                                                                        }
                                                                                        if (result0 === null) {
                                                                                            if (input.charCodeAt(pos) === 64) {
                                                                                                result0 = "@";
                                                                                                pos++;
                                                                                            } else {
                                                                                                result0 = null;
                                                                                                if (reportFailures === 0) matchFailed('"@"');
                                                                                            }
                                                                                            if (result0 === null) {
                                                                                                result0 = parse_Alpha();
                                                                                                if (result0 === null) {
                                                                                                    if (input.charCodeAt(pos) === 91) {
                                                                                                        result0 = "[";
                                                                                                        pos++;
                                                                                                    } else {
                                                                                                        result0 = null;
                                                                                                        if (reportFailures === 0) matchFailed('"["');
                                                                                                    }
                                                                                                    if (result0 === null) {
                                                                                                        if (input.charCodeAt(pos) === 93) {
                                                                                                            result0 = "]";
                                                                                                            pos++;
                                                                                                        } else {
                                                                                                            result0 = null;
                                                                                                            if (reportFailures === 0) matchFailed('"]"');
                                                                                                        }
                                                                                                        if (result0 === null) {
                                                                                                            if (input.charCodeAt(pos) === 94) {
                                                                                                                result0 = "^";
                                                                                                                pos++;
                                                                                                            } else {
                                                                                                                result0 = null;
                                                                                                                if (reportFailures === 0) matchFailed('"^"');
                                                                                                            }
                                                                                                            if (result0 === null) {
                                                                                                                if (input.charCodeAt(pos) === 95) {
                                                                                                                    result0 = "_";
                                                                                                                    pos++;
                                                                                                                } else {
                                                                                                                    result0 = null;
                                                                                                                    if (reportFailures === 0) matchFailed('"_"');
                                                                                                                }
                                                                                                                if (result0 === null) {
                                                                                                                    if (input.charCodeAt(pos) === 96) {
                                                                                                                        result0 = "`";
                                                                                                                        pos++;
                                                                                                                    } else {
                                                                                                                        result0 = null;
                                                                                                                        if (reportFailures === 0) matchFailed('"`"');
                                                                                                                    }
                                                                                                                    if (result0 === null) {
                                                                                                                        if (input.charCodeAt(pos) === 123) {
                                                                                                                            result0 = "{";
                                                                                                                            pos++;
                                                                                                                        } else {
                                                                                                                            result0 = null;
                                                                                                                            if (reportFailures === 0) matchFailed('"{"');
                                                                                                                        }
                                                                                                                        if (result0 === null) {
                                                                                                                            if (/^[\/\/]/.test(input.charAt(pos))) {
                                                                                                                                result0 = input.charAt(pos);
                                                                                                                                pos++;
                                                                                                                            } else {
                                                                                                                                result0 = null;
                                                                                                                                if (reportFailures === 0) matchFailed("[\\/\\/]");
                                                                                                                            }
                                                                                                                            if (result0 === null) {
                                                                                                                                if (input.charCodeAt(pos) === 125) {
                                                                                                                                    result0 = "}";
                                                                                                                                    pos++;
                                                                                                                                } else {
                                                                                                                                    result0 = null;
                                                                                                                                    if (reportFailures === 0) matchFailed('"}"');
                                                                                                                                }
                                                                                                                                if (result0 === null) {
                                                                                                                                    if (input.charCodeAt(pos) === 126) {
                                                                                                                                        result0 = "~";
                                                                                                                                        pos++;
                                                                                                                                    } else {
                                                                                                                                        result0 = null;
                                                                                                                                        if (reportFailures === 0) matchFailed('"~"');
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return result0;
            }
            function parse_OptionalSP() {
                var result0, result1;
                result0 = [];
                result1 = parse_SP();
                while(result1 !== null){
                    result0.push(result1);
                    result1 = parse_SP();
                }
                return result0;
            }
            function parse_QuotedString() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_DQ();
                if (result0 !== null) {
                    result1 = parse_QuotedStringInternal();
                    if (result1 !== null) {
                        result2 = parse_DQ();
                        if (result2 !== null) result0 = [
                            result0,
                            result1,
                            result2
                        ];
                        else {
                            result0 = null;
                            pos = pos1;
                        }
                    } else {
                        result0 = null;
                        pos = pos1;
                    }
                } else {
                    result0 = null;
                    pos = pos1;
                }
                if (result0 !== null) result0 = function(offset, str) {
                    return str;
                }(pos0, result0[1]);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_QuotedStringInternal() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result0 = [];
                result1 = parse_QDText();
                if (result1 === null) result1 = parse_QuotedPair();
                while(result1 !== null){
                    result0.push(result1);
                    result1 = parse_QDText();
                    if (result1 === null) result1 = parse_QuotedPair();
                }
                if (result0 !== null) result0 = function(offset, str) {
                    return str.join("");
                }(pos0, result0);
                if (result0 === null) pos = pos0;
                return result0;
            }
            function parse_Char() {
                var result0;
                if (/^[\0-]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed("[\\0-\x7f]");
                }
                return result0;
            }
            function parse_UpAlpha() {
                var result0;
                if (/^[A-Z]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed("[A-Z]");
                }
                return result0;
            }
            function parse_LoAlpha() {
                var result0;
                if (/^[a-z]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed("[a-z]");
                }
                return result0;
            }
            function parse_Alpha() {
                var result0;
                result0 = parse_UpAlpha();
                if (result0 === null) result0 = parse_LoAlpha();
                return result0;
            }
            function parse_Digit() {
                var result0;
                if (/^[0-9]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed("[0-9]");
                }
                return result0;
            }
            function parse_SP() {
                var result0;
                if (/^[ ]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed("[ ]");
                }
                return result0;
            }
            function parse_DQ() {
                var result0;
                if (/^["]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed('["]');
                }
                return result0;
            }
            function parse_QDText() {
                var result0;
                if (/^[^"]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed('[^"]');
                }
                return result0;
            }
            function parse_QuotedPair() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                if (/^[\\]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                } else {
                    result0 = null;
                    if (reportFailures === 0) matchFailed("[\\\\]");
                }
                if (result0 !== null) {
                    result1 = parse_Char();
                    if (result1 !== null) result0 = [
                        result0,
                        result1
                    ];
                    else {
                        result0 = null;
                        pos = pos0;
                    }
                } else {
                    result0 = null;
                    pos = pos0;
                }
                return result0;
            }
            function cleanupExpected(expected) {
                expected.sort();
                var lastExpected = null;
                var cleanExpected = [];
                for(var i = 0; i < expected.length; i++)if (expected[i] !== lastExpected) {
                    cleanExpected.push(expected[i]);
                    lastExpected = expected[i];
                }
                return cleanExpected;
            }
            function computeErrorPosition() {
                /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */ var line = 1;
                var column = 1;
                var seenCR = false;
                for(var i = 0; i < Math.max(pos, rightmostFailuresPos); i++){
                    var ch = input.charAt(i);
                    if (ch === "\n") {
                        if (!seenCR) line++;
                        column = 1;
                        seenCR = false;
                    } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                        line++;
                        column = 1;
                        seenCR = true;
                    } else {
                        column++;
                        seenCR = false;
                    }
                }
                return {
                    line: line,
                    column: column
                };
            }
            var result = parseFunctions[startRule]();
            /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */ if (result === null || pos !== input.length) {
                var offset = Math.max(pos, rightmostFailuresPos);
                var found = offset < input.length ? input.charAt(offset) : null;
                var errorPosition = computeErrorPosition();
                throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);
            }
            return result;
        },
        /* Returns the parser source code. */ toSource: function() {
            return this._source;
        }
    };
    /* Thrown when a parser encounters a syntax error. */ result.SyntaxError = function(expected, found, offset, line, column) {
        function buildMessage(expected, found) {
            var expectedHumanized, foundHumanized;
            switch(expected.length){
                case 0:
                    expectedHumanized = "end of input";
                    break;
                case 1:
                    expectedHumanized = expected[0];
                    break;
                default:
                    expectedHumanized = expected.slice(0, expected.length - 1).join(", ") + " or " + expected[expected.length - 1];
            }
            foundHumanized = found ? quote(found) : "end of input";
            return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
        }
        this.name = "SyntaxError";
        this.expected = expected;
        this.found = found;
        this.message = buildMessage(expected, found);
        this.offset = offset;
        this.line = line;
        this.column = column;
    };
    result.SyntaxError.prototype = Error.prototype;
    return result;
}();

},{}],"7qjc7":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var punycode = require("3ed713f3ae68ffa3");
var util = require("180197b40a151feb");
exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;
function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
}
// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    "\n",
    "	"
], // RFC 2396: characters not allowed for various reasons.
unwise = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
].concat(delims), // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = [
    "'"
].concat(unwise), // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = [
    "%",
    "/",
    "?",
    ";",
    "#"
].concat(autoEscape), hostEndingChars = [
    "/",
    "?",
    "#"
], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
    "javascript": true,
    "javascript:": true
}, // protocols that never have a hostname.
hostlessProtocol = {
    "javascript": true,
    "javascript:": true
}, // protocols that always contain a // bit.
slashedProtocol = {
    "http": true,
    "https": true,
    "ftp": true,
    "gopher": true,
    "file": true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
}, querystring = require("37ff3dff3ab98073");
function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util.isObject(url) && url instanceof Url) return url;
    var u = new Url;
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
}
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url)) throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url = uSplit.join(splitter);
    var rest = url;
    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
            this.path = rest;
            this.href = rest;
            this.pathname = simplePath[1];
            if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) this.query = querystring.parse(this.search.substr(1));
                else this.query = this.search.substr(1);
            } else if (parseQueryString) {
                this.search = "";
                this.query = {};
            }
            return this;
        }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
    }
    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
            rest = rest.substr(2);
            this.slashes = true;
        }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c
        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.
        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for(var i = 0; i < hostEndingChars.length; i++){
            var hec = rest.indexOf(hostEndingChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }
        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) // atSign can be anywhere.
        atSign = rest.lastIndexOf("@");
        else // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf("@", hostEnd);
        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
            auth = rest.slice(0, atSign);
            rest = rest.slice(atSign + 1);
            this.auth = decodeURIComponent(auth);
        }
        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for(var i = 0; i < nonHostChars.length; i++){
            var hec = rest.indexOf(nonHostChars[i]);
            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        // pull out port.
        this.parseHost();
        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || "";
        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        // validate a little.
        if (!ipv6Hostname) {
            var hostparts = this.hostname.split(/\./);
            for(var i = 0, l = hostparts.length; i < l; i++){
                var part = hostparts[i];
                if (!part) continue;
                if (!part.match(hostnamePartPattern)) {
                    var newpart = "";
                    for(var j = 0, k = part.length; j < k; j++)if (part.charCodeAt(j) > 127) // we replace non-ASCII char with a temporary placeholder
                    // we need this to make sure size of hostname is not
                    // broken by replacing non-ASCII by nothing
                    newpart += "x";
                    else newpart += part[j];
                    // we test again with ASCII char only
                    if (!newpart.match(hostnamePartPattern)) {
                        var validParts = hostparts.slice(0, i);
                        var notHost = hostparts.slice(i + 1);
                        var bit = part.match(hostnamePartStart);
                        if (bit) {
                            validParts.push(bit[1]);
                            notHost.unshift(bit[2]);
                        }
                        if (notHost.length) rest = "/" + notHost.join(".") + rest;
                        this.hostname = validParts.join(".");
                        break;
                    }
                }
            }
        }
        if (this.hostname.length > hostnameMaxLen) this.hostname = "";
        else // hostnames are always lower case.
        this.hostname = this.hostname.toLowerCase();
        if (!ipv6Hostname) // IDNA Support: Returns a punycoded representation of "domain".
        // It only converts parts of the domain name that
        // have non-ASCII characters, i.e. it doesn't matter if
        // you call it with a domain that already is ASCII-only.
        this.hostname = punycode.toASCII(this.hostname);
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
            this.hostname = this.hostname.substr(1, this.hostname.length - 2);
            if (rest[0] !== "/") rest = "/" + rest;
        }
    }
    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for(var i = 0, l = autoEscape.length; i < l; i++){
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1) continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) esc = escape(ae);
        rest = rest.split(ae).join(esc);
    }
    // chop off from the tail first.
    var hash = rest.indexOf("#");
    if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) this.query = querystring.parse(this.query);
        rest = rest.slice(0, qm);
    } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = "";
        this.query = {};
    }
    if (rest) this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) this.pathname = "/";
    //to support http.request
    if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
    }
    // finally, reconstruct the href based on what has been validated.
    this.href = this.format();
    return this;
};
// format a parsed object into a url string
function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (util.isString(obj)) obj = urlParse(obj);
    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
    return obj.format();
}
Url.prototype.format = function() {
    var auth = this.auth || "";
    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
    }
    var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
    if (this.host) host = auth + this.host;
    else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) host += ":" + this.port;
    }
    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) query = querystring.stringify(this.query);
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":") protocol += ":";
    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
    } else if (!host) host = "";
    if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
    if (search && search.charAt(0) !== "?") search = "?" + search;
    pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
};
function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
    if (!source) return relative;
    return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
    if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
    }
    var result = new Url();
    var tkeys = Object.keys(this);
    for(var tk = 0; tk < tkeys.length; tk++){
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
    }
    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;
    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === "") {
        result.href = result.format();
        return result;
    }
    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for(var rk = 0; rk < rkeys.length; rk++){
            var rkey = rkeys[rk];
            if (rkey !== "protocol") result[rkey] = relative[rkey];
        }
        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) result.path = result.pathname = "/";
        result.href = result.format();
        return result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
            var keys = Object.keys(relative);
            for(var v = 0; v < keys.length; v++){
                var k = keys[v];
                result[k] = relative[k];
            }
            result.href = result.format();
            return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
            var relPath = (relative.pathname || "").split("/");
            while(relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
        } else result.pathname = relative.pathname;
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
            var p = result.pathname || "";
            var s = result.search || "";
            result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
            relative.hostname = null;
            relative.port = null;
            if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
            }
            relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
    // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        result.href = result.format();
        return result;
    }
    if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) result.path = "/" + result.search;
        else result.path = null;
        result.href = result.format();
        return result;
    }
    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for(var i = srcPath.length; i >= 0; i--){
        last = srcPath[i];
        if (last === ".") srcPath.splice(i, 1);
        else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }
    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) for(; up--; up)srcPath.unshift("..");
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) srcPath.unshift("");
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") srcPath.push("");
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) srcPath.unshift("");
    if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
    } else result.pathname = srcPath.join("/");
    //to support request.http
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
};
Url.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
        port = port[0];
        if (port !== ":") this.port = port.substr(1);
        host = host.substr(0, host.length - port.length);
    }
    if (host) this.hostname = host;
};

},{"3ed713f3ae68ffa3":"4SwIZ","180197b40a151feb":"8nk0t","37ff3dff3ab98073":"7oCJH"}],"4SwIZ":[function(require,module,exports) {
var global = arguments[3];
(function(root) {
    /** Detect free variables */ var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal = typeof global == "object" && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) root = freeGlobal;
    /**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */ var punycode, /** Highest positive signed 32-bit float value */ maxInt = 2147483647, /** Bootstring parameters */ base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", /** Regular expressions */ regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, /** Error messages */ errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
    }, /** Convenience shortcuts */ baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, /** Temporary variable */ key;
    /*--------------------------------------------------------------------------*/ /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */ function error(type) {
        throw new RangeError(errors[type]);
    }
    /**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */ function map(array, fn) {
        var length = array.length;
        var result = [];
        while(length--)result[length] = fn(array[length]);
        return result;
    }
    /**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */ function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + "@";
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
    }
    /**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */ function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while(counter < length){
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            } else output.push(value);
        }
        return output;
    }
    /**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */ function ucs2encode(array) {
        return map(array, function(value) {
            var output = "";
            if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
            return output;
        }).join("");
    }
    /**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */ function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) return codePoint - 22;
        if (codePoint - 65 < 26) return codePoint - 65;
        if (codePoint - 97 < 26) return codePoint - 97;
        return base;
    }
    /**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */ function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    /**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */ function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for(; delta > baseMinusTMin * tMax >> 1; k += base)delta = floor(delta / baseMinusTMin);
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    /**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */ function decode(input) {
        // Don't use UCS-2
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, /** Cached calculation results */ baseMinusT;
        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) basic = 0;
        for(j = 0; j < basic; ++j){
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) error("not-basic");
            output.push(input.charCodeAt(j));
        }
        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.
        for(index = basic > 0 ? basic + 1 : 0; index < inputLength;){
            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for(oldi = i, w = 1, k = base;; k += base){
                if (index >= inputLength) error("invalid-input");
                digit = basicToDigit(input.charCodeAt(index++));
                if (digit >= base || digit > floor((maxInt - i) / w)) error("overflow");
                i += digit * w;
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (digit < t) break;
                baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) error("overflow");
                w *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);
            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) error("overflow");
            n += floor(i / out);
            i %= out;
            // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);
        }
        return ucs2encode(output);
    }
    /**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */ function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], /** `inputLength` will hold the number of code points in `input`. */ inputLength, /** Cached calculation results */ handledCPCountPlusOne, baseMinusT, qMinusT;
        // Convert the input in UCS-2 to Unicode
        input = ucs2decode(input);
        // Cache the length
        inputLength = input.length;
        // Initialize the state
        n = initialN;
        delta = 0;
        bias = initialBias;
        // Handle the basic code points
        for(j = 0; j < inputLength; ++j){
            currentValue = input[j];
            if (currentValue < 0x80) output.push(stringFromCharCode(currentValue));
        }
        handledCPCount = basicLength = output.length;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) output.push(delimiter);
        // Main encoding loop:
        while(handledCPCount < inputLength){
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for(m = maxInt, j = 0; j < inputLength; ++j){
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) m = currentValue;
            }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) error("overflow");
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for(j = 0; j < inputLength; ++j){
                currentValue = input[j];
                if (currentValue < n && ++delta > maxInt) error("overflow");
                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for(q = delta, k = base;; k += base){
                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) break;
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                        q = floor(qMinusT / baseMinusT);
                    }
                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }
            ++delta;
            ++n;
        }
        return output.join("");
    }
    /**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */ function toUnicode(input) {
        return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
    }
    /**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */ function toASCII(input) {
        return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
    }
    /*--------------------------------------------------------------------------*/ /** Define the public API */ punycode = {
        /**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */ "version": "1.4.1",
        /**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */ "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
    };
    /** Expose `punycode` */ // Some AMD build optimizers, like r.js, check for specific condition patterns
    // like the following:
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) define("punycode", function() {
        return punycode;
    });
    else if (freeExports && freeModule) {
        if (module.exports == freeExports) // in Node.js, io.js, or RingoJS v0.8.0+
        freeModule.exports = punycode;
        else // in Narwhal or RingoJS v0.7.0-
        for(key in punycode)punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
    } else // in Rhino or a web browser
    root.punycode = punycode;
})(this);

},{}],"8nk0t":[function(require,module,exports) {
"use strict";
module.exports = {
    isString: function(arg) {
        return typeof arg === "string";
    },
    isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
    },
    isNull: function(arg) {
        return arg === null;
    },
    isNullOrUndefined: function(arg) {
        return arg == null;
    }
};

},{}],"7oCJH":[function(require,module,exports) {
"use strict";
exports.decode = exports.parse = require("a70821f2d68727bc");
exports.encode = exports.stringify = require("3ef42d377916b101");

},{"a70821f2d68727bc":"3WtwQ","3ef42d377916b101":"i5gNM"}],"3WtwQ":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
module.exports = function(qs, sep, eq, options) {
    sep = sep || "&";
    eq = eq || "=";
    var obj = {};
    if (typeof qs !== "string" || qs.length === 0) return obj;
    var regexp = /\+/g;
    qs = qs.split(sep);
    var maxKeys = 1000;
    if (options && typeof options.maxKeys === "number") maxKeys = options.maxKeys;
    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) len = maxKeys;
    for(var i = 0; i < len; ++i){
        var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
        if (idx >= 0) {
            kstr = x.substr(0, idx);
            vstr = x.substr(idx + 1);
        } else {
            kstr = x;
            vstr = "";
        }
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k)) obj[k] = v;
        else if (isArray(obj[k])) obj[k].push(v);
        else obj[k] = [
            obj[k],
            v
        ];
    }
    return obj;
};
var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
};

},{}],"i5gNM":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var stringifyPrimitive = function(v) {
    switch(typeof v){
        case "string":
            return v;
        case "boolean":
            return v ? "true" : "false";
        case "number":
            return isFinite(v) ? v : "";
        default:
            return "";
    }
};
module.exports = function(obj, sep, eq, name) {
    sep = sep || "&";
    eq = eq || "=";
    if (obj === null) obj = undefined;
    if (typeof obj === "object") return map(objectKeys(obj), function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (isArray(obj[k])) return map(obj[k], function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
        else return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
    }).join(sep);
    if (!name) return "";
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};
var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
};
function map(xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for(var i = 0; i < xs.length; i++)res.push(f(xs[i], i));
    return res;
}
var objectKeys = Object.keys || function(obj) {
    var res = [];
    for(var key in obj)if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
    return res;
};

},{}],"74Bhx":[function(require,module,exports) {
var interceptor = require("4f04b7f9f5681709");
var standardResponse = interceptor({
    response: transform
});
function transform(response) {
    return {
        url: response.url,
        status: response.status && response.status.code,
        headers: response.headers,
        entity: response.entity,
        error: response.error,
        callback: response.request && response.request.callback,
        nextPage: response.nextPage
    };
}
module.exports = standardResponse;

},{"4f04b7f9f5681709":"ddaBh"}],"5Rn3i":[function(require,module,exports) {
"use strict";
// install ES6 Promise polyfill
require("eb55cee8c6b18e85");
var interceptor = require("bdceb37ccc55de00");
var callbackify = interceptor({
    success: function(response) {
        var callback = response && response.callback;
        if (typeof callback === "function") callback(null, response.entity, response);
        return response;
    },
    error: function(response) {
        var callback = response && response.callback;
        if (typeof callback === "function") {
            var err = response.error || response.entity;
            if (typeof err !== "object") err = new Error(err);
            callback(err);
        }
        return response;
    }
});
module.exports = callbackify;

},{"eb55cee8c6b18e85":"1vHlJ","bdceb37ccc55de00":"ddaBh"}],"k0he1":[function(require,module,exports) {
"use strict";
var b64 = require("5a10c350d9082b16");
/**
 * Access tokens actually are data, and using them we can derive
 * a user's username. This method attempts to do just that,
 * decoding the part of the token after the first `.` into
 * a username.
 *
 * @private
 * @param {string} token an access token
 * @return {string} username
 */ function getUser(token) {
    var data = token.split(".")[1];
    if (!data) return null;
    data = data.replace(/-/g, "+").replace(/_/g, "/");
    var mod = data.length % 4;
    if (mod === 2) data += "==";
    if (mod === 3) data += "=";
    if (mod === 1 || mod > 3) return null;
    try {
        return JSON.parse(b64.decode(data)).u;
    } catch (err) {
        return null;
    }
}
module.exports = getUser;

},{"5a10c350d9082b16":"kTKVR"}],"kTKVR":[function(require,module,exports) {
/*
 * Copyright (c) 2009 Nicholas C. Zakas. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */ /*
 * Base 64 implementation in JavaScript
 * Original source available at https://raw.github.com/nzakas/computer-science-in-javascript/02a2745b4aa8214f2cae1bf0b15b447ca1a91b23/encodings/base64/base64.js
 *
 * Linter refinement by Scott Andrews
 */ "use strict";
/*jshint bitwise: false */ var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
/**
 * Base64-encodes a string of text.
 *
 * @param {string} text The text to encode.
 * @return {string} The base64-encoded string.
 */ function base64Encode(text) {
    if (/([^\u0000-\u00ff])/.test(text)) throw new Error("Can't base64 encode non-ASCII characters.");
    var i = 0, cur, prev, byteNum, result = [];
    while(i < text.length){
        cur = text.charCodeAt(i);
        byteNum = i % 3;
        switch(byteNum){
            case 0:
                result.push(digits.charAt(cur >> 2));
                break;
            case 1:
                result.push(digits.charAt((prev & 3) << 4 | cur >> 4));
                break;
            case 2:
                result.push(digits.charAt((prev & 0x0f) << 2 | cur >> 6));
                result.push(digits.charAt(cur & 0x3f));
                break;
        }
        prev = cur;
        i += 1;
    }
    if (byteNum === 0) {
        result.push(digits.charAt((prev & 3) << 4));
        result.push("==");
    } else if (byteNum === 1) {
        result.push(digits.charAt((prev & 0x0f) << 2));
        result.push("=");
    }
    return result.join("");
}
/**
 * Base64-decodes a string of text.
 *
 * @param {string} text The text to decode.
 * @return {string} The base64-decoded string.
 */ function base64Decode(text) {
    //ignore white space
    text = text.replace(/\s/g, "");
    //first check for any unexpected input
    if (!/^[a-z0-9\+\/\s]+\={0,2}$/i.test(text) || text.length % 4 > 0) throw new Error("Not a base64-encoded string.");
    //local variables
    var cur, prev, digitNum, i = 0, result = [];
    //remove any equals signs
    text = text.replace(/\=/g, "");
    //loop over each character
    while(i < text.length){
        cur = digits.indexOf(text.charAt(i));
        digitNum = i % 4;
        switch(digitNum){
            //case 0: first digit - do nothing, not enough info to work with
            case 1:
                result.push(String.fromCharCode(prev << 2 | cur >> 4));
                break;
            case 2:
                result.push(String.fromCharCode((prev & 0x0f) << 4 | cur >> 2));
                break;
            case 3:
                result.push(String.fromCharCode((prev & 3) << 6 | cur));
                break;
        }
        prev = cur;
        i += 1;
    }
    //return a string
    return result.join("");
}
module.exports = {
    encode: base64Encode,
    decode: base64Decode
};

},{}],"oeR9s":[function(require,module,exports) {
/*
 * xtend by Jake Verbaten
 *
 * Licensed under MIT
 * https://github.com/Raynos/xtend
 */ module.exports.extendMutable = extendMutable;
module.exports.extend = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extendMutable(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if (hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}
function extend() {
    var target = {};
    for(var i = 0; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if (hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}

},{}],"1DWGK":[function(require,module,exports) {
"use strict";
var invariant = require("35dfe0dff94ca548");
var makeService = require("9026b25dfeeeadcc");
/**
 * @class MapboxGeocoding
 */ var MapboxGeocoding = makeService("MapboxGeocoding");
var API_GEOCODING_FORWARD = "/geocoding/v5/{dataset}/{query}.json{?access_token,proximity,country,types,bbox,limit,autocomplete,language}";
var API_GEOCODING_REVERSE = "/geocoding/v5/{dataset}/{longitude},{latitude}.json{?access_token,types,limit,language}";
var REVERSE_GEOCODING_PRECISION = 5;
var FORWARD_GEOCODING_PROXIMITY_PRECISION = 3;
function roundTo(value, places) {
    var mult = Math.pow(10, places);
    return Math.round(value * mult) / mult;
}
/**
 * Search for a location with a string, using the
 * [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).
 *
 * The `query` parmeter can be an array of strings only if batch geocoding
 * is used by specifying `mapbox.places-permanent` as the `dataset` option.
 *
 * @param {string|Array<string>} query desired location
 * @param {Object} [options={}] additional options meant to tune
 * the request
 * @param {Object} options.proximity a proximity argument: this is
 * a geographical point given as an object with latitude and longitude
 * properties. Search results closer to this point will be given
 * higher priority.
 * @param {Array} options.bbox a bounding box argument: this is
 * a bounding box given as an array in the format [minX, minY, maxX, maxY].
 * Search results will be limited to the bounding box.
 * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, as an array or separated by commas.
 * @param {Array<string>|string} options.types an array or comma seperated list of types that filter
 * results to match those specified. See https://www.mapbox.com/developers/api/geocoding/#filter-type
 * for available types.
 * @param {number} [options.limit=5] is the maximum number of results to return, between 1 and 10 inclusive.
 * Some very specific queries may return fewer results than the limit.
 * @param {Array<string>|string} options.country an array or comma separated list of country codes to
 * limit results to specified country or countries.
 * @param {boolean} [options.autocomplete=true] whether to include results that include
 * the query only as a prefix. This is useful for UIs where users type
 * values, but if you have complete addresses as input, you'll want to turn it off
 * @param {string} [options.dataset=mapbox.places] the desired data to be
 * geocoded against. The default, mapbox.places, does not permit unlimited
 * caching. `mapbox.places-permanent` is available on request and does
 * permit permanent caching.
 * @param {Function} callback called with (err, results)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.geocodeForward('Paris, France', function(err, res) {
 *   // res is a GeoJSON document with geocoding matches
 * });
 * // using the proximity option to weight results closer to texas
 * mapboxClient.geocodeForward('Paris, France', {
 *   proximity: { latitude: 33.6875431, longitude: -95.4431142 }
 * }, function(err, res) {
 *   // res is a GeoJSON document with geocoding matches
 * });
 * // using the bbox option to limit results to a portion of Washington, D.C.
 * mapboxClient.geocodeForward('Starbucks', {
 *   bbox: [-77.083056,38.908611,-76.997778,38.959167]
 * }, function(err, res) {
 *   // res is a GeoJSON document with geocoding matches
 * });
 */ MapboxGeocoding.prototype.geocodeForward = function(query, options, callback) {
    // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax
    if (callback === undefined && (options === undefined || typeof options === "function")) {
        callback = options;
        options = {};
    }
    // typecheck arguments
    if (Array.isArray(query)) {
        if (options.dataset !== "mapbox.places-permanent") throw new Error("Batch geocoding is only available with the mapbox.places-permanent endpoint. See https://mapbox.com/api-documentation/#batch-requests for details");
        else query = query.join(";");
    }
    invariant(typeof query === "string", "query must be a string");
    invariant(typeof options === "object", "options must be an object");
    var queryOptions = {
        query: query,
        dataset: "mapbox.places"
    };
    var precision = FORWARD_GEOCODING_PROXIMITY_PRECISION;
    if (options.precision) {
        invariant(typeof options.precision === "number", "precision option must be number");
        precision = options.precision;
    }
    if (options.proximity) {
        invariant(typeof options.proximity.latitude === "number" && typeof options.proximity.longitude === "number", "proximity must be an object with numeric latitude & longitude properties");
        queryOptions.proximity = roundTo(options.proximity.longitude, precision) + "," + roundTo(options.proximity.latitude, precision);
    }
    if (options.bbox) {
        invariant(typeof options.bbox[0] === "number" && typeof options.bbox[1] === "number" && typeof options.bbox[2] === "number" && typeof options.bbox[3] === "number" && options.bbox.length === 4, "bbox must be an array with numeric values in the form [minX, minY, maxX, maxY]");
        queryOptions.bbox = options.bbox[0] + "," + options.bbox[1] + "," + options.bbox[2] + "," + options.bbox[3];
    }
    if (options.limit) {
        invariant(typeof options.limit === "number", "limit must be a number");
        queryOptions.limit = options.limit;
    }
    if (options.dataset) {
        invariant(typeof options.dataset === "string", "dataset option must be string");
        queryOptions.dataset = options.dataset;
    }
    if (options.country) {
        if (Array.isArray(options.country)) queryOptions.country = options.country.join(",");
        else {
            invariant(typeof options.country === "string", "country option must be an array or string");
            queryOptions.country = options.country;
        }
    }
    if (options.language) {
        if (Array.isArray(options.language)) queryOptions.language = options.language.join(",");
        else {
            invariant(typeof options.language === "string", "language option must be an array or string");
            queryOptions.language = options.language;
        }
    }
    if (options.types) {
        if (Array.isArray(options.types)) queryOptions.types = options.types.join(",");
        else {
            invariant(typeof options.types === "string", "types option must be an array or string");
            queryOptions.types = options.types;
        }
    }
    if (typeof options.autocomplete === "boolean") {
        invariant(typeof options.autocomplete === "boolean", "autocomplete must be a boolean");
        queryOptions.autocomplete = options.autocomplete;
    }
    return this.client({
        path: API_GEOCODING_FORWARD,
        params: queryOptions,
        callback: callback
    });
};
/**
 * Given a location, determine what geographical features are located
 * there. This uses the [Mapbox Geocoding API](https://www.mapbox.com/api-documentation/#geocoding).
 *
 * @param {Object} location the geographical point to search
 * @param {number} location.latitude decimal degrees latitude, in range -90 to 90
 * @param {number} location.longitude decimal degrees longitude, in range -180 to 180
 * @param {Object} [options={}] additional options meant to tune
 * the request.
 * @param {Array<string>|string} options.language Specify the language to use for response text and, for forward geocoding, query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas or as an array.
 * @param {Array<string>|string} options.types an array or comma seperated list of types that filter
 * results to match those specified. See
 * https://www.mapbox.com/api-documentation/#retrieve-places-near-a-location
 * for available types.
 * @param {number} [options.limit=1] is the maximum number of results to return, between 1 and 5
 * inclusive. Requires a single options.types to be specified (see example).
 * @param {string} [options.dataset=mapbox.places] the desired data to be
 * geocoded against. The default, mapbox.places, does not permit unlimited
 * caching. `mapbox.places-permanent` is available on request and does
 * permit permanent caching.
 * @param {Function} callback called with (err, results)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.geocodeReverse(
 *   { latitude: 33.6875431, longitude: -95.4431142 },
 *   function(err, res) {
 *   // res is a GeoJSON document with geocoding matches
 * });
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.geocodeReverse(
 *   { latitude: 33.6875431, longitude: -95.4431142, options: { types: 'address', limit: 3 } },
 *   function(err, res) {
 *   // res is a GeoJSON document with up to 3 geocoding matches
 * });
 */ MapboxGeocoding.prototype.geocodeReverse = function(location, options, callback) {
    // permit the options argument to be omitted, or the options + callback args to be omitted if using promise syntax
    if (callback === undefined && (options === undefined || typeof options === "function")) {
        callback = options;
        options = {};
    }
    // typecheck arguments
    invariant(typeof location === "object" && location !== null, "location must be an object");
    invariant(typeof options === "object", "options must be an object");
    invariant(typeof location.latitude === "number" && typeof location.longitude === "number", "location must be an object with numeric latitude & longitude properties");
    var queryOptions = {
        dataset: "mapbox.places"
    };
    if (options.dataset) {
        invariant(typeof options.dataset === "string", "dataset option must be string");
        queryOptions.dataset = options.dataset;
    }
    var precision = REVERSE_GEOCODING_PRECISION;
    if (options.precision) {
        invariant(typeof options.precision === "number", "precision option must be number");
        precision = options.precision;
    }
    if (options.language) {
        if (Array.isArray(options.language)) queryOptions.language = options.language.join(",");
        else {
            invariant(typeof options.language === "string", "language option must be an array or string");
            queryOptions.language = options.language;
        }
    }
    if (options.types) {
        if (Array.isArray(options.types)) queryOptions.types = options.types.join(",");
        else {
            invariant(typeof options.types === "string", "types option must be an array or string");
            queryOptions.types = options.types;
        }
    }
    if (options.limit) {
        invariant(typeof options.limit === "number", "limit option must be a number");
        invariant(options.types.split(",").length === 1, "a single type must be specified to use the limit option");
        queryOptions.limit = options.limit;
    }
    queryOptions.longitude = roundTo(location.longitude, precision);
    queryOptions.latitude = roundTo(location.latitude, precision);
    return this.client({
        path: API_GEOCODING_REVERSE,
        params: queryOptions,
        callback: callback
    });
};
module.exports = MapboxGeocoding;

},{"35dfe0dff94ca548":"ja2cL","9026b25dfeeeadcc":"czhc8"}],"jClEW":[function(require,module,exports) {
"use strict";
var invariant = require("6f9629450047b329");
var formatPoints = require("484150d5e5b5a5cc");
var makeService = require("53be3859436d3c17");
/**
 * @class MapboxSurface
 */ var MapboxSurface = makeService("MapboxSurface");
var API_SURFACE = "/v4/surface/{mapid}.json{?access_token,layer,fields,points,geojson,interpolate,encoded_polyline}";
/**
 * Given a list of locations, retrieve vector tiles, find the nearest
 * spatial features, extract their data values, and then absolute values and
 * optionally interpolated values in-between, if the interpolate option is specified.
 *
 * Consult the [Surface API](https://www.mapbox.com/developers/api/surface/)
 * for more documentation.
 *
 * @param {string} mapid a Mapbox mapid containing vector tiles against
 * which we'll query
 * @param {string} layer layer within the given `mapid` for which to pull
 * data
 * @param {Array<string>} fields layer within the given `mapid` for which to pull
 * data
 * @param {Array<Object>|string} path either an encoded polyline,
 * provided as a string, or an array of objects with longitude and latitude
 * properties, similar to waypoints.
 * @param {Object} [options={}] additional options meant to tune
 * the request
 * @param {string} [options.geojson=false] whether to return data as a
 * GeoJSON point
 * @param {string} [options.zoom=maximum] zoom level at which features
 * are queried
 * @param {boolean} [options.interpolate=true] Whether to interpolate
 * between matches in the feature collection.
 * @param {Function} callback called with (err, results)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 */ MapboxSurface.prototype.surface = function(mapid, layer, fields, path, options, callback) {
    // permit the options argument to be omitted
    if (callback === undefined && typeof options === "function") {
        callback = options;
        options = {};
    }
    // typecheck arguments
    invariant(typeof mapid === "string", "mapid must be a string");
    invariant(typeof layer === "string", "layer must be a string");
    invariant(Array.isArray(fields), "fields must be an array of strings");
    invariant(Array.isArray(path) || typeof path === "string", "path must be an array of objects or a string");
    invariant(typeof options === "object", "options must be an object");
    var interpolate = true, geojson = false;
    if (options.interpolate !== undefined) {
        invariant(typeof options.interpolate === "boolean", "interpolate must be a boolean");
        interpolate = options.interpolate;
    }
    if (options.geojson !== undefined) {
        invariant(typeof options.geojson === "boolean", "geojson option must be boolean");
        geojson = options.geojson;
    }
    var surfaceOptions = {
        geojson: geojson,
        layer: layer,
        mapid: mapid,
        fields: fields.join(","),
        interpolate: interpolate
    };
    if (Array.isArray(path)) surfaceOptions.points = formatPoints(path);
    else surfaceOptions.encoded_polyline = path;
    if (options.zoom !== undefined) {
        invariant(typeof options.zoom === "number", "zoom must be a number");
        surfaceOptions.z = options.zoom;
    }
    return this.client({
        path: API_SURFACE,
        params: surfaceOptions,
        callback: callback
    });
};
module.exports = MapboxSurface;

},{"6f9629450047b329":"ja2cL","484150d5e5b5a5cc":"lydwX","53be3859436d3c17":"czhc8"}],"lydwX":[function(require,module,exports) {
"use strict";
var invariantLocation = require("f2e8930e162d1288");
/**
 * Format waypionts in a way that's friendly to the directions and surface
 * API: comma-separated latitude, longitude pairs with semicolons between
 * them.
 * @private
 * @param {Array<Object>} waypoints array of objects with latitude and longitude
 * properties
 * @returns {string} formatted points
 * @throws {Error} if the input is invalid
 */ function formatPoints(waypoints) {
    return waypoints.map(function(location) {
        invariantLocation(location);
        return location.longitude + "," + location.latitude;
    }).join(";");
}
module.exports = formatPoints;

},{"f2e8930e162d1288":"71Ibc"}],"71Ibc":[function(require,module,exports) {
"use strict";
var invariant = require("40c807c3e9ba7998");
/**
 * Given an object that should be a location, ensure that it has
 * valid numeric longitude & latitude properties
 *
 * @param {Object} location object with longitude and latitude values
 * @throws {AssertError} if the object is not a valid location
 * @returns {undefined} nothing
 * @private
 */ function invariantLocation(location) {
    invariant(typeof location.latitude === "number" && typeof location.longitude === "number", "location must be an object with numeric latitude & longitude properties");
    if (location.zoom !== undefined) invariant(typeof location.zoom === "number", "zoom must be numeric");
}
module.exports = invariantLocation;

},{"40c807c3e9ba7998":"ja2cL"}],"7zyxf":[function(require,module,exports) {
"use strict";
var invariant = require("891ab0cfff245789");
var formatPoints = require("f39fca3fedd870b5");
var makeService = require("15109e77418bbb4d");
/**
 * @class MapboxDirections
 */ var MapboxDirections = makeService("MapboxDirections");
var API_DIRECTIONS = "/directions/v5/{account}/{profile}/{encodedWaypoints}.json{?access_token,alternatives,geometries,overview,radiuses,steps,continue_straight,bearings}";
/**
 * Find directions from A to B, or between any number of locations.
 * Consult the [Mapbox Directions API](https://www.mapbox.com/api-documentation/#directions)
 * for more documentation.
 *
 * @param {Array<Object>} waypoints an array of objects with `latitude`
 * and `longitude` properties that represent waypoints in order. Up to
 * 25 waypoints can be specified.
 * @param {Object} [options={}] additional options meant to tune
 * the request
 * @param {string} [options.profile=driving] the directions
 * profile, which determines how to prioritize different routes.
 * Options are `'driving-traffic'` for automotive routing which factors
 * in current and historic traffic conditions to avoid slowdowns,
 * `'driving'`, which assumes transportation via an
 * automobile and will use highways, `'walking'`, which avoids
 * streets without sidewalks, and `'cycling'`, which prefers streets
 * with bicycle lanes and lower speed limits for transportation via
 * bicycle.
 * @param {string} [options.account=mapbox] Account for the profile.
 * @param {string} [options.alternatives=true] whether to generate
 * alternative routes along with the preferred route.
 * @param {string} [options.geometries=geojson] format for the returned
 * route. Options are `'geojson'`, `'polyline'`, or `false`: `polyline`
 * yields more compact responses which can be decoded on the client side.
 * [GeoJSON](http://geojson.org/), the default, is compatible with libraries
 * like [Mapbox GL](https://www.mapbox.com/mapbox-gl/),
 * Leaflet and [Mapbox.js](https://www.mapbox.com/mapbox.js/). `false`
 * omits the geometry entirely and only returns instructions.
 * @param {string} [options.overview=simplified] type of returned overview
 * geometry. Can be `full` (the most detailed geometry available), `simplified`
 * (a simplified version of the full geometry), or `false`.
 * @param {Array<number|string>} [options.radiuses] an array of integers in meters
 * indicating the maximum distance each coordinate is allowed to move when
 * snapped to a nearby road segment. There must be as many radiuses as there
 * are coordinates in the request. Values can be any number greater than `0` or
 * they can be the string `unlimited`. If no routable road is found within the
 * radius, a `NoSegment` error is returned.
 * @param {boolean} [options.steps=false] whether to return steps and
 * turn-by-turn instructions. Can be `true` or `false`.
 * @param {boolean} [options.continue_straight] sets allowed direction of travel
 * when departing intermediate waypoints. If `true` the route will continue in
 * the same direction of travel. If `false` the route may continue in the
 * opposite direction of travel. Defaults to `true` for the `driving` profile
 * and `false` for the `walking` and `cycling` profiles.
 * @param {Array<Array>} [options.bearings] used to filter the road
 * segment the waypoint will be placed on by direction and dictates the angle
 * of approach. This option should always be used in conjunction with the
 * `radiuses` option. The parameter takes two values per waypoint: the first is
 * an angle clockwise from true north between `0` and `360`. The second is the
 * range of degrees the angle can deviate by. We recommend a value of `45` or
 * `90` for the range, as bearing measurements tend to be inaccurate. This is
 * useful for making sure we reroute vehicles on new routes that continue
 * traveling in their current direction. A request that does this would provide
 * bearing and radius values for the first waypoint and leave the remaining
 * values empty.If provided, the list of bearings must be the same length as
 * the list of waypoints, but you can skip a coordinate and show its position
 * by providing an empty array.
 * @param {Function} callback called with (err, results)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.getDirections(
 *   [
 *     { latitude: 33.6, longitude: -95.4431 },
 *     { latitude: 33.2, longitude: -95.4431 } ],
 *   function(err, res) {
 *   // res is a document with directions
 * });
 *
 * // With options
 * mapboxClient.getDirections([
 *   { latitude: 33.6875431, longitude: -95.4431142 },
 *   { latitude: 33.6875431, longitude: -95.4831142 }
 * ], {
 *   profile: 'walking',
 *   alternatives: false,
 *   geometry: 'polyline'
 * }, function(err, results) {
 *   console.log(results);
 * });
 */ MapboxDirections.prototype.getDirections = function(waypoints, options, callback) {
    // permit the options argument to be omitted
    if (callback === undefined && typeof options === "function") {
        callback = options;
        options = {};
    } else if (options === undefined) options = {};
    // typecheck arguments
    invariant(Array.isArray(waypoints), "waypoints must be an array");
    invariant(typeof options === "object", "options must be an object");
    var encodedWaypoints = formatPoints(waypoints);
    var params = {
        encodedWaypoints: encodedWaypoints,
        profile: "driving",
        account: "mapbox",
        alternatives: true,
        steps: true,
        geometries: "geojson"
    };
    if (options.profile) {
        invariant(typeof options.profile === "string", "profile option must be string");
        params.profile = options.profile;
    }
    if (options.account) {
        invariant(typeof options.account === "string", "account option must be string");
        params.account = options.account;
    }
    if (typeof options.alternatives !== "undefined") {
        invariant(typeof options.alternatives === "boolean", "alternatives option must be boolean");
        params.alternatives = options.alternatives;
    }
    if (options.radiuses) {
        invariant(Array.isArray(options.radiuses), "radiuses must be an array");
        invariant(options.radiuses.length === waypoints.length, "There must be as many radiuses as there are waypoints in the request");
        params.radiuses = options.radiuses.join(";");
    }
    if (typeof options.steps !== "undefined") {
        invariant(typeof options.steps === "boolean", "steps option must be boolean");
        params.steps = options.steps;
    }
    var allowedGeometries = [
        "polyline",
        "geojson"
    ];
    if (options.geometries) {
        invariant(allowedGeometries.indexOf(options.geometries) !== -1, "geometries option must be " + allowedGeometries);
        params.geometries = options.geometries;
    }
    var allowedOverviews = [
        "simplified",
        "full"
    ];
    if (options.overview) {
        invariant(allowedOverviews.indexOf(options.overview) !== -1, "overview option must be " + allowedOverviews);
        params.overview = options.overview;
    }
    if (typeof options.continue_straight !== "undefined") {
        invariant(typeof options.continue_straight === "boolean", "continue_straight option must be boolean");
        params.continue_straight = options.continue_straight;
    }
    if (options.bearings) {
        invariant(Array.isArray(options.radiuses), "bearings must be an array");
        invariant(options.bearings.length === waypoints.length, "There must be as many bearings as there are waypoints in the request");
        params.bearings = options.bearings.join(";");
    }
    return this.client({
        path: API_DIRECTIONS,
        params: params,
        callback: callback
    });
};
module.exports = MapboxDirections;

},{"891ab0cfff245789":"ja2cL","f39fca3fedd870b5":"lydwX","15109e77418bbb4d":"czhc8"}],"gbvyF":[function(require,module,exports) {
"use strict";
var invariant = require("c73e6b64a5ad4595");
var makeService = require("464b24aeb3351e24");
/**
 * @class MapboxUploads
 */ var MapboxUploads = module.exports = makeService("MapboxUploads");
var API_UPLOADS = "/uploads/v1/{owner}{?access_token}";
var API_UPLOAD = "/uploads/v1/{owner}/{upload}{?access_token}";
var API_UPLOAD_CREDENTIALS = "/uploads/v1/{owner}/credentials{?access_token}";
/**
 * Retrieve a listing of uploads for a particular account.
 *
 * This request requires an access token with the uploads:list scope.
 *
 * @param {Function} callback called with (err, uploads)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.listUploads(function(err, uploads) {
 *   console.log(uploads);
 *   // [
 *   //   {
 *   //     "complete": true,
 *   //     "tileset": "example.mbtiles",
 *   //     "error": null,
 *   //     "id": "abc123",
 *   //     "modified": "2014-11-21T19:41:10.000Z",
 *   //     "created": "2014-11-21T19:41:10.000Z",
 *   //     "owner": "example",
 *   //     "progress": 1
 *   //   },
 *   //   {
 *   //     "complete": false,
 *   //     "tileset": "example.foo",
 *   //     "error": null,
 *   //     "id": "xyz789",
 *   //     "modified": "2014-11-21T19:41:10.000Z",
 *   //     "created": "2014-11-21T19:41:10.000Z",
 *   //     "owner": "example",
 *   //     "progress": 0
 *   //   }
 *   // ]
 * });
 */ MapboxUploads.prototype.listUploads = function(callback) {
    return this.client({
        path: API_UPLOADS,
        params: {
            owner: this.owner
        },
        callback: callback
    });
};
/**
 * Retrieve credentials that allow a new file to be staged on Amazon S3
 * while an upload is processed. All uploads must be staged using these
 * credentials before being uploaded to Mapbox.
 *
 * This request requires an access token with the uploads:write scope.
 *
 * @param {Function} callback called with (err, credentials)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.createUploadCredentials(function(err, credentials) {
 *   console.log(credentials);
 *   // {
 *   //   "accessKeyId": "{accessKeyId}",
 *   //   "bucket": "somebucket",
 *   //   "key": "hij456",
 *   //   "secretAccessKey": "{secretAccessKey}",
 *   //   "sessionToken": "{sessionToken}",
 *   //   "url": "{s3 url}"
 *   // }
 *
 *   // Use aws-sdk to stage the file on Amazon S3
 *   var AWS = require('aws-sdk');
 *   var s3 = new AWS.S3({
 *        accessKeyId: credentials.accessKeyId,
 *        secretAccessKey: credentials.secretAccessKey,
 *        sessionToken: credentials.sessionToken,
 *        region: 'us-east-1'
 *   });
 *   s3.putObject({
 *     Bucket: credentials.bucket,
 *     Key: credentials.key,
 *     Body: fs.createReadStream('/path/to/file.mbtiles')
 *   }, function(err, resp) {
 *   });
 * });
 */ MapboxUploads.prototype.createUploadCredentials = function(callback) {
    return this.client({
        path: API_UPLOAD_CREDENTIALS,
        params: {
            owner: this.owner
        },
        method: "post",
        callback: callback
    });
};
/**
 * Create an new upload with a file previously staged on Amazon S3.
 *
 * This request requires an access token with the uploads:write scope.
 *
 * @param {Object} options an object that defines the upload's properties
 * @param {String} options.tileset id of the tileset to create or
 * replace. This must consist of an account id and a unique key
 * separated by a period. Reuse of a tileset value will overwrite
 * existing data. To avoid overwriting existing data, you must ensure
 * that you are using unique tileset ids.
 * @param {String} options.url https url of a file staged on Amazon S3.
 * @param {Function} callback called with (err, upload)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * // Response from a call to createUploadCredentials
 * var credentials = {
 *   "accessKeyId": "{accessKeyId}",
 *   "bucket": "somebucket",
 *   "key": "hij456",
 *   "secretAccessKey": "{secretAccessKey}",
 *   "sessionToken": "{sessionToken}",
 *   "url": "{s3 url}"
 * };
 * mapboxClient.createUpload({
 *    tileset: [accountid, 'mytileset'].join('.'),
 *    url: credentials.url
 * }, function(err, upload) {
 *   console.log(upload);
 *   // {
 *   //   "complete": false,
 *   //   "tileset": "example.markers",
 *   //   "error": null,
 *   //   "id": "hij456",
 *   //   "modified": "2014-11-21T19:41:10.000Z",
 *   //   "created": "2014-11-21T19:41:10.000Z",
 *   //   "owner": "example",
 *   //   "progress": 0
 *   // }
 * });
 */ MapboxUploads.prototype.createUpload = function(options, callback) {
    invariant(typeof options === "object", "options must be an object");
    return this.client({
        path: API_UPLOADS,
        params: {
            owner: this.owner
        },
        entity: options,
        callback: callback
    });
};
/**
 * Retrieve state of an upload.
 *
 * This request requires an access token with the uploads:read scope.
 *
 * @param {String} upload id of the upload to read
 * @param {Function} callback called with (err, upload)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.readUpload('hij456', function(err, upload) {
 *   console.log(upload);
 *   // {
 *   //   "complete": true,
 *   //   "tileset": "example.markers",
 *   //   "error": null,
 *   //   "id": "hij456",
 *   //   "modified": "2014-11-21T19:41:10.000Z",
 *   //   "created": "2014-11-21T19:41:10.000Z",
 *   //   "owner": "example",
 *   //   "progress": 1
 *   // }
 * });
 */ MapboxUploads.prototype.readUpload = function(upload, callback) {
    invariant(typeof upload === "string", "upload must be a string");
    return this.client({
        path: API_UPLOAD,
        params: {
            owner: this.owner,
            upload: upload
        },
        callback: callback
    });
};
/**
 * Delete a completed upload. In-progress uploads cannot be deleted.
 *
 * This request requires an access token with the uploads:delete scope.
 *
 * @param {string} upload upload identifier
 * @param {Function} callback called with (err)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.deleteUpload('hij456', function(err) {
 * });
 */ MapboxUploads.prototype.deleteUpload = function(upload, callback) {
    invariant(typeof upload === "string", "upload must be a string");
    return this.client({
        method: "delete",
        path: API_UPLOAD,
        params: {
            owner: this.owner,
            upload: upload
        },
        callback: callback
    });
};

},{"c73e6b64a5ad4595":"ja2cL","464b24aeb3351e24":"czhc8"}],"k2iff":[function(require,module,exports) {
"use strict";
var invariant = require("1b6fb2681b0c45cd");
var makeService = require("a97845948a3c372b");
/**
 * @class MapboxMatching
 */ var MapboxMatching = makeService("MapboxMatching");
var API_MATCHING = "/matching/v5/{account}/{profile}/{coordinates}.json{?access_token,geometries,radiuses,steps,overview,timestamps,annotations}";
/**
 * Snap recorded location traces to roads and paths from OpenStreetMap.
 * Consult the [Map Matching API](https://www.mapbox.com/api-documentation/#map-matching)
 * for more documentation.
 *
 * @param {Array<Array<number>>} coordinates an array of coordinate pairs
 * in [longitude, latitude] order. Up to 100 coordinates can be specified.
 * @param {Object} [options={}] additional options meant to tune
 * the request
 * @param {string} [options.profile=driving] the directions
 * profile, which determines how to prioritize different routes.
 * Options are `'driving'`, which assumes transportation via an
 * automobile and will use highways, `'walking'`, which avoids
 * streets without sidewalks, and `'cycling'`, which prefers streets
 * with bicycle lanes and lower speed limits for transportation via
 * bicycle.
 * @param {string} [options.geometries=geojson] format of the returned geometry.
 * Allowed values are: `'geojson'` (as LineString), `'polyline'` with
 * precision 5, `'polyline6'`. `'polyline'` yields more compact responses which
 * can be decoded on the client side. [GeoJSON](http://geojson.org/), the
 * default, is compatible with libraries like
 * [Mapbox GL](https://www.mapbox.com/mapbox-gl/), Leaflet and
 * [Mapbox.js](https://www.mapbox.com/mapbox.js/).
 * @param {Array<number>} [options.radiuses] an array of integers in meters
 * indicating the assumed precision of the used tracking device. There must be
 * as many radiuses as there are coordinates in the request. Values can be a
 * number between 0 and 30. Use higher numbers (20-30) for noisy traces and
 * lower numbers (1-10) for clean traces. The default value is 5.
 * @param {boolean} [options.steps=false] Whether to return steps and
 * turn-by-turn instructions. Can be `true` or `false`.
 * @param {string|boolean} [options.overview=simplified] type of returned
 * overview geometry. Can be `'full'` (the most detailed geometry available),
 * `'simplified'` (a simplified version of the full geometry), or `false`.
 * @param {Array<number>} [options.timestamps] an array of timestamps
 * corresponding to each coordinate provided in the request; must be numbers in
 * [Unix time](https://en.wikipedia.org/wiki/Unix_time)
 * (seconds since the Unix epoch). There must be as many timestamps as there
 * are coordinates in the request.
 * @param {Array<string>} [options.annotations] an array of fields that return
 * additional metadata for each coordinate along the match geometry. Can be any
 * of `'duration'`, `'distance'`, or `'nodes'`.
 * @param {Function} callback called with (err, results)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * mapboxClient.matching([
 *   [-95.4431142, 33.6875431],
 *   [-95.0431142, 33.6875431],
 *   [-95.0431142, 33.0875431],
 *   [-95.0431142, 33.0175431],
 *   [-95.4831142, 33.6875431]
 * ], {
 *  overview: 'full'
 * }, function(err, res) {
 *   // res is a match response object
 * });
 */ MapboxMatching.prototype.matching = function(coordinates, options, callback) {
    // permit the options argument to be omitted
    if (callback === undefined && typeof options === "function") {
        callback = options;
        options = {};
    }
    // typecheck arguments
    invariant(Array.isArray(coordinates), "coordinates must be an array");
    var params = {
        profile: "driving",
        account: "mapbox",
        geometries: "geojson",
        coordinates: coordinates.join(";")
    };
    if (options.profile) {
        invariant(typeof options.profile === "string", "profile option must be string");
        params.profile = options.profile;
    }
    var allowedGeometries = [
        "polyline",
        "geojson"
    ];
    if (options.geometries) {
        invariant(allowedGeometries.indexOf(options.geometries) !== -1, "geometries option must be " + allowedGeometries);
        params.geometries = options.geometries;
    }
    if (options.radiuses) {
        invariant(Array.isArray(options.radiuses), "radiuses must be an array");
        invariant(options.radiuses.length === coordinates.length, "There must be as many radiuses as there are coordinates in the request");
        params.radiuses = options.radiuses.join(";");
    }
    if (typeof options.steps !== "undefined") {
        invariant(typeof options.steps === "boolean", "steps option must be boolean");
        params.steps = options.steps;
    }
    var allowedOverview = [
        "full",
        "simplified"
    ];
    if (typeof options.overview !== "undefined") {
        invariant(allowedOverview.indexOf(options.overview) !== -1 || options.overview === false, "overview option must be " + allowedOverview + " or false");
        params.overview = options.overview;
    }
    if (options.timestamps) {
        invariant(Array.isArray(options.timestamps), "timestamps must be an array");
        invariant(options.timestamps.length === coordinates.length, "There must be as many timestamps as there are coordinates in the request");
        params.timestamps = options.timestamps.join(";");
    }
    if (options.annotations) {
        invariant(Array.isArray(options.annotations), "annotations must be an array");
        params.annotations = options.annotations.join();
    }
    return this.client({
        path: API_MATCHING,
        params: params,
        method: "get",
        callback: callback
    });
};
module.exports = MapboxMatching;

},{"1b6fb2681b0c45cd":"ja2cL","a97845948a3c372b":"czhc8"}],"l2usb":[function(require,module,exports) {
"use strict";
var invariant = require("a77041dd9867c66a");
var hat = require("83ed00e7fada6b5");
var makeService = require("1968983f40411934");
/**
 * @class MapboxDatasets
 */ var MapboxDatasets = module.exports = makeService("MapboxDatasets");
var API_DATASET_DATASETS = "/datasets/v1/{owner}{?access_token,limit,fresh}";
var API_DATASET_DATASET = "/datasets/v1/{owner}/{dataset}{?access_token}";
var API_DATASET_FEATURES = "/datasets/v1/{owner}/{dataset}/features{?access_token,limit}";
var API_DATASET_FEATURE = "/datasets/v1/{owner}/{dataset}/features/{id}{?access_token}";
/**
 * To retrieve a listing of datasets for a particular account.
 * This request requires an access token with the datasets:read scope.
 *
 * @param {Object} [opts={}] list options
 * @param {number} opts.limit limit, for paging
 * @param {boolean} opts.fresh whether to request fresh data
 * @param {Function} callback called with (err, datasets)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.listDatasets(function(err, datasets) {
 *   console.log(datasets);
 *   // [
 *   //   {
 *   //     "owner": {account},
 *   //     "id": {dataset id},
 *   //     "name": {dataset name},
 *   //     "description": {dataset description},
 *   //     "created": {timestamp},
 *   //     "modified": {timestamp}
 *   //   },
 *   //   {
 *   //     "owner": {account},
 *   //     "id": {dataset id},
 *   //     "name": {dataset name},
 *   //     "description": {dataset description},
 *   //     "created": {timestamp},
 *   //     "modified": {timestamp}
 *   //   }
 *   // ]
 * });
 */ MapboxDatasets.prototype.listDatasets = function(opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return this.client({
        path: API_DATASET_DATASETS,
        params: {
            limit: opts.limit,
            fresh: opts.fresh,
            owner: this.owner
        },
        callback: callback
    });
};
/**
 * To create a new dataset. Valid properties include title and description (not required).
 * This request requires an access token with the datasets:write scope.
 *
 * @param {object} [options] an object defining a dataset's properties
 * @param {string} [options.name] the dataset's name
 * @param {string} [options.description] the dataset's description
 * @param {Function} callback called with (err, dataset)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.createDataset({ name: 'foo', description: 'bar' }, function(err, dataset) {
 *   console.log(dataset);
 *   // {
 *   //   "owner": {account},
 *   //   "id": {dataset id},
 *   //   "name": "foo",
 *   //   "description": "description",
 *   //   "created": {timestamp},
 *   //   "modified": {timestamp}
 *   // }
 * });
 */ MapboxDatasets.prototype.createDataset = function(options, callback) {
    // permit the options argument to be omitted
    if (callback === undefined && typeof options === "function") {
        callback = options;
        options = {};
    }
    invariant(typeof options === "object", "options must be an object");
    return this.client({
        path: API_DATASET_DATASETS,
        params: {
            owner: this.owner
        },
        entity: options,
        callback: callback
    });
};
/**
 * To retrieve information about a particular dataset.
 * This request requires an access token with the datasets:read scope.
 *
 * @param {string} dataset the id for an existing dataset
 * @param {Function} callback called with (err, dataset)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.readDataset('dataset-id', function(err, dataset) {
 *   console.log(dataset);
 *   // {
 *   //   "owner": {account},
 *   //   "id": "dataset-id",
 *   //   "name": {dataset name},
 *   //   "description": {dataset description},
 *   //   "created": {timestamp},
 *   //   "modified": {timestamp}
 *   // }
 * });
 */ MapboxDatasets.prototype.readDataset = function(dataset, callback) {
    invariant(typeof dataset === "string", "dataset must be a string");
    return this.client({
        path: API_DATASET_DATASET,
        params: {
            owner: this.owner,
            dataset: dataset
        },
        callback: callback
    });
};
/**
 * To make updates to a particular dataset's properties.
 * This request requires an access token with the datasets:write scope.
 *
 * @param {string} dataset the id for an existing dataset
 * @param {object} [options] an object defining updates to the dataset's properties
 * @param {string} [options.name] the updated dataset's name
 * @param {string} [options.description] the updated dataset's description
 * @param {Function} callback called with (err, dataset)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * var options = { name: 'foo' };
 * client.updateDataset('dataset-id', options, function(err, dataset) {
 *   console.log(dataset);
 *   // {
 *   //   "owner": {account},
 *   //   "id": "dataset-id",
 *   //   "name": "foo",
 *   //   "description": {dataset description},
 *   //   "created": {timestamp},
 *   //   "modified": {timestamp}
 *   // }
 * });
 */ MapboxDatasets.prototype.updateDataset = function(dataset, options, callback) {
    invariant(typeof dataset === "string", "dataset must be a string");
    invariant(typeof options === "object", "options must be an object");
    invariant(!!options.name || !!options.description, "options must include a name or a description");
    return this.client({
        path: API_DATASET_DATASET,
        params: {
            owner: this.owner,
            dataset: dataset
        },
        method: "patch",
        entity: options,
        callback: callback
    });
};
/**
 * To delete a particular dataset.
 * This request requires an access token with the datasets:write scope.
 *
 * @param {string} dataset the id for an existing dataset
 * @param {Function} callback called with (err)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.deleteDataset('dataset-id', function(err) {
 *   if (!err) console.log('deleted!');
 * });
 */ MapboxDatasets.prototype.deleteDataset = function(dataset, callback) {
    invariant(typeof dataset === "string", "dataset must be a string");
    return this.client({
        path: API_DATASET_DATASET,
        params: {
            owner: this.owner,
            dataset: dataset
        },
        method: "delete",
        callback: callback
    });
};
/**
 * Retrive a list of the features in a particular dataset. The response body will be a GeoJSON FeatureCollection.
 * This request requires an access token with the datasets:read scope.
 *
 * @param {string} dataset the id for an existing dataset
 * @param {object} [options] an object for passing pagination arguments
 * @param {number} [options.limit] The maximum number of objects to return. This value must be between 1 and 100. The API will attempt to return the requested number of objects, but receiving fewer objects does not necessarily signal the end of the collection. Receiving an empty page of results is the only way to determine when you are at the end of a collection.
 * @param {Function} callback called with (err, collection)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.listFeatures('dataset-id', options, function(err, collection) {
 *   console.log(collection);
 *   {
 *     "type": "FeatureCollection",
 *     "features": [
 *       {
 *         "id": {feature id},
 *         "type": "Feature",
 *         "properties": {feature properties}
 *         "geometry": {feature geometry}
 *       },
 *       {
 *         "id": {feature id},
 *         "type": "Feature",
 *         "properties": {feature properties}
 *         "geometry": {feature geometry}
 *       }
 *     ]
 *   }
 * });
 */ MapboxDatasets.prototype.listFeatures = function(dataset, options, callback) {
    // permit the options argument to be omitted
    if (callback === undefined && typeof options === "function") {
        callback = options;
        options = {};
    }
    invariant(typeof dataset === "string", "dataset must be a string");
    invariant(typeof options === "object", "options must be a object");
    var params = {
        owner: this.owner,
        dataset: dataset
    };
    if (options.limit) {
        invariant(typeof options.limit === "number", "limit option must be a number");
        params.limit = options.limit;
    }
    return this.client({
        path: API_DATASET_FEATURES,
        params: params,
        callback: callback
    });
};
/**
 * Insert a feature into a dataset. This can be a new feature, or overwrite an existing one.
 * If overwriting an existing feature, make sure that the feature's `id` property correctly identifies
 * the feature you wish to overwrite.
 * For new features, specifying an `id` is optional. If you do not specify an `id`, one will be assigned
 * and returned as part of the response.
 * This request requires an access token with the datasets:write scope.
 * There are a number of limits to consider when making this request:
 *   - a single feature cannot be larger than 500 KB
 *   - the dataset must not exceed 2000 total features
 *   - the dataset must not exceed a total of 5 MB
 *
 * @param {object} feature the feature to insert. Must be a valid GeoJSON feature per http://geojson.org/geojson-spec.html#feature-objects
 * @param {string} dataset the id for an existing dataset
 * @param {Function} callback called with (err, feature)
 * @returns {Promise} response
 * @example
 * // Insert a brand new feature without an id
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * var feature = {
 *   "type": "Feature",
 *   "properties": {
 *     "name": "Null Island"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [0, 0]
 *   }
 * };
 * client.insertFeature(feature, 'dataset-id', function(err, feature) {
 *   console.log(feature);
 *   // {
 *   //   "id": {feature id},
 *   //   "type": "Feature",
 *   //   "properties": {
 *   //     "name": "Null Island"
 *   //   },
 *   //   "geometry": {
 *   //     "type": "Point",
 *   //     "coordinates": [0, 0]
 *   //   }
 *   // }
 * });
 * @example
 * // Insert a brand new feature with an id, or overwrite an existing feature at that id
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * var feature = {
 *   "id": "feature-id",
 *   "type": "Feature",
 *   "properties": {
 *     "name": "Null Island"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [0, 0]
 *   }
 * };
 * client.insertFeature(feature, 'dataset-id', function(err, feature) {
 *   console.log(feature);
 *   // {
 *   //   "id": "feature-id",
 *   //   "type": "Feature",
 *   //   "properties": {
 *   //     "name": "Null Island"
 *   //   },
 *   //   "geometry": {
 *   //     "type": "Point",
 *   //     "coordinates": [0, 0]
 *   //   }
 *   // }
 * });
 */ MapboxDatasets.prototype.insertFeature = function(feature, dataset, callback) {
    invariant(typeof dataset === "string", "dataset must be a string");
    var id = feature.id || hat();
    invariant(typeof id === "string", "The GeoJSON feature's id must be a string");
    return this.client({
        path: API_DATASET_FEATURE,
        params: {
            owner: this.owner,
            dataset: dataset,
            id: id
        },
        method: "put",
        entity: feature,
        callback: callback
    });
};
/**
 * Read an existing feature from a dataset.
 * This request requires an access token with the datasets:read scope.
 *
 * @param {string} id the `id` of the feature to read
 * @param {string} dataset the id for an existing dataset
 * @param {Function} callback called with (err, feature)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.readFeature('feature-id', 'dataset-id', function(err, feature) {
 *   console.log(feature);
 *   // {
 *   //   "id": "feature-id",
 *   //   "type": "Feature",
 *   //   "properties": {
 *   //     "name": "Null Island"
 *   //   },
 *   //   "geometry": {
 *   //     "type": "Point",
 *   //     "coordinates": [0, 0]
 *   //   }
 *   // }
 * });
 */ MapboxDatasets.prototype.readFeature = function(id, dataset, callback) {
    invariant(typeof id === "string", "id must be a string");
    invariant(typeof dataset === "string", "dataset must be a string");
    return this.client({
        path: API_DATASET_FEATURE,
        params: {
            owner: this.owner,
            dataset: dataset,
            id: id
        },
        callback: callback
    });
};
/**
 * Delete an existing feature from a dataset.
 * This request requires an access token with the datasets:write scope.
 *
 * @param {string} id the `id` of the feature to delete
 * @param {string} dataset the id for an existing dataset
 * @param {Function} callback called with (err)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.deleteFeature('feature-id', 'dataset-id', function(err, feature) {
 *   if (!err) console.log('deleted!');
 * });
 */ MapboxDatasets.prototype.deleteFeature = function(id, dataset, callback) {
    invariant(typeof id === "string", "id must be a string");
    invariant(typeof dataset === "string", "dataset must be a string");
    return this.client({
        path: API_DATASET_FEATURE,
        params: {
            owner: this.owner,
            dataset: dataset,
            id: id
        },
        method: "delete",
        callback: callback
    });
};

},{"a77041dd9867c66a":"ja2cL","83ed00e7fada6b5":"cVuSX","1968983f40411934":"czhc8"}],"cVuSX":[function(require,module,exports) {
/* eslint-disable */ /*
 * hat
 * written by James Halliday, licensed under MIT/X11
 * https://github.com/substack/node-hat
 */ var hat = module.exports = function(bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return "0";
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for(var i = 2; digits === Infinity; i *= 2)digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    var rem = digits - Math.floor(digits);
    var res = "";
    for(var i = 0; i < Math.floor(digits); i++){
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) return hat(bits, base);
    else return res;
};

},{}],"4ViaM":[function(require,module,exports) {
"use strict";
var invariant = require("83419eec25a8d53");
var formatPoints = require("9220465f1407ea71");
var makeService = require("467b1b9b9c03abe");
/**
 * @class MapboxMatrix
 */ var MapboxMatrix = makeService("MapboxMatrix");
var API_MATRIX = "/directions-matrix/v1/mapbox/{profile}/{encodedWaypoints}.json{?access_token}";
/**
 * Compute a table of travel-time estimates between a set of waypoints.
 * Consult the [Mapbox Matrix API](https://www.mapbox.com/api-documentation/#matrix)
 * for more documentation and limits.
 *
 * @param {Array<Object>} waypoints an array of coordinate objects
 * in the form `{longitude: 0, latitude: 0}`.
 * @param {Object} [options={}] additional options meant to tune
 * the request
 * @param {string} [options.profile=driving] the directions
 * profile, which determines how to prioritize different routes.
 * Options are `'driving'`, which assumes transportation via an
 * automobile and will use highways, `'walking'`, which avoids
 * streets without sidewalks, and `'cycling'`, which prefers streets
 * with bicycle lanes and lower speed limits for transportation via
 * bicycle. The `'driving-traffic'` profile is not supported.
 * @param {Function} callback called with (err, results)
 * @returns {Promise} response
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * // Without options
 * mapboxClient.getMatrix([{
 *   longitude: -122.42,
 *   latitude: 37.78
 * },
 * {
 *   longitude: -122.45,
 *   latitude: 37.91
 * },
 * {
 *   longitude: -122.48,
 *   latitude: 37.73
 * }], {
 * }, function(err, results) {
 *   console.log(results);
 * });
 *
 * // With options
 * mapboxClient.getMatrix([{
 *   longitude: -122.42,
 *   latitude: 37.78
 * },
 * {
 *   longitude: -122.45,
 *   latitude: 37.91
 * },
 * {
 *   longitude: -122.48,
 *   latitude: 37.73
 * }], { profile: 'walking' }, {
 * }, function(err, results) {
 *   console.log(results);
 * });
 *
 * // Results is an object like:
 * { durations:
 *   [ [ 0, 1196, 3977, 3415, 5196 ],
 *     [ 1207, 0, 3775, 3213, 4993 ],
 *     [ 3976, 3774, 0, 2650, 2579 ],
 *     [ 3415, 3212, 2650, 0, 3869 ],
 *     [ 5208, 5006, 2579, 3882, 0 ] ] }
 *
 * // If the coordinates include an un-routable place, then
 * // the table may contain 'null' values to indicate this, like
 * { durations:
 *   [ [ 0, 11642, 57965, null, 72782 ],
 *     [ 11642, 0, 56394, null, 69918 ],
 *     [ 57965, 56394, 0, null, 19284 ],
 *     [ null, null, null, 0, null ],
 *     [ 72782, 69918, 19284, null, 0 ] ] }
 */ MapboxMatrix.prototype.getMatrix = function(waypoints, options, callback) {
    // permit the options argument to be omitted
    if (callback === undefined && typeof options === "function") {
        callback = options;
        options = {};
    } else if (options === undefined) options = {};
    // typecheck arguments
    invariant(Array.isArray(waypoints), "waypoints must be an array");
    invariant(typeof options === "object", "options must be an object");
    var encodedWaypoints = formatPoints(waypoints);
    var params = {
        encodedWaypoints: encodedWaypoints,
        profile: "driving"
    };
    if (options.profile) {
        invariant(typeof options.profile === "string", "profile option must be string");
        params.profile = options.profile;
    }
    return this.client({
        path: API_MATRIX,
        params: params,
        callback: callback
    });
};
module.exports = MapboxMatrix;

},{"83419eec25a8d53":"ja2cL","9220465f1407ea71":"lydwX","467b1b9b9c03abe":"czhc8"}],"gukND":[function(require,module,exports) {
"use strict";
var invariant = require("35c819fb319443ec");
var makeService = require("332b76c38de76a94");
/**
 * @class MapboxTilestats
 */ var MapboxTilestats = module.exports = makeService("MapboxTilestats");
var API_TILESTATS_STATISTICS = "/tilestats/v1/{owner}/{tileset}{?access_token}";
/**
 * To retrieve statistics about a specific tileset.
 *
 * @param {String} tileset - the id for the tileset
 * @param {Function} callback called with (err, tilestats)
 * @returns {Promise} response
 * @example
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.getTilestats('tileset-id', function(err, info) {
 *   console.log(info);
 *   // {
 *   //   "layerCount": {layer count},
 *   //   "layers": [
 *   //     {
 *   //       "layer": {layer name},
 *   //       "geometry": {dominant geometry},
 *   //       "count": {feature count},
 *   //       "attributeCount": {attribute count}
 *   //       "attributes": [
 *   //         {
 *   //           "attribute": {attribute name},
 *   //           "type": {attribute type},
 *   //           "count": {unique value count},
 *   //           "min": {minimum value if type is number},
 *   //           "max": {maximum value if type is number},
 *   //           "values": [{...unique values}]
 *   //         }
 *   //       ]
 *   //     }
 *   //   ]
 *   // }
 * });
 */ MapboxTilestats.prototype.getTilestats = function(tileset, callback) {
    invariant(typeof tileset === "string", "tileset must be a string");
    var owner = tileset.split(".")[0];
    if (owner === tileset) owner = this.owner;
    return this.client({
        path: API_TILESTATS_STATISTICS,
        params: {
            owner: owner,
            tileset: tileset
        },
        callback: callback
    });
};
/**
 * To create or update statistics about a specific tileset.
 *
 * @param {String} tileset - the id for the tileset
 * @param {object} statistics - the statistics to upload
 * @param {Function} callback called with (err, tilestats)
 * @returns {Promise} response
 * @example
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.getTilestats('tileset-id', function(err, stats) {
 *   console.log(stats);
 *   // {
 *   //   "account": {account}
 *   //   ... see stats example above (for Tilestats#getTilestats)
 *   // }
 * });
 */ MapboxTilestats.prototype.putTilestats = function(tileset, statistics, callback) {
    invariant(typeof tileset === "string", "tileset must be a string");
    var owner = tileset.split(".")[0];
    if (owner === tileset) owner = this.owner;
    return this.client({
        path: API_TILESTATS_STATISTICS,
        params: {
            owner: owner,
            tileset: tileset
        },
        entity: statistics,
        method: "put",
        callback: callback
    });
};

},{"35c819fb319443ec":"ja2cL","332b76c38de76a94":"czhc8"}],"3yiai":[function(require,module,exports) {
var Buffer = require("490a9e9f044d159b").Buffer;
"use strict";
var invariant = require("1799ea84e1fb0fa");
var uriTemplate = require("9ffe0d88466e1a91");
var makeService = require("5501036aa9f7a715");
/**
 * @class MapboxStyles
 */ var MapboxStyles = module.exports = makeService("MapboxStyles");
var API_STYLES_LIST = "/styles/v1/{owner}{?access_token}";
var API_STYLES_CREATE = "/styles/v1/{owner}{?access_token}";
var API_STYLES_READ = "/styles/v1/{owner}/{styleid}{?access_token}";
var API_STYLES_UPDATE = "/styles/v1/{owner}/{styleid}{?access_token}";
var API_STYLES_DELETE = "/styles/v1/{owner}/{styleid}{?access_token}";
var API_STYLES_EMBED = "/styles/v1/{owner}/{styleid}.html{?access_token,zoomwheel,title}";
var API_STYLES_SPRITE = "/styles/v1/{owner}/{styleid}/sprite{+retina}{.format}{?access_token}";
var API_STYLES_SPRITE_ICON = "/styles/v1/{owner}/{styleid}/sprite/{iconName}{?access_token}";
var API_STYLES_FONT_GLYPH_RANGES = "/fonts/v1/{owner}/{font}/{start}-{end}.pbf{?access_token}";
/**
 * To retrieve a listing of styles for a particular account.
 *
 * @param {Function} callback called with (err, styles)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.listStyles(function(err, styles) {
 *   console.log(styles);
 *   // [{ version: 8,
 *   //  name: 'Light',
 *   //  center: [ -77.0469979435026, 38.898634927602814 ],
 *   //  zoom: 12.511766533145998,
 *   //  bearing: 0,
 *   //  pitch: 0,
 *   //  created: '2016-02-09T14:26:15.059Z',
 *   //  id: 'STYLEID',
 *   //  modified: '2016-02-09T14:28:31.253Z',
 *   //  owner: '{username}' },
 *   //  { version: 8,
 *   //  name: 'Dark',
 *   //  created: '2015-08-28T18:05:22.517Z',
 *   //  id: 'STYILEID',
 *   //  modified: '2015-08-28T18:05:22.517Z',
 *   //  owner: '{username}' }]
 * });
 */ MapboxStyles.prototype.listStyles = function(callback) {
    return this.client({
        path: API_STYLES_LIST,
        params: {
            owner: this.owner
        },
        callback: callback
    });
};
/**
 * Create a style, given the style as a JSON object.
 *
 * @param {Object} style Mapbox GL Style Spec object
 * @param {Function} callback called with (err, createdStyle)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * var style = {
 *   'version': 8,
 *   'name': 'My Awesome Style',
 *   'metadata': {},
 *   'sources': {},
 *   'layers': [],
 *   'glyphs': 'mapbox://fonts/{owner}/{fontstack}/{range}.pbf'
 * };
 * client.createStyle(style, function(err, createdStyle) {
 *   console.log(createdStyle);
 * });
 */ MapboxStyles.prototype.createStyle = function(style, callback) {
    return this.client({
        path: API_STYLES_CREATE,
        params: {
            owner: this.owner
        },
        entity: style,
        callback: callback
    });
};
/**
 * Update a style, given the style as a JSON object.
 *
 * @param {Object} style Mapbox GL Style Spec object
 * @param {string} styleid style id
 * @param {Function} callback called with (err, createdStyle)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * var style = {
 *   'version': 8,
 *   'name': 'My Awesome Style',
 *   'metadata': {},
 *   'sources': {},
 *   'layers': [],
 *   'glyphs': 'mapbox://fonts/{owner}/{fontstack}/{range}.pbf'
 * };
 * client.updateStyle(style, 'style-id', function(err, createdStyle) {
 *   console.log(createdStyle);
 * });
 */ MapboxStyles.prototype.updateStyle = function(style, styleid, callback) {
    invariant(typeof styleid === "string", "style id must be a string");
    return this.client({
        path: API_STYLES_UPDATE,
        params: {
            owner: this.owner,
            styleid: styleid
        },
        entity: style,
        method: "patch",
        callback: callback
    });
};
/**
 * Deletes a particular style.
 *
 * @param {string} styleid the id for an existing style
 * @param {Function} callback called with (err)
 * @returns {Promise} a promise with the response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.deleteStyle('style-id', function(err) {
 *   if (!err) console.log('deleted!');
 * });
 */ MapboxStyles.prototype.deleteStyle = function(styleid, callback) {
    invariant(typeof styleid === "string", "styleid must be a string");
    return this.client({
        path: API_STYLES_DELETE,
        params: {
            owner: this.owner,
            styleid: styleid
        },
        method: "delete",
        callback: callback
    });
};
/**
 * Reads a particular style.
 *
 * @param {string} styleid the id for an existing style
 * @param {Function} callback called with (err, style)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.readStyle('style-id', function(err, style) {
 *   if (!err) console.log(style);
 * });
 */ MapboxStyles.prototype.readStyle = function(styleid, callback) {
    invariant(typeof styleid === "string", "styleid must be a string");
    return this.client({
        path: API_STYLES_READ,
        params: {
            owner: this.owner,
            styleid: styleid
        },
        callback: callback
    });
};
/**
 * Read sprite
 *
 * @param {string} styleid the id for an existing style
 * @param {Object=} options optional options
 * @param {boolean} options.retina whether the sprite JSON should be for a
 * retina sprite.
 * @param {Function} callback called with (err)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.readSprite('style-id', {
 *   retina: true
 * }, function(err) {
 *   if (!err) console.log('deleted!');
 * });
 */ MapboxStyles.prototype.readSprite = function(styleid, options, callback) {
    invariant(typeof styleid === "string", "styleid must be a string");
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    var retina = "";
    if (options.retina) {
        invariant(typeof options.retina === "boolean", "retina option must be a boolean value");
        if (options.retina) retina = "@2x";
    }
    var format = "json";
    if (options.format) {
        invariant(options.format === "json" || options.format === "png", "format parameter must be either json or png");
        format = options.format;
    }
    return this.client({
        path: API_STYLES_SPRITE,
        params: {
            owner: this.owner,
            retina: retina,
            format: format,
            styleid: styleid
        },
        callback: callback
    });
};
/**
 * Get font glyph ranges
 *
 * @param {string} font or fonts
 * @param {number} start character code of starting glyph
 * @param {number} end character code of last glyph. typically the same
 * as start + 255
 * @param {Function} callback called with (err)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.readFontGlyphRanges('Arial Unicode', 0, 255, function(err, ranges) {
 *   if (!err) console.log(ranges);
 * });
 */ MapboxStyles.prototype.readFontGlyphRanges = function(font, start, end, callback) {
    invariant(typeof font === "string", "font must be a string");
    invariant(typeof start === "number", "start must be a number");
    invariant(typeof end === "number", "end must be a number");
    return this.client({
        path: API_STYLES_FONT_GLYPH_RANGES,
        params: {
            owner: this.owner,
            font: font,
            start: start,
            end: end
        },
        callback: callback
    });
};
/**
 * Add an icon to a sprite.
 *
 * @param {string} styleid the id for an existing style
 * @param {string} iconName icon's name
 * @param {Buffer} icon icon content as a buffer
 * @param {Function} callback called with (err)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var fs = require('fs');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.addIcon('style-id', 'icon-name', fs.readFileSync('icon.png'), function(err) {
 *   if (!err) console.log('added icon!');
 * });
 */ MapboxStyles.prototype.addIcon = function(styleid, iconName, icon, callback) {
    invariant(typeof styleid === "string", "style must be a string");
    invariant(typeof iconName === "string", "icon name must be a string");
    invariant(Buffer.isBuffer(icon), "icon must be a Buffer");
    return this.client({
        path: API_STYLES_SPRITE_ICON,
        params: {
            owner: this.owner,
            styleid: styleid,
            iconName: iconName
        },
        headers: {
            "Content-Type": "text/plain"
        },
        entity: icon,
        method: "put",
        callback: callback
    });
};
/**
 * Delete an icon from a sprite.
 *
 * @param {string} styleid the id for an existing style
 * @param {string} iconName icon's name
 * @param {Function} callback called with (err)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.deleteIcon('style-id', 'icon-name', function(err) {
 *   if (!err) console.log('deleted icon!');
 * });
 */ MapboxStyles.prototype.deleteIcon = function(styleid, iconName, callback) {
    invariant(typeof styleid === "string", "style must be a string");
    invariant(typeof iconName === "string", "icon name must be a string");
    return this.client({
        path: API_STYLES_SPRITE_ICON,
        params: {
            owner: this.owner,
            styleid: styleid,
            iconName: iconName
        },
        method: "delete",
        callback: callback
    });
};
/**
 * Embed a style.
 *
 * @param {string} styleid the id for an existing style
 * @param {Object} options optional params
 * @param {boolean} [options.title=false] If true, shows a title box in upper right
 * corner with map title and owner
 * @param {boolean} [options.zoomwheel=true] Disables zooming with mouse scroll wheel
 * @returns {string} URL of style embed page
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * var url = client.embedStyle('style-id');
 */ MapboxStyles.prototype.embedStyle = function(styleid, options) {
    invariant(typeof styleid === "string", "style must be a string");
    var params = {
        styleid: styleid,
        access_token: this.accessToken,
        owner: this.owner,
        title: false,
        zoomwheel: true
    };
    if (options) {
        if (options.title !== undefined) {
            invariant(typeof options.title === "boolean", "title must be a boolean");
            params.title = options.title;
        }
        if (options.zoomwheel !== undefined) {
            invariant(typeof options.zoomwheel === "boolean", "zoomwheel must be a boolean");
            params.zoomwheel = options.zoomwheel;
        }
    }
    return this.endpoint + uriTemplate.expand(API_STYLES_EMBED, params);
};

},{"490a9e9f044d159b":"fCgem","1799ea84e1fb0fa":"ja2cL","9ffe0d88466e1a91":"9Ktmx","5501036aa9f7a715":"czhc8"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
var base64 = require("a6ed18358701b377");
var ieee754 = require("4e51f083fd44f905");
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"a6ed18358701b377":"eIiSV","4e51f083fd44f905":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"eRiQz":[function(require,module,exports) {
"use strict";
var invariant = require("464ef85866977810");
var xtend = require("3f520659f51ba4bc").extend;
var uriTemplate = require("c7faea9740ad6b6b");
var encodeOverlay = require("4208dacb95ddfe86");
var invariantLocation = require("9cd7ed5ec9f5e4e1");
var makeService = require("f44969090b067b2e");
/**
 * @class MapboxStatic
 */ var MapboxStatic = makeService("MapboxStatic");
var API_STATIC = "/styles/v1/{username}/{styleid}/static{+overlay}/{+xyzbp}/{width}x{height}{+retina}{?access_token,attribution,logo,before_layer}";
var API_STATIC_CLASSIC = "/v4/{mapid}{+overlay}/{+xyz}/{width}x{height}{+retina}{.format}{?access_token}";
/**
 * Determine a URL for a static map image, using the [Mapbox Static Map API](https://www.mapbox.com/api-documentation/#static).
 *
 * @param {string} username Mapbox username
 * @param {string} styleid Mapbox Style ID
 * @param {number} width width of the image
 * @param {number} height height of the image
 *
 * @param {Object|string} position either an object with longitude and latitude members, or the string 'auto'
 * @param {number} position.longitude east, west bearing
 * @param {number} position.latitude north, south bearing
 * @param {number} position.zoom map zoom level
 * @param {number} position.bearing map bearing in degrees between 0 and 360
 * @param {number} position.pitch map pitch in degrees between 0 (straight down, no pitch) and 60 (maximum pitch)
 *
 * @param {Object} options all map options
 * @param {boolean} [options.retina=false] whether to double image pixel density
 *
 * @param {Array<Object>} [options.markers=[]] an array of simple marker objects as an overlay
 * @param {Object} [options.geojson={}] geojson data for the overlay
 * @param {Object} [options.path={}] a path and
 * @param {Array<Object>} options.path.geojson data for the path as an array of longitude, latitude objects
 * @param {Array<Object>} options.path.style optional style definitions for a path
 * @param {boolean} options.attribution controlling whether there is attribution on the image; defaults to true
 * @param {boolean} options.logo controlling whether there is a Mapbox logo on the image; defaults to true
 * @param {string} options.before_layer value for controlling where the overlay is inserted in the style
 *
 * @returns {string} static map url
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 * var url = mapboxClient.getStaticURL('mapbox', 'streets-v10', 600, 400, {
 *   longitude: 151.22,
 *   latitude: -33.87,
 *   zoom: 11
 * }, {
 *   markers: [{ longitude: 151.22, latitude: -33.87 }],
 *   before_layer: 'housenum-label'
 * });
 * // url = https://api.mapbox.com/styles/v1/mapbox/streets-v10/static/pin-l-circle(151.22,-33.87)/151.22,-33.87,11/600x400?access_token=ACCESS_TOKEN&before_layer=housenum-label
 */ MapboxStatic.prototype.getStaticURL = function(username, styleid, width, height, position, options) {
    invariant(typeof username === "string", "username option required and must be a string");
    invariant(typeof styleid === "string", "styleid option required and must be a string");
    invariant(typeof width === "number", "width option required and must be a number");
    invariant(typeof height === "number", "height option required and must be a number");
    var defaults = {
        retina: ""
    };
    var xyzbp;
    if (position === "auto") xyzbp = "auto";
    else {
        invariantLocation(position);
        xyzbp = position.longitude + "," + position.latitude + "," + position.zoom;
        if ("pitch" in position) xyzbp += "," + (position.bearing || 0) + "," + position.pitch;
        else if ("bearing" in position) xyzbp += "," + position.bearing;
    }
    var userOptions = {};
    if (options) {
        invariant(typeof options === "object", "options must be an object");
        if (options.format) {
            invariant(typeof options.format === "string", "format must be a string");
            userOptions.format = options.format;
        }
        if (options.retina) {
            invariant(typeof options.retina === "boolean", "retina must be a boolean");
            userOptions.retina = options.retina;
        }
        if (options.markers) userOptions.overlay = "/" + encodeOverlay.encodeMarkers(options.markers);
        else if (options.geojson) userOptions.overlay = "/" + encodeOverlay.encodeGeoJSON(options.geojson);
        else if (options.path) userOptions.overlay = "/" + encodeOverlay.encodePath(options.path);
        if ("attribution" in options) {
            invariant(typeof options.attribution === "boolean", "attribution must be a boolean");
            userOptions.attribution = options.attribution;
        }
        if ("logo" in options) {
            invariant(typeof options.logo === "boolean", "logo must be a boolean");
            userOptions.logo = options.logo;
        }
        if (options.before_layer) {
            invariant(typeof options.before_layer === "string", "before_layer must be a string");
            userOptions.before_layer = options.before_layer;
        }
    }
    var params = xtend(defaults, userOptions, {
        username: username,
        styleid: styleid,
        width: width,
        xyzbp: xyzbp,
        height: height,
        access_token: this.accessToken
    });
    if (params.retina === true) params.retina = "@2x";
    return this.endpoint + uriTemplate.expand(API_STATIC, params);
};
/**
 * Determine a URL for a static classic map image, using the [Mapbox Static (Classic) Map API](https://www.mapbox.com/api-documentation/pages/static_classic.html).
 *
 * @param {string} mapid a Mapbox map id in username.id form
 * @param {number} width width of the image
 * @param {number} height height of the image
 *
 * @param {Object|string} position either an object with longitude and latitude members, or the string 'auto'
 * @param {number} position.longitude east, west bearing
 * @param {number} position.latitude north, south bearing
 * @param {number} position.zoom zoom level
 *
 * @param {Object} options all map options
 * @param {string} [options.format=png] image format. can be jpg70, jpg80, jpg90, png32, png64, png128, png256
 * @param {boolean} [options.retina=false] whether to double image pixel density
 *
 * @param {Array<Object>} [options.markers=[]] an array of simple marker objects as an overlay
 * @param {Object} [options.geojson={}] geojson data for the overlay
 * @param {Object} [options.path={}] a path and
 * @param {Array<Object>} options.path.geojson data for the path as an array of longitude, latitude objects
 * @param {Array<Object>} options.path.style optional style definitions for a path
 *
 * @returns {string} static classic map url
 * @example
 * var mapboxClient = new MapboxClient('ACCESSTOKEN');
 */ MapboxStatic.prototype.getStaticClassicURL = function(mapid, width, height, position, options) {
    invariant(typeof mapid === "string", "mapid option required and must be a string");
    invariant(typeof width === "number", "width option required and must be a number");
    invariant(typeof height === "number", "height option required and must be a number");
    var defaults = {
        format: "png",
        retina: ""
    };
    var xyz;
    if (position === "auto") xyz = "auto";
    else {
        invariantLocation(position);
        xyz = position.longitude + "," + position.latitude + "," + position.zoom;
    }
    var userOptions = {};
    if (options) {
        invariant(typeof options === "object", "options must be an object");
        if (options.format) {
            invariant(typeof options.format === "string", "format must be a string");
            userOptions.format = options.format;
        }
        if (options.retina) {
            invariant(typeof options.retina === "boolean", "retina must be a boolean");
            userOptions.retina = options.retina;
        }
        if (options.markers) userOptions.overlay = "/" + encodeOverlay.encodeMarkers(options.markers);
        else if (options.geojson) userOptions.overlay = "/" + encodeOverlay.encodeGeoJSON(options.geojson);
        else if (options.path) userOptions.overlay = "/" + encodeOverlay.encodePath(options.path);
    }
    var params = xtend(defaults, userOptions, {
        mapid: mapid,
        width: width,
        xyz: xyz,
        height: height,
        access_token: this.accessToken
    });
    if (params.retina === true) params.retina = "@2x";
    return this.endpoint + uriTemplate.expand(API_STATIC_CLASSIC, params);
};
module.exports = MapboxStatic;

},{"464ef85866977810":"ja2cL","3f520659f51ba4bc":"oeR9s","c7faea9740ad6b6b":"9Ktmx","4208dacb95ddfe86":"3CFXa","9cd7ed5ec9f5e4e1":"71Ibc","f44969090b067b2e":"czhc8"}],"3CFXa":[function(require,module,exports) {
"use strict";
var invariant = require("7faefa33f545b72d"), invariantLocation = require("5ee877394a0b47e1"), polyline = require("e94c19568d8b50d4");
/**
 * Given a list of markers, encode them for display
 * @param {Array<Object>} markers a list of markers
 * @returns {string} encoded markers
 * @private
 */ function encodeMarkers(markers) {
    return markers.map(function(marker) {
        invariantLocation(marker);
        var size = marker.size || "l";
        var symbol = marker.symbol || "circle";
        return "pin-" + size + "-" + symbol + "(" + marker.longitude + "," + marker.latitude + ")";
    }).join(",");
}
module.exports.encodeMarkers = encodeMarkers;
/**
 * Given a path and style, encode it for display
 * @param {Object} path an object of a path and style
 * @param {Object} path.geojson a GeoJSON LineString
 * @param {Object} [path.style={}] style parameters
 * @returns {string} encoded path as polyline
 * @private
 */ function encodePath(path) {
    invariant(path.geojson.type === "LineString", "path line must be a LineString");
    var encoded = polyline.fromGeoJSON(path.geojson);
    var style = "";
    if (path.style) {
        if (path.style.strokewidth !== undefined) style += "-" + path.style.strokewidth;
        if (path.style.strokecolor !== undefined) style += "+" + path.style.strokecolor;
    }
    return "path" + style + "(" + encoded + ")";
}
module.exports.encodePath = encodePath;
/**
 * Given a GeoJSON object, encode it for a static map.
 * @param {Object} geojson a geojson object
 * @returns {string} encoded geojson as string
 * @private
 */ function encodeGeoJSON(geojson) {
    var encoded = JSON.stringify(geojson);
    invariant(encoded.length < 4096, "encoded GeoJSON must be shorter than 4096 characters long");
    return "geojson(" + encoded + ")";
}
module.exports.encodeGeoJSON = encodeGeoJSON;

},{"7faefa33f545b72d":"ja2cL","5ee877394a0b47e1":"71Ibc","e94c19568d8b50d4":"aqTDq"}],"aqTDq":[function(require,module,exports) {
"use strict";
/*
 * polyline
 *
 * https://github.com/mapbox/polyline
 *
 * by John Firebaugh, Tom MacWright, and contributors
 * licensed under BSD 3-clause
 */ /*
 * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
 *
 * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)
 * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)
 *
 * @module polyline
 */ var polyline = {};
function encode(coordinate, factor) {
    coordinate = Math.round(coordinate * factor);
    coordinate <<= 1;
    if (coordinate < 0) coordinate = ~coordinate;
    var output = "";
    while(coordinate >= 0x20){
        output += String.fromCharCode((0x20 | coordinate & 0x1f) + 63);
        coordinate >>= 5;
    }
    output += String.fromCharCode(coordinate + 63);
    return output;
}
/**
 * Encodes the given [latitude, longitude] coordinates array.
 *
 * @param {Array.<Array.<Number>>} coordinates
 * @param {Number} precision
 * @returns {String}
 */ polyline.encode = function(coordinates, precision) {
    if (!coordinates.length) return "";
    var factor = Math.pow(10, precision || 5), output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);
    for(var i = 1; i < coordinates.length; i++){
        var a = coordinates[i], b = coordinates[i - 1];
        output += encode(a[0] - b[0], factor);
        output += encode(a[1] - b[1], factor);
    }
    return output;
};
function flipped(coords) {
    var flipped = [];
    for(var i = 0; i < coords.length; i++)flipped.push(coords[i].slice().reverse());
    return flipped;
}
/**
 * Encodes a GeoJSON LineString feature/geometry.
 *
 * @param {Object} geojson
 * @param {Number} precision
 * @returns {String}
 */ polyline.fromGeoJSON = function(geojson, precision) {
    if (geojson && geojson.type === "Feature") geojson = geojson.geometry;
    if (!geojson || geojson.type !== "LineString") throw new Error("Input must be a GeoJSON LineString");
    return polyline.encode(flipped(geojson.coordinates), precision);
};
module.exports = polyline;

},{}],"6pINk":[function(require,module,exports) {
"use strict";
var invariant = require("d8648a47f972c4d6");
var makeService = require("3eb7b72743f61202");
/**
 * @class MapboxTilesets
 */ var MapboxTilesets = module.exports = makeService("MapboxTilesets");
var API_TILESETS_TILEQUERY = "/v4/{mapid}/tilequery/{longitude},{latitude}.json{?access_token,radius,limit}";
var API_TILESETS_LIST = "/tilesets/v1/{owner}{?access_token,limit}";
/**
 * Retrieve data about specific vector features at a specified location within a vector tileset
 *
 * @param {String} mapid Map ID of the tileset to query (eg. mapbox.mapbox-streets-v7)
 * @param {Array} position An array in the form [longitude, latitude] of the position to query
 * @param {Object} [options] optional options
 * @param {Number} options.radius Approximate distance in meters to query for features
 * @param {Number} options.limit Number of features between 1-50 to return
 * @param {Function} [callback] called with (err, results, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.tilequery('mapbox.mapbox-streets-v7', [-77, 38], {}, function(err, response) {
 *   console.log(response);
 * });
 */ MapboxTilesets.prototype.tilequery = function(mapid, position, options, callback) {
    invariant(typeof mapid === "string", "mapid must be a string");
    invariant(typeof position === "object", "position must be an array");
    invariant(position.length == 2, "position must be an array of length 2");
    invariant(typeof position[0] === "number" && typeof position[1] === "number", "position must be an array of two numbers");
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    return this.client({
        path: API_TILESETS_TILEQUERY,
        params: {
            mapid: mapid,
            longitude: position[0],
            latitude: position[1],
            radius: options.radius,
            limit: options.limit
        },
        callback: callback
    });
};
/**
 * Retrieve all tilesets
 *
 * @param {Object} [options] optional options
 * @param {Number} options.limit Maximum Number of tilesets to return
 * @param {Function} [callback] called with (err, tilesets, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.listTilesets(function(err, tilesets) {
 *   console.log(tilesets);
 * });
 */ MapboxTilesets.prototype.listTilesets = function(options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = null;
    }
    options = options || {};
    return this.client({
        path: API_TILESETS_LIST,
        params: {
            owner: this.owner,
            limit: options.limit
        },
        callback: callback
    });
};

},{"d8648a47f972c4d6":"ja2cL","3eb7b72743f61202":"czhc8"}],"kACIX":[function(require,module,exports) {
"use strict";
var invariant = require("128d95f5d340b10d");
var makeService = require("57280ff42c9c891f");
/**
 * @class MapboxTokens
 */ var MapboxTokens = module.exports = makeService("MapboxTokens");
var API_TOKENS_LIST = "/tokens/v2/{owner}{?access_token}";
var API_TOKENS_CREATE = "/tokens/v2/{owner}{?access_token}";
var API_TOKENS_UPDATE_AUTHORIZATION = "/tokens/v2/{owner}/{authorization_id}{?access_token}";
var API_TOKENS_DELETE_AUTHORIZATION = "/tokens/v2/{owner}/{authorization_id}{?access_token}";
var API_TOKENS_RETRIEVE = "/tokens/v2{?access_token}";
var API_TOKENS_LIST_SCOPES = "/scopes/v1/{owner}{?access_token}";
/**
 * To retrieve a listing of tokens for a particular account.
 *
 * @param {Function} [callback] called with (err, tokens, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.listTokens(function(err, tokens) {
 *   console.log(tokens);
 *   // [{ client: 'api'
 *   //  note: 'Default Public Token',
 *   //  usage: 'pk',
 *   //  id: 'TOKENID',
 *   //  default: true,
 *   //  scopes: ['styles:tiles','styles:read','fonts:read','datasets:read'],
 *   //  created: '2016-02-09T14:26:15.059Z',
 *   //  modified: '2016-02-09T14:28:31.253Z',
 *   //  token: 'pk.TOKEN' }]
 * });
 */ MapboxTokens.prototype.listTokens = function(callback) {
    return this.client({
        path: API_TOKENS_LIST,
        params: {
            owner: this.owner
        },
        callback: callback
    });
};
/**
 * Create a token
 *
 * @param {string} note Note attached to the token
 * @param {Array} scopes List of scopes for the new token
 * @param {Function} [callback] called with (err, token, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.createToken('My top secret project', ["styles:read", "fonts:read"], function(err, createdToken) {
 *   console.log(createdToken);
 * });
 */ MapboxTokens.prototype.createToken = function(note, scopes, callback) {
    invariant(typeof note === "string", "note must be a string");
    invariant(Object.prototype.toString.call(scopes) === "[object Array]", "scopes must be an array");
    return this.client({
        path: API_TOKENS_CREATE,
        params: {
            owner: this.owner
        },
        entity: {
            scopes: scopes,
            note: note
        },
        callback: callback
    });
};
/**
 * Create a temporary token
 *
 * @param {string} expires Time token expires in RFC 3339
 * @param {Array} scopes List of scopes for the new token
 * @param {Function} [callback] called with (err, token, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.createTemporaryToken('2016-09-15T19:27:53.000Z', ["styles:read", "fonts:read"], function(err, createdToken) {
 *   console.log(createdToken);
 * });
 */ MapboxTokens.prototype.createTemporaryToken = function(expires, scopes, callback) {
    invariant(typeof expires === "string", "expires must be a string");
    invariant(Object.prototype.toString.call(scopes) === "[object Array]", "scopes must be an array");
    return this.client({
        path: API_TOKENS_CREATE,
        params: {
            owner: this.owner
        },
        entity: {
            scopes: scopes,
            expires: expires
        },
        callback: callback
    });
};
/**
 * Update a token's authorization
 *
 * @param {string} authorization_id Authorization ID
 * @param {Array} scopes List of scopes for the new token
 * @param {Function} [callback] called with (err, token, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.updateTokenAuthorization('auth id', ["styles:read", "fonts:read"], function(err, updatedToken) {
 *   console.log(updatedToken);
 * });
 */ MapboxTokens.prototype.updateTokenAuthorization = function(authorization_id, scopes, callback) {
    invariant(typeof authorization_id === "string", "authorization_id must be a string");
    invariant(Object.prototype.toString.call(scopes) === "[object Array]", "scopes must be an array");
    return this.client({
        path: API_TOKENS_UPDATE_AUTHORIZATION,
        params: {
            authorization_id: authorization_id,
            owner: this.owner
        },
        entity: {
            scopes: scopes
        },
        method: "patch",
        callback: callback
    });
};
/**
 * Delete a token's authorization
 *
 * @param {string} authorization_id Authorization ID
 * @param {Function} [callback] called with (err, token, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.deleteTokenAuthorization('auth id', function(err) {
 * });
 */ MapboxTokens.prototype.deleteTokenAuthorization = function(authorization_id, callback) {
    invariant(typeof authorization_id === "string", "authorization_id must be a string");
    return this.client({
        path: API_TOKENS_DELETE_AUTHORIZATION,
        params: {
            authorization_id: authorization_id,
            owner: this.owner
        },
        method: "delete",
        callback: callback
    });
};
/**
 * Retrieve a token
 *
 * @param {string} access_token access token to check
 * @param {Function} [callback] called with (err, token, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.retrieveToken('ACCESSTOKEN', function(err, tokenResponse) {
 *   console.log(tokenResponse);
 * });
 */ MapboxTokens.prototype.retrieveToken = function(access_token, callback) {
    invariant(typeof access_token === "string", "access_token must be a string");
    return this.client({
        path: API_TOKENS_RETRIEVE,
        params: {
            access_token: access_token
        },
        callback: callback
    });
};
/**
 * List scopes
 *
 * @param {Function} [callback] called with (err, scopes, response)
 * @returns {Promise} response
 * @example
 * var MapboxClient = require('mapbox');
 * var client = new MapboxClient('ACCESSTOKEN');
 * client.listScopes(function(err, scopes) {
 *   console.log(scopes);
 * });
 */ MapboxTokens.prototype.listScopes = function(callback) {
    return this.client({
        path: API_TOKENS_LIST_SCOPES,
        params: {
            owner: this.owner
        },
        callback: callback
    });
};

},{"128d95f5d340b10d":"ja2cL","57280ff42c9c891f":"czhc8"}],"6qduQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initPageEditarMascota", ()=>initPageEditarMascota);
var _state = require("../../state");
var _dropzone = require("dropzone");
var _mapboxGl = require("mapbox-gl");
var _mapbox = require("../../lib/mapbox");
const MAPBOX_TOKEN = "pk.eyJ1IjoiZGFuaWVsYS1ha2VybWFuIiwiYSI6ImNsZGs3aXo0MzE1MG4zdXMyNXF3ZDRnYzUifQ.kr3GsybRoqh2YOfz4faKgw";
function initPageEditarMascota(root) {
    const div = document.createElement("div");
    div.innerHTML = `
  <link
  href="//api.mapbox.com/mapbox-gl-js/v2.3.1/mapbox-gl.css"
  rel="stylesheet"
/>
  <h1 class="fs-1">Editar Mascota</h1>

  <form class="form-publicar">

  <div class="mb-3">
    <label for="Name" class="form-label">Nombre de tu mascota</label>
    <input class="form-control" id="Name" aria-describedby="nameHelp">
  </div>

  <div class="mb-3 dropzone">
    <img class="pet-picture" src="" alt="" style="width:100%">
    <button type="button" class="btn btn-link actualizar-picture">Eliminar esta imagen</button>
  </div>

  <div class="mb-3 mapa-container"></div>

  <div class="mb-3">
    <label for="Ubicacion" class="form-label">Ciudad o barrio</label>
    <input class="form-control" id="Ubicacion">
    <p class="text-danger alerta"></p>
  </div>

  <button type="submit" class="btn btn-primary">Publicar</button>
  
  </form>

  `;
    // Dropzone
    const divDrop = div.querySelector(".dropzone");
    const eliminarImg = div.querySelector(".actualizar-picture");
    const img = div.querySelector(".pet-picture");
    eliminarImg.addEventListener("click", ()=>{
        img.remove();
        eliminarImg.remove();
    });
    let imageDataURL;
    const myDropzone = new (0, _dropzone.Dropzone)(divDrop, {
        url: "/falsa",
        clickable: true,
        autoProcessQueue: false,
        addRemoveLinks: true
    });
    myDropzone.on("thumbnail", function(file) {
        // usando este evento pueden acceder al dataURL directamente
        imageDataURL = file.dataURL;
    });
    // Mapbox
    // INICIA EL MAPA EN EL CONTENEDOR
    function initMap() {
        const mapContainer = div.querySelector(".mapa-container");
        _mapboxGl.accessToken = MAPBOX_TOKEN;
        return new _mapboxGl.Map({
            container: mapContainer,
            style: "mapbox://styles/mapbox/streets-v11",
            center: [
                -74.5,
                40
            ],
            zoom: 9
        });
    }
    const map = initMap();
    const petName = div.querySelector("#Name");
    const form = div.querySelector(".form-publicar");
    form.addEventListener("submit", (e)=>{
        e.preventDefault();
        const pet_id = petName.getAttribute("pet_id");
        const inputLocalizacion = div.querySelector("#Ubicacion");
        const localValue = inputLocalizacion.value;
        if (localValue) // SE REALIZA LA GEOBUSQUEDA
        (0, _mapbox.mapboxClient).geocodeForward(localValue, {
            country: "ar",
            autocomplete: true,
            language: "es"
        }, // SE GUARDA LOS DATOS DE LA BUSQUIEDA EN UN ATRIBUTO SEARCHDATA
        (err, data, res)=>{
            const firstResult = data.features[0];
            const lng = firstResult.geometry.coordinates[0];
            const lat = firstResult.geometry.coordinates[1];
            const searchData = {
                lng,
                lat
            };
            console.log(searchData);
            // CREA EL MARKER EN EL MAPA
            new _mapboxGl.Marker().setLngLat(firstResult.geometry.coordinates).addTo(map);
            map.setCenter(firstResult.geometry.coordinates);
            map.setZoom(14);
            // Objeto para request
            const datosNewPet = {};
            datosNewPet.name = petName.value || "";
            datosNewPet.id = pet_id;
            datosNewPet.imagen_data = imageDataURL || "";
            datosNewPet.ubication = localValue;
            datosNewPet.last_location_lat = lat || "";
            datosNewPet.last_location_lng = lng || "";
            console.log({
                datosNewPet
            });
            (0, _state.state).editarMascota(datosNewPet);
        });
        else if (!localValue) {
            console.log("poner ubicacion");
            div.querySelector(".alerta").innerHTML = `Insertar ubicación para continuar`;
        }
    });
    return div;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../../state":"gYwa1","dropzone":"bsyxN","mapbox-gl":"562rs","../../lib/mapbox":"cxbpN"}],"iz1VF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initRouter", ()=>initRouter);
var _0Ubication = require("./pages/0-ubication");
var _1Welcome = require("./pages/1-welcome");
var _2ASignup = require("./pages/2a-signup");
var _2BLogin = require("./pages/2b-login");
var _2CMisDatos = require("./pages/2c-mis-datos");
var _3APublicar = require("./pages/3a-publicar");
var _3BMisMascotas = require("./pages/3b-mis-mascotas");
var _3CEditarMascota = require("./pages/3c-editar-mascota");
const routes = [
    {
        path: /\//,
        handler: (0, _0Ubication.initPageUbication)
    },
    {
        path: /\/ubication/,
        handler: (0, _0Ubication.initPageUbication)
    },
    {
        path: /\/welcome/,
        handler: (0, _1Welcome.initPageWelcome)
    },
    {
        path: /\/signup/,
        handler: (0, _2ASignup.initPageSignUp)
    },
    {
        path: /\/login/,
        handler: (0, _2BLogin.initPageLogIn)
    },
    {
        path: /\/mis-datos/,
        handler: (0, _2CMisDatos.initPageMisDatos)
    },
    {
        path: /\/publicar-mascota/,
        handler: (0, _3APublicar.initPagePublicar)
    },
    {
        path: /\/mis-mascotas/,
        handler: (0, _3BMisMascotas.initPageMisMascotas)
    },
    {
        path: /\/editar-mascota/,
        handler: (0, _3CEditarMascota.initPageEditarMascota)
    }
];
function initRouter(container) {
    function goTo(path) {
        history.pushState({}, "", path);
        handleRoute(path);
    }
    function handleRoute(route) {
        for (const r of routes)if (r.path.test(route)) {
            const el = r.handler({
                goTo
            });
            if (container.firstChild) container.firstChild.remove();
            container.appendChild(el);
        }
    }
    handleRoute(location.pathname);
    window.onpopstate = function() {
        handleRoute(location.pathname);
    };
}

},{"./pages/0-ubication":"798W8","./pages/1-welcome":"14FxZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","./pages/2a-signup":"gsduI","./pages/2b-login":"kxzJg","./pages/2c-mis-datos":"5afcR","./pages/3a-publicar":"3fMd3","./pages/3b-mis-mascotas":"123UY","./pages/3c-editar-mascota":"6qduQ"}],"798W8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initPageUbication", ()=>initPageUbication);
var _state = require("../../state");
const search = require("360caf7a590cd413");
function initPageUbication(root) {
    const div = document.createElement("div");
    div.innerHTML = `
  <div class="img-container">
    <img src=${search} class="img-fluid">
  </div>
  <p class="">Para continuar, necesitamos conocer tu ubicación</p>
  <button class="btn btn-success" id="button">Aceptar</button>`;
    const button = div.querySelector("#button");
    button.addEventListener("click", ()=>{
        navigator.geolocation.getCurrentPosition((e)=>{
            const ubication = {
                lat: e.coords.latitude,
                lng: e.coords.longitude
            };
            (0, _state.state).setMyUbication(ubication);
            root.goTo("/welcome");
        });
    });
    return div;
}

},{"../../state":"gYwa1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","360caf7a590cd413":"5e8Td"}],"5e8Td":[function(require,module,exports) {
module.exports = require("e3869bfac1519a16").getBundleURL("3co8E") + "search.2a272a1a.jpeg" + "?" + Date.now();

},{"e3869bfac1519a16":"lgJ39"}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"14FxZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initPageWelcome", ()=>initPageWelcome);
var _state = require("../../state");
function initPageWelcome(root) {
    const currentState = (0, _state.state).getState();
    const div = document.createElement("div");
    div.innerHTML = `
  <h1 class="fs-1">Mascotas perdidas cerca tuyo</h1>

  <div class="results" id="results"></div>

  <template id="template">

    <div class="card mb-3" style="width: 18rem;">
      <img src="" class="card-img-top" alt="...">
      <div class="card-body">
        <h5 class="card-title"></h5>
        <p class="card-text"></p>
        <button 
        class="btn btn-warning selected_pet" 
        data-bs-toggle="modal" 
        data-bs-target="#exampleModal" 
        data-bs-pet_name=""
        data-bs-pet_id="" >
          ¿Lo viste?
        </button>
      </div>
    </div>

    </template>

    <div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h1 class="modal-title fs-5" id="exampleModalLabel"></h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
  
            <form class="form">
  
              <div class="mb-3">
                <label for="name" class="form-label">Tu nombre:</label>
                <input class="form-control name" id="name" placeholder="Ingresá tu nombre">
              </div>
  
              <div class="mb-3">
                <label for="telefono" class="form-label">Tu teléfono:</label>
                <input class="form-control telefono" id="telefono" placeholder="Ingresá tu teléfono">
              </div>
  
              <div class="mb-3">
                <label for="mensaje" class="form-label">¿Dónde lo viste?</label>
                <textarea class="form-control mensaje" id="mensaje" rows="3"></textarea>
              </div>
  
              <button type="submit" class="btn btn-success" data-bs-dismiss="modal" aria-label="Close">Enviar</button>
          
            </form>
            
          </div>
        </div>
      </div>
    </div>
  `;
    const contenedor = div.querySelector(".results");
    const template = div.querySelector("#template");
    const myModal = div.querySelector(".modal");
    const form = div.querySelector(".form");
    myModal.addEventListener("shown.bs.modal", (e)=>{
        const event = e;
        const button = event.relatedTarget;
        const petName = button.getAttribute("data-bs-pet_name");
        const petId = button.getAttribute("data-bs-pet_id");
        const modalTitle = myModal.querySelector(".modal-title");
        modalTitle.textContent = `Ayudanos a encontrar a ${petName}`;
        const inputReporterName = myModal.querySelector(".name");
        const inputReporterTelefono = myModal.querySelector(".telefono");
        const inputReporterMensaje = myModal.querySelector(".mensaje");
        form.addEventListener("submit", function formulario(e) {
            e.preventDefault();
            const reporte = {};
            reporte.pet_name = petName;
            reporte.reporter = inputReporterName.value;
            reporte.phone_number = inputReporterTelefono.value;
            reporte.message = inputReporterMensaje.value;
            reporte.pet_id = petId;
            (0, _state.state).setReporte(reporte);
            form.removeEventListener("submit", formulario);
        });
        form.reset();
    });
    (0, _state.state).mostrarMascotasCercaTuyo(root, contenedor, template);
    return div;
}

},{"../../state":"gYwa1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gsduI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initPageSignUp", ()=>initPageSignUp);
var _state = require("../../state");
function initPageSignUp(root) {
    const div = document.createElement("div");
    div.innerHTML = `
  <h1 class="fs-1">Crear cuenta</h1>

  <form class="form-signup">

  <div class="mb-3">
    <label for="Name" class="form-label">Nombre</label>
    <input class="form-control" id="Name" aria-describedby="nameHelp">
  </div>

  <div class="mb-3">
    <label for="Email" class="form-label">Email</label>
    <input type="email" class="form-control" id="Email" aria-describedby="emailHelp">
  </div>

  <div class="mb-3">
    <label for="Contraseña" class="form-label">Contraseña</label>
    <input type="password" class="form-control" id="Contraseña">
  </div>

  <div class="mb-3">
    <label for="Repetir-Contraseña" class="form-label">Repetir contraseña</label>
    <input type="password" class="form-control" id="Repetir-Contraseña">
  </div>

  <div class="alerta-password"></div>

  <button type="submit" class="btn btn-primary">Ingresar</button>
  
  </form>

  <div class="confirmacion"></div>

  `;
    const alertaPassword = div.querySelector(".alerta-password");
    const confirmacion = div.querySelector(".confirmacion");
    const nameInput = div.querySelector("#Name");
    const emailInput = div.querySelector("#Email");
    const passwordInput = div.querySelector("#Contrase\xf1a");
    const repeatPasswordInput = div.querySelector("#Repetir-Contrase\xf1a");
    const form = div.querySelector(".form-signup");
    form.addEventListener("submit", (e)=>{
        e.preventDefault();
        if (passwordInput.value == repeatPasswordInput.value) {
            alertaPassword.innerHTML = "";
            const signUpValues = {};
            signUpValues.fullname = nameInput.value;
            signUpValues.email = emailInput.value;
            signUpValues.password = passwordInput.value;
            (0, _state.state).getAuth(signUpValues, root, confirmacion);
        } else if (passwordInput.value != repeatPasswordInput.value) alertaPassword.innerHTML = `Las constraseñas no coinciden`;
    });
    return div;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../../state":"gYwa1"}],"kxzJg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "initPageLogIn", ()=>initPageLogIn);
var _state = require("../../state");
var _2ASignup = require("../2a-signup");
function initPageLogIn(root, route) {
    const div = document.createElement("div");
    div.innerHTML = `
  <h1 class="fs-1">Log in</h1>

  <form class="form-login">

  <div class="mb-3">
    <label for="Email" class="form-label">Email</label>
    <input type="email" class="form-control" id="Email" aria-describedby="emailHelp">
  </div>

  <div class="mb-3">
    <label for="Password" class="form-label">Contraseña</label>
    <input type="password" class="form-control" id="Password">
  </div>

  <div class="mb-3 form-check">
    <input type="checkbox" class="form-check-input" id="Check" checked>
    <label class="form-check-label" for="Check">Mantener sesión iniciada</label>
  </div>

  <button type="submit" class="btn btn-primary">Ingresar</button>
  
  <div class="alerta"></div>

  </form>
  
  <hr>
  
  <div class="login-signup-container">
    <label class="login-signup">¿Aún no tenés cuenta?</label>
    <button class="btn btn-success crear-cuenta">Crear cuenta</button>
  </div>
  `;
    const buttonNewAccount = div.querySelector(".crear-cuenta");
    buttonNewAccount?.addEventListener("click", (e)=>{
        history.pushState({}, "", "/signup");
        if (root.firstChild) root.firstChild.remove();
        root.appendChild((0, _2ASignup.initPageSignUp)(root));
    });
    const emailInput = div.querySelector("#Email");
    const passwordInput = div.querySelector("#Password");
    const checkInput = div.querySelector("#Check");
    const alerta = div.querySelector(".alerta");
    const form = div.querySelector(".form-login");
    form?.addEventListener("submit", (e)=>{
        e.preventDefault();
        const loginValues = {};
        loginValues.email = emailInput.value;
        loginValues.password = passwordInput.value;
        loginValues.check = checkInput.checked;
        (0, _state.state).logIn(loginValues, root, alerta, route);
    });
    return div;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../../state":"gYwa1","../2a-signup":"gsduI"}]},["iOKch","3xP9X"], "3xP9X", "parcelRequireecba")

//# sourceMappingURL=index.2ab86267.js.map
